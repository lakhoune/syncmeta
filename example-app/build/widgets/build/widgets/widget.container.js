import { css, html, LitElement } from 'lit';
import 'https://unpkg.com/jquery@3.6.0/dist/jquery.js';
import 'https://cdnjs.cloudflare.com/ajax/libs/jquery-migrate/1.4.1/jquery-migrate.min.js';
import 'https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.13.2/jquery-ui.min.js';
import 'https://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.min.js';
import 'https://cdnjs.cloudflare.com/ajax/libs/jquery-contextmenu/2.9.2/jquery.contextMenu.js';
import 'https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js';
import { Text as Text$1, Map as Map$2, Doc } from 'yjs';
import { WebsocketProvider } from 'y-websocket';
import 'https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js';
import { QuillBinding } from 'y-quill';
import 'https://cdnjs.cloudflare.com/ajax/libs/graphlib/2.1.8/graphlib.min.js';
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
const e = e => n => "function" == typeof n ? ((e, n) => (customElements.define(e, n), n))(e, n) : ((e, n) => { const { kind: t, elements: s } = n; return { kind: t, elements: s, finisher(n) { customElements.define(e, n); } }; })(e, n);
var n;
null != (null === (n = window.HTMLSlotElement) || void 0 === n ? void 0 : n.prototype.assignedElements) ? (o, n) => o.assignedElements(n) : (o, n) => o.assignedNodes(n).filter((o => o.nodeType === Node.ELEMENT_NODE));
function filterList(list, value, missingIsFalse) {
    if (list === "*") {
        return true;
    }
    return list.length > 0 ? list.indexOf(value) !== -1 : !missingIsFalse;
}
function extend(o1, o2, keys) {
    var i;
    o1 = o1 || {};
    o2 = o2 || {};
    var _o1 = o1, _o2 = o2;
    if (keys) {
        for (i = 0; i < keys.length; i++) {
            _o1[keys[i]] = _o2[keys[i]];
        }
    }
    else {
        for (i in _o2) {
            _o1[i] = _o2[i];
        }
    }
    return o1;
}
function isNumber$1(n) {
    return Object.prototype.toString.call(n) === "[object Number]";
}
function isString$1(s) {
    return typeof s === "string";
}
function isBoolean$1(s) {
    return typeof s === "boolean";
}
function isObject$1(o) {
    return o == null ? false : Object.prototype.toString.call(o) === "[object Object]";
}
function isDate$1(o) {
    return Object.prototype.toString.call(o) === "[object Date]";
}
function isFunction$1(o) {
    return Object.prototype.toString.call(o) === "[object Function]";
}
function clone$1(a) {
    if (isString$1(a)) {
        return "" + a;
    }
    else if (isBoolean$1(a)) {
        return !!a;
    }
    else if (isDate$1(a)) {
        return new Date(a.getTime());
    }
    else if (isFunction$1(a)) {
        return a;
    }
    else if (Array.isArray(a)) {
        var _b = [];
        for (var i = 0; i < a.length; i++) {
            _b.push(clone$1(a[i]));
        }
        return _b;
    }
    else if (isObject$1(a)) {
        var c = {};
        for (var j in a) {
            c[j] = clone$1(a[j]);
        }
        return c;
    }
    else {
        return a;
    }
}
function merge$1(a, b, collations, overwrites) {
    var cMap = {}, ar, i, oMap = {};
    collations = collations || [];
    overwrites = overwrites || [];
    for (i = 0; i < collations.length; i++) {
        cMap[collations[i]] = true;
    }
    for (i = 0; i < overwrites.length; i++) {
        oMap[overwrites[i]] = true;
    }
    var c = clone$1(a);
    for (i in b) {
        if (c[i] == null || oMap[i]) {
            c[i] = b[i];
        }
        else if (cMap[i]) {
            ar = [];
            ar.push.apply(ar, Array.isArray(c[i]) ? c[i] : [c[i]]);
            ar.push(b[i]);
            c[i] = ar;
        }
        else if (isString$1(b[i]) || isBoolean$1(b[i]) || isFunction$1(b[i]) || isNumber$1(b[i])) {
            c[i] = b[i];
        }
        else {
            if (Array.isArray(b[i])) {
                ar = [];
                if (Array.isArray(c[i])) {
                    ar.push.apply(ar, c[i]);
                }
                ar.push.apply(ar, b[i]);
                c[i] = ar;
            }
            else if (isObject$1(b[i])) {
                if (!isObject$1(c[i])) {
                    c[i] = {};
                }
                for (var j in b[i]) {
                    c[i][j] = b[i][j];
                }
            }
        }
    }
    return c;
}
function functionChain(successValue, failValue, fns) {
    for (var i = 0; i < fns.length; i++) {
        var o = fns[i][0][fns[i][1]].apply(fns[i][0], fns[i][2]);
        if (o === failValue) {
            return o;
        }
    }
    return successValue;
}
function populate(model, values, functionPrefix, doNotExpandFunctions) {
    var getValue = function getValue(fromString) {
        var matches = fromString.match(/(\${.*?})/g);
        if (matches != null) {
            for (var i = 0; i < matches.length; i++) {
                var val = values[matches[i].substring(2, matches[i].length - 1)] || "";
                if (val != null) {
                    fromString = fromString.replace(matches[i], val);
                }
            }
        }
        matches = fromString.match(/({{.*?}})/g);
        if (matches != null) {
            for (var _i = 0; _i < matches.length; _i++) {
                var _val = values[matches[_i].substring(2, matches[_i].length - 2)] || "";
                if (_val != null) {
                    fromString = fromString.replace(matches[_i], _val);
                }
            }
        }
        return fromString;
    };
    var _one = function _one(d) {
        if (d != null) {
            if (isString$1(d)) {
                return getValue(d);
            }
            else if (isFunction$1(d) && !doNotExpandFunctions && (functionPrefix == null || (d.name || "").indexOf(functionPrefix) === 0)) {
                return d(values);
            }
            else if (Array.isArray(d)) {
                var r = [];
                for (var i = 0; i < d.length; i++) {
                    r.push(_one(d[i]));
                }
                return r;
            }
            else if (isObject$1(d)) {
                var s = {};
                for (var j in d) {
                    s[j] = _one(d[j]);
                }
                return s;
            }
            else {
                return d;
            }
        }
    };
    return _one(model);
}
function forEach$1(a, f) {
    if (a) {
        for (var i = 0; i < a.length; i++) {
            f(a[i]);
        }
    }
    else {
        return null;
    }
}
function findWithFunction(a, f) {
    if (a) {
        for (var i = 0; i < a.length; i++) {
            if (f(a[i])) {
                return i;
            }
        }
    }
    return -1;
}
function findAllWithFunction(a, predicate) {
    var o = [];
    if (a) {
        for (var i = 0; i < a.length; i++) {
            if (predicate(a[i])) {
                o.push(i);
            }
        }
    }
    return o;
}
function getWithFunction(a, f) {
    var idx = findWithFunction(a, f);
    return idx === -1 ? null : a[idx];
}
function getAllWithFunction(a, f) {
    var indexes = findAllWithFunction(a, f);
    return indexes.map(function (i) {
        return a[i];
    });
}
function getFromSetWithFunction(s, f) {
    var out = null;
    s.forEach(function (t) {
        if (f(t)) {
            out = t;
        }
    });
    return out;
}
function setToArray$1(s) {
    var a = [];
    s.forEach(function (t) {
        a.push(t);
    });
    return a;
}
function removeWithFunction(a, f) {
    var idx = findWithFunction(a, f);
    if (idx > -1) {
        a.splice(idx, 1);
    }
    return idx !== -1;
}
function fromArray(a) {
    if (Array.fromArray != null) {
        return Array.from(a);
    }
    else {
        var arr = [];
        Array.prototype.push.apply(arr, a);
        return arr;
    }
}
function remove$1(l, v) {
    var idx = l.indexOf(v);
    if (idx > -1) {
        l.splice(idx, 1);
    }
    return idx !== -1;
}
function addToDictionary(map, key, value, insertAtStart) {
    var l = map[key];
    if (l == null) {
        l = [];
        map[key] = l;
    }
    l[insertAtStart ? "unshift" : "push"](value);
    return l;
}
function suggest(list, item, insertAtHead) {
    if (list.indexOf(item) === -1) {
        if (insertAtHead) {
            list.unshift(item);
        }
        else {
            list.push(item);
        }
        return true;
    }
    return false;
}
var lut = [];
for (var i = 0; i < 256; i++) {
    lut[i] = (i < 16 ? '0' : '') + i.toString(16);
}
function uuid() {
    var d0 = Math.random() * 0xffffffff | 0;
    var d1 = Math.random() * 0xffffffff | 0;
    var d2 = Math.random() * 0xffffffff | 0;
    var d3 = Math.random() * 0xffffffff | 0;
    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
}
function rotatePoint(point, center, rotation) {
    var radial = {
        x: point.x - center.x,
        y: point.y - center.y
    }, cr = Math.cos(rotation / 360 * Math.PI * 2), sr = Math.sin(rotation / 360 * Math.PI * 2);
    return {
        x: radial.x * cr - radial.y * sr + center.x,
        y: radial.y * cr + radial.x * sr + center.y,
        cr: cr,
        sr: sr
    };
}
function fastTrim(s) {
    if (s == null) {
        return null;
    }
    var str = s.replace(/^\s\s*/, ''), ws = /\s/, i = str.length;
    while (ws.test(str.charAt(--i))) { }
    return str.slice(0, i + 1);
}
function each(obj, fn) {
    obj = obj.length == null || typeof obj === "string" ? [obj] : obj;
    for (var _i2 = 0; _i2 < obj.length; _i2++) {
        fn(obj[_i2]);
    }
}
function map$1(obj, fn) {
    var o = [];
    for (var _i3 = 0; _i3 < obj.length; _i3++) {
        o.push(fn(obj[_i3]));
    }
    return o;
}
function log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }
    if (typeof console !== "undefined") {
        try {
            var msg = arguments[arguments.length - 1];
            console.log(msg);
        }
        catch (e) { }
    }
}
function sgn$1(x) {
    return x < 0 ? -1 : x > 0 ? 1 : 0;
}
function wrap$1(wrappedFunction, newFunction, returnOnThisValue) {
    return function () {
        var r = null;
        try {
            if (newFunction != null) {
                r = newFunction.apply(this, arguments);
            }
        }
        catch (e) {
            log("jsPlumb function failed : " + e);
        }
        if (wrappedFunction != null && (returnOnThisValue == null || r !== returnOnThisValue)) {
            try {
                r = wrappedFunction.apply(this, arguments);
            }
            catch (e) {
                log("wrapped function failed : " + e);
            }
        }
        return r;
    };
}
function getsert(map, key, valueGenerator) {
    if (!map.has(key)) {
        map.set(key, valueGenerator());
    }
    return map.get(key);
}
function isAssignableFrom(object, cls) {
    var proto = object.__proto__;
    while (proto != null) {
        if (proto instanceof cls) {
            return true;
        }
        else {
            proto = proto.__proto__;
        }
    }
    return false;
}
function insertSorted(value, array, comparator, sortDescending) {
    if (array.length === 0) {
        array.push(value);
    }
    else {
        var flip = sortDescending ? -1 : 1;
        var min = 0;
        var max = array.length;
        var index = Math.floor((min + max) / 2);
        while (max > min) {
            var c = comparator(value, array[index]) * flip;
            if (c < 0) {
                max = index;
            }
            else {
                min = index + 1;
            }
            index = Math.floor((min + max) / 2);
        }
        array.splice(index, 0, value);
    }
}
function _classCallCheck$5(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$5(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
            descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass$5(Constructor, protoProps, staticProps) {
    if (protoProps)
        _defineProperties$5(Constructor.prototype, protoProps);
    if (staticProps)
        _defineProperties$5(Constructor, staticProps);
    return Constructor;
}
function _defineProperty$5(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    else {
        obj[key] = value;
    }
    return obj;
}
function _inherits$4(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass)
        _setPrototypeOf$4(subClass, superClass);
}
function _getPrototypeOf$4(o) {
    _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$4(o);
}
function _setPrototypeOf$4(o, p) {
    _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf$4(o, p);
}
function _isNativeReflectConstruct$4() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
    if (Reflect.construct.sham)
        return false;
    if (typeof Proxy === "function")
        return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { }));
        return true;
    }
    catch (e) {
        return false;
    }
}
function _assertThisInitialized$4(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _possibleConstructorReturn$4(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized$4(self);
}
function _createSuper$4(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf$4(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf$4(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        }
        else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$4(this, result);
    };
}
var EventGenerator = function () {
    function EventGenerator() {
        _classCallCheck$5(this, EventGenerator);
        _defineProperty$5(this, "_listeners", {});
        _defineProperty$5(this, "eventsSuspended", false);
        _defineProperty$5(this, "tick", false);
        _defineProperty$5(this, "eventsToDieOn", {
            "ready": true
        });
        _defineProperty$5(this, "queue", []);
    }
    _createClass$5(EventGenerator, [{
            key: "fire",
            value: function fire(event, value, originalEvent) {
                var ret = null;
                if (!this.tick) {
                    this.tick = true;
                    if (!this.eventsSuspended && this._listeners[event]) {
                        var l = this._listeners[event].length, i = 0, _gone = false;
                        if (!this.shouldFireEvent || this.shouldFireEvent(event, value, originalEvent)) {
                            while (!_gone && i < l && ret !== false) {
                                if (this.eventsToDieOn[event]) {
                                    this._listeners[event][i](value, originalEvent);
                                }
                                else {
                                    try {
                                        ret = this._listeners[event][i](value, originalEvent);
                                    }
                                    catch (e) {
                                        log("jsPlumb: fire failed for event " + event + " : " + (e.message || e));
                                    }
                                }
                                i++;
                                if (this._listeners == null || this._listeners[event] == null) {
                                    _gone = true;
                                }
                            }
                        }
                    }
                    this.tick = false;
                    this._drain();
                }
                else {
                    this.queue.unshift(arguments);
                }
                return ret;
            }
        }, {
            key: "_drain",
            value: function _drain() {
                var n = this.queue.pop();
                if (n) {
                    this.fire.apply(this, n);
                }
            }
        }, {
            key: "unbind",
            value: function unbind(eventOrListener, listener) {
                if (arguments.length === 0) {
                    this._listeners = {};
                }
                else if (arguments.length === 1) {
                    if (typeof eventOrListener === "string") {
                        delete this._listeners[eventOrListener];
                    }
                    else if (eventOrListener.__jsPlumb) {
                        var evt;
                        for (var i in eventOrListener.__jsPlumb) {
                            evt = eventOrListener.__jsPlumb[i];
                            remove$1(this._listeners[evt] || [], eventOrListener);
                        }
                    }
                }
                else if (arguments.length === 2) {
                    remove$1(this._listeners[eventOrListener] || [], listener);
                }
                return this;
            }
        }, {
            key: "getListener",
            value: function getListener(forEvent) {
                return this._listeners[forEvent] || [];
            }
        }, {
            key: "isSuspendEvents",
            value: function isSuspendEvents() {
                return this.eventsSuspended;
            }
        }, {
            key: "setSuspendEvents",
            value: function setSuspendEvents(val) {
                this.eventsSuspended = val;
            }
        }, {
            key: "bind",
            value: function bind(event, listener, insertAtStart) {
                var _this = this;
                var _one = function _one(evt) {
                    addToDictionary(_this._listeners, evt, listener, insertAtStart);
                    listener.__jsPlumb = listener.__jsPlumb || {};
                    listener.__jsPlumb[uuid()] = evt;
                };
                if (typeof event === "string") {
                    _one(event);
                }
                else if (event.length != null) {
                    for (var i = 0; i < event.length; i++) {
                        _one(event[i]);
                    }
                }
                return this;
            }
        }, {
            key: "silently",
            value: function silently(fn) {
                this.setSuspendEvents(true);
                try {
                    fn();
                }
                catch (e) {
                    log("Cannot execute silent function " + e);
                }
                this.setSuspendEvents(false);
            }
        }]);
    return EventGenerator;
}();
(function (_EventGenerator) {
    _inherits$4(OptimisticEventGenerator, _EventGenerator);
    var _super = _createSuper$4(OptimisticEventGenerator);
    function OptimisticEventGenerator() {
        _classCallCheck$5(this, OptimisticEventGenerator);
        return _super.apply(this, arguments);
    }
    _createClass$5(OptimisticEventGenerator, [{
            key: "shouldFireEvent",
            value: function shouldFireEvent(event, value, originalEvent) {
                return true;
            }
        }]);
    return OptimisticEventGenerator;
})(EventGenerator);
var segmentMultipliers = [null, [1, -1], [1, 1], [-1, 1], [-1, -1]];
var inverseSegmentMultipliers = [null, [-1, -1], [-1, 1], [1, 1], [1, -1]];
var TWO_PI = 2 * Math.PI;
function gradient(p1, p2) {
    if (p2.x === p1.x)
        return p2.y > p1.y ? Infinity : -Infinity;
    else if (p2.y === p1.y)
        return p2.x > p1.x ? 0 : -0;
    else
        return (p2.y - p1.y) / (p2.x - p1.x);
}
function normal(p1, p2) {
    return -1 / gradient(p1, p2);
}
function lineLength(p1, p2) {
    return Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2));
}
function quadrant(p1, p2) {
    if (p2.x > p1.x) {
        return p2.y > p1.y ? 2 : 1;
    }
    else if (p2.x == p1.x) {
        return p2.y > p1.y ? 2 : 1;
    }
    else {
        return p2.y > p1.y ? 3 : 4;
    }
}
function theta(p1, p2) {
    var m = gradient(p1, p2), t = Math.atan(m), s = quadrant(p1, p2);
    if (s == 4 || s == 3)
        t += Math.PI;
    if (t < 0)
        t += 2 * Math.PI;
    return t;
}
function intersects(r1, r2) {
    var x1 = r1.x, x2 = r1.x + r1.w, y1 = r1.y, y2 = r1.y + r1.h, a1 = r2.x, a2 = r2.x + r2.w, b1 = r2.y, b2 = r2.y + r2.h;
    return x1 <= a1 && a1 <= x2 && y1 <= b1 && b1 <= y2 || x1 <= a2 && a2 <= x2 && y1 <= b1 && b1 <= y2 || x1 <= a1 && a1 <= x2 && y1 <= b2 && b2 <= y2 || x1 <= a2 && a1 <= x2 && y1 <= b2 && b2 <= y2 || a1 <= x1 && x1 <= a2 && b1 <= y1 && y1 <= b2 || a1 <= x2 && x2 <= a2 && b1 <= y1 && y1 <= b2 || a1 <= x1 && x1 <= a2 && b1 <= y2 && y2 <= b2 || a1 <= x2 && x1 <= a2 && b1 <= y2 && y2 <= b2;
}
function pointOnLine(fromPoint, toPoint, distance) {
    var m = gradient(fromPoint, toPoint), s = quadrant(fromPoint, toPoint), segmentMultiplier = distance > 0 ? segmentMultipliers[s] : inverseSegmentMultipliers[s], theta = Math.atan(m), y = Math.abs(distance * Math.sin(theta)) * segmentMultiplier[1], x = Math.abs(distance * Math.cos(theta)) * segmentMultiplier[0];
    return {
        x: fromPoint.x + x,
        y: fromPoint.y + y
    };
}
function perpendicularLineTo(fromPoint, toPoint, length) {
    var m = gradient(fromPoint, toPoint), theta2 = Math.atan(-1 / m), y = length / 2 * Math.sin(theta2), x = length / 2 * Math.cos(theta2);
    return [{
            x: toPoint.x + x,
            y: toPoint.y + y
        }, {
            x: toPoint.x - x,
            y: toPoint.y - y
        }];
}
function snapToGrid(pos, grid, thresholdX, thresholdY) {
    thresholdX = thresholdX == null ? grid.thresholdX == null ? grid.w / 2 : grid.thresholdX : thresholdX;
    thresholdY = thresholdY == null ? grid.thresholdY == null ? grid.h / 2 : grid.thresholdY : thresholdY;
    var _dx = Math.floor(pos.x / grid.w), _dxl = grid.w * _dx, _dxt = _dxl + grid.w, x = Math.abs(pos.x - _dxl) <= thresholdX ? _dxl : Math.abs(_dxt - pos.x) <= thresholdX ? _dxt : pos.x;
    var _dy = Math.floor(pos.y / grid.h), _dyl = grid.h * _dy, _dyt = _dyl + grid.h, y = Math.abs(pos.y - _dyl) <= thresholdY ? _dyl : Math.abs(_dyt - pos.y) <= thresholdY ? _dyt : pos.y;
    return {
        x: x,
        y: y
    };
}
var PerimeterAnchorShapes;
(function (PerimeterAnchorShapes) {
    PerimeterAnchorShapes["Circle"] = "Circle";
    PerimeterAnchorShapes["Ellipse"] = "Ellipse";
    PerimeterAnchorShapes["Triangle"] = "Triangle";
    PerimeterAnchorShapes["Diamond"] = "Diamond";
    PerimeterAnchorShapes["Rectangle"] = "Rectangle";
    PerimeterAnchorShapes["Square"] = "Square";
})(PerimeterAnchorShapes || (PerimeterAnchorShapes = {}));
var AnchorLocations;
(function (AnchorLocations) {
    AnchorLocations["Assign"] = "Assign";
    AnchorLocations["AutoDefault"] = "AutoDefault";
    AnchorLocations["Bottom"] = "Bottom";
    AnchorLocations["BottomLeft"] = "BottomLeft";
    AnchorLocations["BottomRight"] = "BottomRight";
    AnchorLocations["Center"] = "Center";
    AnchorLocations["Continuous"] = "Continuous";
    AnchorLocations["ContinuousBottom"] = "ContinuousBottom";
    AnchorLocations["ContinuousLeft"] = "ContinuousLeft";
    AnchorLocations["ContinuousRight"] = "ContinuousRight";
    AnchorLocations["ContinuousTop"] = "ContinuousTop";
    AnchorLocations["ContinuousLeftRight"] = "ContinuousLeftRight";
    AnchorLocations["ContinuousTopBottom"] = "ContinuousTopBottom";
    AnchorLocations["Left"] = "Left";
    AnchorLocations["Perimeter"] = "Perimeter";
    AnchorLocations["Right"] = "Right";
    AnchorLocations["Top"] = "Top";
    AnchorLocations["TopLeft"] = "TopLeft";
    AnchorLocations["TopRight"] = "TopRight";
})(AnchorLocations || (AnchorLocations = {}));
function _classCallCheck$4(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$4(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
            descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass$4(Constructor, protoProps, staticProps) {
    if (protoProps)
        _defineProperties$4(Constructor.prototype, protoProps);
    if (staticProps)
        _defineProperties$4(Constructor, staticProps);
    return Constructor;
}
function _defineProperty$4(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    else {
        obj[key] = value;
    }
    return obj;
}
function noSuchPoint() {
    return {
        d: Infinity,
        x: null,
        y: null,
        l: null,
        x1: null,
        y1: null,
        x2: null,
        y2: null
    };
}
function EMPTY_BOUNDS() {
    return {
        xmin: Infinity,
        xmax: -Infinity,
        ymin: Infinity,
        ymax: -Infinity
    };
}
var AbstractSegment = function () {
    function AbstractSegment(params) {
        _classCallCheck$4(this, AbstractSegment);
        this.params = params;
        _defineProperty$4(this, "x1", void 0);
        _defineProperty$4(this, "x2", void 0);
        _defineProperty$4(this, "y1", void 0);
        _defineProperty$4(this, "y2", void 0);
        _defineProperty$4(this, "extents", EMPTY_BOUNDS());
        _defineProperty$4(this, "type", void 0);
        this.x1 = params.x1;
        this.y1 = params.y1;
        this.x2 = params.x2;
        this.y2 = params.y2;
    }
    _createClass$4(AbstractSegment, [{
            key: "findClosestPointOnPath",
            value: function findClosestPointOnPath(x, y) {
                return noSuchPoint();
            }
        }, {
            key: "lineIntersection",
            value: function lineIntersection(x1, y1, x2, y2) {
                return [];
            }
        }, {
            key: "boxIntersection",
            value: function boxIntersection(x, y, w, h) {
                var a = [];
                a.push.apply(a, this.lineIntersection(x, y, x + w, y));
                a.push.apply(a, this.lineIntersection(x + w, y, x + w, y + h));
                a.push.apply(a, this.lineIntersection(x + w, y + h, x, y + h));
                a.push.apply(a, this.lineIntersection(x, y + h, x, y));
                return a;
            }
        }, {
            key: "boundingBoxIntersection",
            value: function boundingBoxIntersection(box) {
                return this.boxIntersection(box.x, box.y, box.w, box.h);
            }
        }]);
    return AbstractSegment;
}();
var UNDEFINED = "undefined";
var DEFAULT = "default";
var TRUE$1 = "true";
var FALSE$1 = "false";
var WILDCARD = "*";
function _classCallCheck$3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$3(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
            descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass$3(Constructor, protoProps, staticProps) {
    if (protoProps)
        _defineProperties$3(Constructor.prototype, protoProps);
    if (staticProps)
        _defineProperties$3(Constructor, staticProps);
    return Constructor;
}
function _defineProperty$3(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    else {
        obj[key] = value;
    }
    return obj;
}
function _inherits$3(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass)
        _setPrototypeOf$3(subClass, superClass);
}
function _getPrototypeOf$3(o) {
    _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$3(o);
}
function _setPrototypeOf$3(o, p) {
    _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf$3(o, p);
}
function _isNativeReflectConstruct$3() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
    if (Reflect.construct.sham)
        return false;
    if (typeof Proxy === "function")
        return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { }));
        return true;
    }
    catch (e) {
        return false;
    }
}
function _assertThisInitialized$3(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _possibleConstructorReturn$3(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized$3(self);
}
function _createSuper$3(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf$3(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf$3(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        }
        else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$3(this, result);
    };
}
function _superPropBase$1(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$3(object);
        if (object === null)
            break;
    }
    return object;
}
function _get$1(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$1 = Reflect.get;
    }
    else {
        _get$1 = function _get(target, property, receiver) {
            var base = _superPropBase$1(target, property);
            if (!base)
                return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver);
            }
            return desc.value;
        };
    }
    return _get$1(target, property, receiver || target);
}
function _slicedToArray$1(arr, i) {
    return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
}
function _toConsumableArray$1(arr) {
    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _arrayWithoutHoles$1(arr) {
    if (Array.isArray(arr))
        return _arrayLikeToArray$1(arr);
}
function _arrayWithHoles$1(arr) {
    if (Array.isArray(arr))
        return arr;
}
function _iterableToArray$1(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
}
function _iterableToArrayLimit$1(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
        return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
                break;
        }
    }
    catch (err) {
        _d = true;
        _e = err;
    }
    finally {
        try {
            if (!_n && _i["return"] != null)
                _i["return"]();
        }
        finally {
            if (_d)
                throw _e;
        }
    }
    return _arr;
}
function _unsupportedIterableToArray$1(o, minLen) {
    if (!o)
        return;
    if (typeof o === "string")
        return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
        n = o.constructor.name;
    if (n === "Map" || n === "Set")
        return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length)
        len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
    return arr2;
}
function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var endpointMap$1 = {};
var endpointComputers = {};
var handlers = {};
var EndpointFactory = {
    get: function get(ep, name, params) {
        var e = endpointMap$1[name];
        if (!e) {
            throw {
                message: "jsPlumb: unknown endpoint type '" + name + "'"
            };
        }
        else {
            return new e(ep, params);
        }
    },
    clone: function clone(epr) {
        var handler = handlers[epr.type];
        return EndpointFactory.get(epr.endpoint, epr.type, handler.getParams(epr));
    },
    compute: function compute(endpoint, anchorPoint, orientation, endpointStyle) {
        var c = endpointComputers[endpoint.type];
        if (c != null) {
            return c(endpoint, anchorPoint, orientation, endpointStyle);
        }
        else {
            log("jsPlumb: cannot find endpoint calculator for endpoint of type ", endpoint.type);
        }
    },
    registerHandler: function registerHandler(eph) {
        handlers[eph.type] = eph;
        endpointMap$1[eph.type] = eph.cls;
        endpointComputers[eph.type] = eph.compute;
    }
};
var EndpointRepresentation = function () {
    function EndpointRepresentation(endpoint, params) {
        _classCallCheck$3(this, EndpointRepresentation);
        this.endpoint = endpoint;
        _defineProperty$3(this, "typeId", void 0);
        _defineProperty$3(this, "x", void 0);
        _defineProperty$3(this, "y", void 0);
        _defineProperty$3(this, "w", void 0);
        _defineProperty$3(this, "h", void 0);
        _defineProperty$3(this, "computedValue", void 0);
        _defineProperty$3(this, "bounds", EMPTY_BOUNDS());
        _defineProperty$3(this, "classes", []);
        _defineProperty$3(this, "instance", void 0);
        _defineProperty$3(this, "type", void 0);
        params = params || {};
        this.instance = endpoint.instance;
        if (endpoint.cssClass) {
            this.classes.push(endpoint.cssClass);
        }
        if (params.cssClass) {
            this.classes.push(params.cssClass);
        }
    }
    _createClass$3(EndpointRepresentation, [{
            key: "addClass",
            value: function addClass(c) {
                this.classes.push(c);
                this.instance.addEndpointClass(this.endpoint, c);
            }
        }, {
            key: "removeClass",
            value: function removeClass(c) {
                this.classes = this.classes.filter(function (_c) {
                    return _c !== c;
                });
                this.instance.removeEndpointClass(this.endpoint, c);
            }
        }, {
            key: "compute",
            value: function compute(anchorPoint, orientation, endpointStyle) {
                this.computedValue = EndpointFactory.compute(this, anchorPoint, orientation, endpointStyle);
                this.bounds.xmin = this.x;
                this.bounds.ymin = this.y;
                this.bounds.xmax = this.x + this.w;
                this.bounds.ymax = this.y + this.h;
            }
        }, {
            key: "setVisible",
            value: function setVisible(v) {
                this.instance.setEndpointVisible(this.endpoint, v);
            }
        }]);
    return EndpointRepresentation;
}();
var DotEndpoint = function (_EndpointRepresentati) {
    _inherits$3(DotEndpoint, _EndpointRepresentati);
    var _super = _createSuper$3(DotEndpoint);
    function DotEndpoint(endpoint, params) {
        var _this;
        _classCallCheck$3(this, DotEndpoint);
        _this = _super.call(this, endpoint, params);
        _defineProperty$3(_assertThisInitialized$3(_this), "radius", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "defaultOffset", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "defaultInnerRadius", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "type", DotEndpoint.type);
        params = params || {};
        _this.radius = params.radius || 5;
        _this.defaultOffset = 0.5 * _this.radius;
        _this.defaultInnerRadius = _this.radius / 3;
        return _this;
    }
    return DotEndpoint;
}(EndpointRepresentation);
_defineProperty$3(DotEndpoint, "type", "Dot");
var DotEndpointHandler = {
    type: DotEndpoint.type,
    cls: DotEndpoint,
    compute: function compute(ep, anchorPoint, orientation, endpointStyle) {
        var x = anchorPoint.curX - ep.radius, y = anchorPoint.curY - ep.radius, w = ep.radius * 2, h = ep.radius * 2;
        if (endpointStyle && endpointStyle.stroke) {
            var lw = endpointStyle.strokeWidth || 1;
            x -= lw;
            y -= lw;
            w += lw * 2;
            h += lw * 2;
        }
        ep.x = x;
        ep.y = y;
        ep.w = w;
        ep.h = h;
        return [x, y, w, h, ep.radius];
    },
    getParams: function getParams(ep) {
        return {
            radius: ep.radius
        };
    }
};
var BlankEndpoint = function (_EndpointRepresentati) {
    _inherits$3(BlankEndpoint, _EndpointRepresentati);
    var _super = _createSuper$3(BlankEndpoint);
    function BlankEndpoint(endpoint, params) {
        var _this;
        _classCallCheck$3(this, BlankEndpoint);
        _this = _super.call(this, endpoint, params);
        _defineProperty$3(_assertThisInitialized$3(_this), "type", BlankEndpoint.type);
        return _this;
    }
    return BlankEndpoint;
}(EndpointRepresentation);
_defineProperty$3(BlankEndpoint, "type", "Blank");
var BlankEndpointHandler = {
    type: BlankEndpoint.type,
    cls: BlankEndpoint,
    compute: function compute(ep, anchorPoint, orientation, endpointStyle) {
        ep.x = anchorPoint.curX;
        ep.y = anchorPoint.curY;
        ep.w = 10;
        ep.h = 0;
        return [anchorPoint.curX, anchorPoint.curY, 10, 0];
    },
    getParams: function getParams(ep) {
        return {};
    }
};
var RectangleEndpoint = function (_EndpointRepresentati) {
    _inherits$3(RectangleEndpoint, _EndpointRepresentati);
    var _super = _createSuper$3(RectangleEndpoint);
    function RectangleEndpoint(endpoint, params) {
        var _this;
        _classCallCheck$3(this, RectangleEndpoint);
        _this = _super.call(this, endpoint, params);
        _defineProperty$3(_assertThisInitialized$3(_this), "width", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "height", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "type", RectangleEndpoint.type);
        params = params || {};
        _this.width = params.width || 10;
        _this.height = params.height || 10;
        return _this;
    }
    _createClass$3(RectangleEndpoint, null, [{
            key: "_getParams",
            value: function _getParams(ep) {
                return {
                    width: ep.width,
                    height: ep.height
                };
            }
        }]);
    return RectangleEndpoint;
}(EndpointRepresentation);
_defineProperty$3(RectangleEndpoint, "type", "Rectangle");
var RectangleEndpointHandler = {
    type: RectangleEndpoint.type,
    cls: RectangleEndpoint,
    compute: function compute(ep, anchorPoint, orientation, endpointStyle) {
        var width = endpointStyle.width || ep.width, height = endpointStyle.height || ep.height, x = anchorPoint.curX - width / 2, y = anchorPoint.curY - height / 2;
        ep.x = x;
        ep.y = y;
        ep.w = width;
        ep.h = height;
        return [x, y, width, height];
    },
    getParams: function getParams(ep) {
        return {
            width: ep.width,
            height: ep.height
        };
    }
};
var AbstractConnector = function () {
    function AbstractConnector(connection, params) {
        _classCallCheck$3(this, AbstractConnector);
        this.connection = connection;
        _defineProperty$3(this, "type", void 0);
        _defineProperty$3(this, "edited", false);
        _defineProperty$3(this, "stub", void 0);
        _defineProperty$3(this, "sourceStub", void 0);
        _defineProperty$3(this, "targetStub", void 0);
        _defineProperty$3(this, "maxStub", void 0);
        _defineProperty$3(this, "typeId", void 0);
        _defineProperty$3(this, "gap", void 0);
        _defineProperty$3(this, "sourceGap", void 0);
        _defineProperty$3(this, "targetGap", void 0);
        _defineProperty$3(this, "segments", []);
        _defineProperty$3(this, "totalLength", 0);
        _defineProperty$3(this, "segmentProportions", []);
        _defineProperty$3(this, "segmentProportionalLengths", []);
        _defineProperty$3(this, "paintInfo", null);
        _defineProperty$3(this, "strokeWidth", void 0);
        _defineProperty$3(this, "x", void 0);
        _defineProperty$3(this, "y", void 0);
        _defineProperty$3(this, "w", void 0);
        _defineProperty$3(this, "h", void 0);
        _defineProperty$3(this, "segment", void 0);
        _defineProperty$3(this, "bounds", EMPTY_BOUNDS());
        _defineProperty$3(this, "cssClass", void 0);
        _defineProperty$3(this, "hoverClass", void 0);
        _defineProperty$3(this, "geometry", void 0);
        this.stub = params.stub || this.getDefaultStubs();
        this.sourceStub = Array.isArray(this.stub) ? this.stub[0] : this.stub;
        this.targetStub = Array.isArray(this.stub) ? this.stub[1] : this.stub;
        this.gap = params.gap || 0;
        this.sourceGap = Array.isArray(this.gap) ? this.gap[0] : this.gap;
        this.targetGap = Array.isArray(this.gap) ? this.gap[1] : this.gap;
        this.maxStub = Math.max(this.sourceStub, this.targetStub);
        this.cssClass = params.cssClass || "";
        this.hoverClass = params.hoverClass || "";
    }
    _createClass$3(AbstractConnector, [{
            key: "getTypeDescriptor",
            value: function getTypeDescriptor() {
                return "connector";
            }
        }, {
            key: "getIdPrefix",
            value: function getIdPrefix() {
                return "_jsplumb_connector";
            }
        }, {
            key: "setGeometry",
            value: function setGeometry(g, internal) {
                this.geometry = g;
                this.edited = g != null && !internal;
            }
        }, {
            key: "exportGeometry",
            value: function exportGeometry() {
                return this.geometry;
            }
        }, {
            key: "importGeometry",
            value: function importGeometry(g) {
                this.geometry = g;
                return true;
            }
        }, {
            key: "resetGeometry",
            value: function resetGeometry() {
                this.geometry = null;
                this.edited = false;
            }
        }, {
            key: "transformAnchorPlacement",
            value: function transformAnchorPlacement(a, dx, dy) {
                return {
                    x: a.x,
                    y: a.y,
                    ox: a.ox,
                    oy: a.oy,
                    curX: a.curX + dx,
                    curY: a.curY + dy
                };
            }
        }, {
            key: "resetBounds",
            value: function resetBounds() {
                this.bounds = EMPTY_BOUNDS();
            }
        }, {
            key: "findSegmentForPoint",
            value: function findSegmentForPoint(x, y) {
                var out = {
                    d: Infinity,
                    s: null,
                    x: null,
                    y: null,
                    l: null,
                    x1: null,
                    y1: null,
                    x2: null,
                    y2: null,
                    index: null,
                    connectorLocation: null
                };
                for (var i = 0; i < this.segments.length; i++) {
                    var _s = this.segments[i].findClosestPointOnPath(x, y);
                    if (_s.d < out.d) {
                        out.d = _s.d;
                        out.l = _s.l;
                        out.x = _s.x;
                        out.y = _s.y;
                        out.s = this.segments[i];
                        out.x1 = _s.x1;
                        out.x2 = _s.x2;
                        out.y1 = _s.y1;
                        out.y2 = _s.y2;
                        out.index = i;
                        out.connectorLocation = this.segmentProportions[i][0] + _s.l * (this.segmentProportions[i][1] - this.segmentProportions[i][0]);
                    }
                }
                return out;
            }
        }, {
            key: "lineIntersection",
            value: function lineIntersection(x1, y1, x2, y2) {
                var out = [];
                for (var i = 0; i < this.segments.length; i++) {
                    out.push.apply(out, this.segments[i].lineIntersection(x1, y1, x2, y2));
                }
                return out;
            }
        }, {
            key: "boxIntersection",
            value: function boxIntersection(x, y, w, h) {
                var out = [];
                for (var i = 0; i < this.segments.length; i++) {
                    out.push.apply(out, this.segments[i].boxIntersection(x, y, w, h));
                }
                return out;
            }
        }, {
            key: "boundingBoxIntersection",
            value: function boundingBoxIntersection(box) {
                var out = [];
                for (var i = 0; i < this.segments.length; i++) {
                    out.push.apply(out, this.segments[i].boundingBoxIntersection(box));
                }
                return out;
            }
        }, {
            key: "_updateSegmentProportions",
            value: function _updateSegmentProportions() {
                var curLoc = 0;
                for (var i = 0; i < this.segments.length; i++) {
                    var sl = this.segments[i].getLength();
                    this.segmentProportionalLengths[i] = sl / this.totalLength;
                    this.segmentProportions[i] = [curLoc, curLoc += sl / this.totalLength];
                }
            }
        }, {
            key: "_findSegmentForLocation",
            value: function _findSegmentForLocation(location, absolute) {
                var idx, i, inSegmentProportion;
                if (absolute) {
                    location = location > 0 ? location / this.totalLength : (this.totalLength + location) / this.totalLength;
                }
                if (location === 1) {
                    idx = this.segments.length - 1;
                    inSegmentProportion = 1;
                }
                else if (location === 0) {
                    inSegmentProportion = 0;
                    idx = 0;
                }
                else {
                    if (location >= 0.5) {
                        idx = 0;
                        inSegmentProportion = 0;
                        for (i = this.segmentProportions.length - 1; i > -1; i--) {
                            if (this.segmentProportions[i][1] >= location && this.segmentProportions[i][0] <= location) {
                                idx = i;
                                inSegmentProportion = (location - this.segmentProportions[i][0]) / this.segmentProportionalLengths[i];
                                break;
                            }
                        }
                    }
                    else {
                        idx = this.segmentProportions.length - 1;
                        inSegmentProportion = 1;
                        for (i = 0; i < this.segmentProportions.length; i++) {
                            if (this.segmentProportions[i][1] >= location) {
                                idx = i;
                                inSegmentProportion = (location - this.segmentProportions[i][0]) / this.segmentProportionalLengths[i];
                                break;
                            }
                        }
                    }
                }
                return {
                    segment: this.segments[idx],
                    proportion: inSegmentProportion,
                    index: idx
                };
            }
        }, {
            key: "_addSegment",
            value: function _addSegment(clazz, params) {
                if (params.x1 === params.x2 && params.y1 === params.y2) {
                    return;
                }
                var s = new clazz(params);
                this.segments.push(s);
                this.totalLength += s.getLength();
                this.updateBounds(s);
            }
        }, {
            key: "_clearSegments",
            value: function _clearSegments() {
                this.totalLength = 0;
                this.segments.length = 0;
                this.segmentProportions.length = 0;
                this.segmentProportionalLengths.length = 0;
            }
        }, {
            key: "getLength",
            value: function getLength() {
                return this.totalLength;
            }
        }, {
            key: "_prepareCompute",
            value: function _prepareCompute(params) {
                this.strokeWidth = params.strokeWidth;
                var x1 = params.sourcePos.curX, x2 = params.targetPos.curX, y1 = params.sourcePos.curY, y2 = params.targetPos.curY, segment = quadrant({
                    x: x1,
                    y: y1
                }, {
                    x: x2,
                    y: y2
                }), swapX = x2 < x1, swapY = y2 < y1, so = [params.sourcePos.ox, params.sourcePos.oy], to = [params.targetPos.ox, params.targetPos.oy], x = swapX ? x2 : x1, y = swapY ? y2 : y1, w = Math.abs(x2 - x1), h = Math.abs(y2 - y1);
                var noSourceOrientation = so[0] === 0 && so[1] === 0;
                var noTargetOrientation = to[0] === 0 && to[1] === 0;
                if (noSourceOrientation || noTargetOrientation) {
                    var index = w > h ? 0 : 1, oIndex = [1, 0][index], v1 = index === 0 ? x1 : y1, v2 = index === 0 ? x2 : y2;
                    if (noSourceOrientation) {
                        so[index] = v1 > v2 ? -1 : 1;
                        so[oIndex] = 0;
                    }
                    if (noTargetOrientation) {
                        to[index] = v1 > v2 ? 1 : -1;
                        to[oIndex] = 0;
                    }
                }
                var sx = swapX ? w + this.sourceGap * so[0] : this.sourceGap * so[0], sy = swapY ? h + this.sourceGap * so[1] : this.sourceGap * so[1], tx = swapX ? this.targetGap * to[0] : w + this.targetGap * to[0], ty = swapY ? this.targetGap * to[1] : h + this.targetGap * to[1], oProduct = so[0] * to[0] + so[1] * to[1];
                var result = {
                    sx: sx,
                    sy: sy,
                    tx: tx,
                    ty: ty,
                    xSpan: Math.abs(tx - sx),
                    ySpan: Math.abs(ty - sy),
                    mx: (sx + tx) / 2,
                    my: (sy + ty) / 2,
                    so: so,
                    to: to,
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    segment: segment,
                    startStubX: sx + so[0] * this.sourceStub,
                    startStubY: sy + so[1] * this.sourceStub,
                    endStubX: tx + to[0] * this.targetStub,
                    endStubY: ty + to[1] * this.targetStub,
                    isXGreaterThanStubTimes2: Math.abs(sx - tx) > this.sourceStub + this.targetStub,
                    isYGreaterThanStubTimes2: Math.abs(sy - ty) > this.sourceStub + this.targetStub,
                    opposite: oProduct === -1,
                    perpendicular: oProduct === 0,
                    orthogonal: oProduct === 1,
                    sourceAxis: so[0] === 0 ? "y" : "x",
                    points: [x, y, w, h, sx, sy, tx, ty],
                    stubs: [this.sourceStub, this.targetStub]
                };
                result.anchorOrientation = result.opposite ? "opposite" : result.orthogonal ? "orthogonal" : "perpendicular";
                return result;
            }
        }, {
            key: "updateBounds",
            value: function updateBounds(segment) {
                var segBounds = segment.extents;
                this.bounds.xmin = Math.min(this.bounds.xmin, segBounds.xmin);
                this.bounds.xmax = Math.max(this.bounds.xmax, segBounds.xmax);
                this.bounds.ymin = Math.min(this.bounds.ymin, segBounds.ymin);
                this.bounds.ymax = Math.max(this.bounds.ymax, segBounds.ymax);
            }
        }, {
            key: "dumpSegmentsToConsole",
            value: function dumpSegmentsToConsole() {
                log("SEGMENTS:");
                for (var i = 0; i < this.segments.length; i++) {
                    log(this.segments[i].type, "" + this.segments[i].getLength(), "" + this.segmentProportions[i]);
                }
            }
        }, {
            key: "pointOnPath",
            value: function pointOnPath(location, absolute) {
                var seg = this._findSegmentForLocation(location, absolute);
                return seg.segment && seg.segment.pointOnPath(seg.proportion, false) || {
                    x: 0,
                    y: 0
                };
            }
        }, {
            key: "gradientAtPoint",
            value: function gradientAtPoint(location, absolute) {
                var seg = this._findSegmentForLocation(location, absolute);
                return seg.segment && seg.segment.gradientAtPoint(seg.proportion, false) || 0;
            }
        }, {
            key: "pointAlongPathFrom",
            value: function pointAlongPathFrom(location, distance, absolute) {
                var seg = this._findSegmentForLocation(location, absolute);
                return seg.segment && seg.segment.pointAlongPathFrom(seg.proportion, distance, false) || {
                    x: 0,
                    y: 0
                };
            }
        }, {
            key: "compute",
            value: function compute(params) {
                this.paintInfo = this._prepareCompute(params);
                this._clearSegments();
                this._compute(this.paintInfo, params);
                this.x = this.paintInfo.points[0];
                this.y = this.paintInfo.points[1];
                this.w = this.paintInfo.points[2];
                this.h = this.paintInfo.points[3];
                this.segment = this.paintInfo.segment;
                this._updateSegmentProportions();
            }
        }, {
            key: "setAnchorOrientation",
            value: function setAnchorOrientation(idx, orientation) { }
        }]);
    return AbstractConnector;
}();
var StraightSegment = function (_AbstractSegment) {
    _inherits$3(StraightSegment, _AbstractSegment);
    var _super = _createSuper$3(StraightSegment);
    function StraightSegment(params) {
        var _this;
        _classCallCheck$3(this, StraightSegment);
        _this = _super.call(this, params);
        _defineProperty$3(_assertThisInitialized$3(_this), "length", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "m", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "m2", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "type", StraightSegment.segmentType);
        _this._setCoordinates({
            x1: params.x1,
            y1: params.y1,
            x2: params.x2,
            y2: params.y2
        });
        return _this;
    }
    _createClass$3(StraightSegment, [{
            key: "getPath",
            value: function getPath(isFirstSegment) {
                return (isFirstSegment ? "M " + this.x1 + " " + this.y1 + " " : "") + "L " + this.x2 + " " + this.y2;
            }
        }, {
            key: "_recalc",
            value: function _recalc() {
                this.length = Math.sqrt(Math.pow(this.x2 - this.x1, 2) + Math.pow(this.y2 - this.y1, 2));
                this.m = gradient({
                    x: this.x1,
                    y: this.y1
                }, {
                    x: this.x2,
                    y: this.y2
                });
                this.m2 = -1 / this.m;
                this.extents = {
                    xmin: Math.min(this.x1, this.x2),
                    ymin: Math.min(this.y1, this.y2),
                    xmax: Math.max(this.x1, this.x2),
                    ymax: Math.max(this.y1, this.y2)
                };
            }
        }, {
            key: "getLength",
            value: function getLength() {
                return this.length;
            }
        }, {
            key: "getGradient",
            value: function getGradient() {
                return this.m;
            }
        }, {
            key: "_setCoordinates",
            value: function _setCoordinates(coords) {
                this.x1 = coords.x1;
                this.y1 = coords.y1;
                this.x2 = coords.x2;
                this.y2 = coords.y2;
                this._recalc();
            }
        }, {
            key: "pointOnPath",
            value: function pointOnPath(location, absolute) {
                if (location === 0 && !absolute) {
                    return {
                        x: this.x1,
                        y: this.y1
                    };
                }
                else if (location === 1 && !absolute) {
                    return {
                        x: this.x2,
                        y: this.y2
                    };
                }
                else {
                    var l = absolute ? location > 0 ? location : this.length + location : location * this.length;
                    return pointOnLine({
                        x: this.x1,
                        y: this.y1
                    }, {
                        x: this.x2,
                        y: this.y2
                    }, l);
                }
            }
        }, {
            key: "gradientAtPoint",
            value: function gradientAtPoint(location, absolute) {
                return this.m;
            }
        }, {
            key: "pointAlongPathFrom",
            value: function pointAlongPathFrom(location, distance, absolute) {
                var p = this.pointOnPath(location, absolute), farAwayPoint = distance <= 0 ? {
                    x: this.x1,
                    y: this.y1
                } : {
                    x: this.x2,
                    y: this.y2
                };
                if (distance <= 0 && Math.abs(distance) > 1) {
                    distance *= -1;
                }
                return pointOnLine(p, farAwayPoint, distance);
            }
        }, {
            key: "within",
            value: function within(a, b, c) {
                return c >= Math.min(a, b) && c <= Math.max(a, b);
            }
        }, {
            key: "closest",
            value: function closest(a, b, c) {
                return Math.abs(c - a) < Math.abs(c - b) ? a : b;
            }
        }, {
            key: "findClosestPointOnPath",
            value: function findClosestPointOnPath(x, y) {
                var out = {
                    d: Infinity,
                    x: null,
                    y: null,
                    l: null,
                    x1: this.x1,
                    x2: this.x2,
                    y1: this.y1,
                    y2: this.y2
                };
                if (this.m === 0) {
                    out.y = this.y1;
                    out.x = this.within(this.x1, this.x2, x) ? x : this.closest(this.x1, this.x2, x);
                }
                else if (this.m === Infinity || this.m === -Infinity) {
                    out.x = this.x1;
                    out.y = this.within(this.y1, this.y2, y) ? y : this.closest(this.y1, this.y2, y);
                }
                else {
                    var b = this.y1 - this.m * this.x1, b2 = y - this.m2 * x, _x1 = (b2 - b) / (this.m - this.m2), _y1 = this.m * _x1 + b;
                    out.x = this.within(this.x1, this.x2, _x1) ? _x1 : this.closest(this.x1, this.x2, _x1);
                    out.y = this.within(this.y1, this.y2, _y1) ? _y1 : this.closest(this.y1, this.y2, _y1);
                }
                var fractionInSegment = lineLength({
                    x: out.x,
                    y: out.y
                }, {
                    x: this.x1,
                    y: this.y1
                });
                out.d = lineLength({
                    x: x,
                    y: y
                }, out);
                out.l = fractionInSegment / length;
                return out;
            }
        }, {
            key: "_pointLiesBetween",
            value: function _pointLiesBetween(q, p1, p2) {
                return p2 > p1 ? p1 <= q && q <= p2 : p1 >= q && q >= p2;
            }
        }, {
            key: "lineIntersection",
            value: function lineIntersection(_x1, _y1, _x2, _y2) {
                var m2 = Math.abs(gradient({
                    x: _x1,
                    y: _y1
                }, {
                    x: _x2,
                    y: _y2
                })), m1 = Math.abs(this.m), b = m1 === Infinity ? this.x1 : this.y1 - m1 * this.x1, out = [], b2 = m2 === Infinity ? _x1 : _y1 - m2 * _x1;
                if (m2 !== m1) {
                    if (m2 === Infinity && m1 === 0) {
                        if (this._pointLiesBetween(_x1, this.x1, this.x2) && this._pointLiesBetween(this.y1, _y1, _y2)) {
                            out.push({
                                x: _x1,
                                y: this.y1
                            });
                        }
                    }
                    else if (m2 === 0 && m1 === Infinity) {
                        if (this._pointLiesBetween(_y1, this.y1, this.y2) && this._pointLiesBetween(this.x1, _x1, _x2)) {
                            out.push({
                                x: this.x1,
                                y: _y1
                            });
                        }
                    }
                    else {
                        var X, Y;
                        if (m2 === Infinity) {
                            X = _x1;
                            if (this._pointLiesBetween(X, this.x1, this.x2)) {
                                Y = m1 * _x1 + b;
                                if (this._pointLiesBetween(Y, _y1, _y2)) {
                                    out.push({
                                        x: X,
                                        y: Y
                                    });
                                }
                            }
                        }
                        else if (m2 === 0) {
                            Y = _y1;
                            if (this._pointLiesBetween(Y, this.y1, this.y2)) {
                                X = (_y1 - b) / m1;
                                if (this._pointLiesBetween(X, _x1, _x2)) {
                                    out.push({
                                        x: X,
                                        y: Y
                                    });
                                }
                            }
                        }
                        else {
                            X = (b2 - b) / (m1 - m2);
                            Y = m1 * X + b;
                            if (this._pointLiesBetween(X, this.x1, this.x2) && this._pointLiesBetween(Y, this.y1, this.y2)) {
                                out.push({
                                    x: X,
                                    y: Y
                                });
                            }
                        }
                    }
                }
                return out;
            }
        }, {
            key: "boxIntersection",
            value: function boxIntersection(x, y, w, h) {
                var a = [];
                a.push.apply(a, this.lineIntersection(x, y, x + w, y));
                a.push.apply(a, this.lineIntersection(x + w, y, x + w, y + h));
                a.push.apply(a, this.lineIntersection(x + w, y + h, x, y + h));
                a.push.apply(a, this.lineIntersection(x, y + h, x, y));
                return a;
            }
        }]);
    return StraightSegment;
}(AbstractSegment);
_defineProperty$3(StraightSegment, "segmentType", "Straight");
var StraightConnector = function (_AbstractConnector) {
    _inherits$3(StraightConnector, _AbstractConnector);
    var _super = _createSuper$3(StraightConnector);
    function StraightConnector() {
        var _this;
        _classCallCheck$3(this, StraightConnector);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$3(_assertThisInitialized$3(_this), "type", StraightConnector.type);
        return _this;
    }
    _createClass$3(StraightConnector, [{
            key: "getDefaultStubs",
            value: function getDefaultStubs() {
                return [0, 0];
            }
        }, {
            key: "_compute",
            value: function _compute(paintInfo, p) {
                this._addSegment(StraightSegment, {
                    x1: paintInfo.sx,
                    y1: paintInfo.sy,
                    x2: paintInfo.startStubX,
                    y2: paintInfo.startStubY
                });
                this._addSegment(StraightSegment, {
                    x1: paintInfo.startStubX,
                    y1: paintInfo.startStubY,
                    x2: paintInfo.endStubX,
                    y2: paintInfo.endStubY
                });
                this._addSegment(StraightSegment, {
                    x1: paintInfo.endStubX,
                    y1: paintInfo.endStubY,
                    x2: paintInfo.tx,
                    y2: paintInfo.ty
                });
                this.geometry = {
                    source: p.sourcePos,
                    target: p.targetPos
                };
            }
        }, {
            key: "transformGeometry",
            value: function transformGeometry(g, dx, dy) {
                return {
                    source: this.transformAnchorPlacement(g.source, dx, dy),
                    target: this.transformAnchorPlacement(g.target, dx, dy)
                };
            }
        }]);
    return StraightConnector;
}(AbstractConnector);
_defineProperty$3(StraightConnector, "type", "Straight");
var connectorMap = {};
var Connectors = {
    get: function get(connection, name, params) {
        var c = connectorMap[name];
        if (!c) {
            throw {
                message: "jsPlumb: unknown connector type '" + name + "'"
            };
        }
        else {
            return new c(connection, params);
        }
    },
    register: function register(name, conn) {
        connectorMap[name] = conn;
    }
};
function cls() {
    for (var _len = arguments.length, className = new Array(_len), _key = 0; _key < _len; _key++) {
        className[_key] = arguments[_key];
    }
    return className.map(function (cn) {
        return "." + cn;
    }).join(",");
}
function classList() {
    for (var _len2 = arguments.length, className = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        className[_key2] = arguments[_key2];
    }
    return className.join(" ");
}
function att() {
    for (var _len3 = arguments.length, attName = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        attName[_key3] = arguments[_key3];
    }
    return attName.map(function (an) {
        return "[" + an + "]";
    }).join(",");
}
var SOURCE = "source";
var TARGET = "target";
var BLOCK = "block";
var NONE = "none";
var ABSOLUTE = "absolute";
var FIXED = "fixed";
var STATIC = "static";
var ATTRIBUTE_GROUP = "data-jtk-group";
var ATTRIBUTE_MANAGED = "data-jtk-managed";
var ATTRIBUTE_NOT_DRAGGABLE = "data-jtk-not-draggable";
var ATTRIBUTE_TABINDEX = "tabindex";
var ATTRIBUTE_SCOPE = "data-jtk-scope";
var ATTRIBUTE_SCOPE_PREFIX = ATTRIBUTE_SCOPE + "-";
var CHECK_CONDITION = "checkCondition";
var CHECK_DROP_ALLOWED = "checkDropAllowed";
var CLASS_CONNECTOR = "jtk-connector";
var CLASS_CONNECTOR_OUTLINE = "jtk-connector-outline";
var CLASS_CONNECTED = "jtk-connected";
var CLASS_ENDPOINT = "jtk-endpoint";
var CLASS_ENDPOINT_CONNECTED = "jtk-endpoint-connected";
var CLASS_ENDPOINT_FULL = "jtk-endpoint-full";
var CLASS_ENDPOINT_FLOATING = "jtk-floating-endpoint";
var CLASS_ENDPOINT_DROP_ALLOWED = "jtk-endpoint-drop-allowed";
var CLASS_ENDPOINT_DROP_FORBIDDEN = "jtk-endpoint-drop-forbidden";
var CLASS_ENDPOINT_ANCHOR_PREFIX = "jtk-endpoint-anchor";
var CLASS_GROUP_COLLAPSED = "jtk-group-collapsed";
var CLASS_GROUP_EXPANDED = "jtk-group-expanded";
var CLASS_OVERLAY = "jtk-overlay";
var EVENT_ANCHOR_CHANGED = "anchor:changed";
var EVENT_CONNECTION = "connection";
var EVENT_INTERNAL_CONNECTION = "internal.connection";
var EVENT_CONNECTION_DETACHED = "connection:detach";
var EVENT_CONNECTION_MOVED = "connection:move";
var EVENT_CONTAINER_CHANGE = "container:change";
var EVENT_ENDPOINT_REPLACED = "endpoint:replaced";
var EVENT_INTERNAL_ENDPOINT_UNREGISTERED = "internal.endpoint:unregistered";
var EVENT_INTERNAL_CONNECTION_DETACHED = "internal.connection:detached";
var EVENT_MANAGE_ELEMENT = "element:manage";
var EVENT_GROUP_ADDED = "group:added";
var EVENT_GROUP_COLLAPSE = "group:collapse";
var EVENT_GROUP_EXPAND = "group:expand";
var EVENT_GROUP_MEMBER_ADDED = "group:member:added";
var EVENT_GROUP_MEMBER_REMOVED = "group:member:removed";
var EVENT_GROUP_REMOVED = "group:removed";
var EVENT_MAX_CONNECTIONS = "maxConnections";
var EVENT_NESTED_GROUP_ADDED = "group:nested:added";
var EVENT_NESTED_GROUP_REMOVED = "group:nested:removed";
var EVENT_UNMANAGE_ELEMENT = "element:unmanage";
var EVENT_ZOOM = "zoom";
var IS_DETACH_ALLOWED = "isDetachAllowed";
var INTERCEPT_BEFORE_DRAG = "beforeDrag";
var INTERCEPT_BEFORE_DROP = "beforeDrop";
var INTERCEPT_BEFORE_DETACH = "beforeDetach";
var INTERCEPT_BEFORE_START_DETACH = "beforeStartDetach";
var SELECTOR_MANAGED_ELEMENT = att(ATTRIBUTE_MANAGED);
var ERROR_SOURCE_ENDPOINT_FULL = "Cannot establish connection: source endpoint is full";
var ERROR_TARGET_ENDPOINT_FULL = "Cannot establish connection: target endpoint is full";
var ERROR_SOURCE_DOES_NOT_EXIST = "Cannot establish connection: source does not exist";
var ERROR_TARGET_DOES_NOT_EXIST = "Cannot establish connection: target does not exist";
var KEY_CONNECTION_OVERLAYS = "connectionOverlays";
var DEFAULT_KEY_ALLOW_NESTED_GROUPS = "allowNestedGroups";
var DEFAULT_KEY_PAINT_STYLE = "paintStyle";
var DEFAULT_KEY_SCOPE = "scope";
function convertToFullOverlaySpec(spec) {
    var o = null;
    if (isString$1(spec)) {
        o = {
            type: spec,
            options: {}
        };
    }
    else {
        o = spec;
    }
    o.options.id = o.options.id || uuid();
    return o;
}
var Overlay = function (_EventGenerator) {
    _inherits$3(Overlay, _EventGenerator);
    var _super = _createSuper$3(Overlay);
    function Overlay(instance, component, p) {
        var _this;
        _classCallCheck$3(this, Overlay);
        _this = _super.call(this);
        _this.instance = instance;
        _this.component = component;
        _defineProperty$3(_assertThisInitialized$3(_this), "id", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "type", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "cssClass", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "visible", true);
        _defineProperty$3(_assertThisInitialized$3(_this), "location", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "events", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "attributes", void 0);
        p = p || {};
        _this.id = p.id || uuid();
        _this.cssClass = p.cssClass || "";
        _this.setLocation(p.location);
        _this.events = p.events || {};
        _this.attributes = p.attributes || {};
        for (var _event in _this.events) {
            _this.bind(_event, _this.events[_event]);
        }
        return _this;
    }
    _createClass$3(Overlay, [{
            key: "setLocation",
            value: function setLocation(l) {
                var newLocation = this.location == null ? 0.5 : this.location;
                if (l != null) {
                    try {
                        var _l = typeof l === "string" ? parseFloat(l) : l;
                        if (!isNaN(_l)) {
                            newLocation = _l;
                        }
                    }
                    catch (e) {
                    }
                }
                this.location = newLocation;
            }
        }, {
            key: "shouldFireEvent",
            value: function shouldFireEvent(event, value, originalEvent) {
                return true;
            }
        }, {
            key: "setVisible",
            value: function setVisible(v) {
                this.visible = v;
                this.instance.setOverlayVisible(this, v);
            }
        }, {
            key: "isVisible",
            value: function isVisible() {
                return this.visible;
            }
        }]);
    return Overlay;
}(EventGenerator);
var overlayMap = {};
var OverlayFactory = {
    get: function get(instance, name, component, params) {
        var c = overlayMap[name];
        if (!c) {
            throw {
                message: "jsPlumb: unknown overlay type '" + name + "'"
            };
        }
        else {
            return new c(instance, component, params);
        }
    },
    register: function register(name, overlay) {
        overlayMap[name] = overlay;
    }
};
var LabelOverlay = function (_Overlay) {
    _inherits$3(LabelOverlay, _Overlay);
    var _super = _createSuper$3(LabelOverlay);
    function LabelOverlay(instance, component, p) {
        var _this;
        _classCallCheck$3(this, LabelOverlay);
        _this = _super.call(this, instance, component, p);
        _this.instance = instance;
        _this.component = component;
        _defineProperty$3(_assertThisInitialized$3(_this), "label", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "labelText", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "type", LabelOverlay.type);
        _defineProperty$3(_assertThisInitialized$3(_this), "cachedDimensions", void 0);
        p = p || {
            label: ""
        };
        _this.setLabel(p.label);
        return _this;
    }
    _createClass$3(LabelOverlay, [{
            key: "getLabel",
            value: function getLabel() {
                if (isFunction$1(this.label)) {
                    return this.label(this);
                }
                else {
                    return this.labelText;
                }
            }
        }, {
            key: "setLabel",
            value: function setLabel(l) {
                this.label = l;
                this.labelText = null;
                this.instance.updateLabel(this);
            }
        }, {
            key: "getDimensions",
            value: function getDimensions() {
                return {
                    w: 1,
                    h: 1
                };
            }
        }, {
            key: "updateFrom",
            value: function updateFrom(d) {
                if (d.label != null) {
                    this.setLabel(d.label);
                }
                if (d.location != null) {
                    this.setLocation(d.location);
                    this.instance.updateLabel(this);
                }
            }
        }]);
    return LabelOverlay;
}(Overlay);
_defineProperty$3(LabelOverlay, "type", "Label");
function isLabelOverlay(o) {
    return o.type === LabelOverlay.type;
}
OverlayFactory.register(LabelOverlay.type, LabelOverlay);
function _splitType(t) {
    return t == null ? null : t.split(" ").filter(function (t) {
        return t != null && t.length > 0;
    });
}
function _mapType(map, obj, typeId) {
    for (var i in obj) {
        map[i] = typeId;
    }
}
var CONNECTOR = "connector";
var MERGE_STRATEGY_OVERRIDE = "override";
var CSS_CLASS = "cssClass";
var DEFAULT_TYPE_KEY = "__default";
var ANCHOR = "anchor";
var ANCHORS = "anchors";
var _internalLabelOverlayId = "__label";
var _internalLabelOverlayClass = "jtk-default-label";
var TYPE_ITEM_OVERLAY = "overlay";
var LOCATION_ATTRIBUTE = "labelLocation";
var ACTION_ADD = "add";
var ACTION_REMOVE = "remove";
function _applyTypes(component, params) {
    if (component.getDefaultType) {
        var td = component.getTypeDescriptor(), map = {};
        var defType = component.getDefaultType();
        var o = extend({}, defType);
        _mapType(map, defType, DEFAULT_TYPE_KEY);
        component._types.forEach(function (tid) {
            if (tid !== DEFAULT_TYPE_KEY) {
                var _t = component.instance.getType(tid, td);
                if (_t != null) {
                    var overrides = new Set([CONNECTOR, ANCHOR, ANCHORS]);
                    if (_t.mergeStrategy === MERGE_STRATEGY_OVERRIDE) {
                        for (var k in _t) {
                            overrides.add(k);
                        }
                    }
                    o = merge$1(o, _t, [CSS_CLASS], setToArray$1(overrides));
                    _mapType(map, _t, tid);
                }
            }
        });
        if (params) {
            o = populate(o, params, "_");
        }
        component.applyType(o, map);
    }
}
function _removeTypeCssHelper(component, typeId) {
    var type = component.instance.getType(typeId, component.getTypeDescriptor());
    if (type != null && type.cssClass) {
        component.removeClass(type.cssClass);
    }
}
function _updateHoverStyle(component) {
    if (component.paintStyle && component.hoverPaintStyle) {
        var mergedHoverStyle = {};
        extend(mergedHoverStyle, component.paintStyle);
        extend(mergedHoverStyle, component.hoverPaintStyle);
        component.hoverPaintStyle = mergedHoverStyle;
    }
}
function _makeLabelOverlay(component, params) {
    var _params = {
        cssClass: params.cssClass,
        id: _internalLabelOverlayId,
        component: component
    }, mergedParams = extend(_params, params);
    return new LabelOverlay(component.instance, component, mergedParams);
}
function _processOverlay(component, o) {
    var _newOverlay = null;
    if (isString$1(o)) {
        _newOverlay = OverlayFactory.get(component.instance, o, component, {});
    }
    else if (o.type != null && o.options != null) {
        var oa = o;
        var p = extend({}, oa.options);
        _newOverlay = OverlayFactory.get(component.instance, oa.type, component, p);
    }
    else {
        _newOverlay = o;
    }
    _newOverlay.id = _newOverlay.id || uuid();
    component.cacheTypeItem(TYPE_ITEM_OVERLAY, _newOverlay, _newOverlay.id);
    component.overlays[_newOverlay.id] = _newOverlay;
    return _newOverlay;
}
var Component = function (_EventGenerator) {
    _inherits$3(Component, _EventGenerator);
    var _super = _createSuper$3(Component);
    function Component(instance, params) {
        var _this;
        _classCallCheck$3(this, Component);
        _this = _super.call(this);
        _this.instance = instance;
        _defineProperty$3(_assertThisInitialized$3(_this), "defaultLabelLocation", 0.5);
        _defineProperty$3(_assertThisInitialized$3(_this), "overlays", {});
        _defineProperty$3(_assertThisInitialized$3(_this), "overlayPositions", {});
        _defineProperty$3(_assertThisInitialized$3(_this), "overlayPlacements", {});
        _defineProperty$3(_assertThisInitialized$3(_this), "clone", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "deleted", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "segment", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "x", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "y", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "w", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "h", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "id", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "visible", true);
        _defineProperty$3(_assertThisInitialized$3(_this), "typeId", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "params", {});
        _defineProperty$3(_assertThisInitialized$3(_this), "paintStyle", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "hoverPaintStyle", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "paintStyleInUse", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "_hover", false);
        _defineProperty$3(_assertThisInitialized$3(_this), "lastPaintedAt", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "data", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "_defaultType", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "events", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "parameters", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "_types", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "_typeCache", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "cssClass", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "hoverClass", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "beforeDetach", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "beforeDrop", void 0);
        params = params || {};
        _this.cssClass = params.cssClass || "";
        _this.hoverClass = params.hoverClass || instance.defaults.hoverClass;
        _this.beforeDetach = params.beforeDetach;
        _this.beforeDrop = params.beforeDrop;
        _this._types = new Set();
        _this._typeCache = {};
        _this.parameters = clone$1(params.parameters || {});
        _this.id = params.id || _this.getIdPrefix() + new Date().getTime();
        _this._defaultType = {
            parameters: _this.parameters,
            scope: params.scope || _this.instance.defaultScope,
            overlays: {}
        };
        if (params.events) {
            for (var evtName in params.events) {
                _this.bind(evtName, params.events[evtName]);
            }
        }
        _this.clone = function () {
            var o = Object.create(_this.constructor.prototype);
            _this.constructor.apply(o, [instance, params]);
            return o;
        };
        _this.overlays = {};
        _this.overlayPositions = {};
        var o = params.overlays || [], oo = {};
        var defaultOverlayKey = _this.getDefaultOverlayKey();
        if (defaultOverlayKey) {
            var defaultOverlays = _this.instance.defaults[defaultOverlayKey];
            if (defaultOverlays) {
                o.push.apply(o, _toConsumableArray$1(defaultOverlays));
            }
            for (var i = 0; i < o.length; i++) {
                var fo = convertToFullOverlaySpec(o[i]);
                oo[fo.options.id] = fo;
            }
        }
        _this._defaultType.overlays = oo;
        if (params.label) {
            _this.getDefaultType().overlays[_internalLabelOverlayId] = {
                type: LabelOverlay.type,
                options: {
                    label: params.label,
                    location: params.labelLocation || _this.defaultLabelLocation,
                    id: _internalLabelOverlayId,
                    cssClass: _internalLabelOverlayClass
                }
            };
        }
        return _this;
    }
    _createClass$3(Component, [{
            key: "isDetachAllowed",
            value: function isDetachAllowed(connection) {
                var r = true;
                if (this.beforeDetach) {
                    try {
                        r = this.beforeDetach(connection);
                    }
                    catch (e) {
                        log("jsPlumb: beforeDetach callback failed", e);
                    }
                }
                return r;
            }
        }, {
            key: "isDropAllowed",
            value: function isDropAllowed(sourceId, targetId, scope, connection, dropEndpoint) {
                var r;
                var payload = {
                    sourceId: sourceId,
                    targetId: targetId,
                    scope: scope,
                    connection: connection,
                    dropEndpoint: dropEndpoint
                };
                if (this.beforeDrop) {
                    try {
                        r = this.beforeDrop(payload);
                    }
                    catch (e) {
                        log("jsPlumb: beforeDrop callback failed", e);
                    }
                }
                else {
                    r = this.instance.checkCondition(INTERCEPT_BEFORE_DROP, payload);
                }
                return r;
            }
        }, {
            key: "getDefaultType",
            value: function getDefaultType() {
                return this._defaultType;
            }
        }, {
            key: "appendToDefaultType",
            value: function appendToDefaultType(obj) {
                for (var i in obj) {
                    this._defaultType[i] = obj[i];
                }
            }
        }, {
            key: "getId",
            value: function getId() {
                return this.id;
            }
        }, {
            key: "cacheTypeItem",
            value: function cacheTypeItem(key, item, typeId) {
                this._typeCache[typeId] = this._typeCache[typeId] || {};
                this._typeCache[typeId][key] = item;
            }
        }, {
            key: "getCachedTypeItem",
            value: function getCachedTypeItem(key, typeId) {
                return this._typeCache[typeId] ? this._typeCache[typeId][key] : null;
            }
        }, {
            key: "setType",
            value: function setType(typeId, params) {
                this.clearTypes();
                (_splitType(typeId) || []).forEach(this._types.add, this._types);
                _applyTypes(this, params);
            }
        }, {
            key: "getType",
            value: function getType() {
                return Array.from(this._types.keys());
            }
        }, {
            key: "reapplyTypes",
            value: function reapplyTypes(params) {
                _applyTypes(this, params);
            }
        }, {
            key: "hasType",
            value: function hasType(typeId) {
                return this._types.has(typeId);
            }
        }, {
            key: "addType",
            value: function addType(typeId, params) {
                var t = _splitType(typeId), _somethingAdded = false;
                if (t != null) {
                    for (var i = 0, j = t.length; i < j; i++) {
                        if (!this._types.has(t[i])) {
                            this._types.add(t[i]);
                            _somethingAdded = true;
                        }
                    }
                    if (_somethingAdded) {
                        _applyTypes(this, params);
                    }
                }
            }
        }, {
            key: "removeType",
            value: function removeType(typeId, params) {
                var _this2 = this;
                var t = _splitType(typeId), _cont = false, _one = function _one(tt) {
                    if (_this2._types.has(tt)) {
                        _removeTypeCssHelper(_this2, tt);
                        _this2._types["delete"](tt);
                        return true;
                    }
                    return false;
                };
                if (t != null) {
                    for (var i = 0, j = t.length; i < j; i++) {
                        _cont = _one(t[i]) || _cont;
                    }
                    if (_cont) {
                        _applyTypes(this, params);
                    }
                }
            }
        }, {
            key: "clearTypes",
            value: function clearTypes(params) {
                var _this3 = this;
                this._types.forEach(function (t) {
                    _removeTypeCssHelper(_this3, t);
                });
                this._types.clear();
                _applyTypes(this, params);
            }
        }, {
            key: "toggleType",
            value: function toggleType(typeId, params) {
                var t = _splitType(typeId);
                if (t != null) {
                    for (var i = 0, j = t.length; i < j; i++) {
                        if (this._types.has(t[i])) {
                            _removeTypeCssHelper(this, t[i]);
                            this._types["delete"](t[i]);
                        }
                        else {
                            this._types.add(t[i]);
                        }
                    }
                    _applyTypes(this, params);
                }
            }
        }, {
            key: "applyType",
            value: function applyType(t, params) {
                this.setPaintStyle(t.paintStyle);
                this.setHoverPaintStyle(t.hoverPaintStyle);
                this.mergeParameters(t.parameters);
                this.paintStyleInUse = this.getPaintStyle();
                if (t.overlays) {
                    var keep = {}, i;
                    for (i in t.overlays) {
                        var existing = this.overlays[t.overlays[i].options.id];
                        if (existing) {
                            existing.updateFrom(t.overlays[i].options);
                            keep[t.overlays[i].options.id] = true;
                            this.instance.reattachOverlay(existing, this);
                        }
                        else {
                            var _c = this.getCachedTypeItem(TYPE_ITEM_OVERLAY, t.overlays[i].options.id);
                            if (_c != null) {
                                this.instance.reattachOverlay(_c, this);
                                _c.setVisible(true);
                                _c.updateFrom(t.overlays[i].options);
                                this.overlays[_c.id] = _c;
                            }
                            else {
                                _c = this.addOverlay(t.overlays[i]);
                            }
                            keep[_c.id] = true;
                        }
                    }
                    for (i in this.overlays) {
                        if (keep[this.overlays[i].id] == null) {
                            this.removeOverlay(this.overlays[i].id, true);
                        }
                    }
                }
            }
        }, {
            key: "setPaintStyle",
            value: function setPaintStyle(style) {
                this.paintStyle = style;
                this.paintStyleInUse = this.paintStyle;
                _updateHoverStyle(this);
            }
        }, {
            key: "getPaintStyle",
            value: function getPaintStyle() {
                return this.paintStyle;
            }
        }, {
            key: "setHoverPaintStyle",
            value: function setHoverPaintStyle(style) {
                this.hoverPaintStyle = style;
                _updateHoverStyle(this);
            }
        }, {
            key: "getHoverPaintStyle",
            value: function getHoverPaintStyle() {
                return this.hoverPaintStyle;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                for (var i in this.overlays) {
                    this.instance.destroyOverlay(this.overlays[i]);
                }
                this.overlays = {};
                this.overlayPositions = {};
                this.unbind();
                this.clone = null;
            }
        }, {
            key: "isHover",
            value: function isHover() {
                return this._hover;
            }
        }, {
            key: "mergeParameters",
            value: function mergeParameters(p) {
                if (p != null) {
                    extend(this.parameters, p);
                }
            }
        }, {
            key: "setVisible",
            value: function setVisible(v) {
                this.visible = v;
                if (v) {
                    this.showOverlays();
                }
                else {
                    this.hideOverlays();
                }
            }
        }, {
            key: "isVisible",
            value: function isVisible() {
                return this.visible;
            }
        }, {
            key: "setAbsoluteOverlayPosition",
            value: function setAbsoluteOverlayPosition(overlay, xy) {
                this.overlayPositions[overlay.id] = xy;
            }
        }, {
            key: "getAbsoluteOverlayPosition",
            value: function getAbsoluteOverlayPosition(overlay) {
                return this.overlayPositions ? this.overlayPositions[overlay.id] : null;
            }
        }, {
            key: "_clazzManip",
            value: function _clazzManip(action, clazz) {
                for (var i in this.overlays) {
                    if (action === ACTION_ADD) {
                        this.instance.addOverlayClass(this.overlays[i], clazz);
                    }
                    else if (action === ACTION_REMOVE) {
                        this.instance.removeOverlayClass(this.overlays[i], clazz);
                    }
                }
            }
        }, {
            key: "addClass",
            value: function addClass(clazz, cascade) {
                var parts = (this.cssClass || "").split(" ");
                parts.push(clazz);
                this.cssClass = parts.join(" ");
                this._clazzManip(ACTION_ADD, clazz);
            }
        }, {
            key: "removeClass",
            value: function removeClass(clazz, cascade) {
                var parts = (this.cssClass || "").split(" ");
                this.cssClass = parts.filter(function (p) {
                    return p !== clazz;
                }).join(" ");
                this._clazzManip(ACTION_REMOVE, clazz);
            }
        }, {
            key: "getClass",
            value: function getClass() {
                return this.cssClass;
            }
        }, {
            key: "shouldFireEvent",
            value: function shouldFireEvent(event, value, originalEvent) {
                return true;
            }
        }, {
            key: "getData",
            value: function getData() {
                return this.data;
            }
        }, {
            key: "setData",
            value: function setData(d) {
                this.data = d || {};
            }
        }, {
            key: "mergeData",
            value: function mergeData(d) {
                this.data = extend(this.data, d);
            }
        }, {
            key: "addOverlay",
            value: function addOverlay(overlay) {
                var o = _processOverlay(this, overlay);
                if (this.getData && o.type === LabelOverlay.type && !isString$1(overlay)) {
                    var d = this.getData(), p = overlay.options;
                    if (d) {
                        var locationAttribute = p.labelLocationAttribute || LOCATION_ATTRIBUTE;
                        var loc = d[locationAttribute];
                        if (loc) {
                            o.location = loc;
                        }
                    }
                }
                return o;
            }
        }, {
            key: "getOverlay",
            value: function getOverlay(id) {
                return this.overlays[id];
            }
        }, {
            key: "getOverlays",
            value: function getOverlays() {
                return this.overlays;
            }
        }, {
            key: "hideOverlay",
            value: function hideOverlay(id) {
                var o = this.getOverlay(id);
                if (o) {
                    o.setVisible(false);
                }
            }
        }, {
            key: "hideOverlays",
            value: function hideOverlays() {
                for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {
                    ids[_key] = arguments[_key];
                }
                ids = ids || [];
                for (var i in this.overlays) {
                    if (ids.length === 0 || ids.indexOf(i) !== -1) {
                        this.overlays[i].setVisible(false);
                    }
                }
            }
        }, {
            key: "showOverlay",
            value: function showOverlay(id) {
                var o = this.getOverlay(id);
                if (o) {
                    o.setVisible(true);
                }
            }
        }, {
            key: "showOverlays",
            value: function showOverlays() {
                for (var _len2 = arguments.length, ids = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    ids[_key2] = arguments[_key2];
                }
                ids = ids || [];
                for (var i in this.overlays) {
                    if (ids.length === 0 || ids.indexOf(i) !== -1) {
                        this.overlays[i].setVisible(true);
                    }
                }
            }
        }, {
            key: "removeAllOverlays",
            value: function removeAllOverlays() {
                for (var i in this.overlays) {
                    this.instance.destroyOverlay(this.overlays[i]);
                }
                this.overlays = {};
                this.overlayPositions = null;
                this.overlayPlacements = {};
            }
        }, {
            key: "removeOverlay",
            value: function removeOverlay(overlayId, dontCleanup) {
                var o = this.overlays[overlayId];
                if (o) {
                    o.setVisible(false);
                    if (!dontCleanup) {
                        this.instance.destroyOverlay(o);
                    }
                    delete this.overlays[overlayId];
                    if (this.overlayPositions) {
                        delete this.overlayPositions[overlayId];
                    }
                    if (this.overlayPlacements) {
                        delete this.overlayPlacements[overlayId];
                    }
                }
            }
        }, {
            key: "removeOverlays",
            value: function removeOverlays() {
                for (var _len3 = arguments.length, overlays = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                    overlays[_key3] = arguments[_key3];
                }
                for (var i = 0, j = overlays.length; i < j; i++) {
                    this.removeOverlay(arguments[i]);
                }
            }
        }, {
            key: "getLabel",
            value: function getLabel() {
                var lo = this.getLabelOverlay();
                return lo != null ? lo.getLabel() : null;
            }
        }, {
            key: "getLabelOverlay",
            value: function getLabelOverlay() {
                return this.getOverlay(_internalLabelOverlayId);
            }
        }, {
            key: "setLabel",
            value: function setLabel(l) {
                var lo = this.getLabelOverlay();
                if (!lo) {
                    var _params2 = isString$1(l) || isFunction$1(l) ? {
                        label: l
                    } : l;
                    lo = _makeLabelOverlay(this, _params2);
                    this.overlays[_internalLabelOverlayId] = lo;
                }
                else {
                    if (isString$1(l) || isFunction$1(l)) {
                        lo.setLabel(l);
                    }
                    else {
                        var ll = l;
                        if (ll.label) {
                            lo.setLabel(ll.label);
                        }
                        if (ll.location) {
                            lo.location = ll.location;
                        }
                    }
                }
            }
        }]);
    return Component;
}(EventGenerator);
var _opposites, _clockwiseOptions, _antiClockwiseOptions;
var FaceValues;
(function (FaceValues) {
    FaceValues["top"] = "top";
    FaceValues["left"] = "left";
    FaceValues["right"] = "right";
    FaceValues["bottom"] = "bottom";
})(FaceValues || (FaceValues = {}));
var TOP = FaceValues.top;
var LEFT = FaceValues.left;
var RIGHT = FaceValues.right;
var BOTTOM = FaceValues.bottom;
var X_AXIS_FACES = [LEFT, RIGHT];
var Y_AXIS_FACES = [TOP, BOTTOM];
var LightweightFloatingAnchor = function () {
    function LightweightFloatingAnchor(instance, element, elementId) {
        _classCallCheck$3(this, LightweightFloatingAnchor);
        this.instance = instance;
        this.element = element;
        _defineProperty$3(this, "isFloating", true);
        _defineProperty$3(this, "isContinuous", void 0);
        _defineProperty$3(this, "isDynamic", void 0);
        _defineProperty$3(this, "locations", []);
        _defineProperty$3(this, "currentLocation", 0);
        _defineProperty$3(this, "locked", false);
        _defineProperty$3(this, "cssClass", '');
        _defineProperty$3(this, "timestamp", null);
        _defineProperty$3(this, "type", "Floating");
        _defineProperty$3(this, "id", uuid());
        _defineProperty$3(this, "orientation", [0, 0]);
        _defineProperty$3(this, "size", void 0);
        this.size = instance.viewport.getPosition(elementId);
        this.locations.push({
            x: 0.5,
            y: 0.5,
            ox: this.orientation[0],
            oy: this.orientation[1],
            offx: 0,
            offy: 0,
            iox: this.orientation[0],
            ioy: this.orientation[1],
            cls: ''
        });
    }
    _createClass$3(LightweightFloatingAnchor, [{
            key: "_updateOrientationInRouter",
            value: function _updateOrientationInRouter() {
                this.instance.router.setAnchorOrientation(this, [this.locations[0].ox, this.locations[0].oy]);
            }
        }, {
            key: "over",
            value: function over(endpoint) {
                this.orientation = this.instance.router.getEndpointOrientation(endpoint);
                this.locations[0].ox = this.orientation[0];
                this.locations[0].oy = this.orientation[1];
                this._updateOrientationInRouter();
            }
        }, {
            key: "out",
            value: function out() {
                this.orientation = null;
                this.locations[0].ox = this.locations[0].iox;
                this.locations[0].oy = this.locations[0].ioy;
                this._updateOrientationInRouter();
            }
        }]);
    return LightweightFloatingAnchor;
}();
var opposites = (_opposites = {}, _defineProperty$3(_opposites, TOP, BOTTOM), _defineProperty$3(_opposites, RIGHT, LEFT), _defineProperty$3(_opposites, LEFT, RIGHT), _defineProperty$3(_opposites, BOTTOM, TOP), _opposites);
var clockwiseOptions = (_clockwiseOptions = {}, _defineProperty$3(_clockwiseOptions, TOP, RIGHT), _defineProperty$3(_clockwiseOptions, RIGHT, BOTTOM), _defineProperty$3(_clockwiseOptions, LEFT, TOP), _defineProperty$3(_clockwiseOptions, BOTTOM, LEFT), _clockwiseOptions);
var antiClockwiseOptions = (_antiClockwiseOptions = {}, _defineProperty$3(_antiClockwiseOptions, TOP, LEFT), _defineProperty$3(_antiClockwiseOptions, RIGHT, TOP), _defineProperty$3(_antiClockwiseOptions, LEFT, BOTTOM), _defineProperty$3(_antiClockwiseOptions, BOTTOM, RIGHT), _antiClockwiseOptions);
function getDefaultFace(a) {
    return a.faces.length === 0 ? TOP : a.faces[0];
}
function _isFaceAvailable(a, face) {
    return a.faces.indexOf(face) !== -1;
}
function _secondBest(a, edge) {
    return (a.clockwise ? clockwiseOptions : antiClockwiseOptions)[edge];
}
function _lastChoice(a, edge) {
    return (a.clockwise ? antiClockwiseOptions : clockwiseOptions)[edge];
}
function isEdgeSupported(a, edge) {
    return a.lockedAxis == null ? a.lockedFace == null ? _isFaceAvailable(a, edge) === true : a.lockedFace === edge : a.lockedAxis.indexOf(edge) !== -1;
}
function verifyFace(a, edge) {
    if (_isFaceAvailable(a, edge)) {
        return edge;
    }
    else if (_isFaceAvailable(a, opposites[edge])) {
        return opposites[edge];
    }
    else {
        var secondBest = _secondBest(a, edge);
        if (_isFaceAvailable(a, secondBest)) {
            return secondBest;
        }
        else {
            var lastChoice = _lastChoice(a, edge);
            if (_isFaceAvailable(a, lastChoice)) {
                return lastChoice;
            }
        }
    }
    return edge;
}
var _top = {
    x: 0.5,
    y: 0,
    ox: 0,
    oy: -1,
    offx: 0,
    offy: 0
}, _bottom = {
    x: 0.5,
    y: 1,
    ox: 0,
    oy: 1,
    offx: 0,
    offy: 0
}, _left = {
    x: 0,
    y: 0.5,
    ox: -1,
    oy: 0,
    offx: 0,
    offy: 0
}, _right = {
    x: 1,
    y: 0.5,
    ox: 1,
    oy: 0,
    offx: 0,
    offy: 0
}, _topLeft = {
    x: 0,
    y: 0,
    ox: 0,
    oy: -1,
    offx: 0,
    offy: 0
}, _topRight = {
    x: 1,
    y: 0,
    ox: 1,
    oy: -1,
    offx: 0,
    offy: 0
}, _bottomLeft = {
    x: 0,
    y: 1,
    ox: 0,
    oy: 1,
    offx: 0,
    offy: 0
}, _bottomRight = {
    x: 1,
    y: 1,
    ox: 0,
    oy: 1,
    offx: 0,
    offy: 0
}, _center = {
    x: 0.5,
    y: 0.5,
    ox: 0,
    oy: 0,
    offx: 0,
    offy: 0
};
var namedValues = {
    "Top": [_top],
    "Bottom": [_bottom],
    "Left": [_left],
    "Right": [_right],
    "TopLeft": [_topLeft],
    "TopRight": [_topRight],
    "BottomLeft": [_bottomLeft],
    "BottomRight": [_bottomRight],
    "Center": [_center],
    "AutoDefault": [_top, _left, _bottom, _right]
};
var namedContinuousValues = {
    "Continuous": {
        faces: [TOP, LEFT, BOTTOM, RIGHT]
    },
    "ContinuousTop": {
        faces: [TOP]
    },
    "ContinuousRight": {
        faces: [RIGHT]
    },
    "ContinuousBottom": {
        faces: [BOTTOM]
    },
    "ContinuousLeft": {
        faces: [LEFT]
    },
    "ContinuousLeftRight": {
        faces: [LEFT, RIGHT]
    },
    "ContinuousTopBottom": {
        faces: [TOP, BOTTOM]
    }
};
function getNamedAnchor(name, params) {
    params = params || {};
    if (name === AnchorLocations.Perimeter) {
        return _createPerimeterAnchor(params);
    }
    var a = namedValues[name];
    if (a != null) {
        return _createAnchor(name, map$1(a, function (_a) {
            return extend({
                iox: _a.ox,
                ioy: _a.oy
            }, _a);
        }), params);
    }
    a = namedContinuousValues[name];
    if (a != null) {
        return _createContinuousAnchor(name, a.faces, params);
    }
    throw {
        message: "jsPlumb: unknown anchor type '" + name + "'"
    };
}
function _createAnchor(type, locations, params) {
    return {
        type: type,
        locations: locations,
        currentLocation: 0,
        locked: false,
        id: uuid(),
        isFloating: false,
        isContinuous: false,
        isDynamic: locations.length > 1,
        timestamp: null,
        cssClass: params.cssClass || ""
    };
}
function createFloatingAnchor(instance, element, elementId) {
    return new LightweightFloatingAnchor(instance, element, elementId);
}
var PROPERTY_CURRENT_FACE = "currentFace";
function _createContinuousAnchor(type, faces, params) {
    var ca = {
        type: type,
        locations: [],
        currentLocation: 0,
        locked: false,
        id: uuid(),
        cssClass: params.cssClass || "",
        isFloating: false,
        isContinuous: true,
        timestamp: null,
        faces: params.faces || faces,
        lockedFace: null,
        lockedAxis: null,
        clockwise: !(params.clockwise === false),
        __currentFace: null
    };
    Object.defineProperty(ca, PROPERTY_CURRENT_FACE, {
        get: function get() {
            return this.__currentFace;
        },
        set: function set(f) {
            this.__currentFace = verifyFace(this, f);
        }
    });
    return ca;
}
function isPrimitiveAnchorSpec(sa) {
    return sa.length < 7 && sa.every(isNumber$1) || sa.length === 7 && sa.slice(0, 5).every(isNumber$1) && isString$1(sa[6]);
}
function makeLightweightAnchorFromSpec(spec) {
    if (isString$1(spec)) {
        return getNamedAnchor(spec, null);
    }
    else if (Array.isArray(spec)) {
        if (isPrimitiveAnchorSpec(spec)) {
            var _spec = spec;
            return _createAnchor(null, [{
                    x: _spec[0],
                    y: _spec[1],
                    ox: _spec[2],
                    oy: _spec[3],
                    offx: _spec[4] == null ? 0 : _spec[4],
                    offy: _spec[5] == null ? 0 : _spec[5],
                    iox: _spec[2],
                    ioy: _spec[3],
                    cls: _spec[6] || ""
                }], {
                cssClass: _spec[6] || ""
            });
        }
        else {
            var locations = map$1(spec, function (aSpec) {
                if (isString$1(aSpec)) {
                    var a = namedValues[aSpec];
                    return a != null ? extend({
                        iox: a[0].ox,
                        ioy: a[0].oy,
                        cls: ""
                    }, a[0]) : null;
                }
                else if (isPrimitiveAnchorSpec(aSpec)) {
                    return {
                        x: aSpec[0],
                        y: aSpec[1],
                        ox: aSpec[2],
                        oy: aSpec[3],
                        offx: aSpec[4] == null ? 0 : aSpec[4],
                        offy: aSpec[5] == null ? 0 : aSpec[5],
                        iox: aSpec[2],
                        ioy: aSpec[3],
                        cls: aSpec[6] || ""
                    };
                }
            }).filter(function (ar) {
                return ar != null;
            });
            return _createAnchor("Dynamic", locations, {});
        }
    }
    else {
        var sa = spec;
        return getNamedAnchor(sa.type, sa.options);
    }
}
function circleGenerator(anchorCount) {
    var r = 0.5, step = Math.PI * 2 / anchorCount, a = [];
    var current = 0;
    for (var i = 0; i < anchorCount; i++) {
        var x = r + r * Math.sin(current), y = r + r * Math.cos(current);
        a.push({
            x: x,
            y: y,
            ox: 0,
            oy: 0,
            offx: 0,
            offy: 0,
            iox: 0,
            ioy: 0,
            cls: ''
        });
        current += step;
    }
    return a;
}
function _path(segments, anchorCount) {
    var anchorsPerFace = anchorCount / segments.length, a = [], _computeFace = function _computeFace(x1, y1, x2, y2, fractionalLength, ox, oy) {
        anchorsPerFace = anchorCount * fractionalLength;
        var dx = (x2 - x1) / anchorsPerFace, dy = (y2 - y1) / anchorsPerFace;
        for (var i = 0; i < anchorsPerFace; i++) {
            a.push({
                x: x1 + dx * i,
                y: y1 + dy * i,
                ox: ox == null ? 0 : ox,
                oy: oy == null ? 0 : oy,
                offx: 0,
                offy: 0,
                iox: 0,
                ioy: 0,
                cls: ''
            });
        }
    };
    for (var i = 0; i < segments.length; i++) {
        _computeFace.apply(null, segments[i]);
    }
    return a;
}
function shapeGenerator(faces, anchorCount) {
    var s = [];
    for (var i = 0; i < faces.length; i++) {
        s.push([faces[i][0], faces[i][1], faces[i][2], faces[i][3], 1 / faces.length, faces[i][4], faces[i][5]]);
    }
    return _path(s, anchorCount);
}
function rectangleGenerator(anchorCount) {
    return shapeGenerator([[0, 0, 1, 0, 0, -1], [1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 1, 0, 0, -1, 0]], anchorCount);
}
function diamondGenerator(anchorCount) {
    return shapeGenerator([[0.5, 0, 1, 0.5], [1, 0.5, 0.5, 1], [0.5, 1, 0, 0.5], [0, 0.5, 0.5, 0]], anchorCount);
}
function triangleGenerator(anchorCount) {
    return shapeGenerator([[0.5, 0, 1, 1], [1, 1, 0, 1], [0, 1, 0.5, 0]], anchorCount);
}
function rotate$1(points, amountInDegrees) {
    var o = [], theta = amountInDegrees / 180 * Math.PI;
    for (var i = 0; i < points.length; i++) {
        var _x = points[i].x - 0.5, _y = points[i].y - 0.5;
        o.push({
            x: 0.5 + (_x * Math.cos(theta) - _y * Math.sin(theta)),
            y: 0.5 + (_x * Math.sin(theta) + _y * Math.cos(theta)),
            ox: points[i].ox,
            oy: points[i].oy,
            offx: 0,
            offy: 0,
            iox: 0,
            ioy: 0,
            cls: ''
        });
    }
    return o;
}
var anchorGenerators = new Map();
anchorGenerators.set(PerimeterAnchorShapes.Circle, circleGenerator);
anchorGenerators.set(PerimeterAnchorShapes.Ellipse, circleGenerator);
anchorGenerators.set(PerimeterAnchorShapes.Rectangle, rectangleGenerator);
anchorGenerators.set(PerimeterAnchorShapes.Square, rectangleGenerator);
anchorGenerators.set(PerimeterAnchorShapes.Diamond, diamondGenerator);
anchorGenerators.set(PerimeterAnchorShapes.Triangle, triangleGenerator);
function _createPerimeterAnchor(params) {
    params = params || {};
    var anchorCount = params.anchorCount || 60, shape = params.shape;
    if (!shape) {
        throw new Error("no shape supplied to Perimeter Anchor type");
    }
    if (!anchorGenerators.has(shape)) {
        throw new Error("Shape [" + shape + "] is unknown by Perimeter Anchor type");
    }
    var da = anchorGenerators.get(shape)(anchorCount);
    if (params.rotation) {
        da = rotate$1(da, params.rotation);
    }
    var a = _createAnchor(AnchorLocations.Perimeter, da, params);
    var aa = extend(a, {
        shape: shape
    });
    return aa;
}
var TYPE_ITEM_ANCHORS = "anchors";
var TYPE_ITEM_CONNECTOR = "connector";
function prepareEndpoint(conn, existing, index, anchor, element, elementId, endpoint) {
    var e;
    if (existing) {
        conn.endpoints[index] = existing;
        existing.addConnection(conn);
    }
    else {
        var ep = endpoint || conn.endpointSpec || conn.endpointsSpec[index] || conn.instance.defaults.endpoints[index] || conn.instance.defaults.endpoint;
        var es = conn.endpointStyles[index] || conn.endpointStyle || conn.instance.defaults.endpointStyles[index] || conn.instance.defaults.endpointStyle;
        if (es.fill == null && conn.paintStyle != null) {
            es.fill = conn.paintStyle.stroke;
        }
        if (es.outlineStroke == null && conn.paintStyle != null) {
            es.outlineStroke = conn.paintStyle.outlineStroke;
        }
        if (es.outlineWidth == null && conn.paintStyle != null) {
            es.outlineWidth = conn.paintStyle.outlineWidth;
        }
        var ehs = conn.endpointHoverStyles[index] || conn.endpointHoverStyle || conn.endpointHoverStyle || conn.instance.defaults.endpointHoverStyles[index] || conn.instance.defaults.endpointHoverStyle;
        if (conn.hoverPaintStyle != null) {
            if (ehs == null) {
                ehs = {};
            }
            if (ehs.fill == null) {
                ehs.fill = conn.hoverPaintStyle.stroke;
            }
        }
        var u = conn.uuids ? conn.uuids[index] : null;
        anchor = anchor != null ? anchor : conn.instance.defaults.anchors != null ? conn.instance.defaults.anchors[index] : conn.instance.defaults.anchor;
        e = conn.instance._internal_newEndpoint({
            paintStyle: es,
            hoverPaintStyle: ehs,
            endpoint: ep,
            connections: [conn],
            uuid: u,
            element: element,
            scope: conn.scope,
            anchor: anchor,
            reattachConnections: conn.reattach || conn.instance.defaults.reattachConnections,
            connectionsDetachable: conn.detachable || conn.instance.defaults.connectionsDetachable
        });
        conn.instance._refreshEndpoint(e);
        if (existing == null) {
            e.deleteOnEmpty = true;
        }
        conn.endpoints[index] = e;
    }
    return e;
}
var Connection = function (_Component) {
    _inherits$3(Connection, _Component);
    var _super = _createSuper$3(Connection);
    function Connection(instance, params) {
        var _this;
        _classCallCheck$3(this, Connection);
        _this = _super.call(this, instance, params);
        _this.instance = instance;
        _defineProperty$3(_assertThisInitialized$3(_this), "connector", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "defaultLabelLocation", 0.5);
        _defineProperty$3(_assertThisInitialized$3(_this), "scope", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "typeId", "_jsplumb_connection");
        _defineProperty$3(_assertThisInitialized$3(_this), "previousConnection", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "sourceId", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "targetId", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "source", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "target", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "detachable", true);
        _defineProperty$3(_assertThisInitialized$3(_this), "reattach", false);
        _defineProperty$3(_assertThisInitialized$3(_this), "uuids", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "cost", 1);
        _defineProperty$3(_assertThisInitialized$3(_this), "directed", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpoints", [null, null]);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointStyles", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointSpec", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointsSpec", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointStyle", {});
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointHoverStyle", {});
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointHoverStyles", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "suspendedEndpoint", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "suspendedIndex", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "suspendedElement", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "suspendedElementId", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "suspendedElementType", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "_forceReattach", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "_forceDetach", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "proxies", []);
        _defineProperty$3(_assertThisInitialized$3(_this), "pending", false);
        _this.id = params.id;
        _this.previousConnection = params.previousConnection;
        _this.source = params.source;
        _this.target = params.target;
        if (params.sourceEndpoint) {
            _this.source = params.sourceEndpoint.element;
            _this.sourceId = params.sourceEndpoint.elementId;
        }
        else {
            _this.sourceId = instance.getId(_this.source);
        }
        if (params.targetEndpoint) {
            _this.target = params.targetEndpoint.element;
            _this.targetId = params.targetEndpoint.elementId;
        }
        else {
            _this.targetId = instance.getId(_this.target);
        }
        _this.scope = params.scope;
        var sourceAnchor = params.anchors ? params.anchors[0] : params.anchor;
        var targetAnchor = params.anchors ? params.anchors[1] : params.anchor;
        instance.manage(_this.source);
        instance.manage(_this.target);
        _this.visible = true;
        _this.params = {
            cssClass: params.cssClass,
            hoverClass: params.hoverClass,
            "pointer-events": params["pointer-events"],
            overlays: params.overlays
        };
        _this.lastPaintedAt = null;
        if (params.type) {
            params.endpoints = params.endpoints || _this.instance._deriveEndpointAndAnchorSpec(params.type).endpoints;
        }
        _this.endpointSpec = params.endpoint;
        _this.endpointsSpec = params.endpoints || [null, null];
        _this.endpointStyle = params.endpointStyle;
        _this.endpointHoverStyle = params.endpointHoverStyle;
        _this.endpointStyles = params.endpointStyles || [null, null];
        _this.endpointHoverStyles = params.endpointHoverStyles || [null, null];
        _this.paintStyle = params.paintStyle;
        _this.hoverPaintStyle = params.hoverPaintStyle;
        _this.uuids = params.uuids;
        _this.makeEndpoint(true, _this.source, _this.sourceId, sourceAnchor, params.sourceEndpoint);
        _this.makeEndpoint(false, _this.target, _this.targetId, targetAnchor, params.targetEndpoint);
        if (!_this.scope) {
            _this.scope = _this.endpoints[0].scope;
        }
        if (params.deleteEndpointsOnEmpty != null) {
            _this.endpoints[0].deleteOnEmpty = params.deleteEndpointsOnEmpty;
            _this.endpoints[1].deleteOnEmpty = params.deleteEndpointsOnEmpty;
        }
        var _detachable = _this.instance.defaults.connectionsDetachable;
        if (params.detachable === false) {
            _detachable = false;
        }
        if (_this.endpoints[0].connectionsDetachable === false) {
            _detachable = false;
        }
        if (_this.endpoints[1].connectionsDetachable === false) {
            _detachable = false;
        }
        _this.endpointsSpec = params.endpoints || [null, null];
        _this.endpointSpec = params.endpoint || null;
        var _reattach = params.reattach || _this.endpoints[0].reattachConnections || _this.endpoints[1].reattachConnections || _this.instance.defaults.reattachConnections;
        var initialPaintStyle = extend({}, _this.endpoints[0].connectorStyle || _this.endpoints[1].connectorStyle || params.paintStyle || _this.instance.defaults.paintStyle);
        _this.appendToDefaultType({
            detachable: _detachable,
            reattach: _reattach,
            paintStyle: initialPaintStyle,
            hoverPaintStyle: extend({}, _this.endpoints[0].connectorHoverStyle || _this.endpoints[1].connectorHoverStyle || params.hoverPaintStyle || _this.instance.defaults.hoverPaintStyle)
        });
        if (params.outlineWidth) {
            initialPaintStyle.outlineWidth = params.outlineWidth;
        }
        if (params.outlineColor) {
            initialPaintStyle.outlineStroke = params.outlineColor;
        }
        if (params.lineWidth) {
            initialPaintStyle.strokeWidth = params.lineWidth;
        }
        if (params.color) {
            initialPaintStyle.stroke = params.color;
        }
        if (!_this.instance._suspendDrawing) {
            var initialTimestamp = _this.instance._suspendedAt || uuid();
            _this.instance._paintEndpoint(_this.endpoints[0], {
                timestamp: initialTimestamp
            });
            _this.instance._paintEndpoint(_this.endpoints[1], {
                timestamp: initialTimestamp
            });
        }
        _this.cost = params.cost || _this.endpoints[0].connectionCost;
        _this.directed = params.directed;
        if (params.directed == null) {
            _this.directed = _this.endpoints[0].connectionsDirected;
        }
        var _p = extend({}, _this.endpoints[1].parameters);
        extend(_p, _this.endpoints[0].parameters);
        extend(_p, _this.parameters);
        _this.parameters = _p;
        _this.paintStyleInUse = _this.getPaintStyle() || {};
        _this._setConnector(_this.endpoints[0].connector || _this.endpoints[1].connector || params.connector || _this.instance.defaults.connector, true);
        var data = params.data == null || !isObject$1(params.data) ? {} : params.data;
        _this.setData(data);
        var _types = [DEFAULT, _this.endpoints[0].edgeType, _this.endpoints[1].edgeType, params.type].join(" ");
        if (/[^\s]/.test(_types)) {
            _this.addType(_types, params.data);
        }
        return _this;
    }
    _createClass$3(Connection, [{
            key: "getIdPrefix",
            value: function getIdPrefix() {
                return "_jsPlumb_c";
            }
        }, {
            key: "getDefaultOverlayKey",
            value: function getDefaultOverlayKey() {
                return KEY_CONNECTION_OVERLAYS;
            }
        }, {
            key: "getXY",
            value: function getXY() {
                return {
                    x: this.connector.x,
                    y: this.connector.y
                };
            }
        }, {
            key: "makeEndpoint",
            value: function makeEndpoint(isSource, el, elId, anchor, ep) {
                elId = elId || this.instance.getId(el);
                return prepareEndpoint(this, ep, isSource ? 0 : 1, anchor, el);
            }
        }, {
            key: "getTypeDescriptor",
            value: function getTypeDescriptor() {
                return Connection.type;
            }
        }, {
            key: "isDetachable",
            value: function isDetachable(ep) {
                return this.detachable === false ? false : ep != null ? ep.connectionsDetachable === true : this.detachable === true;
            }
        }, {
            key: "setDetachable",
            value: function setDetachable(detachable) {
                this.detachable = detachable === true;
            }
        }, {
            key: "isReattach",
            value: function isReattach() {
                return this.reattach === true || this.endpoints[0].reattachConnections === true || this.endpoints[1].reattachConnections === true;
            }
        }, {
            key: "setReattach",
            value: function setReattach(reattach) {
                this.reattach = reattach === true;
            }
        }, {
            key: "applyType",
            value: function applyType(t, typeMap) {
                var _connector = null;
                if (t.connector != null) {
                    _connector = this.getCachedTypeItem(TYPE_ITEM_CONNECTOR, typeMap.connector);
                    if (_connector == null) {
                        _connector = this.prepareConnector(t.connector, typeMap.connector);
                        this.cacheTypeItem(TYPE_ITEM_CONNECTOR, _connector, typeMap.connector);
                    }
                    this.setPreparedConnector(_connector);
                }
                _get$1(_getPrototypeOf$3(Connection.prototype), "applyType", this).call(this, t, typeMap);
                if (t.detachable != null) {
                    this.setDetachable(t.detachable);
                }
                if (t.reattach != null) {
                    this.setReattach(t.reattach);
                }
                if (t.scope) {
                    this.scope = t.scope;
                }
                var _anchors = null;
                if (t.anchor) {
                    _anchors = this.getCachedTypeItem(TYPE_ITEM_ANCHORS, typeMap.anchor);
                    if (_anchors == null) {
                        _anchors = [makeLightweightAnchorFromSpec(t.anchor), makeLightweightAnchorFromSpec(t.anchor)];
                        this.cacheTypeItem(TYPE_ITEM_ANCHORS, _anchors, typeMap.anchor);
                    }
                }
                else if (t.anchors) {
                    _anchors = this.getCachedTypeItem(TYPE_ITEM_ANCHORS, typeMap.anchors);
                    if (_anchors == null) {
                        _anchors = [makeLightweightAnchorFromSpec(t.anchors[0]), makeLightweightAnchorFromSpec(t.anchors[1])];
                        this.cacheTypeItem(TYPE_ITEM_ANCHORS, _anchors, typeMap.anchors);
                    }
                }
                if (_anchors != null) {
                    this.instance.router.setConnectionAnchors(this, _anchors);
                    if (this.instance.router.isDynamicAnchor(this.endpoints[1])) {
                        this.instance.repaint(this.endpoints[1].element);
                    }
                }
                this.instance.applyConnectorType(this.connector, t);
            }
        }, {
            key: "addClass",
            value: function addClass(c, cascade) {
                _get$1(_getPrototypeOf$3(Connection.prototype), "addClass", this).call(this, c);
                if (cascade) {
                    this.endpoints[0].addClass(c);
                    this.endpoints[1].addClass(c);
                    if (this.suspendedEndpoint) {
                        this.suspendedEndpoint.addClass(c);
                    }
                }
                if (this.connector) {
                    this.instance.addConnectorClass(this.connector, c);
                }
            }
        }, {
            key: "removeClass",
            value: function removeClass(c, cascade) {
                _get$1(_getPrototypeOf$3(Connection.prototype), "removeClass", this).call(this, c);
                if (cascade) {
                    this.endpoints[0].removeClass(c);
                    this.endpoints[1].removeClass(c);
                    if (this.suspendedEndpoint) {
                        this.suspendedEndpoint.removeClass(c);
                    }
                }
                if (this.connector) {
                    this.instance.removeConnectorClass(this.connector, c);
                }
            }
        }, {
            key: "setVisible",
            value: function setVisible(v) {
                _get$1(_getPrototypeOf$3(Connection.prototype), "setVisible", this).call(this, v);
                if (this.connector) {
                    this.instance.setConnectorVisible(this.connector, v);
                }
                this.instance._paintConnection(this);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get$1(_getPrototypeOf$3(Connection.prototype), "destroy", this).call(this);
                this.endpoints = null;
                this.endpointStyles = null;
                this.source = null;
                this.target = null;
                this.instance.destroyConnector(this);
                this.connector = null;
                this.deleted = true;
            }
        }, {
            key: "getUuids",
            value: function getUuids() {
                return [this.endpoints[0].getUuid(), this.endpoints[1].getUuid()];
            }
        }, {
            key: "prepareConnector",
            value: function prepareConnector(connectorSpec, typeId) {
                var connectorArgs = {
                    cssClass: this.params.cssClass,
                    hoverClass: this.params.hoverClass,
                    "pointer-events": this.params["pointer-events"]
                }, connector;
                if (isString$1(connectorSpec)) {
                    connector = this.instance._makeConnector(this, connectorSpec, connectorArgs);
                }
                else {
                    var co = connectorSpec;
                    connector = this.instance._makeConnector(this, co.type, merge$1(co.options || {}, connectorArgs));
                }
                if (typeId != null) {
                    connector.typeId = typeId;
                }
                return connector;
            }
        }, {
            key: "setPreparedConnector",
            value: function setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId) {
                if (this.connector !== connector) {
                    var previous, previousClasses = "";
                    if (this.connector != null) {
                        previous = this.connector;
                        previousClasses = this.instance.getConnectorClass(this.connector);
                        this.instance.destroyConnector(this);
                    }
                    this.connector = connector;
                    if (typeId) {
                        this.cacheTypeItem(TYPE_ITEM_CONNECTOR, connector, typeId);
                    }
                    this.addClass(previousClasses);
                    if (previous != null) {
                        var o = this.getOverlays();
                        for (var i in o) {
                            this.instance.reattachOverlay(o[i], this);
                        }
                    }
                    if (!doNotRepaint) {
                        this.instance._paintConnection(this);
                    }
                }
            }
        }, {
            key: "_setConnector",
            value: function _setConnector(connectorSpec, doNotRepaint, doNotChangeListenerComponent, typeId) {
                var connector = this.prepareConnector(connectorSpec, typeId);
                this.setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId);
            }
        }, {
            key: "replaceEndpoint",
            value: function replaceEndpoint(idx, endpointDef) {
                var current = this.endpoints[idx], elId = current.elementId, ebe = this.instance.getEndpoints(current.element), _idx = ebe.indexOf(current), _new = prepareEndpoint(this, null, idx, null, current.element, elId, endpointDef);
                this.endpoints[idx] = _new;
                ebe.splice(_idx, 1, _new);
                current.detachFromConnection(this);
                this.instance.deleteEndpoint(current);
                this.instance.fire(EVENT_ENDPOINT_REPLACED, {
                    previous: current,
                    current: _new
                });
            }
        }]);
    return Connection;
}(Component);
_defineProperty$3(Connection, "type", "connection");
var typeParameters = ["connectorStyle", "connectorHoverStyle", "connectorOverlays", "connector", "connectionType", "connectorClass", "connectorHoverClass"];
var Endpoint = function (_Component) {
    _inherits$3(Endpoint, _Component);
    var _super = _createSuper$3(Endpoint);
    function Endpoint(instance, params) {
        var _this;
        _classCallCheck$3(this, Endpoint);
        _this = _super.call(this, instance, params);
        _this.instance = instance;
        _defineProperty$3(_assertThisInitialized$3(_this), "connections", []);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpoint", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "element", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "elementId", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "dragAllowedWhenFull", true);
        _defineProperty$3(_assertThisInitialized$3(_this), "timestamp", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "portId", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "maxConnections", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "proxiedBy", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "connectorClass", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "connectorHoverClass", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "finalEndpoint", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "enabled", true);
        _defineProperty$3(_assertThisInitialized$3(_this), "isSource", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "isTarget", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "isTemporarySource", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "connectionCost", 1);
        _defineProperty$3(_assertThisInitialized$3(_this), "connectionsDirected", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "connectionsDetachable", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "reattachConnections", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "currentAnchorClass", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "referenceEndpoint", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "edgeType", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "connector", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "connectorOverlays", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "connectorStyle", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "connectorHoverStyle", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "deleteOnEmpty", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "uuid", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "scope", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "_anchor", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "defaultLabelLocation", [0.5, 0.5]);
        _this.appendToDefaultType({
            edgeType: params.edgeType,
            maxConnections: params.maxConnections == null ? _this.instance.defaults.maxConnections : params.maxConnections,
            paintStyle: params.paintStyle || _this.instance.defaults.endpointStyle,
            hoverPaintStyle: params.hoverPaintStyle || _this.instance.defaults.endpointHoverStyle,
            connectorStyle: params.connectorStyle,
            connectorHoverStyle: params.connectorHoverStyle,
            connectorClass: params.connectorClass,
            connectorHoverClass: params.connectorHoverClass,
            connectorOverlays: params.connectorOverlays,
            connector: params.connector
        });
        _this.enabled = !(params.enabled === false);
        _this.visible = true;
        _this.element = params.element;
        _this.uuid = params.uuid;
        _this.portId = params.portId;
        _this.elementId = params.elementId;
        _this.connectionCost = params.connectionCost == null ? 1 : params.connectionCost;
        _this.connectionsDirected = params.connectionsDirected;
        _this.currentAnchorClass = "";
        _this.events = {};
        _this.connectorOverlays = params.connectorOverlays;
        _this.connectorStyle = params.connectorStyle;
        _this.connectorHoverStyle = params.connectorHoverStyle;
        _this.connector = params.connector;
        _this.edgeType = params.edgeType;
        _this.connectorClass = params.connectorClass;
        _this.connectorHoverClass = params.connectorHoverClass;
        _this.deleteOnEmpty = params.deleteOnEmpty === true;
        _this.isSource = params.source || false;
        _this.isTemporarySource = params.isTemporarySource || false;
        _this.isTarget = params.target || false;
        _this.connections = params.connections || [];
        _this.scope = params.scope || instance.defaultScope;
        _this.timestamp = null;
        _this.reattachConnections = params.reattachConnections || instance.defaults.reattachConnections;
        _this.connectionsDetachable = instance.defaults.connectionsDetachable;
        if (params.connectionsDetachable === false) {
            _this.connectionsDetachable = false;
        }
        _this.dragAllowedWhenFull = params.dragAllowedWhenFull !== false;
        if (params.onMaxConnections) {
            _this.bind(EVENT_MAX_CONNECTIONS, params.onMaxConnections);
        }
        var ep = params.endpoint || params.existingEndpoint || instance.defaults.endpoint;
        _this.setEndpoint(ep);
        if (params.preparedAnchor != null) {
            _this.setPreparedAnchor(params.preparedAnchor);
        }
        else {
            var anchorParamsToUse = params.anchor ? params.anchor : params.anchors ? params.anchors : instance.defaults.anchor || AnchorLocations.Top;
            _this.setAnchor(anchorParamsToUse);
        }
        var type = [DEFAULT, params.type || ""].join(" ");
        _this.addType(type, params.data);
        return _this;
    }
    _createClass$3(Endpoint, [{
            key: "getIdPrefix",
            value: function getIdPrefix() {
                return "_jsplumb_e";
            }
        }, {
            key: "getTypeDescriptor",
            value: function getTypeDescriptor() {
                return "endpoint";
            }
        }, {
            key: "getXY",
            value: function getXY() {
                return {
                    x: this.endpoint.x,
                    y: this.endpoint.y
                };
            }
        }, {
            key: "getDefaultOverlayKey",
            value: function getDefaultOverlayKey() {
                return "endpointOverlays";
            }
        }, {
            key: "_updateAnchorClass",
            value: function _updateAnchorClass() {
                var ac = this._anchor && this._anchor.cssClass;
                if (ac != null && ac.length > 0) {
                    var oldAnchorClass = this.instance.endpointAnchorClassPrefix + "-" + this.currentAnchorClass;
                    this.currentAnchorClass = ac;
                    var anchorClass = this.instance.endpointAnchorClassPrefix + (this.currentAnchorClass ? "-" + this.currentAnchorClass : "");
                    if (oldAnchorClass !== anchorClass) {
                        this.removeClass(oldAnchorClass);
                        this.addClass(anchorClass);
                        this.instance.removeClass(this.element, oldAnchorClass);
                        this.instance.addClass(this.element, anchorClass);
                    }
                }
            }
        }, {
            key: "setPreparedAnchor",
            value: function setPreparedAnchor(anchor) {
                this.instance.router.setAnchor(this, anchor);
                this._updateAnchorClass();
                return this;
            }
        }, {
            key: "_anchorLocationChanged",
            value: function _anchorLocationChanged(currentAnchor) {
                this.fire(EVENT_ANCHOR_CHANGED, {
                    endpoint: this,
                    anchor: currentAnchor
                });
                this._updateAnchorClass();
            }
        }, {
            key: "setAnchor",
            value: function setAnchor(anchorParams) {
                var a = this.instance.router.prepareAnchor(anchorParams);
                this.setPreparedAnchor(a);
                return this;
            }
        }, {
            key: "addConnection",
            value: function addConnection(conn) {
                this.connections.push(conn);
                this.instance._refreshEndpoint(this);
            }
        }, {
            key: "detachFromConnection",
            value: function detachFromConnection(connection, idx, transientDetach) {
                idx = idx == null ? this.connections.indexOf(connection) : idx;
                if (idx >= 0) {
                    this.connections.splice(idx, 1);
                    this.instance._refreshEndpoint(this);
                }
                if (!transientDetach && this.deleteOnEmpty && this.connections.length === 0) {
                    this.instance.deleteEndpoint(this);
                }
            }
        }, {
            key: "deleteEveryConnection",
            value: function deleteEveryConnection(params) {
                var c = this.connections.length;
                for (var i = 0; i < c; i++) {
                    this.instance.deleteConnection(this.connections[0], params);
                }
            }
        }, {
            key: "detachFrom",
            value: function detachFrom(otherEndpoint) {
                var c = [];
                for (var i = 0; i < this.connections.length; i++) {
                    if (this.connections[i].endpoints[1] === otherEndpoint || this.connections[i].endpoints[0] === otherEndpoint) {
                        c.push(this.connections[i]);
                    }
                }
                for (var j = 0, count = c.length; j < count; j++) {
                    this.instance.deleteConnection(c[0]);
                }
                return this;
            }
        }, {
            key: "setVisible",
            value: function setVisible(v, doNotChangeConnections, doNotNotifyOtherEndpoint) {
                _get$1(_getPrototypeOf$3(Endpoint.prototype), "setVisible", this).call(this, v);
                this.endpoint.setVisible(v);
                if (v) {
                    this.showOverlays();
                }
                else {
                    this.hideOverlays();
                }
                if (!doNotChangeConnections) {
                    for (var i = 0; i < this.connections.length; i++) {
                        this.connections[i].setVisible(v);
                        if (!doNotNotifyOtherEndpoint) {
                            var oIdx = this === this.connections[i].endpoints[0] ? 1 : 0;
                            if (this.connections[i].endpoints[oIdx].connections.length === 1) {
                                this.connections[i].endpoints[oIdx].setVisible(v, true, true);
                            }
                        }
                    }
                }
            }
        }, {
            key: "applyType",
            value: function applyType(t, typeMap) {
                _get$1(_getPrototypeOf$3(Endpoint.prototype), "applyType", this).call(this, t, typeMap);
                this.setPaintStyle(t.endpointStyle || t.paintStyle);
                this.setHoverPaintStyle(t.endpointHoverStyle || t.hoverPaintStyle);
                this.connectorStyle = t.connectorStyle;
                this.connectorHoverStyle = t.connectorHoverStyle;
                this.connector = t.connector;
                this.connectorOverlays = t.connectorOverlays;
                this.edgeType = t.edgeType;
                if (t.maxConnections != null) {
                    this.maxConnections = t.maxConnections;
                }
                if (t.scope) {
                    this.scope = t.scope;
                }
                extend(t, typeParameters);
                this.instance.applyEndpointType(this, t);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                _get$1(_getPrototypeOf$3(Endpoint.prototype), "destroy", this).call(this);
                this.deleted = true;
                if (this.endpoint != null) {
                    this.instance.destroyEndpoint(this);
                }
            }
        }, {
            key: "isFull",
            value: function isFull() {
                return this.maxConnections === 0 ? true : !(this.isFloating() || this.maxConnections < 0 || this.connections.length < this.maxConnections);
            }
        }, {
            key: "isFloating",
            value: function isFloating() {
                return this.instance.router.isFloating(this);
            }
        }, {
            key: "isConnectedTo",
            value: function isConnectedTo(otherEndpoint) {
                var found = false;
                if (otherEndpoint) {
                    for (var i = 0; i < this.connections.length; i++) {
                        if (this.connections[i].endpoints[1] === otherEndpoint || this.connections[i].endpoints[0] === otherEndpoint) {
                            found = true;
                            break;
                        }
                    }
                }
                return found;
            }
        }, {
            key: "setDragAllowedWhenFull",
            value: function setDragAllowedWhenFull(allowed) {
                this.dragAllowedWhenFull = allowed;
            }
        }, {
            key: "getUuid",
            value: function getUuid() {
                return this.uuid;
            }
        }, {
            key: "connectorSelector",
            value: function connectorSelector() {
                return this.connections[0];
            }
        }, {
            key: "prepareEndpoint",
            value: function prepareEndpoint(ep, typeId) {
                var endpointArgs = {
                    cssClass: this.cssClass,
                    endpoint: this
                };
                var endpoint;
                if (isAssignableFrom(ep, EndpointRepresentation)) {
                    var epr = ep;
                    endpoint = EndpointFactory.clone(epr);
                    endpoint.classes = endpointArgs.cssClass.split(" ");
                }
                else if (isString$1(ep)) {
                    endpoint = EndpointFactory.get(this, ep, endpointArgs);
                }
                else {
                    var fep = ep;
                    extend(endpointArgs, fep.options || {});
                    endpoint = EndpointFactory.get(this, fep.type, endpointArgs);
                }
                endpoint.typeId = typeId;
                return endpoint;
            }
        }, {
            key: "setEndpoint",
            value: function setEndpoint(ep) {
                var _ep = this.prepareEndpoint(ep);
                this.setPreparedEndpoint(_ep);
            }
        }, {
            key: "setPreparedEndpoint",
            value: function setPreparedEndpoint(ep) {
                if (this.endpoint != null) {
                    this.instance.destroyEndpoint(this);
                }
                this.endpoint = ep;
            }
        }, {
            key: "addClass",
            value: function addClass(clazz, cascade) {
                _get$1(_getPrototypeOf$3(Endpoint.prototype), "addClass", this).call(this, clazz, cascade);
                if (this.endpoint != null) {
                    this.endpoint.addClass(clazz);
                }
            }
        }, {
            key: "removeClass",
            value: function removeClass(clazz, cascade) {
                _get$1(_getPrototypeOf$3(Endpoint.prototype), "removeClass", this).call(this, clazz, cascade);
                if (this.endpoint != null) {
                    this.endpoint.removeClass(clazz);
                }
            }
        }]);
    return Endpoint;
}(Component);
var UINode = function UINode(instance, el) {
    _classCallCheck$3(this, UINode);
    this.instance = instance;
    this.el = el;
    _defineProperty$3(this, "group", void 0);
};
var UIGroup = function (_UINode) {
    _inherits$3(UIGroup, _UINode);
    var _super = _createSuper$3(UIGroup);
    function UIGroup(instance, el, options) {
        var _this;
        _classCallCheck$3(this, UIGroup);
        _this = _super.call(this, instance, el);
        _this.instance = instance;
        _defineProperty$3(_assertThisInitialized$3(_this), "children", []);
        _defineProperty$3(_assertThisInitialized$3(_this), "collapsed", false);
        _defineProperty$3(_assertThisInitialized$3(_this), "droppable", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "enabled", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "orphan", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "constrain", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "proxied", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "ghost", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "revert", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "prune", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "dropOverride", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "anchor", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpoint", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "connections", {
            source: [],
            target: [],
            internal: []
        });
        _defineProperty$3(_assertThisInitialized$3(_this), "manager", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "id", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "elId", void 0);
        var jel = _this.el;
        jel._isJsPlumbGroup = true;
        jel._jsPlumbGroup = _assertThisInitialized$3(_this);
        _this.elId = instance.getId(el);
        _this.orphan = options.orphan === true;
        _this.revert = _this.orphan === true ? false : options.revert !== false;
        _this.droppable = options.droppable !== false;
        _this.ghost = options.ghost === true;
        _this.enabled = options.enabled !== false;
        _this.prune = _this.orphan !== true && options.prune === true;
        _this.constrain = _this.ghost || options.constrain === true;
        _this.proxied = options.proxied !== false;
        _this.id = options.id || uuid();
        _this.dropOverride = options.dropOverride === true;
        _this.anchor = options.anchor;
        _this.endpoint = options.endpoint;
        _this.anchor = options.anchor;
        instance.setAttribute(el, ATTRIBUTE_GROUP, "");
        return _this;
    }
    _createClass$3(UIGroup, [{
            key: "contentArea",
            get: function get() {
                return this.instance.getGroupContentArea(this);
            }
        }, {
            key: "overrideDrop",
            value: function overrideDrop(el, targetGroup) {
                return this.dropOverride && (this.revert || this.prune || this.orphan);
            }
        }, {
            key: "getAnchor",
            value: function getAnchor(conn, endpointIndex) {
                return this.anchor || "Continuous";
            }
        }, {
            key: "getEndpoint",
            value: function getEndpoint(conn, endpointIndex) {
                return this.endpoint || {
                    type: DotEndpoint.type,
                    options: {
                        radius: 10
                    }
                };
            }
        }, {
            key: "add",
            value: function add(_el, doNotFireEvent) {
                var dragArea = this.instance.getGroupContentArea(this);
                var __el = _el;
                if (__el._jsPlumbParentGroup != null) {
                    if (__el._jsPlumbParentGroup === this) {
                        return;
                    }
                    else {
                        __el._jsPlumbParentGroup.remove(_el, true, doNotFireEvent, false);
                    }
                }
                __el._jsPlumbParentGroup = this;
                this.children.push(new UINode(this.instance, _el));
                this.instance._appendElement(__el, dragArea);
                this.manager._updateConnectionsForGroup(this);
            }
        }, {
            key: "resolveNode",
            value: function resolveNode(el) {
                return el == null ? null : getWithFunction(this.children, function (u) {
                    return u.el === el;
                });
            }
        }, {
            key: "remove",
            value: function remove(el, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup) {
                var uiNode = this.resolveNode(el);
                if (uiNode != null) {
                    this._doRemove(uiNode, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup);
                }
            }
        }, {
            key: "_doRemove",
            value: function _doRemove(child, manipulateDOM, doNotFireEvent, doNotUpdateConnections, targetGroup) {
                var __el = child.el;
                delete __el._jsPlumbParentGroup;
                removeWithFunction(this.children, function (e) {
                    return e === child;
                });
                if (manipulateDOM) {
                    try {
                        this.instance.getGroupContentArea(this).removeChild(__el);
                    }
                    catch (e) {
                        log("Could not remove element from Group " + e);
                    }
                }
                if (!doNotFireEvent) {
                    var p = {
                        group: this,
                        el: __el
                    };
                    if (targetGroup) {
                        p.targetGroup = targetGroup;
                    }
                    this.instance.fire(EVENT_GROUP_MEMBER_REMOVED, p);
                }
                if (!doNotUpdateConnections) {
                    this.manager._updateConnectionsForGroup(this);
                }
            }
        }, {
            key: "removeAll",
            value: function removeAll(manipulateDOM, doNotFireEvent) {
                for (var i = 0, l = this.children.length; i < l; i++) {
                    var child = this.children[0];
                    this._doRemove(child, manipulateDOM, doNotFireEvent, true);
                    this.instance.unmanage(child.el, true);
                }
                this.children.length = 0;
                this.manager._updateConnectionsForGroup(this);
            }
        }, {
            key: "orphanAll",
            value: function orphanAll() {
                var orphanedPositions = {};
                for (var i = 0; i < this.children.length; i++) {
                    var newPosition = this.manager.orphan(this.children[i].el, false);
                    orphanedPositions[newPosition.id] = newPosition.pos;
                }
                this.children.length = 0;
                return orphanedPositions;
            }
        }, {
            key: "addGroup",
            value: function addGroup(group) {
                if (this.instance.allowNestedGroups && group !== this) {
                    if (this.instance.groupManager.isAncestor(this, group)) {
                        return false;
                    }
                    if (group.group != null) {
                        group.group.removeGroup(group);
                    }
                    var groupElId = this.instance.getId(group.el);
                    var entry = this.instance.getManagedElements()[groupElId];
                    entry.group = this.elId;
                    var elpos = this.instance.getOffsetRelativeToRoot(group.el);
                    var cpos = this.collapsed ? this.instance.getOffsetRelativeToRoot(this.el) : this.instance.getOffsetRelativeToRoot(this.instance.getGroupContentArea(this));
                    group.el._jsPlumbParentGroup = this;
                    this.children.push(group);
                    this.instance._appendElementToGroup(this, group.el);
                    group.group = this;
                    var newPosition = {
                        x: elpos.x - cpos.x,
                        y: elpos.y - cpos.y
                    };
                    this.instance.setPosition(group.el, newPosition);
                    this.instance.fire(EVENT_NESTED_GROUP_ADDED, {
                        parent: this,
                        child: group
                    });
                    return true;
                }
                else {
                    return false;
                }
            }
        }, {
            key: "removeGroup",
            value: function removeGroup(group) {
                if (group.group === this) {
                    var jel = group.el;
                    var d = this.instance.getGroupContentArea(this);
                    if (d === jel.parentNode) {
                        d.removeChild(group.el);
                    }
                    var groupElId = this.instance.getId(group.el);
                    var entry = this.instance.getManagedElements()[groupElId];
                    if (entry) {
                        delete entry.group;
                    }
                    this.children = this.children.filter(function (cg) {
                        return cg.id !== group.id;
                    });
                    delete group.group;
                    delete jel._jsPlumbParentGroup;
                    this.instance.fire(EVENT_NESTED_GROUP_REMOVED, {
                        parent: this,
                        child: group
                    });
                }
            }
        }, {
            key: "getGroups",
            value: function getGroups() {
                return this.children.filter(function (cg) {
                    return cg.constructor === UIGroup;
                });
            }
        }, {
            key: "getNodes",
            value: function getNodes() {
                return this.children.filter(function (cg) {
                    return cg.constructor === UINode;
                });
            }
        }, {
            key: "collapseParent",
            get: function get() {
                var cg = null;
                if (this.group == null) {
                    return null;
                }
                else {
                    var g = this.group;
                    while (g != null) {
                        if (g.collapsed) {
                            cg = g;
                        }
                        g = g.group;
                    }
                    return cg;
                }
            }
        }]);
    return UIGroup;
}(UINode);
var GroupManager = function () {
    function GroupManager(instance) {
        var _this = this;
        _classCallCheck$3(this, GroupManager);
        this.instance = instance;
        _defineProperty$3(this, "groupMap", {});
        _defineProperty$3(this, "_connectionSourceMap", {});
        _defineProperty$3(this, "_connectionTargetMap", {});
        instance.bind(EVENT_INTERNAL_CONNECTION, function (p) {
            var sourceGroup = _this.getGroupFor(p.source);
            var targetGroup = _this.getGroupFor(p.target);
            if (sourceGroup != null && targetGroup != null && sourceGroup === targetGroup) {
                _this._connectionSourceMap[p.connection.id] = sourceGroup;
                _this._connectionTargetMap[p.connection.id] = sourceGroup;
                suggest(sourceGroup.connections.internal, p.connection);
            }
            else {
                if (sourceGroup != null) {
                    if (p.target._jsPlumbGroup === sourceGroup) {
                        suggest(sourceGroup.connections.internal, p.connection);
                    }
                    else {
                        suggest(sourceGroup.connections.source, p.connection);
                    }
                    _this._connectionSourceMap[p.connection.id] = sourceGroup;
                }
                if (targetGroup != null) {
                    if (p.source._jsPlumbGroup === targetGroup) {
                        suggest(targetGroup.connections.internal, p.connection);
                    }
                    else {
                        suggest(targetGroup.connections.target, p.connection);
                    }
                    _this._connectionTargetMap[p.connection.id] = targetGroup;
                }
            }
        });
        instance.bind(EVENT_INTERNAL_CONNECTION_DETACHED, function (p) {
            _this._cleanupDetachedConnection(p.connection);
        });
        instance.bind(EVENT_CONNECTION_MOVED, function (p) {
            var originalElement = p.originalEndpoint.element, originalGroup = _this.getGroupFor(originalElement), newEndpoint = p.connection.endpoints[p.index], newElement = newEndpoint.element, newGroup = _this.getGroupFor(newElement), connMap = p.index === 0 ? _this._connectionSourceMap : _this._connectionTargetMap, otherConnMap = p.index === 0 ? _this._connectionTargetMap : _this._connectionSourceMap;
            if (newGroup != null) {
                connMap[p.connection.id] = newGroup;
                if (p.connection.source === p.connection.target) {
                    otherConnMap[p.connection.id] = newGroup;
                }
            }
            else {
                delete connMap[p.connection.id];
                if (p.connection.source === p.connection.target) {
                    delete otherConnMap[p.connection.id];
                }
            }
            if (originalGroup != null) {
                _this._updateConnectionsForGroup(originalGroup);
            }
            if (newGroup != null) {
                _this._updateConnectionsForGroup(newGroup);
            }
        });
    }
    _createClass$3(GroupManager, [{
            key: "_cleanupDetachedConnection",
            value: function _cleanupDetachedConnection(conn) {
                conn.proxies.length = 0;
                var group = this._connectionSourceMap[conn.id], f;
                if (group != null) {
                    f = function f(c) {
                        return c.id === conn.id;
                    };
                    removeWithFunction(group.connections.source, f);
                    removeWithFunction(group.connections.target, f);
                    removeWithFunction(group.connections.internal, f);
                    delete this._connectionSourceMap[conn.id];
                }
                group = this._connectionTargetMap[conn.id];
                if (group != null) {
                    f = function f(c) {
                        return c.id === conn.id;
                    };
                    removeWithFunction(group.connections.source, f);
                    removeWithFunction(group.connections.target, f);
                    removeWithFunction(group.connections.internal, f);
                    delete this._connectionTargetMap[conn.id];
                }
            }
        }, {
            key: "addGroup",
            value: function addGroup(params) {
                var jel = params.el;
                if (this.groupMap[params.id] != null) {
                    throw new Error("cannot create Group [" + params.id + "]; a Group with that ID exists");
                }
                if (jel._isJsPlumbGroup != null) {
                    throw new Error("cannot create Group [" + params.id + "]; the given element is already a Group");
                }
                var group = new UIGroup(this.instance, params.el, params);
                this.groupMap[group.id] = group;
                if (params.collapsed) {
                    this.collapseGroup(group);
                }
                this.instance.manage(group.el);
                this.instance.addClass(group.el, CLASS_GROUP_EXPANDED);
                group.manager = this;
                this._updateConnectionsForGroup(group);
                this.instance.fire(EVENT_GROUP_ADDED, {
                    group: group
                });
                return group;
            }
        }, {
            key: "getGroup",
            value: function getGroup(groupId) {
                var group = groupId;
                if (isString$1(groupId)) {
                    group = this.groupMap[groupId];
                    if (group == null) {
                        throw new Error("No such group [" + groupId + "]");
                    }
                }
                return group;
            }
        }, {
            key: "getGroupFor",
            value: function getGroupFor(el) {
                var jel = el;
                var c = this.instance.getContainer();
                var abort = false, g = null;
                while (!abort) {
                    if (jel == null || jel === c) {
                        abort = true;
                    }
                    else {
                        if (jel._jsPlumbParentGroup) {
                            g = jel._jsPlumbParentGroup;
                            abort = true;
                        }
                        else {
                            jel = jel.parentNode;
                        }
                    }
                }
                return g;
            }
        }, {
            key: "getGroups",
            value: function getGroups() {
                var g = [];
                for (var key in this.groupMap) {
                    g.push(this.groupMap[key]);
                }
                return g;
            }
        }, {
            key: "removeGroup",
            value: function removeGroup(group, deleteMembers, manipulateView, doNotFireEvent) {
                var _this2 = this;
                var actualGroup = this.getGroup(group);
                this.expandGroup(actualGroup, true);
                var newPositions = {};
                forEach$1(actualGroup.children, function (uiNode) {
                    var entry = _this2.instance.getManagedElements()[_this2.instance.getId(uiNode.el)];
                    if (entry) {
                        delete entry.group;
                    }
                });
                if (deleteMembers) {
                    forEach$1(actualGroup.getGroups(), function (cg) {
                        return _this2.removeGroup(cg, deleteMembers, manipulateView);
                    });
                    actualGroup.removeAll(manipulateView, doNotFireEvent);
                }
                else {
                    if (actualGroup.group) {
                        forEach$1(actualGroup.children, function (c) {
                            return actualGroup.group.add(c.el);
                        });
                    }
                    newPositions = actualGroup.orphanAll();
                }
                if (actualGroup.group) {
                    actualGroup.group.removeGroup(actualGroup);
                }
                this.instance.unmanage(actualGroup.el, true);
                delete this.groupMap[actualGroup.id];
                this.instance.fire(EVENT_GROUP_REMOVED, {
                    group: actualGroup
                });
                return newPositions;
            }
        }, {
            key: "removeAllGroups",
            value: function removeAllGroups(deleteMembers, manipulateView, doNotFireEvent) {
                for (var _g in this.groupMap) {
                    this.removeGroup(this.groupMap[_g], deleteMembers, manipulateView, doNotFireEvent);
                }
            }
        }, {
            key: "forEach",
            value: function forEach(f) {
                for (var key in this.groupMap) {
                    f(this.groupMap[key]);
                }
            }
        }, {
            key: "orphan",
            value: function orphan(el, doNotTransferToAncestor) {
                var jel = el;
                if (jel._jsPlumbParentGroup) {
                    var currentParent = jel._jsPlumbParentGroup;
                    var id = this.instance.getId(jel);
                    var pos = this.instance.getOffset(el);
                    if (doNotTransferToAncestor !== true && currentParent.group) {
                        this.instance._appendElementToGroup(currentParent.group, el);
                    }
                    else {
                        this.instance._appendElementToContainer(el);
                    }
                    this.instance.setPosition(el, pos);
                    delete jel._jsPlumbParentGroup;
                    return {
                        id: id,
                        pos: pos
                    };
                }
            }
        }, {
            key: "_updateConnectionsForGroup",
            value: function _updateConnectionsForGroup(group) {
                var _this3 = this;
                group.connections.source.length = 0;
                group.connections.target.length = 0;
                group.connections.internal.length = 0;
                var members = group.children.slice().map(function (cn) {
                    return cn.el;
                });
                var childMembers = [];
                forEach$1(members, function (member) {
                    Array.prototype.push.apply(childMembers, _this3.instance.getSelector(member, SELECTOR_MANAGED_ELEMENT));
                });
                Array.prototype.push.apply(members, childMembers);
                if (members.length > 0) {
                    var c1 = this.instance.getConnections({
                        source: members,
                        scope: WILDCARD
                    }, true);
                    var c2 = this.instance.getConnections({
                        target: members,
                        scope: WILDCARD
                    }, true);
                    var processed = {};
                    var gs, gt;
                    var oneSet = function oneSet(c) {
                        for (var i = 0; i < c.length; i++) {
                            if (processed[c[i].id]) {
                                continue;
                            }
                            processed[c[i].id] = true;
                            gs = _this3.getGroupFor(c[i].source);
                            gt = _this3.getGroupFor(c[i].target);
                            if (c[i].source === group.el && gt === group || c[i].target === group.el && gs === group) {
                                group.connections.internal.push(c[i]);
                            }
                            else if (gs === group) {
                                if (gt !== group) {
                                    group.connections.source.push(c[i]);
                                }
                                else {
                                    group.connections.internal.push(c[i]);
                                }
                                _this3._connectionSourceMap[c[i].id] = group;
                            }
                            else if (gt === group) {
                                group.connections.target.push(c[i]);
                                _this3._connectionTargetMap[c[i].id] = group;
                            }
                        }
                    };
                    oneSet(c1);
                    oneSet(c2);
                }
            }
        }, {
            key: "_collapseConnection",
            value: function _collapseConnection(conn, index, group) {
                var otherEl = conn.endpoints[index === 0 ? 1 : 0].element;
                if (otherEl._jsPlumbParentGroup && !otherEl._jsPlumbParentGroup.proxied && otherEl._jsPlumbParentGroup.collapsed) {
                    return false;
                }
                var es = conn.endpoints[0].element, esg = es._jsPlumbParentGroup, esgcp = esg != null ? esg.collapseParent || esg : null, et = conn.endpoints[1].element, etg = et._jsPlumbParentGroup, etgcp = etg != null ? etg.collapseParent || etg : null;
                if (esgcp == null || etgcp == null || esgcp.id !== etgcp.id) {
                    var groupEl = group.el;
                    this.instance.getId(groupEl);
                    this.instance.proxyConnection(conn, index, groupEl, function (conn, index) {
                        return group.getEndpoint(conn, index);
                    }, function (conn, index) {
                        return group.getAnchor(conn, index);
                    });
                    return true;
                }
                else {
                    return false;
                }
            }
        }, {
            key: "_expandConnection",
            value: function _expandConnection(c, index, group) {
                this.instance.unproxyConnection(c, index);
            }
        }, {
            key: "isElementDescendant",
            value: function isElementDescendant(el, parentEl) {
                var c = this.instance.getContainer();
                var abort = false;
                while (!abort) {
                    if (el == null || el === c) {
                        return false;
                    }
                    else {
                        if (el === parentEl) {
                            return true;
                        }
                        else {
                            el = el.parentNode;
                        }
                    }
                }
            }
        }, {
            key: "collapseGroup",
            value: function collapseGroup(group) {
                var _this4 = this;
                var actualGroup = this.getGroup(group);
                if (actualGroup == null || actualGroup.collapsed) {
                    return;
                }
                var groupEl = actualGroup.el;
                if (actualGroup.collapseParent == null) {
                    this.instance.setGroupVisible(actualGroup, false);
                    actualGroup.collapsed = true;
                    this.instance.removeClass(groupEl, CLASS_GROUP_EXPANDED);
                    this.instance.addClass(groupEl, CLASS_GROUP_COLLAPSED);
                    if (actualGroup.proxied) {
                        var collapsedConnectionIds = new Set();
                        var _collapseSet = function _collapseSet(conns, index) {
                            for (var i = 0; i < conns.length; i++) {
                                var c = conns[i];
                                if (_this4._collapseConnection(c, index, actualGroup) === true) {
                                    collapsedConnectionIds.add(c.id);
                                }
                            }
                        };
                        _collapseSet(actualGroup.connections.source, 0);
                        _collapseSet(actualGroup.connections.target, 1);
                        forEach$1(actualGroup.getGroups(), function (cg) {
                            _this4.cascadeCollapse(actualGroup, cg, collapsedConnectionIds);
                        });
                    }
                    this.instance.revalidate(groupEl);
                    this.repaintGroup(actualGroup);
                    this.instance.fire(EVENT_GROUP_COLLAPSE, {
                        group: actualGroup
                    });
                }
                else {
                    actualGroup.collapsed = true;
                    this.instance.removeClass(groupEl, CLASS_GROUP_EXPANDED);
                    this.instance.addClass(groupEl, CLASS_GROUP_COLLAPSED);
                }
            }
        }, {
            key: "cascadeCollapse",
            value: function cascadeCollapse(collapsedGroup, targetGroup, collapsedIds) {
                var _this5 = this;
                if (collapsedGroup.proxied) {
                    var _collapseSet = function _collapseSet(conns, index) {
                        for (var i = 0; i < conns.length; i++) {
                            var c = conns[i];
                            if (!collapsedIds.has(c.id)) {
                                if (_this5._collapseConnection(c, index, collapsedGroup) === true) {
                                    collapsedIds.add(c.id);
                                }
                            }
                        }
                    };
                    _collapseSet(targetGroup.connections.source, 0);
                    _collapseSet(targetGroup.connections.target, 1);
                }
                forEach$1(targetGroup.getGroups(), function (cg) {
                    _this5.cascadeCollapse(collapsedGroup, cg, collapsedIds);
                });
            }
        }, {
            key: "expandGroup",
            value: function expandGroup(group, doNotFireEvent) {
                var _this6 = this;
                var actualGroup = this.getGroup(group);
                if (actualGroup == null) {
                    return;
                }
                var groupEl = actualGroup.el;
                if (actualGroup.collapseParent == null) {
                    this.instance.setGroupVisible(actualGroup, true);
                    actualGroup.collapsed = false;
                    this.instance.addClass(groupEl, CLASS_GROUP_EXPANDED);
                    this.instance.removeClass(groupEl, CLASS_GROUP_COLLAPSED);
                    if (actualGroup.proxied) {
                        var _expandSet = function _expandSet(conns, index) {
                            for (var i = 0; i < conns.length; i++) {
                                var c = conns[i];
                                _this6._expandConnection(c, index, actualGroup);
                            }
                        };
                        _expandSet(actualGroup.connections.source, 0);
                        _expandSet(actualGroup.connections.target, 1);
                        var _expandNestedGroup = function _expandNestedGroup(group, ignoreCollapsedStateForNested) {
                            if (ignoreCollapsedStateForNested || group.collapsed) {
                                var _collapseSet = function _collapseSet(conns, index) {
                                    for (var i = 0; i < conns.length; i++) {
                                        var c = conns[i];
                                        _this6._collapseConnection(c, index, group.collapseParent || group);
                                    }
                                };
                                _collapseSet(group.connections.source, 0);
                                _collapseSet(group.connections.target, 1);
                                forEach$1(group.connections.internal, function (c) {
                                    return c.setVisible(false);
                                });
                                forEach$1(group.getGroups(), function (g) {
                                    return _expandNestedGroup(g, true);
                                });
                            }
                            else {
                                _this6.expandGroup(group, true);
                            }
                        };
                        forEach$1(actualGroup.getGroups(), _expandNestedGroup);
                    }
                    this.instance.revalidate(groupEl);
                    this.repaintGroup(actualGroup);
                    if (!doNotFireEvent) {
                        this.instance.fire(EVENT_GROUP_EXPAND, {
                            group: actualGroup
                        });
                    }
                }
                else {
                    actualGroup.collapsed = false;
                    this.instance.addClass(groupEl, CLASS_GROUP_EXPANDED);
                    this.instance.removeClass(groupEl, CLASS_GROUP_COLLAPSED);
                }
            }
        }, {
            key: "toggleGroup",
            value: function toggleGroup(group) {
                group = this.getGroup(group);
                if (group != null) {
                    if (group.collapsed) {
                        this.expandGroup(group);
                    }
                    else {
                        this.collapseGroup(group);
                    }
                }
            }
        }, {
            key: "repaintGroup",
            value: function repaintGroup(group) {
                var actualGroup = this.getGroup(group);
                var m = actualGroup.children;
                for (var i = 0; i < m.length; i++) {
                    this.instance.revalidate(m[i].el);
                }
            }
        }, {
            key: "addToGroup",
            value: function addToGroup(group, doNotFireEvent) {
                var _this7 = this;
                var actualGroup = this.getGroup(group);
                if (actualGroup) {
                    var groupEl = actualGroup.el;
                    var _one = function _one(el) {
                        var jel = el;
                        var isGroup = jel._isJsPlumbGroup != null, droppingGroup = jel._jsPlumbGroup;
                        var currentGroup = jel._jsPlumbParentGroup;
                        if (currentGroup !== actualGroup) {
                            var entry = _this7.instance.manage(el);
                            var elpos = _this7.instance.getOffset(el);
                            var cpos = actualGroup.collapsed ? _this7.instance.getOffsetRelativeToRoot(groupEl) : _this7.instance.getOffset(_this7.instance.getGroupContentArea(actualGroup));
                            entry.group = actualGroup.elId;
                            if (currentGroup != null) {
                                currentGroup.remove(el, false, doNotFireEvent, false, actualGroup);
                                _this7._updateConnectionsForGroup(currentGroup);
                            }
                            if (isGroup) {
                                actualGroup.addGroup(droppingGroup);
                            }
                            else {
                                actualGroup.add(el, doNotFireEvent);
                            }
                            var handleDroppedConnections = function handleDroppedConnections(list, index) {
                                var oidx = index === 0 ? 1 : 0;
                                list.each(function (c) {
                                    c.setVisible(false);
                                    if (c.endpoints[oidx].element._jsPlumbGroup === actualGroup) {
                                        c.endpoints[oidx].setVisible(false);
                                        _this7._expandConnection(c, oidx, actualGroup);
                                    }
                                    else {
                                        c.endpoints[index].setVisible(false);
                                        _this7._collapseConnection(c, index, actualGroup);
                                    }
                                });
                            };
                            if (actualGroup.collapsed) {
                                handleDroppedConnections(_this7.instance.select({
                                    source: el
                                }), 0);
                                handleDroppedConnections(_this7.instance.select({
                                    target: el
                                }), 1);
                            }
                            _this7.instance.getId(el);
                            var newPosition = {
                                x: elpos.x - cpos.x,
                                y: elpos.y - cpos.y
                            };
                            _this7.instance.setPosition(el, newPosition);
                            _this7._updateConnectionsForGroup(actualGroup);
                            _this7.instance.revalidate(el);
                            if (!doNotFireEvent) {
                                var p = {
                                    group: actualGroup,
                                    el: el,
                                    pos: newPosition
                                };
                                if (currentGroup) {
                                    p.sourceGroup = currentGroup;
                                }
                                _this7.instance.fire(EVENT_GROUP_MEMBER_ADDED, p);
                            }
                        }
                    };
                    for (var _len = arguments.length, el = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                        el[_key - 2] = arguments[_key];
                    }
                    forEach$1(el, _one);
                }
            }
        }, {
            key: "removeFromGroup",
            value: function removeFromGroup(group, doNotFireEvent) {
                var _this8 = this;
                var actualGroup = this.getGroup(group);
                if (actualGroup) {
                    var _one = function _one(_el) {
                        if (actualGroup.collapsed) {
                            var _expandSet = function _expandSet(conns, index) {
                                for (var i = 0; i < conns.length; i++) {
                                    var c = conns[i];
                                    if (c.proxies) {
                                        for (var j = 0; j < c.proxies.length; j++) {
                                            if (c.proxies[j] != null) {
                                                var proxiedElement = c.proxies[j].originalEp.element;
                                                if (proxiedElement === _el || _this8.isElementDescendant(proxiedElement, _el)) {
                                                    _this8._expandConnection(c, index, actualGroup);
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                            _expandSet(actualGroup.connections.source.slice(), 0);
                            _expandSet(actualGroup.connections.target.slice(), 1);
                        }
                        actualGroup.remove(_el, null, doNotFireEvent);
                        var entry = _this8.instance.getManagedElements()[_this8.instance.getId(_el)];
                        if (entry) {
                            delete entry.group;
                        }
                    };
                    for (var _len2 = arguments.length, el = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                        el[_key2 - 2] = arguments[_key2];
                    }
                    forEach$1(el, _one);
                }
            }
        }, {
            key: "getAncestors",
            value: function getAncestors(group) {
                var ancestors = [];
                var p = group.group;
                while (p != null) {
                    ancestors.push(p);
                    p = p.group;
                }
                return ancestors;
            }
        }, {
            key: "isAncestor",
            value: function isAncestor(group, possibleAncestor) {
                if (group == null || possibleAncestor == null) {
                    return false;
                }
                return this.getAncestors(group).indexOf(possibleAncestor) !== -1;
            }
        }, {
            key: "getDescendants",
            value: function getDescendants(group) {
                var d = [];
                var _one = function _one(g) {
                    var childGroups = g.getGroups();
                    d.push.apply(d, _toConsumableArray$1(childGroups));
                    forEach$1(childGroups, _one);
                };
                _one(group);
                return d;
            }
        }, {
            key: "isDescendant",
            value: function isDescendant(possibleDescendant, ancestor) {
                if (possibleDescendant == null || ancestor == null) {
                    return false;
                }
                return this.getDescendants(ancestor).indexOf(possibleDescendant) !== -1;
            }
        }, {
            key: "reset",
            value: function reset() {
                this._connectionSourceMap = {};
                this._connectionTargetMap = {};
                this.groupMap = {};
            }
        }]);
    return GroupManager;
}();
var SelectionBase = function () {
    function SelectionBase(instance, entries) {
        _classCallCheck$3(this, SelectionBase);
        this.instance = instance;
        this.entries = entries;
    }
    _createClass$3(SelectionBase, [{
            key: "length",
            get: function get() {
                return this.entries.length;
            }
        }, {
            key: "each",
            value: function each(handler) {
                forEach$1(this.entries, function (e) {
                    return handler(e);
                });
                return this;
            }
        }, {
            key: "get",
            value: function get(index) {
                return this.entries[index];
            }
        }, {
            key: "addClass",
            value: function addClass(clazz, cascade) {
                this.each(function (c) {
                    return c.addClass(clazz, cascade);
                });
                return this;
            }
        }, {
            key: "removeClass",
            value: function removeClass(clazz, cascade) {
                this.each(function (c) {
                    return c.removeClass(clazz, cascade);
                });
                return this;
            }
        }, {
            key: "removeAllOverlays",
            value: function removeAllOverlays() {
                this.each(function (c) {
                    return c.removeAllOverlays();
                });
                return this;
            }
        }, {
            key: "setLabel",
            value: function setLabel(label) {
                this.each(function (c) {
                    return c.setLabel(label);
                });
                return this;
            }
        }, {
            key: "clear",
            value: function clear() {
                this.entries.length = 0;
                return this;
            }
        }, {
            key: "map",
            value: function map(fn) {
                var a = [];
                this.each(function (e) {
                    return a.push(fn(e));
                });
                return a;
            }
        }, {
            key: "addOverlay",
            value: function addOverlay(spec) {
                this.each(function (c) {
                    return c.addOverlay(spec);
                });
                return this;
            }
        }, {
            key: "removeOverlay",
            value: function removeOverlay(id) {
                this.each(function (c) {
                    return c.removeOverlay(id);
                });
                return this;
            }
        }, {
            key: "removeOverlays",
            value: function removeOverlays() {
                this.each(function (c) {
                    return c.removeOverlays();
                });
                return this;
            }
        }, {
            key: "showOverlay",
            value: function showOverlay(id) {
                this.each(function (c) {
                    return c.showOverlay(id);
                });
                return this;
            }
        }, {
            key: "hideOverlay",
            value: function hideOverlay(id) {
                this.each(function (c) {
                    return c.hideOverlay(id);
                });
                return this;
            }
        }, {
            key: "setPaintStyle",
            value: function setPaintStyle(style) {
                this.each(function (c) {
                    return c.setPaintStyle(style);
                });
                return this;
            }
        }, {
            key: "setHoverPaintStyle",
            value: function setHoverPaintStyle(style) {
                this.each(function (c) {
                    return c.setHoverPaintStyle(style);
                });
                return this;
            }
        }, {
            key: "setSuspendEvents",
            value: function setSuspendEvents(suspend) {
                this.each(function (c) {
                    return c.setSuspendEvents(suspend);
                });
                return this;
            }
        }, {
            key: "setParameter",
            value: function setParameter(name, value) {
                this.each(function (c) {
                    return c.parameters[name] = value;
                });
                return this;
            }
        }, {
            key: "setParameters",
            value: function setParameters(p) {
                this.each(function (c) {
                    return c.parameters = p;
                });
                return this;
            }
        }, {
            key: "setVisible",
            value: function setVisible(v) {
                this.each(function (c) {
                    return c.setVisible(v);
                });
                return this;
            }
        }, {
            key: "addType",
            value: function addType(name) {
                this.each(function (c) {
                    return c.addType(name);
                });
                return this;
            }
        }, {
            key: "toggleType",
            value: function toggleType(name) {
                this.each(function (c) {
                    return c.toggleType(name);
                });
                return this;
            }
        }, {
            key: "removeType",
            value: function removeType(name) {
                this.each(function (c) {
                    return c.removeType(name);
                });
                return this;
            }
        }, {
            key: "bind",
            value: function bind(evt, handler) {
                this.each(function (c) {
                    return c.bind(evt, handler);
                });
                return this;
            }
        }, {
            key: "unbind",
            value: function unbind(evt, handler) {
                this.each(function (c) {
                    return c.unbind(evt, handler);
                });
                return this;
            }
        }, {
            key: "setHover",
            value: function setHover(h) {
                var _this = this;
                this.each(function (c) {
                    return _this.instance.setHover(c, h);
                });
                return this;
            }
        }]);
    return SelectionBase;
}();
var EndpointSelection = function (_SelectionBase) {
    _inherits$3(EndpointSelection, _SelectionBase);
    var _super = _createSuper$3(EndpointSelection);
    function EndpointSelection() {
        _classCallCheck$3(this, EndpointSelection);
        return _super.apply(this, arguments);
    }
    _createClass$3(EndpointSelection, [{
            key: "setEnabled",
            value: function setEnabled(e) {
                this.each(function (ep) {
                    return ep.enabled = e;
                });
                return this;
            }
        }, {
            key: "setAnchor",
            value: function setAnchor(a) {
                this.each(function (ep) {
                    return ep.setAnchor(a);
                });
                return this;
            }
        }, {
            key: "deleteEveryConnection",
            value: function deleteEveryConnection() {
                this.each(function (ep) {
                    return ep.deleteEveryConnection();
                });
                return this;
            }
        }, {
            key: "deleteAll",
            value: function deleteAll() {
                var _this = this;
                this.each(function (ep) {
                    return _this.instance.deleteEndpoint(ep);
                });
                this.clear();
                return this;
            }
        }]);
    return EndpointSelection;
}(SelectionBase);
var ConnectionSelection = function (_SelectionBase) {
    _inherits$3(ConnectionSelection, _SelectionBase);
    var _super = _createSuper$3(ConnectionSelection);
    function ConnectionSelection() {
        _classCallCheck$3(this, ConnectionSelection);
        return _super.apply(this, arguments);
    }
    _createClass$3(ConnectionSelection, [{
            key: "setDetachable",
            value: function setDetachable(d) {
                this.each(function (c) {
                    return c.setDetachable(d);
                });
                return this;
            }
        }, {
            key: "setReattach",
            value: function setReattach(d) {
                this.each(function (c) {
                    return c.setReattach(d);
                });
                return this;
            }
        }, {
            key: "setConnector",
            value: function setConnector(spec) {
                this.each(function (c) {
                    return c._setConnector(spec);
                });
                return this;
            }
        }, {
            key: "deleteAll",
            value: function deleteAll() {
                var _this = this;
                this.each(function (c) {
                    return _this.instance.deleteConnection(c);
                });
                this.clear();
            }
        }, {
            key: "repaint",
            value: function repaint() {
                var _this2 = this;
                this.each(function (c) {
                    return _this2.instance._paintConnection(c);
                });
                return this;
            }
        }]);
    return ConnectionSelection;
}(SelectionBase);
var Transaction = function Transaction() {
    _classCallCheck$3(this, Transaction);
    _defineProperty$3(this, "affectedElements", new Set());
};
function EMPTY_POSITION() {
    return {
        x: 0,
        y: 0,
        w: 0,
        h: 0,
        r: 0,
        c: {
            x: 0,
            y: 0
        },
        x2: 0,
        y2: 0,
        t: {
            x: 0,
            y: 0,
            c: {
                x: 0,
                y: 0
            },
            w: 0,
            h: 0,
            r: 0,
            x2: 0,
            y2: 0,
            cr: 0,
            sr: 0
        },
        dirty: true
    };
}
function rotate(x, y, w, h, r) {
    var center = {
        x: x + w / 2,
        y: y + h / 2
    }, cr = Math.cos(r / 360 * Math.PI * 2), sr = Math.sin(r / 360 * Math.PI * 2), _point = function _point(x, y) {
        return {
            x: center.x + Math.round((x - center.x) * cr - (y - center.y) * sr),
            y: center.y + Math.round((y - center.y) * cr - (x - center.x) * sr)
        };
    };
    var p1 = _point(x, y), p2 = _point(x + w, y), p3 = _point(x + w, y + h), p4 = _point(x, y + h), c = _point(x + w / 2, y + h / 2);
    var xmin = Math.min(p1.x, p2.x, p3.x, p4.x), xmax = Math.max(p1.x, p2.x, p3.x, p4.x), ymin = Math.min(p1.y, p2.y, p3.y, p4.y), ymax = Math.max(p1.y, p2.y, p3.y, p4.y);
    return {
        x: xmin,
        y: ymin,
        w: xmax - xmin,
        h: ymax - ymin,
        c: c,
        r: r,
        x2: xmax,
        y2: ymax,
        cr: cr,
        sr: sr
    };
}
var entryComparator = function entryComparator(value, arrayEntry) {
    var c = 0;
    if (arrayEntry[1] > value[1]) {
        c = -1;
    }
    else if (arrayEntry[1] < value[1]) {
        c = 1;
    }
    return c;
};
var reverseEntryComparator = function reverseEntryComparator(value, arrayEntry) {
    return entryComparator(value, arrayEntry) * -1;
};
function _updateElementIndex(id, value, array, sortDescending) {
    insertSorted([id, value], array, entryComparator, sortDescending);
}
function _clearElementIndex(id, array) {
    var idx = findWithFunction(array, function (entry) {
        return entry[0] === id;
    });
    if (idx > -1) {
        array.splice(idx, 1);
    }
}
var Viewport = function (_EventGenerator) {
    _inherits$3(Viewport, _EventGenerator);
    var _super = _createSuper$3(Viewport);
    function Viewport(instance) {
        var _this;
        _classCallCheck$3(this, Viewport);
        _this = _super.call(this);
        _this.instance = instance;
        _defineProperty$3(_assertThisInitialized$3(_this), "_currentTransaction", null);
        _defineProperty$3(_assertThisInitialized$3(_this), "_sortedElements", {
            xmin: [],
            xmax: [],
            ymin: [],
            ymax: []
        });
        _defineProperty$3(_assertThisInitialized$3(_this), "_elementMap", new Map());
        _defineProperty$3(_assertThisInitialized$3(_this), "_transformedElementMap", new Map());
        _defineProperty$3(_assertThisInitialized$3(_this), "_bounds", {
            minx: 0,
            maxx: 0,
            miny: 0,
            maxy: 0
        });
        return _this;
    }
    _createClass$3(Viewport, [{
            key: "_updateBounds",
            value: function _updateBounds(id, updatedElement, doNotRecalculateBounds) {
                if (updatedElement != null) {
                    _clearElementIndex(id, this._sortedElements.xmin);
                    _clearElementIndex(id, this._sortedElements.xmax);
                    _clearElementIndex(id, this._sortedElements.ymin);
                    _clearElementIndex(id, this._sortedElements.ymax);
                    _updateElementIndex(id, updatedElement.t.x, this._sortedElements.xmin, false);
                    _updateElementIndex(id, updatedElement.t.x + updatedElement.t.w, this._sortedElements.xmax, true);
                    _updateElementIndex(id, updatedElement.t.y, this._sortedElements.ymin, false);
                    _updateElementIndex(id, updatedElement.t.y + updatedElement.t.h, this._sortedElements.ymax, true);
                    if (doNotRecalculateBounds !== true) {
                        this._recalculateBounds();
                    }
                }
            }
        }, {
            key: "_recalculateBounds",
            value: function _recalculateBounds() {
                this._bounds.minx = this._sortedElements.xmin.length > 0 ? this._sortedElements.xmin[0][1] : 0;
                this._bounds.maxx = this._sortedElements.xmax.length > 0 ? this._sortedElements.xmax[0][1] : 0;
                this._bounds.miny = this._sortedElements.ymin.length > 0 ? this._sortedElements.ymin[0][1] : 0;
                this._bounds.maxy = this._sortedElements.ymax.length > 0 ? this._sortedElements.ymax[0][1] : 0;
            }
        }, {
            key: "recomputeBounds",
            value: function recomputeBounds() {
                var _this2 = this;
                this._sortedElements.xmin.length = 0;
                this._sortedElements.xmax.length = 0;
                this._sortedElements.ymin.length = 0;
                this._sortedElements.ymax.length = 0;
                this._elementMap.forEach(function (vp, id) {
                    _this2._sortedElements.xmin.push([id, vp.t.x]);
                    _this2._sortedElements.xmax.push([id, vp.t.x + vp.t.w]);
                    _this2._sortedElements.ymin.push([id, vp.t.y]);
                    _this2._sortedElements.ymax.push([id, vp.t.y + vp.t.h]);
                });
                this._sortedElements.xmin.sort(entryComparator);
                this._sortedElements.ymin.sort(entryComparator);
                this._sortedElements.xmax.sort(reverseEntryComparator);
                this._sortedElements.ymax.sort(reverseEntryComparator);
                this._recalculateBounds();
            }
        }, {
            key: "_finaliseUpdate",
            value: function _finaliseUpdate(id, e, doNotRecalculateBounds) {
                e.t = rotate(e.x, e.y, e.w, e.h, e.r);
                this._transformedElementMap.set(id, e.t);
                if (doNotRecalculateBounds !== true) {
                    this._updateBounds(id, e, doNotRecalculateBounds);
                }
            }
        }, {
            key: "shouldFireEvent",
            value: function shouldFireEvent(event, value, originalEvent) {
                return true;
            }
        }, {
            key: "startTransaction",
            value: function startTransaction() {
                if (this._currentTransaction != null) {
                    throw new Error("Viewport: cannot start transaction; a transaction is currently active.");
                }
                this._currentTransaction = new Transaction();
            }
        }, {
            key: "endTransaction",
            value: function endTransaction() {
                var _this3 = this;
                if (this._currentTransaction != null) {
                    this._currentTransaction.affectedElements.forEach(function (id) {
                        var entry = _this3.getPosition(id);
                        _this3._finaliseUpdate(id, entry, true);
                    });
                    this.recomputeBounds();
                    this._currentTransaction = null;
                }
            }
        }, {
            key: "updateElements",
            value: function updateElements(entries) {
                var _this4 = this;
                forEach$1(entries, function (e) {
                    return _this4.updateElement(e.id, e.x, e.y, e.width, e.height, e.rotation);
                });
            }
        }, {
            key: "updateElement",
            value: function updateElement(id, x, y, width, height, rotation, doNotRecalculateBounds) {
                var e = getsert(this._elementMap, id, EMPTY_POSITION);
                e.dirty = x == null && e.x == null || y == null && e.y == null || width == null && e.w == null || height == null && e.h == null;
                if (x != null) {
                    e.x = x;
                }
                if (y != null) {
                    e.y = y;
                }
                if (width != null) {
                    e.w = width;
                }
                if (height != null) {
                    e.h = height;
                }
                if (rotation != null) {
                    e.r = rotation || 0;
                }
                e.c.x = e.x + e.w / 2;
                e.c.y = e.y + e.h / 2;
                e.x2 = e.x + e.w;
                e.y2 = e.y + e.h;
                if (this._currentTransaction == null) {
                    this._finaliseUpdate(id, e, doNotRecalculateBounds);
                }
                else {
                    this._currentTransaction.affectedElements.add(id);
                }
                return e;
            }
        }, {
            key: "refreshElement",
            value: function refreshElement(elId, doNotRecalculateBounds) {
                var me = this.instance.getManagedElements();
                var s = me[elId] ? me[elId].el : null;
                if (s != null) {
                    var size = this.getSize(s);
                    var offset = this.getOffset(s);
                    return this.updateElement(elId, offset.x, offset.y, size.w, size.h, null, doNotRecalculateBounds);
                }
                else {
                    return null;
                }
            }
        }, {
            key: "getSize",
            value: function getSize(el) {
                return this.instance.getSize(el);
            }
        }, {
            key: "getOffset",
            value: function getOffset(el) {
                return this.instance.getOffset(el);
            }
        }, {
            key: "registerElement",
            value: function registerElement(id, doNotRecalculateBounds) {
                return this.updateElement(id, 0, 0, 0, 0, 0, doNotRecalculateBounds);
            }
        }, {
            key: "addElement",
            value: function addElement(id, x, y, width, height, rotation) {
                return this.updateElement(id, x, y, width, height, rotation);
            }
        }, {
            key: "rotateElement",
            value: function rotateElement(id, rotation) {
                var e = getsert(this._elementMap, id, EMPTY_POSITION);
                e.r = rotation || 0;
                this._finaliseUpdate(id, e);
                return e;
            }
        }, {
            key: "getBoundsWidth",
            value: function getBoundsWidth() {
                return this._bounds.maxx - this._bounds.minx;
            }
        }, {
            key: "getBoundsHeight",
            value: function getBoundsHeight() {
                return this._bounds.maxy - this._bounds.miny;
            }
        }, {
            key: "getX",
            value: function getX() {
                return this._bounds.minx;
            }
        }, {
            key: "getY",
            value: function getY() {
                return this._bounds.miny;
            }
        }, {
            key: "setSize",
            value: function setSize(id, w, h) {
                if (this._elementMap.has(id)) {
                    return this.updateElement(id, null, null, w, h, null);
                }
            }
        }, {
            key: "setPosition",
            value: function setPosition(id, x, y) {
                if (this._elementMap.has(id)) {
                    return this.updateElement(id, x, y, null, null, null);
                }
            }
        }, {
            key: "reset",
            value: function reset() {
                this._sortedElements.xmin.length = 0;
                this._sortedElements.xmax.length = 0;
                this._sortedElements.ymin.length = 0;
                this._sortedElements.ymax.length = 0;
                this._elementMap.clear();
                this._transformedElementMap.clear();
                this._recalculateBounds();
            }
        }, {
            key: "remove",
            value: function remove(id) {
                _clearElementIndex(id, this._sortedElements.xmin);
                _clearElementIndex(id, this._sortedElements.xmax);
                _clearElementIndex(id, this._sortedElements.ymin);
                _clearElementIndex(id, this._sortedElements.ymax);
                this._elementMap["delete"](id);
                this._transformedElementMap["delete"](id);
                this._recalculateBounds();
            }
        }, {
            key: "getPosition",
            value: function getPosition(id) {
                return this._elementMap.get(id);
            }
        }, {
            key: "getElements",
            value: function getElements() {
                return this._elementMap;
            }
        }, {
            key: "isEmpty",
            value: function isEmpty() {
                return this._elementMap.size === 0;
            }
        }]);
    return Viewport;
}(EventGenerator);
var _edgeSortFunctions;
function _placeAnchorsOnLine(element, connections, horizontal, otherMultiplier, reverse) {
    var sizeInAxis = horizontal ? element.w : element.h;
    var sizeInOtherAxis = horizontal ? element.h : element.w;
    var a = [], step = sizeInAxis / (connections.length + 1);
    for (var i = 0; i < connections.length; i++) {
        var val = (i + 1) * step, other = otherMultiplier * sizeInOtherAxis;
        if (reverse) {
            val = sizeInAxis - val;
        }
        var dx = horizontal ? val : other, x = element.x + dx, xp = dx / element.w;
        var dy = horizontal ? other : val, y = element.y + dy, yp = dy / element.h;
        if (element.r !== 0 && element.r != null) {
            var rotated = rotatePoint({
                x: x,
                y: y
            }, element.c, element.r);
            x = rotated.x;
            y = rotated.y;
        }
        a.push({
            x: x,
            y: y,
            xLoc: xp,
            yLoc: yp,
            c: connections[i].c
        });
    }
    return a;
}
function _rightAndBottomSort(a, b) {
    return b.theta - a.theta;
}
function _leftAndTopSort(a, b) {
    var p1 = a.theta < 0 ? -Math.PI - a.theta : Math.PI - a.theta, p2 = b.theta < 0 ? -Math.PI - b.theta : Math.PI - b.theta;
    return p1 - p2;
}
var edgeSortFunctions = (_edgeSortFunctions = {}, _defineProperty$3(_edgeSortFunctions, TOP, _leftAndTopSort), _defineProperty$3(_edgeSortFunctions, RIGHT, _rightAndBottomSort), _defineProperty$3(_edgeSortFunctions, BOTTOM, _rightAndBottomSort), _defineProperty$3(_edgeSortFunctions, LEFT, _leftAndTopSort), _edgeSortFunctions);
function isContinuous(a) {
    return a.isContinuous === true;
}
function _isFloating(a) {
    return a.isContinuous === true;
}
function isDynamic(a) {
    return a.locations.length > 1;
}
function getCurrentLocation(anchor) {
    return [anchor.currentLocation, anchor.locations[anchor.currentLocation]];
}
var LightweightRouter = function () {
    function LightweightRouter(instance) {
        var _this = this;
        _classCallCheck$3(this, LightweightRouter);
        this.instance = instance;
        _defineProperty$3(this, "anchorLists", new Map());
        _defineProperty$3(this, "anchorLocations", new Map());
        instance.bind(EVENT_INTERNAL_CONNECTION_DETACHED, function (p) {
            if (p.sourceEndpoint._anchor.isContinuous) {
                _this._removeEndpointFromAnchorLists(p.sourceEndpoint);
            }
            if (p.targetEndpoint._anchor.isContinuous) {
                _this._removeEndpointFromAnchorLists(p.targetEndpoint);
            }
        });
        instance.bind(EVENT_INTERNAL_ENDPOINT_UNREGISTERED, function (ep) {
            _this._removeEndpointFromAnchorLists(ep);
        });
    }
    _createClass$3(LightweightRouter, [{
            key: "getAnchorOrientation",
            value: function getAnchorOrientation(anchor) {
                var loc = this.anchorLocations.get(anchor.id);
                return loc ? [loc.ox, loc.oy] : [0, 0];
            }
        }, {
            key: "_distance",
            value: function _distance(anchor, cx, cy, xy, wh, rotation, targetRotation) {
                var ax = xy.x + anchor.x * wh.w, ay = xy.y + anchor.y * wh.h, acx = xy.x + wh.w / 2, acy = xy.y + wh.h / 2;
                if (rotation != null && rotation.length > 0) {
                    var rotated = this.instance._applyRotations([ax, ay, 0, 0], rotation);
                    ax = rotated.x;
                    ay = rotated.y;
                }
                return Math.sqrt(Math.pow(cx - ax, 2) + Math.pow(cy - ay, 2)) + Math.sqrt(Math.pow(acx - ax, 2) + Math.pow(acy - ay, 2));
            }
        }, {
            key: "_anchorSelector",
            value: function _anchorSelector(xy, wh, txy, twh, rotation, targetRotation, locations) {
                var cx = txy.x + twh.w / 2, cy = txy.y + twh.h / 2;
                var minIdx = -1, minDist = Infinity;
                for (var i = 0; i < locations.length; i++) {
                    var d = this._distance(locations[i], cx, cy, xy, wh, rotation, targetRotation);
                    if (d < minDist) {
                        minIdx = i + 0;
                        minDist = d;
                    }
                }
                return [minIdx, locations[minIdx]];
            }
        }, {
            key: "_floatingAnchorCompute",
            value: function _floatingAnchorCompute(anchor, params) {
                var xy = params.xy;
                var pos = {
                    curX: xy.x + anchor.size.w / 2,
                    curY: xy.y + anchor.size.h / 2,
                    x: 0,
                    y: 0,
                    ox: 0,
                    oy: 0
                };
                return this._setComputedPosition(anchor, pos);
            }
        }, {
            key: "_setComputedPosition",
            value: function _setComputedPosition(anchor, pos, timestamp) {
                this.anchorLocations.set(anchor.id, pos);
                anchor.computedPosition = pos;
                if (timestamp) {
                    anchor.timestamp = timestamp;
                }
                return pos;
            }
        }, {
            key: "_computeSingleLocation",
            value: function _computeSingleLocation(loc, xy, wh, params) {
                var pos;
                var rotation = params.rotation;
                var candidate = {
                    curX: xy.x + loc.x * wh.w + loc.offx,
                    curY: xy.y + loc.y * wh.h + loc.offy,
                    x: loc.x,
                    y: loc.y,
                    ox: 0,
                    oy: 0
                };
                if (rotation != null && rotation.length > 0) {
                    var o = [loc.iox, loc.ioy], current = {
                        x: candidate.curX,
                        y: candidate.curY,
                        cr: 0,
                        sr: 0
                    };
                    forEach$1(rotation, function (r) {
                        current = rotatePoint(current, r.c, r.r);
                        var _o = [Math.round(o[0] * current.cr - o[1] * current.sr), Math.round(o[1] * current.cr + o[0] * current.sr)];
                        o = _o.slice();
                    });
                    loc.ox = o[0];
                    loc.oy = o[1];
                    pos = {
                        curX: current.x,
                        curY: current.y,
                        x: loc.x,
                        y: loc.y,
                        ox: o[0],
                        oy: o[1]
                    };
                }
                else {
                    loc.ox = loc.iox;
                    loc.oy = loc.ioy;
                    pos = extend({
                        ox: loc.iox,
                        oy: loc.ioy
                    }, candidate);
                }
                return pos;
            }
        }, {
            key: "_singleAnchorCompute",
            value: function _singleAnchorCompute(anchor, params) {
                var xy = params.xy, wh = params.wh, timestamp = params.timestamp, pos = this.anchorLocations.get(anchor.id);
                if (pos != null && timestamp && timestamp === anchor.timestamp) {
                    return pos;
                }
                var _getCurrentLocation = getCurrentLocation(anchor), _getCurrentLocation2 = _slicedToArray$1(_getCurrentLocation, 2);
                _getCurrentLocation2[0];
                var currentLoc = _getCurrentLocation2[1];
                pos = this._computeSingleLocation(currentLoc, xy, wh, params);
                return this._setComputedPosition(anchor, pos, timestamp);
            }
        }, {
            key: "_defaultAnchorCompute",
            value: function _defaultAnchorCompute(anchor, params) {
                var pos;
                if (anchor.locations.length === 1) {
                    return this._singleAnchorCompute(anchor, params);
                }
                var xy = params.xy, wh = params.wh, txy = params.txy, twh = params.twh;
                var _getCurrentLocation3 = getCurrentLocation(anchor), _getCurrentLocation4 = _slicedToArray$1(_getCurrentLocation3, 2), currentIdx = _getCurrentLocation4[0], currentLoc = _getCurrentLocation4[1];
                if (anchor.locked || txy == null || twh == null) {
                    pos = this._computeSingleLocation(currentLoc, xy, wh, params);
                }
                else {
                    var _this$_anchorSelector = this._anchorSelector(xy, wh, txy, twh, params.rotation, params.tRotation, anchor.locations), _this$_anchorSelector2 = _slicedToArray$1(_this$_anchorSelector, 2), newIdx = _this$_anchorSelector2[0], newLoc = _this$_anchorSelector2[1];
                    anchor.currentLocation = newIdx;
                    if (newIdx !== currentIdx) {
                        anchor.cssClass = newLoc.cls || anchor.cssClass;
                        params.element._anchorLocationChanged(anchor);
                    }
                    pos = this._computeSingleLocation(newLoc, xy, wh, params);
                }
                return this._setComputedPosition(anchor, pos, params.timestamp);
            }
        }, {
            key: "_placeAnchors",
            value: function _placeAnchors(elementId, _anchorLists) {
                var _this2 = this;
                var cd = this.instance.viewport.getPosition(elementId), placeSomeAnchors = function placeSomeAnchors(desc, element, unsortedConnections, isHorizontal, otherMultiplier, orientation) {
                    if (unsortedConnections.length > 0) {
                        var sc = unsortedConnections.sort(edgeSortFunctions[desc]), reverse = desc === RIGHT || desc === TOP, anchors = _placeAnchorsOnLine(cd, sc, isHorizontal, otherMultiplier, reverse);
                        for (var i = 0; i < anchors.length; i++) {
                            var c = anchors[i].c, weAreSource = c.endpoints[0].elementId === elementId, ep = weAreSource ? c.endpoints[0] : c.endpoints[1];
                            _this2._setComputedPosition(ep._anchor, {
                                curX: anchors[i].x,
                                curY: anchors[i].y,
                                x: anchors[i].xLoc,
                                y: anchors[i].yLoc,
                                ox: orientation[0],
                                oy: orientation[1]
                            });
                        }
                    }
                };
                placeSomeAnchors(BOTTOM, cd, _anchorLists.bottom, true, 1, [0, 1]);
                placeSomeAnchors(TOP, cd, _anchorLists.top, true, 0, [0, -1]);
                placeSomeAnchors(LEFT, cd, _anchorLists.left, false, 0, [-1, 0]);
                placeSomeAnchors(RIGHT, cd, _anchorLists.right, false, 1, [1, 0]);
            }
        }, {
            key: "_updateAnchorList",
            value: function _updateAnchorList(lists, theta, order, conn, aBoolean, otherElId, idx, reverse, edgeId, connsToPaint, endpointsToPaint) {
                var endpoint = conn.endpoints[idx], endpointId = endpoint.id, oIdx = [1, 0][idx], values = {
                    theta: theta,
                    order: order,
                    c: conn,
                    b: aBoolean,
                    elId: otherElId,
                    epId: endpointId
                }, listToAddTo = lists[edgeId], listToRemoveFrom = endpoint._continuousAnchorEdge ? lists[endpoint._continuousAnchorEdge] : null, candidate;
                if (listToRemoveFrom) {
                    var rIdx = findWithFunction(listToRemoveFrom, function (e) {
                        return e.epId === endpointId;
                    });
                    if (rIdx !== -1) {
                        listToRemoveFrom.splice(rIdx, 1);
                        for (var i = 0; i < listToRemoveFrom.length; i++) {
                            candidate = listToRemoveFrom[i].c;
                            if (candidate.placeholder !== true) {
                                connsToPaint.add(candidate);
                            }
                            endpointsToPaint.add(listToRemoveFrom[i].c.endpoints[idx]);
                            endpointsToPaint.add(listToRemoveFrom[i].c.endpoints[oIdx]);
                        }
                    }
                }
                for (var _i = 0; _i < listToAddTo.length; _i++) {
                    candidate = listToAddTo[_i].c;
                    if (candidate.placeholder !== true) {
                        connsToPaint.add(candidate);
                    }
                    endpointsToPaint.add(listToAddTo[_i].c.endpoints[idx]);
                    endpointsToPaint.add(listToAddTo[_i].c.endpoints[oIdx]);
                }
                {
                    var insertIdx = reverse ? 0 : listToAddTo.length;
                    listToAddTo.splice(insertIdx, 0, values);
                }
                endpoint._continuousAnchorEdge = edgeId;
            }
        }, {
            key: "_removeEndpointFromAnchorLists",
            value: function _removeEndpointFromAnchorLists(endpoint) {
                var listsForElement = this.anchorLists.get(endpoint.elementId);
                var total = 0;
                (function (list, eId) {
                    if (list) {
                        var f = function f(e) {
                            return e.epId === eId;
                        };
                        removeWithFunction(list.top, f);
                        removeWithFunction(list.left, f);
                        removeWithFunction(list.bottom, f);
                        removeWithFunction(list.right, f);
                        total += list.top.length;
                        total += list.left.length;
                        total += list.bottom.length;
                        total += list.right.length;
                    }
                })(listsForElement, endpoint.id);
                if (total === 0) {
                    this.anchorLists["delete"](endpoint.elementId);
                }
                this.anchorLocations["delete"](endpoint._anchor.id);
            }
        }, {
            key: "computeAnchorLocation",
            value: function computeAnchorLocation(anchor, params) {
                var pos;
                if (isContinuous(anchor)) {
                    pos = this.anchorLocations.get(anchor.id) || {
                        curX: 0,
                        curY: 0,
                        x: 0,
                        y: 0,
                        ox: 0,
                        oy: 0
                    };
                }
                else if (_isFloating(anchor)) {
                    pos = this._floatingAnchorCompute(anchor, params);
                }
                else {
                    pos = this._defaultAnchorCompute(anchor, params);
                }
                anchor.timestamp = params.timestamp;
                return pos;
            }
        }, {
            key: "computePath",
            value: function computePath(connection, timestamp) {
                var sourceInfo = this.instance.viewport.getPosition(connection.sourceId), targetInfo = this.instance.viewport.getPosition(connection.targetId), sE = connection.endpoints[0], tE = connection.endpoints[1];
                var sAnchorP = this.getEndpointLocation(sE, {
                    xy: sourceInfo,
                    wh: sourceInfo,
                    element: sE,
                    timestamp: timestamp,
                    rotation: this.instance._getRotations(connection.sourceId)
                }), tAnchorP = this.getEndpointLocation(tE, {
                    xy: targetInfo,
                    wh: targetInfo,
                    element: tE,
                    timestamp: timestamp,
                    rotation: this.instance._getRotations(connection.targetId)
                });
                connection.connector.resetBounds();
                connection.connector.compute({
                    sourcePos: sAnchorP,
                    targetPos: tAnchorP,
                    sourceEndpoint: connection.endpoints[0],
                    targetEndpoint: connection.endpoints[1],
                    strokeWidth: connection.paintStyleInUse.strokeWidth,
                    sourceInfo: sourceInfo,
                    targetInfo: targetInfo
                });
            }
        }, {
            key: "getEndpointLocation",
            value: function getEndpointLocation(endpoint, params) {
                params = params || {};
                var anchor = endpoint._anchor;
                var pos = this.anchorLocations.get(anchor.id);
                if (pos == null || params.timestamp != null && anchor.timestamp !== params.timestamp) {
                    pos = this.computeAnchorLocation(anchor, params);
                    this._setComputedPosition(anchor, pos, params.timestamp);
                }
                return pos;
            }
        }, {
            key: "getEndpointOrientation",
            value: function getEndpointOrientation(ep) {
                return ep._anchor ? this.getAnchorOrientation(ep._anchor) : [0, 0];
            }
        }, {
            key: "setAnchorOrientation",
            value: function setAnchorOrientation(anchor, orientation) {
                var anchorLoc = this.anchorLocations.get(anchor.id);
                if (anchorLoc != null) {
                    anchorLoc.ox = orientation[0];
                    anchorLoc.oy = orientation[1];
                }
            }
        }, {
            key: "isDynamicAnchor",
            value: function isDynamicAnchor(ep) {
                return ep._anchor ? !isContinuous(ep._anchor) && ep._anchor.locations.length > 1 : false;
            }
        }, {
            key: "isFloating",
            value: function isFloating(ep) {
                return ep._anchor ? _isFloating(ep._anchor) : false;
            }
        }, {
            key: "prepareAnchor",
            value: function prepareAnchor(params) {
                return makeLightweightAnchorFromSpec(params);
            }
        }, {
            key: "redraw",
            value: function redraw(elementId, timestamp, offsetToUI) {
                var _this3 = this;
                var connectionsToPaint = new Set(), endpointsToPaint = new Set(), anchorsToUpdate = new Set();
                if (!this.instance._suspendDrawing) {
                    var ep = this.instance.endpointsByElement[elementId] || [];
                    timestamp = timestamp || uuid();
                    var orientationCache = {}, a, anEndpoint;
                    for (var i = 0; i < ep.length; i++) {
                        anEndpoint = ep[i];
                        endpointsToPaint.add(anEndpoint);
                        a = anEndpoint._anchor;
                        if (anEndpoint.connections.length === 0) {
                            if (isContinuous(a)) {
                                if (!this.anchorLists.has(elementId)) {
                                    this.anchorLists.set(elementId, {
                                        top: [],
                                        right: [],
                                        bottom: [],
                                        left: []
                                    });
                                }
                                this._updateAnchorList(this.anchorLists.get(elementId), -Math.PI / 2, 0, {
                                    endpoints: [anEndpoint, anEndpoint],
                                    placeholder: true
                                }, false, elementId, 0, false, getDefaultFace(a), connectionsToPaint, endpointsToPaint);
                                anchorsToUpdate.add(elementId);
                            }
                        }
                        else {
                            for (var _i2 = 0; _i2 < anEndpoint.connections.length; _i2++) {
                                var conn = anEndpoint.connections[_i2], sourceId = conn.sourceId, targetId = conn.targetId, sourceContinuous = isContinuous(conn.endpoints[0]._anchor), targetContinuous = isContinuous(conn.endpoints[1]._anchor);
                                if (sourceContinuous || targetContinuous) {
                                    var c1 = (conn.endpoints[0]._anchor.faces || []).join("-"), c2 = (conn.endpoints[1]._anchor.faces || []).join("-"), oKey = [sourceId, c1, targetId, c2].join("-"), o = orientationCache[oKey], oIdx = conn.sourceId === elementId ? 1 : 0;
                                    if (sourceContinuous && !this.anchorLists.has(sourceId)) {
                                        this.anchorLists.set(sourceId, {
                                            top: [],
                                            right: [],
                                            bottom: [],
                                            left: []
                                        });
                                    }
                                    if (targetContinuous && !this.anchorLists.has(targetId)) {
                                        this.anchorLists.set(targetId, {
                                            top: [],
                                            right: [],
                                            bottom: [],
                                            left: []
                                        });
                                    }
                                    var td = this.instance.viewport.getPosition(targetId), sd = this.instance.viewport.getPosition(sourceId);
                                    if (targetId === sourceId && (sourceContinuous || targetContinuous)) {
                                        this._updateAnchorList(this.anchorLists.get(sourceId), -Math.PI / 2, 0, conn, false, targetId, 0, false, TOP, connectionsToPaint, endpointsToPaint);
                                        this._updateAnchorList(this.anchorLists.get(targetId), -Math.PI / 2, 0, conn, false, sourceId, 1, false, TOP, connectionsToPaint, endpointsToPaint);
                                    }
                                    else {
                                        var sourceRotation = this.instance._getRotations(sourceId);
                                        var targetRotation = this.instance._getRotations(targetId);
                                        if (!o) {
                                            o = this._calculateOrientation(sourceId, targetId, sd, td, conn.endpoints[0]._anchor, conn.endpoints[1]._anchor, sourceRotation, targetRotation);
                                            orientationCache[oKey] = o;
                                        }
                                        if (sourceContinuous) {
                                            this._updateAnchorList(this.anchorLists.get(sourceId), o.theta, 0, conn, false, targetId, 0, false, o.a[0], connectionsToPaint, endpointsToPaint);
                                        }
                                        if (targetContinuous) {
                                            this._updateAnchorList(this.anchorLists.get(targetId), o.theta2, -1, conn, true, sourceId, 1, true, o.a[1], connectionsToPaint, endpointsToPaint);
                                        }
                                    }
                                    if (sourceContinuous) {
                                        anchorsToUpdate.add(sourceId);
                                    }
                                    if (targetContinuous) {
                                        anchorsToUpdate.add(targetId);
                                    }
                                    connectionsToPaint.add(conn);
                                    if (sourceContinuous && oIdx === 0 || targetContinuous && oIdx === 1) {
                                        endpointsToPaint.add(conn.endpoints[oIdx]);
                                    }
                                }
                                else {
                                    var otherEndpoint = anEndpoint.connections[_i2].endpoints[conn.sourceId === elementId ? 1 : 0], otherAnchor = otherEndpoint._anchor;
                                    if (isDynamic(otherAnchor)) {
                                        this.instance._paintEndpoint(otherEndpoint, {
                                            elementWithPrecedence: elementId,
                                            timestamp: timestamp
                                        });
                                        connectionsToPaint.add(anEndpoint.connections[_i2]);
                                        for (var k = 0; k < otherEndpoint.connections.length; k++) {
                                            if (otherEndpoint.connections[k] !== anEndpoint.connections[_i2]) {
                                                connectionsToPaint.add(otherEndpoint.connections[k]);
                                            }
                                        }
                                    }
                                    else {
                                        connectionsToPaint.add(anEndpoint.connections[_i2]);
                                    }
                                }
                            }
                        }
                    }
                    anchorsToUpdate.forEach(function (anchor) {
                        _this3._placeAnchors(anchor, _this3.anchorLists.get(anchor));
                    });
                    endpointsToPaint.forEach(function (ep) {
                        var cd = _this3.instance.viewport.getPosition(ep.elementId);
                        _this3.instance._paintEndpoint(ep, {
                            timestamp: timestamp,
                            offset: cd
                        });
                    });
                    connectionsToPaint.forEach(function (c) {
                        _this3.instance._paintConnection(c, {
                            timestamp: timestamp
                        });
                    });
                }
                return {
                    c: connectionsToPaint,
                    e: endpointsToPaint
                };
            }
        }, {
            key: "reset",
            value: function reset() {
                this.anchorLocations.clear();
                this.anchorLists.clear();
            }
        }, {
            key: "setAnchor",
            value: function setAnchor(endpoint, anchor) {
                if (anchor != null) {
                    endpoint._anchor = anchor;
                }
            }
        }, {
            key: "setConnectionAnchors",
            value: function setConnectionAnchors(conn, anchors) {
                conn.endpoints[0]._anchor = anchors[0];
                conn.endpoints[1]._anchor = anchors[1];
            }
        }, {
            key: "_calculateOrientation",
            value: function _calculateOrientation(sourceId, targetId, sd, td, sourceAnchor, targetAnchor, sourceRotation, targetRotation) {
                var _this4 = this;
                var Orientation = {
                    HORIZONTAL: "horizontal",
                    VERTICAL: "vertical",
                    DIAGONAL: "diagonal",
                    IDENTITY: "identity"
                };
                if (sourceId === targetId) {
                    return {
                        orientation: Orientation.IDENTITY,
                        a: [TOP, TOP]
                    };
                }
                var theta = Math.atan2(td.c.y - sd.c.y, td.c.x - sd.c.x), theta2 = Math.atan2(sd.c.y - td.c.y, sd.c.x - td.c.x);
                var candidates = [], midpoints = {};
                (function (types, dim) {
                    for (var i = 0; i < types.length; i++) {
                        var _midpoints$types$i;
                        midpoints[types[i]] = (_midpoints$types$i = {}, _defineProperty$3(_midpoints$types$i, LEFT, {
                            x: dim[i][0].x,
                            y: dim[i][0].c.y
                        }), _defineProperty$3(_midpoints$types$i, RIGHT, {
                            x: dim[i][0].x + dim[i][0].w,
                            y: dim[i][0].c.y
                        }), _defineProperty$3(_midpoints$types$i, TOP, {
                            x: dim[i][0].c.x,
                            y: dim[i][0].y
                        }), _defineProperty$3(_midpoints$types$i, BOTTOM, {
                            x: dim[i][0].c.x,
                            y: dim[i][0].y + dim[i][0].h
                        }), _midpoints$types$i);
                        if (dim[i][1] != null && dim[i][1].length > 0) {
                            for (var axis in midpoints[types[i]]) {
                                midpoints[types[i]][axis] = _this4.instance._applyRotationsXY(midpoints[types[i]][axis], dim[i][1]);
                            }
                        }
                    }
                })([SOURCE, TARGET], [[sd, sourceRotation], [td, targetRotation]]);
                var FACES = [TOP, LEFT, RIGHT, BOTTOM];
                for (var sf = 0; sf < FACES.length; sf++) {
                    for (var tf = 0; tf < FACES.length; tf++) {
                        candidates.push({
                            source: FACES[sf],
                            target: FACES[tf],
                            dist: lineLength(midpoints.source[FACES[sf]], midpoints.target[FACES[tf]])
                        });
                    }
                }
                candidates.sort(function (a, b) {
                    if (a.dist < b.dist) {
                        return -1;
                    }
                    else if (b.dist < a.dist) {
                        return 1;
                    }
                    else {
                        var _axisIndices;
                        var axisIndices = (_axisIndices = {}, _defineProperty$3(_axisIndices, LEFT, 0), _defineProperty$3(_axisIndices, TOP, 1), _defineProperty$3(_axisIndices, RIGHT, 2), _defineProperty$3(_axisIndices, BOTTOM, 3), _axisIndices), ais = axisIndices[a.source], bis = axisIndices[b.source], ait = axisIndices[a.target], bit = axisIndices[b.target];
                        return ais < bis ? -1 : bis < ais ? 1 : ait < bit ? -1 : bit < ait ? 1 : 0;
                    }
                });
                var sourceEdge = candidates[0].source, targetEdge = candidates[0].target;
                for (var i = 0; i < candidates.length; i++) {
                    if (isContinuous(sourceAnchor) && sourceAnchor.locked) {
                        sourceEdge = sourceAnchor.currentFace;
                    }
                    else if (!sourceAnchor.isContinuous || isEdgeSupported(sourceAnchor, candidates[i].source)) {
                        sourceEdge = candidates[i].source;
                    }
                    else {
                        sourceEdge = null;
                    }
                    if (targetAnchor.isContinuous && targetAnchor.locked) {
                        targetEdge = targetAnchor.currentFace;
                    }
                    else if (!targetAnchor.isContinuous || isEdgeSupported(targetAnchor, candidates[i].target)) {
                        targetEdge = candidates[i].target;
                    }
                    else {
                        targetEdge = null;
                    }
                    if (sourceEdge != null && targetEdge != null) {
                        break;
                    }
                }
                if (sourceAnchor.isContinuous) {
                    this.setCurrentFace(sourceAnchor, sourceEdge);
                }
                if (targetAnchor.isContinuous) {
                    this.setCurrentFace(targetAnchor, targetEdge);
                }
                return {
                    a: [sourceEdge, targetEdge],
                    theta: theta,
                    theta2: theta2
                };
            }
        }, {
            key: "setCurrentFace",
            value: function setCurrentFace(a, face, overrideLock) {
                a.currentFace = face;
                if (overrideLock && a.lockedFace != null) {
                    a.lockedFace = a.currentFace;
                }
            }
        }, {
            key: "lock",
            value: function lock(a) {
                a.locked = true;
                if (isContinuous(a)) {
                    a.lockedFace = a.currentFace;
                }
            }
        }, {
            key: "unlock",
            value: function unlock(a) {
                a.locked = false;
                if (isContinuous(a)) {
                    a.lockedFace = null;
                }
            }
        }, {
            key: "selectAnchorLocation",
            value: function selectAnchorLocation(a, coords) {
                var idx = findWithFunction(a.locations, function (loc) {
                    return loc.x === coords.x && loc.y === coords.y;
                });
                if (idx !== -1) {
                    a.currentLocation = idx;
                    return true;
                }
                else {
                    return false;
                }
            }
        }, {
            key: "lockCurrentAxis",
            value: function lockCurrentAxis(a) {
                if (a.currentFace != null) {
                    a.lockedAxis = a.currentFace === LEFT || a.currentFace === RIGHT ? X_AXIS_FACES : Y_AXIS_FACES;
                }
            }
        }, {
            key: "unlockCurrentAxis",
            value: function unlockCurrentAxis(a) {
                a.lockedAxis = null;
            }
        }, {
            key: "anchorsEqual",
            value: function anchorsEqual(a1, a2) {
                if (!a1 || !a2) {
                    return false;
                }
                var l1 = a1.locations[a1.currentLocation], l2 = a2.locations[a2.currentLocation];
                return l1.x === l2.x && l1.y === l2.y && l1.offx === l2.offx && l1.offy === l2.offy && l1.ox === l2.ox && l1.oy === l2.oy;
            }
        }]);
    return LightweightRouter;
}();
var ConnectionDragSelector = function () {
    function ConnectionDragSelector(selector, def) {
        var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        _classCallCheck$3(this, ConnectionDragSelector);
        this.selector = selector;
        this.def = def;
        this.exclude = exclude;
        _defineProperty$3(this, "id", void 0);
        _defineProperty$3(this, "redrop", void 0);
        this.id = uuid();
        this.redrop = def.def.redrop || REDROP_POLICY_STRICT;
    }
    _createClass$3(ConnectionDragSelector, [{
            key: "setEnabled",
            value: function setEnabled(enabled) {
                this.def.enabled = enabled;
            }
        }, {
            key: "isEnabled",
            value: function isEnabled() {
                return this.def.enabled !== false;
            }
        }]);
    return ConnectionDragSelector;
}();
var REDROP_POLICY_STRICT = "strict";
var REDROP_POLICY_ANY = "any";
var REDROP_POLICY_ANY_SOURCE = "anySource";
var REDROP_POLICY_ANY_TARGET = "anyTarget";
var REDROP_POLICY_ANY_SOURCE_OR_TARGET = "anySourceOrTarget";
function _scopeMatch(e1, e2) {
    var s1 = e1.scope.split(/\s/), s2 = e2.scope.split(/\s/);
    for (var i = 0; i < s1.length; i++) {
        for (var j = 0; j < s2.length; j++) {
            if (s2[j] === s1[i]) {
                return true;
            }
        }
    }
    return false;
}
function prepareList(instance, input, doNotGetIds) {
    var r = [];
    var _resolveId = function _resolveId(i) {
        if (isString$1(i)) {
            return i;
        }
        else {
            return instance.getId(i);
        }
    };
    if (input) {
        if (typeof input === 'string') {
            if (input === "*") {
                return input;
            }
            r.push(input);
        }
        else {
            if (doNotGetIds) {
                r = input;
            }
            else {
                if (input.length != null) {
                    var _r;
                    (_r = r).push.apply(_r, _toConsumableArray$1(_toConsumableArray$1(input).map(_resolveId)));
                }
                else {
                    r.push(_resolveId(input));
                }
            }
        }
    }
    return r;
}
function addManagedEndpoint(managedElement, ep) {
    if (managedElement != null) {
        managedElement.endpoints.push(ep);
    }
}
function removeManagedEndpoint(managedElement, endpoint) {
    if (managedElement != null) {
        removeWithFunction(managedElement.endpoints, function (ep) {
            return ep === endpoint;
        });
    }
}
function addManagedConnection(connection, sourceEl, targetEl) {
    if (sourceEl != null) {
        sourceEl.connections.push(connection);
        if (sourceEl.connections.length === 1) {
            connection.instance.addClass(connection.source, connection.instance.connectedClass);
        }
    }
    if (targetEl != null) {
        if (sourceEl == null || connection.sourceId !== connection.targetId) {
            targetEl.connections.push(connection);
            if (targetEl.connections.length === 1) {
                connection.instance.addClass(connection.target, connection.instance.connectedClass);
            }
        }
    }
}
function removeManagedConnection(connection, sourceEl, targetEl) {
    if (sourceEl != null) {
        var sourceCount = sourceEl.connections.length;
        removeWithFunction(sourceEl.connections, function (_c) {
            return connection.id === _c.id;
        });
        if (sourceCount > 0 && sourceEl.connections.length === 0) {
            connection.instance.removeClass(connection.source, connection.instance.connectedClass);
        }
    }
    if (targetEl != null) {
        var targetCount = targetEl.connections.length;
        if (sourceEl == null || connection.sourceId !== connection.targetId) {
            removeWithFunction(targetEl.connections, function (_c) {
                return connection.id === _c.id;
            });
        }
        if (targetCount > 0 && targetEl.connections.length === 0) {
            connection.instance.removeClass(connection.target, connection.instance.connectedClass);
        }
    }
}
var JsPlumbInstance = function (_EventGenerator) {
    _inherits$3(JsPlumbInstance, _EventGenerator);
    var _super = _createSuper$3(JsPlumbInstance);
    function JsPlumbInstance(_instanceIndex, defaults) {
        var _this;
        _classCallCheck$3(this, JsPlumbInstance);
        _this = _super.call(this);
        _this._instanceIndex = _instanceIndex;
        _defineProperty$3(_assertThisInitialized$3(_this), "defaults", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "_initialDefaults", {});
        _defineProperty$3(_assertThisInitialized$3(_this), "isConnectionBeingDragged", false);
        _defineProperty$3(_assertThisInitialized$3(_this), "currentlyDragging", false);
        _defineProperty$3(_assertThisInitialized$3(_this), "hoverSuspended", false);
        _defineProperty$3(_assertThisInitialized$3(_this), "_suspendDrawing", false);
        _defineProperty$3(_assertThisInitialized$3(_this), "_suspendedAt", null);
        _defineProperty$3(_assertThisInitialized$3(_this), "connectorClass", CLASS_CONNECTOR);
        _defineProperty$3(_assertThisInitialized$3(_this), "connectorOutlineClass", CLASS_CONNECTOR_OUTLINE);
        _defineProperty$3(_assertThisInitialized$3(_this), "connectedClass", CLASS_CONNECTED);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointClass", CLASS_ENDPOINT);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointConnectedClass", CLASS_ENDPOINT_CONNECTED);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointFullClass", CLASS_ENDPOINT_FULL);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointFloatingClass", CLASS_ENDPOINT_FLOATING);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointDropAllowedClass", CLASS_ENDPOINT_DROP_ALLOWED);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointDropForbiddenClass", CLASS_ENDPOINT_DROP_FORBIDDEN);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointAnchorClassPrefix", CLASS_ENDPOINT_ANCHOR_PREFIX);
        _defineProperty$3(_assertThisInitialized$3(_this), "overlayClass", CLASS_OVERLAY);
        _defineProperty$3(_assertThisInitialized$3(_this), "connections", []);
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointsByElement", {});
        _defineProperty$3(_assertThisInitialized$3(_this), "endpointsByUUID", new Map());
        _defineProperty$3(_assertThisInitialized$3(_this), "sourceSelectors", []);
        _defineProperty$3(_assertThisInitialized$3(_this), "targetSelectors", []);
        _defineProperty$3(_assertThisInitialized$3(_this), "allowNestedGroups", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "_curIdStamp", 1);
        _defineProperty$3(_assertThisInitialized$3(_this), "viewport", new Viewport(_assertThisInitialized$3(_this)));
        _defineProperty$3(_assertThisInitialized$3(_this), "router", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "groupManager", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "_connectionTypes", new Map());
        _defineProperty$3(_assertThisInitialized$3(_this), "_endpointTypes", new Map());
        _defineProperty$3(_assertThisInitialized$3(_this), "_container", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "_managedElements", {});
        _defineProperty$3(_assertThisInitialized$3(_this), "DEFAULT_SCOPE", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "_zoom", 1);
        _this.defaults = {
            anchor: AnchorLocations.Bottom,
            anchors: [null, null],
            connectionsDetachable: true,
            connectionOverlays: [],
            connector: StraightConnector.type,
            container: null,
            endpoint: DotEndpoint.type,
            endpointOverlays: [],
            endpoints: [null, null],
            endpointStyle: {
                fill: "#456"
            },
            endpointStyles: [null, null],
            endpointHoverStyle: null,
            endpointHoverStyles: [null, null],
            hoverPaintStyle: null,
            listStyle: {},
            maxConnections: 1,
            paintStyle: {
                strokeWidth: 2,
                stroke: "#456"
            },
            reattachConnections: false,
            scope: "jsplumb_defaultscope",
            allowNestedGroups: true
        };
        if (defaults) {
            extend(_this.defaults, defaults);
        }
        extend(_this._initialDefaults, _this.defaults);
        if (_this._initialDefaults[DEFAULT_KEY_PAINT_STYLE] != null) {
            _this._initialDefaults[DEFAULT_KEY_PAINT_STYLE].strokeWidth = _this._initialDefaults[DEFAULT_KEY_PAINT_STYLE].strokeWidth || 2;
        }
        _this.DEFAULT_SCOPE = _this.defaults[DEFAULT_KEY_SCOPE];
        _this.allowNestedGroups = _this._initialDefaults[DEFAULT_KEY_ALLOW_NESTED_GROUPS] !== false;
        _this.router = new LightweightRouter(_assertThisInitialized$3(_this));
        _this.groupManager = new GroupManager(_assertThisInitialized$3(_this));
        _this.setContainer(_this._initialDefaults.container);
        return _this;
    }
    _createClass$3(JsPlumbInstance, [{
            key: "defaultScope",
            get: function get() {
                return this.DEFAULT_SCOPE;
            }
        }, {
            key: "currentZoom",
            get: function get() {
                return this._zoom;
            }
        }, {
            key: "areDefaultAnchorsSet",
            value: function areDefaultAnchorsSet() {
                return this.validAnchorsSpec(this.defaults.anchors);
            }
        }, {
            key: "validAnchorsSpec",
            value: function validAnchorsSpec(anchors) {
                return anchors != null && anchors[0] != null && anchors[1] != null;
            }
        }, {
            key: "getContainer",
            value: function getContainer() {
                return this._container;
            }
        }, {
            key: "setZoom",
            value: function setZoom(z, repaintEverything) {
                this._zoom = z;
                this.fire(EVENT_ZOOM, this._zoom);
                if (repaintEverything) {
                    this.repaintEverything();
                }
                return true;
            }
        }, {
            key: "_idstamp",
            value: function _idstamp() {
                return "" + this._curIdStamp++;
            }
        }, {
            key: "checkCondition",
            value: function checkCondition(conditionName, args) {
                var l = this.getListener(conditionName), r = true;
                if (l && l.length > 0) {
                    var values = Array.prototype.slice.call(arguments, 1);
                    try {
                        for (var i = 0, j = l.length; i < j; i++) {
                            r = r && l[i].apply(l[i], values);
                        }
                    }
                    catch (e) {
                        log("cannot check condition [" + conditionName + "]" + e);
                    }
                }
                return r;
            }
        }, {
            key: "getId",
            value: function getId(element, uuid) {
                if (element == null) {
                    return null;
                }
                var id = this.getAttribute(element, ATTRIBUTE_MANAGED);
                if (!id || id === "undefined") {
                    if (arguments.length === 2 && arguments[1] !== undefined) {
                        id = uuid;
                    }
                    else if (arguments.length === 1 || arguments.length === 3 && !arguments[2]) {
                        id = "jsplumb-" + this._instanceIndex + "-" + this._idstamp();
                    }
                    this.setAttribute(element, ATTRIBUTE_MANAGED, id);
                }
                return id;
            }
        }, {
            key: "getConnections",
            value: function getConnections(options, flat) {
                if (!options) {
                    options = {};
                }
                else if (options.constructor === String) {
                    options = {
                        "scope": options
                    };
                }
                var scope = options.scope || this.defaultScope, scopes = prepareList(this, scope, true), sources = prepareList(this, options.source), targets = prepareList(this, options.target), results = !flat && scopes.length > 1 ? {} : [], _addOne = function _addOne(scope, obj) {
                    if (!flat && scopes.length > 1) {
                        var ss = results[scope];
                        if (ss == null) {
                            ss = results[scope] = [];
                        }
                        ss.push(obj);
                    }
                    else {
                        results.push(obj);
                    }
                };
                for (var j = 0, jj = this.connections.length; j < jj; j++) {
                    var _c2 = this.connections[j], sourceId = _c2.proxies && _c2.proxies[0] ? _c2.proxies[0].originalEp.elementId : _c2.sourceId, targetId = _c2.proxies && _c2.proxies[1] ? _c2.proxies[1].originalEp.elementId : _c2.targetId;
                    if (filterList(scopes, _c2.scope) && filterList(sources, sourceId) && filterList(targets, targetId)) {
                        _addOne(_c2.scope, _c2);
                    }
                }
                return results;
            }
        }, {
            key: "select",
            value: function select(params) {
                params = params || {};
                params.scope = params.scope || "*";
                return new ConnectionSelection(this, params.connections || this.getConnections(params, true));
            }
        }, {
            key: "selectEndpoints",
            value: function selectEndpoints(params) {
                params = params || {};
                params.scope = params.scope || WILDCARD;
                var noElementFilters = !params.element && !params.source && !params.target, elements = noElementFilters ? WILDCARD : prepareList(this, params.element), sources = noElementFilters ? WILDCARD : prepareList(this, params.source), targets = noElementFilters ? WILDCARD : prepareList(this, params.target), scopes = prepareList(this, params.scope, true);
                var ep = [];
                for (var _el2 in this.endpointsByElement) {
                    var either = filterList(elements, _el2, true), source = filterList(sources, _el2, true), sourceMatchExact = sources !== "*", target = filterList(targets, _el2, true), targetMatchExact = targets !== "*";
                    if (either || source || target) {
                        inner: for (var i = 0, ii = this.endpointsByElement[_el2].length; i < ii; i++) {
                            var _ep = this.endpointsByElement[_el2][i];
                            if (filterList(scopes, _ep.scope, true)) {
                                var noMatchSource = sourceMatchExact && sources.length > 0 && !_ep.isSource, noMatchTarget = targetMatchExact && targets.length > 0 && !_ep.isTarget;
                                if (noMatchSource || noMatchTarget) {
                                    continue inner;
                                }
                                ep.push(_ep);
                            }
                        }
                    }
                }
                return new EndpointSelection(this, ep);
            }
        }, {
            key: "setContainer",
            value: function setContainer(c) {
                this._container = c;
                this.fire(EVENT_CONTAINER_CHANGE, this._container);
            }
        }, {
            key: "_set",
            value: function _set(c, el, idx) {
                var stTypes = [{
                        el: "source",
                        elId: "sourceId"
                    }, {
                        el: "target",
                        elId: "targetId"
                    }];
                var ep, _st = stTypes[idx], cId = c[_st.elId], sid, oldEndpoint = c.endpoints[idx];
                var evtParams = {
                    index: idx,
                    originalEndpoint: oldEndpoint,
                    originalSourceId: idx === 0 ? cId : c.sourceId,
                    newSourceId: c.sourceId,
                    originalTargetId: idx === 1 ? cId : c.targetId,
                    newTargetId: c.targetId,
                    connection: c,
                    newEndpoint: oldEndpoint
                };
                if (el instanceof Endpoint) {
                    ep = el;
                    ep.addConnection(c);
                }
                else {
                    sid = this.getId(el);
                    if (sid === c[_st.elId]) {
                        ep = null;
                    }
                    else {
                        ep = c.makeEndpoint(idx === 0, el, sid);
                    }
                }
                if (ep != null) {
                    evtParams.newEndpoint = ep;
                    oldEndpoint.detachFromConnection(c);
                    c.endpoints[idx] = ep;
                    c[_st.el] = ep.element;
                    c[_st.elId] = ep.elementId;
                    evtParams[idx === 0 ? "newSourceId" : "newTargetId"] = ep.elementId;
                    this.fireMoveEvent(evtParams);
                    this._paintConnection(c);
                }
                return evtParams;
            }
        }, {
            key: "setSource",
            value: function setSource(connection, el) {
                removeManagedConnection(connection, this._managedElements[connection.sourceId]);
                var p = this._set(connection, el, 0);
                addManagedConnection(connection, this._managedElements[p.newSourceId]);
            }
        }, {
            key: "setTarget",
            value: function setTarget(connection, el) {
                removeManagedConnection(connection, this._managedElements[connection.targetId]);
                var p = this._set(connection, el, 1);
                addManagedConnection(connection, this._managedElements[p.newTargetId]);
            }
        }, {
            key: "setConnectionType",
            value: function setConnectionType(connection, type, params) {
                connection.setType(type, params);
                this._paintConnection(connection);
            }
        }, {
            key: "isHoverSuspended",
            value: function isHoverSuspended() {
                return this.hoverSuspended;
            }
        }, {
            key: "setSuspendDrawing",
            value: function setSuspendDrawing(val, repaintAfterwards) {
                var curVal = this._suspendDrawing;
                this._suspendDrawing = val;
                if (val) {
                    this._suspendedAt = "" + new Date().getTime();
                }
                else {
                    this._suspendedAt = null;
                    this.viewport.recomputeBounds();
                }
                if (repaintAfterwards) {
                    this.repaintEverything();
                }
                return curVal;
            }
        }, {
            key: "getSuspendedAt",
            value: function getSuspendedAt() {
                return this._suspendedAt;
            }
        }, {
            key: "batch",
            value: function batch(fn, doNotRepaintAfterwards) {
                var _wasSuspended = this._suspendDrawing === true;
                if (!_wasSuspended) {
                    this.setSuspendDrawing(true);
                }
                fn();
                if (!_wasSuspended) {
                    this.setSuspendDrawing(false, !doNotRepaintAfterwards);
                }
            }
        }, {
            key: "each",
            value: function each(spec, fn) {
                if (spec == null) {
                    return;
                }
                if (spec.length != null) {
                    for (var i = 0; i < spec.length; i++) {
                        fn(spec[i]);
                    }
                }
                else {
                    fn(spec);
                }
                return this;
            }
        }, {
            key: "updateOffset",
            value: function updateOffset(params) {
                var elId = params.elId;
                if (params.recalc) {
                    return this.viewport.refreshElement(elId);
                }
                else {
                    return this.viewport.getPosition(elId);
                }
            }
        }, {
            key: "deleteConnection",
            value: function deleteConnection(connection, params) {
                if (connection != null && connection.deleted !== true) {
                    params = params || {};
                    if (params.force || functionChain(true, false, [[connection.endpoints[0], IS_DETACH_ALLOWED, [connection]], [connection.endpoints[1], IS_DETACH_ALLOWED, [connection]], [connection, IS_DETACH_ALLOWED, [connection]], [this, CHECK_CONDITION, [INTERCEPT_BEFORE_DETACH, connection]]])) {
                        removeManagedConnection(connection, this._managedElements[connection.sourceId], this._managedElements[connection.targetId]);
                        this.fireDetachEvent(connection, !connection.pending && params.fireEvent !== false, params.originalEvent);
                        var _sourceEndpoint = connection.endpoints[0];
                        var targetEndpoint = connection.endpoints[1];
                        if (_sourceEndpoint !== params.endpointToIgnore) {
                            _sourceEndpoint.detachFromConnection(connection, null, true);
                        }
                        if (targetEndpoint !== params.endpointToIgnore) {
                            targetEndpoint.detachFromConnection(connection, null, true);
                        }
                        removeWithFunction(this.connections, function (_c) {
                            return connection.id === _c.id;
                        });
                        connection.destroy();
                        if (_sourceEndpoint !== params.endpointToIgnore && _sourceEndpoint.deleteOnEmpty && _sourceEndpoint.connections.length === 0) {
                            this.deleteEndpoint(_sourceEndpoint);
                        }
                        if (targetEndpoint !== params.endpointToIgnore && targetEndpoint.deleteOnEmpty && targetEndpoint.connections.length === 0) {
                            this.deleteEndpoint(targetEndpoint);
                        }
                        return true;
                    }
                }
                return false;
            }
        }, {
            key: "deleteEveryConnection",
            value: function deleteEveryConnection(params) {
                var _this2 = this;
                params = params || {};
                var count = this.connections.length, deletedCount = 0;
                this.batch(function () {
                    for (var i = 0; i < count; i++) {
                        deletedCount += _this2.deleteConnection(_this2.connections[0], params) ? 1 : 0;
                    }
                });
                return deletedCount;
            }
        }, {
            key: "deleteConnectionsForElement",
            value: function deleteConnectionsForElement(el, params) {
                var id = this.getId(el), m = this._managedElements[id];
                if (m) {
                    var l = m.connections.length;
                    for (var i = 0; i < l; i++) {
                        this.deleteConnection(m.connections[0], params);
                    }
                }
                return this;
            }
        }, {
            key: "fireDetachEvent",
            value: function fireDetachEvent(jpc, doFireEvent, originalEvent) {
                var argIsConnection = jpc.id != null, params = argIsConnection ? {
                    connection: jpc,
                    source: jpc.source,
                    target: jpc.target,
                    sourceId: jpc.sourceId,
                    targetId: jpc.targetId,
                    sourceEndpoint: jpc.endpoints[0],
                    targetEndpoint: jpc.endpoints[1]
                } : jpc;
                if (doFireEvent) {
                    this.fire(EVENT_CONNECTION_DETACHED, params, originalEvent);
                }
                this.fire(EVENT_INTERNAL_CONNECTION_DETACHED, params, originalEvent);
            }
        }, {
            key: "fireMoveEvent",
            value: function fireMoveEvent(params, evt) {
                this.fire(EVENT_CONNECTION_MOVED, params, evt);
            }
        }, {
            key: "manageAll",
            value: function manageAll(elements, recalc) {
                var nl = isString$1(elements) ? this.getSelector(this.getContainer(), elements) : elements;
                for (var i = 0; i < nl.length; i++) {
                    this.manage(nl[i], null, recalc);
                }
            }
        }, {
            key: "manage",
            value: function manage(element, internalId, _recalc) {
                if (this.getAttribute(element, ATTRIBUTE_MANAGED) == null) {
                    internalId = internalId || this.getAttribute(element, "id") || uuid();
                    this.setAttribute(element, ATTRIBUTE_MANAGED, internalId);
                }
                var elId = this.getId(element);
                if (!this._managedElements[elId]) {
                    var obj = {
                        el: element,
                        endpoints: [],
                        connections: [],
                        rotation: 0,
                        data: {}
                    };
                    this._managedElements[elId] = obj;
                    if (this._suspendDrawing) {
                        obj.viewportElement = this.viewport.registerElement(elId, true);
                    }
                    else {
                        obj.viewportElement = this.updateOffset({
                            elId: elId,
                            recalc: true
                        });
                    }
                    this.fire(EVENT_MANAGE_ELEMENT, {
                        el: element
                    });
                }
                else {
                    if (_recalc) {
                        this._managedElements[elId].viewportElement = this.updateOffset({
                            elId: elId,
                            timestamp: null,
                            recalc: true
                        });
                    }
                }
                return this._managedElements[elId];
            }
        }, {
            key: "getManagedData",
            value: function getManagedData(elementId, dataIdentifier, key) {
                if (this._managedElements[elementId]) {
                    var data = this._managedElements[elementId].data[dataIdentifier];
                    return data != null ? data[key] : null;
                }
            }
        }, {
            key: "setManagedData",
            value: function setManagedData(elementId, dataIdentifier, key, data) {
                if (this._managedElements[elementId]) {
                    this._managedElements[elementId].data[dataIdentifier] = this._managedElements[elementId].data[dataIdentifier] || {};
                    this._managedElements[elementId].data[dataIdentifier][key] = data;
                }
            }
        }, {
            key: "getManagedElement",
            value: function getManagedElement(id) {
                return this._managedElements[id] ? this._managedElements[id].el : null;
            }
        }, {
            key: "unmanage",
            value: function unmanage(el, removeElement) {
                var _this3 = this;
                this.removeAllEndpoints(el, true);
                var _one = function _one(_el) {
                    var id = _this3.getId(_el);
                    _this3.removeAttribute(_el, ATTRIBUTE_MANAGED);
                    delete _this3._managedElements[id];
                    _this3.viewport.remove(id);
                    _this3.fire(EVENT_UNMANAGE_ELEMENT, {
                        el: _el,
                        id: id
                    });
                    if (_el && removeElement) {
                        _this3._removeElement(_el);
                    }
                };
                this._getAssociatedElements(el).map(_one);
                _one(el);
            }
        }, {
            key: "rotate",
            value: function rotate(element, rotation, _doNotRepaint) {
                var elementId = this.getId(element);
                if (this._managedElements[elementId]) {
                    this._managedElements[elementId].rotation = rotation;
                    this.viewport.rotateElement(elementId, rotation);
                    if (_doNotRepaint !== true) {
                        return this.revalidate(element);
                    }
                }
                return {
                    c: new Set(),
                    e: new Set()
                };
            }
        }, {
            key: "_getRotation",
            value: function _getRotation(elementId) {
                var entry = this._managedElements[elementId];
                if (entry != null) {
                    return entry.rotation || 0;
                }
                else {
                    return 0;
                }
            }
        }, {
            key: "_getRotations",
            value: function _getRotations(elementId) {
                var _this4 = this;
                var rotations = [];
                var entry = this._managedElements[elementId];
                var _oneLevel = function _oneLevel(e) {
                    if (e.group != null) {
                        var gEntry = _this4._managedElements[e.group];
                        if (gEntry != null) {
                            rotations.push({
                                r: gEntry.viewportElement.r,
                                c: gEntry.viewportElement.c
                            });
                            _oneLevel(gEntry);
                        }
                    }
                };
                if (entry != null) {
                    rotations.push({
                        r: entry.viewportElement.r || 0,
                        c: entry.viewportElement.c
                    });
                    _oneLevel(entry);
                }
                return rotations;
            }
        }, {
            key: "_applyRotations",
            value: function _applyRotations(point, rotations) {
                var sl = point.slice();
                var current = {
                    x: sl[0],
                    y: sl[1],
                    cr: 0,
                    sr: 0
                };
                forEach$1(rotations, function (rotation) {
                    current = rotatePoint(current, rotation.c, rotation.r);
                });
                return current;
            }
        }, {
            key: "_applyRotationsXY",
            value: function _applyRotationsXY(point, rotations) {
                forEach$1(rotations, function (rotation) {
                    point = rotatePoint(point, rotation.c, rotation.r);
                });
                return point;
            }
        }, {
            key: "_internal_newEndpoint",
            value: function _internal_newEndpoint(params) {
                var _p = extend({}, params);
                var managedElement = this.manage(_p.element);
                _p.elementId = this.getId(_p.element);
                _p.id = "ep_" + this._idstamp();
                var ep = new Endpoint(this, _p);
                addManagedEndpoint(managedElement, ep);
                if (params.uuid) {
                    this.endpointsByUUID.set(params.uuid, ep);
                }
                addToDictionary(this.endpointsByElement, ep.elementId, ep);
                if (!this._suspendDrawing) {
                    this._paintEndpoint(ep, {
                        timestamp: this._suspendedAt
                    });
                }
                return ep;
            }
        }, {
            key: "_deriveEndpointAndAnchorSpec",
            value: function _deriveEndpointAndAnchorSpec(type, dontPrependDefault) {
                var bits = ((dontPrependDefault ? "" : "default ") + type).split(/[\s]/), eps = null, ep = null, a = null, as = null;
                for (var i = 0; i < bits.length; i++) {
                    var _t = this.getConnectionType(bits[i]);
                    if (_t) {
                        if (_t.endpoints) {
                            eps = _t.endpoints;
                        }
                        if (_t.endpoint) {
                            ep = _t.endpoint;
                        }
                        if (_t.anchors) {
                            as = _t.anchors;
                        }
                        if (_t.anchor) {
                            a = _t.anchor;
                        }
                    }
                }
                return {
                    endpoints: eps ? eps : [ep, ep],
                    anchors: as ? as : [a, a]
                };
            }
        }, {
            key: "revalidate",
            value: function revalidate(el, timestamp) {
                var elId = this.getId(el);
                this.updateOffset({
                    elId: elId,
                    recalc: true,
                    timestamp: timestamp
                });
                return this.repaint(el);
            }
        }, {
            key: "repaintEverything",
            value: function repaintEverything() {
                var timestamp = uuid(), elId;
                for (elId in this._managedElements) {
                    this.viewport.refreshElement(elId, true);
                }
                this.viewport.recomputeBounds();
                for (elId in this._managedElements) {
                    this.repaint(this._managedElements[elId].el, timestamp, true);
                }
                return this;
            }
        }, {
            key: "setElementPosition",
            value: function setElementPosition(el, x, y) {
                var id = this.getId(el);
                this.viewport.setPosition(id, x, y);
                return this.repaint(el);
            }
        }, {
            key: "repaint",
            value: function repaint(el, timestamp, offsetsWereJustCalculated) {
                var r = {
                    c: new Set(),
                    e: new Set()
                };
                var _mergeRedraw = function _mergeRedraw(r2) {
                    r2.c.forEach(function (c) {
                        return r.c.add(c);
                    });
                    r2.e.forEach(function (e) {
                        return r.e.add(e);
                    });
                };
                if (!this._suspendDrawing) {
                    var id = this.getId(el);
                    if (el != null) {
                        var repaintEls = this._getAssociatedElements(el);
                        if (timestamp == null) {
                            timestamp = uuid();
                        }
                        if (!offsetsWereJustCalculated) {
                            for (var i = 0; i < repaintEls.length; i++) {
                                this.updateOffset({
                                    elId: this.getId(repaintEls[i]),
                                    recalc: true,
                                    timestamp: timestamp
                                });
                            }
                        }
                        _mergeRedraw(this.router.redraw(id, timestamp, null));
                        if (repaintEls.length > 0) {
                            for (var j = 0; j < repaintEls.length; j++) {
                                _mergeRedraw(this.router.redraw(this.getId(repaintEls[j]), timestamp, null));
                            }
                        }
                    }
                }
                return r;
            }
        }, {
            key: "unregisterEndpoint",
            value: function unregisterEndpoint(endpoint) {
                var uuid = endpoint.getUuid();
                if (uuid) {
                    this.endpointsByUUID["delete"](uuid);
                }
                removeManagedEndpoint(this._managedElements[endpoint.elementId], endpoint);
                var ebe = this.endpointsByElement[endpoint.elementId];
                if (ebe != null) {
                    if (ebe.length > 1) {
                        this.endpointsByElement[endpoint.elementId] = ebe.filter(function (e) {
                            return e !== endpoint;
                        });
                    }
                    else {
                        delete this.endpointsByElement[endpoint.elementId];
                    }
                }
                this.fire(EVENT_INTERNAL_ENDPOINT_UNREGISTERED, endpoint);
            }
        }, {
            key: "_maybePruneEndpoint",
            value: function _maybePruneEndpoint(endpoint) {
                if (endpoint.deleteOnEmpty && endpoint.connections.length === 0) {
                    this.deleteEndpoint(endpoint);
                    return true;
                }
                else {
                    return false;
                }
            }
        }, {
            key: "deleteEndpoint",
            value: function deleteEndpoint(object) {
                var _this5 = this;
                var endpoint = typeof object === "string" ? this.endpointsByUUID.get(object) : object;
                if (endpoint) {
                    var proxy = endpoint.proxiedBy;
                    var connectionsToDelete = endpoint.connections.slice();
                    forEach$1(connectionsToDelete, function (connection) {
                        endpoint.detachFromConnection(connection, null, true);
                    });
                    this.unregisterEndpoint(endpoint);
                    endpoint.destroy();
                    forEach$1(connectionsToDelete, function (connection) {
                        _this5.deleteConnection(connection, {
                            force: true,
                            endpointToIgnore: endpoint
                        });
                    });
                    if (proxy != null) {
                        this.deleteEndpoint(proxy);
                    }
                }
                return this;
            }
        }, {
            key: "addEndpoint",
            value: function addEndpoint(el, params, referenceParams) {
                referenceParams = referenceParams || {};
                var p = extend({}, referenceParams);
                extend(p, params || {});
                var _p = extend({
                    element: el
                }, p);
                return this._internal_newEndpoint(_p);
            }
        }, {
            key: "addEndpoints",
            value: function addEndpoints(el, endpoints, referenceParams) {
                var results = [];
                for (var i = 0, j = endpoints.length; i < j; i++) {
                    results.push(this.addEndpoint(el, endpoints[i], referenceParams));
                }
                return results;
            }
        }, {
            key: "reset",
            value: function reset() {
                var _this6 = this;
                this.silently(function () {
                    _this6.endpointsByElement = {};
                    _this6._managedElements = {};
                    _this6.endpointsByUUID.clear();
                    _this6.viewport.reset();
                    _this6.router.reset();
                    _this6.groupManager.reset();
                    _this6.connections.length = 0;
                });
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.reset();
                this.unbind();
                this.sourceSelectors.length = 0;
                this.targetSelectors.length = 0;
                this._connectionTypes.clear();
                this._endpointTypes.clear();
            }
        }, {
            key: "getEndpoints",
            value: function getEndpoints(el) {
                return this.endpointsByElement[this.getId(el)] || [];
            }
        }, {
            key: "getEndpoint",
            value: function getEndpoint(uuid) {
                return this.endpointsByUUID.get(uuid);
            }
        }, {
            key: "setEndpointUuid",
            value: function setEndpointUuid(endpoint, uuid) {
                if (endpoint.uuid) {
                    this.endpointsByUUID["delete"](endpoint.uuid);
                }
                endpoint.uuid = uuid;
                this.endpointsByUUID.set(uuid, endpoint);
            }
        }, {
            key: "connect",
            value: function connect(params, referenceParams) {
                try {
                    var _p = this._prepareConnectionParams(params, referenceParams), jpc = this._newConnection(_p);
                    this._finaliseConnection(jpc, _p);
                    return jpc;
                }
                catch (errorMessage) {
                    log(errorMessage);
                    return;
                }
            }
        }, {
            key: "_prepareConnectionParams",
            value: function _prepareConnectionParams(params, referenceParams) {
                var temp = extend({}, params);
                if (referenceParams) {
                    extend(temp, referenceParams);
                }
                var _p = temp;
                if (_p.source) {
                    if (_p.source.endpoint) {
                        _p.sourceEndpoint = _p.source;
                    }
                }
                if (_p.target) {
                    if (_p.target.endpoint) {
                        _p.targetEndpoint = _p.target;
                    }
                }
                if (params.uuids) {
                    _p.sourceEndpoint = this.getEndpoint(params.uuids[0]);
                    _p.targetEndpoint = this.getEndpoint(params.uuids[1]);
                }
                if (_p.sourceEndpoint != null) {
                    if (_p.sourceEndpoint.isFull()) {
                        throw ERROR_SOURCE_ENDPOINT_FULL;
                    }
                    if (!_p.type) {
                        _p.type = _p.sourceEndpoint.edgeType;
                    }
                    if (_p.sourceEndpoint.connectorOverlays) {
                        _p.overlays = _p.overlays || [];
                        for (var i = 0, j = _p.sourceEndpoint.connectorOverlays.length; i < j; i++) {
                            _p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);
                        }
                    }
                    if (_p.sourceEndpoint.scope) {
                        _p.scope = _p.sourceEndpoint.scope;
                    }
                }
                else {
                    if (_p.source == null) {
                        throw ERROR_SOURCE_DOES_NOT_EXIST;
                    }
                }
                if (_p.targetEndpoint != null) {
                    if (_p.targetEndpoint.isFull()) {
                        throw ERROR_TARGET_ENDPOINT_FULL;
                    }
                }
                else {
                    if (_p.target == null) {
                        throw ERROR_TARGET_DOES_NOT_EXIST;
                    }
                }
                if (_p.sourceEndpoint && _p.targetEndpoint) {
                    if (!_scopeMatch(_p.sourceEndpoint, _p.targetEndpoint)) {
                        throw "Cannot establish connection: scopes do not match";
                    }
                }
                return _p;
            }
        }, {
            key: "_newConnection",
            value: function _newConnection(params) {
                params.id = "con_" + this._idstamp();
                var c = new Connection(this, params);
                addManagedConnection(c, this._managedElements[c.sourceId], this._managedElements[c.targetId]);
                this._paintConnection(c);
                return c;
            }
        }, {
            key: "_finaliseConnection",
            value: function _finaliseConnection(jpc, params, originalEvent) {
                params = params || {};
                if (!jpc.suspendedEndpoint) {
                    this.connections.push(jpc);
                }
                jpc.pending = null;
                jpc.endpoints[0].isTemporarySource = false;
                this.repaint(jpc.source);
                var payload = {
                    connection: jpc,
                    source: jpc.source,
                    target: jpc.target,
                    sourceId: jpc.sourceId,
                    targetId: jpc.targetId,
                    sourceEndpoint: jpc.endpoints[0],
                    targetEndpoint: jpc.endpoints[1]
                };
                this.fire(EVENT_INTERNAL_CONNECTION, payload, originalEvent);
                if (!params.doNotFireConnectionEvent && params.fireEvent !== false) {
                    this.fire(EVENT_CONNECTION, payload, originalEvent);
                }
            }
        }, {
            key: "removeAllEndpoints",
            value: function removeAllEndpoints(el, recurse) {
                var _this7 = this;
                var _one = function _one(_el) {
                    var id = _this7.getId(_el), ebe = _this7.endpointsByElement[id], i, ii;
                    if (ebe) {
                        for (i = 0, ii = ebe.length; i < ii; i++) {
                            _this7.deleteEndpoint(ebe[i]);
                        }
                    }
                    delete _this7.endpointsByElement[id];
                };
                if (recurse) {
                    this._getAssociatedElements(el).map(_one);
                }
                _one(el);
                return this;
            }
        }, {
            key: "_createSourceDefinition",
            value: function _createSourceDefinition(params, referenceParams) {
                var p = extend({}, referenceParams);
                extend(p, params);
                p.edgeType = p.edgeType || DEFAULT;
                var aae = this._deriveEndpointAndAnchorSpec(p.edgeType);
                p.endpoint = p.endpoint || aae.endpoints[0];
                p.anchor = p.anchor || aae.anchors[0];
                var maxConnections = p.maxConnections || -1;
                var _def = {
                    def: extend({}, p),
                    uniqueEndpoint: p.uniqueEndpoint,
                    maxConnections: maxConnections,
                    enabled: true,
                    endpoint: null
                };
                return _def;
            }
        }, {
            key: "addSourceSelector",
            value: function addSourceSelector(selector, params) {
                var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                var _def = this._createSourceDefinition(params);
                var sel = new ConnectionDragSelector(selector, _def, exclude);
                this.sourceSelectors.push(sel);
                return sel;
            }
        }, {
            key: "removeSourceSelector",
            value: function removeSourceSelector(selector) {
                removeWithFunction(this.sourceSelectors, function (s) {
                    return s === selector;
                });
            }
        }, {
            key: "removeTargetSelector",
            value: function removeTargetSelector(selector) {
                removeWithFunction(this.targetSelectors, function (s) {
                    return s === selector;
                });
            }
        }, {
            key: "addTargetSelector",
            value: function addTargetSelector(selector, params) {
                var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                var _def = this._createTargetDefinition(params);
                var sel = new ConnectionDragSelector(selector, _def, exclude);
                this.targetSelectors.push(sel);
                return sel;
            }
        }, {
            key: "_createTargetDefinition",
            value: function _createTargetDefinition(params, referenceParams) {
                var p = extend({}, referenceParams);
                extend(p, params);
                p.edgeType = p.edgeType || DEFAULT;
                var maxConnections = p.maxConnections || -1;
                var _def = {
                    def: extend({}, p),
                    uniqueEndpoint: p.uniqueEndpoint,
                    maxConnections: maxConnections,
                    enabled: true,
                    endpoint: null
                };
                return _def;
            }
        }, {
            key: "show",
            value: function show(el, changeEndpoints) {
                return this._setVisible(el, BLOCK, changeEndpoints);
            }
        }, {
            key: "hide",
            value: function hide(el, changeEndpoints) {
                return this._setVisible(el, NONE, changeEndpoints);
            }
        }, {
            key: "_setVisible",
            value: function _setVisible(el, state, alsoChangeEndpoints) {
                var visible = state === BLOCK;
                var endpointFunc = null;
                if (alsoChangeEndpoints) {
                    endpointFunc = function endpointFunc(ep) {
                        ep.setVisible(visible, true, true);
                    };
                }
                var id = this.getId(el);
                this._operation(el, function (jpc) {
                    if (visible && alsoChangeEndpoints) {
                        var oidx = jpc.sourceId === id ? 1 : 0;
                        if (jpc.endpoints[oidx].isVisible()) {
                            jpc.setVisible(true);
                        }
                    }
                    else {
                        jpc.setVisible(visible);
                    }
                }, endpointFunc);
                return this;
            }
        }, {
            key: "toggleVisible",
            value: function toggleVisible(el, changeEndpoints) {
                var endpointFunc = null;
                if (changeEndpoints) {
                    endpointFunc = function endpointFunc(ep) {
                        var state = ep.isVisible();
                        ep.setVisible(!state);
                    };
                }
                this._operation(el, function (jpc) {
                    var state = jpc.isVisible();
                    jpc.setVisible(!state);
                }, endpointFunc);
            }
        }, {
            key: "_operation",
            value: function _operation(el, func, endpointFunc) {
                var elId = this.getId(el);
                var endpoints = this.endpointsByElement[elId];
                if (endpoints && endpoints.length) {
                    for (var i = 0, ii = endpoints.length; i < ii; i++) {
                        for (var j = 0, jj = endpoints[i].connections.length; j < jj; j++) {
                            var retVal = func(endpoints[i].connections[j]);
                            if (retVal) {
                                return;
                            }
                        }
                        if (endpointFunc) {
                            endpointFunc(endpoints[i]);
                        }
                    }
                }
            }
        }, {
            key: "registerConnectionType",
            value: function registerConnectionType(id, type) {
                this._connectionTypes.set(id, extend({}, type));
                if (type.overlays) {
                    var to = {};
                    for (var i = 0; i < type.overlays.length; i++) {
                        var fo = convertToFullOverlaySpec(type.overlays[i]);
                        to[fo.options.id] = fo;
                    }
                    this._connectionTypes.get(id).overlays = to;
                }
            }
        }, {
            key: "registerConnectionTypes",
            value: function registerConnectionTypes(types) {
                for (var i in types) {
                    this.registerConnectionType(i, types[i]);
                }
            }
        }, {
            key: "registerEndpointType",
            value: function registerEndpointType(id, type) {
                this._endpointTypes.set(id, extend({}, type));
                if (type.overlays) {
                    var to = {};
                    for (var i = 0; i < type.overlays.length; i++) {
                        var fo = convertToFullOverlaySpec(type.overlays[i]);
                        to[fo.options.id] = fo;
                    }
                    this._endpointTypes.get(id).overlays = to;
                }
            }
        }, {
            key: "registerEndpointTypes",
            value: function registerEndpointTypes(types) {
                for (var i in types) {
                    this.registerEndpointType(i, types[i]);
                }
            }
        }, {
            key: "getType",
            value: function getType(id, typeDescriptor) {
                return typeDescriptor === "connection" ? this.getConnectionType(id) : this.getEndpointType(id);
            }
        }, {
            key: "getConnectionType",
            value: function getConnectionType(id) {
                return this._connectionTypes.get(id);
            }
        }, {
            key: "getEndpointType",
            value: function getEndpointType(id) {
                return this._endpointTypes.get(id);
            }
        }, {
            key: "importDefaults",
            value: function importDefaults(d) {
                for (var i in d) {
                    this.defaults[i] = d[i];
                }
                if (this.defaults[DEFAULT_KEY_PAINT_STYLE] != null) {
                    this.defaults[DEFAULT_KEY_PAINT_STYLE].strokeWidth = this.defaults[DEFAULT_KEY_PAINT_STYLE].strokeWidth || 2;
                }
                if (d.container) {
                    this.setContainer(d.container);
                }
                return this;
            }
        }, {
            key: "restoreDefaults",
            value: function restoreDefaults() {
                this.defaults = extend({}, this._initialDefaults);
                return this;
            }
        }, {
            key: "getManagedElements",
            value: function getManagedElements() {
                return this._managedElements;
            }
        }, {
            key: "proxyConnection",
            value: function proxyConnection(connection, index, proxyEl, endpointGenerator, anchorGenerator) {
                var alreadyProxied = connection.proxies[index] != null, proxyEp, originalElementId = alreadyProxied ? connection.proxies[index].originalEp.elementId : connection.endpoints[index].elementId, originalEndpoint = alreadyProxied ? connection.proxies[index].originalEp : connection.endpoints[index], proxyElId = this.getId(proxyEl);
                if (connection.proxies[index]) {
                    if (connection.proxies[index].ep.elementId === proxyElId) {
                        proxyEp = connection.proxies[index].ep;
                    }
                    else {
                        connection.proxies[index].ep.detachFromConnection(connection, index);
                        proxyEp = this._internal_newEndpoint({
                            element: proxyEl,
                            endpoint: endpointGenerator(connection, index),
                            anchor: anchorGenerator(connection, index),
                            parameters: {
                                isProxyEndpoint: true
                            }
                        });
                    }
                }
                else {
                    proxyEp = this._internal_newEndpoint({
                        element: proxyEl,
                        endpoint: endpointGenerator(connection, index),
                        anchor: anchorGenerator(connection, index),
                        parameters: {
                            isProxyEndpoint: true
                        }
                    });
                }
                proxyEp.deleteOnEmpty = true;
                connection.proxies[index] = {
                    ep: proxyEp,
                    originalEp: originalEndpoint
                };
                this.sourceOrTargetChanged(originalElementId, proxyElId, connection, proxyEl, index);
                originalEndpoint.detachFromConnection(connection, null, true);
                proxyEp.connections = [connection];
                connection.endpoints[index] = proxyEp;
                originalEndpoint.proxiedBy = proxyEp;
                originalEndpoint.setVisible(false);
                connection.setVisible(true);
                this.revalidate(proxyEl);
            }
        }, {
            key: "unproxyConnection",
            value: function unproxyConnection(connection, index) {
                if (connection.proxies == null || connection.proxies[index] == null) {
                    return;
                }
                var originalElement = connection.proxies[index].originalEp.element, originalElementId = connection.proxies[index].originalEp.elementId, proxyElId = connection.proxies[index].ep.elementId;
                connection.endpoints[index] = connection.proxies[index].originalEp;
                delete connection.proxies[index].originalEp.proxiedBy;
                this.sourceOrTargetChanged(proxyElId, originalElementId, connection, originalElement, index);
                connection.proxies[index].ep.detachFromConnection(connection, null);
                connection.proxies[index].originalEp.addConnection(connection);
                if (connection.isVisible()) {
                    connection.proxies[index].originalEp.setVisible(true);
                }
                connection.proxies[index] = null;
                if (findWithFunction(connection.proxies, function (p) {
                    return p != null;
                }) === -1) {
                    connection.proxies.length = 0;
                }
            }
        }, {
            key: "sourceOrTargetChanged",
            value: function sourceOrTargetChanged(originalId, newId, connection, newElement, index) {
                if (originalId !== newId) {
                    if (index === 0) {
                        connection.sourceId = newId;
                        connection.source = newElement;
                    }
                    else if (index === 1) {
                        connection.targetId = newId;
                        connection.target = newElement;
                    }
                    removeManagedConnection(connection, this._managedElements[originalId]);
                    addManagedConnection(connection, this._managedElements[newId]);
                }
            }
        }, {
            key: "getGroup",
            value: function getGroup(groupId) {
                return this.groupManager.getGroup(groupId);
            }
        }, {
            key: "getGroupFor",
            value: function getGroupFor(el) {
                return this.groupManager.getGroupFor(el);
            }
        }, {
            key: "addGroup",
            value: function addGroup(params) {
                return this.groupManager.addGroup(params);
            }
        }, {
            key: "addToGroup",
            value: function addToGroup(group) {
                var _this$groupManager;
                for (var _len = arguments.length, el = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    el[_key - 1] = arguments[_key];
                }
                return (_this$groupManager = this.groupManager).addToGroup.apply(_this$groupManager, [group, false].concat(el));
            }
        }, {
            key: "collapseGroup",
            value: function collapseGroup(group) {
                this.groupManager.collapseGroup(group);
            }
        }, {
            key: "expandGroup",
            value: function expandGroup(group) {
                this.groupManager.expandGroup(group);
            }
        }, {
            key: "toggleGroup",
            value: function toggleGroup(group) {
                this.groupManager.toggleGroup(group);
            }
        }, {
            key: "removeGroup",
            value: function removeGroup(group, deleteMembers, _manipulateView, _doNotFireEvent) {
                return this.groupManager.removeGroup(group, deleteMembers, _manipulateView, _doNotFireEvent);
            }
        }, {
            key: "removeAllGroups",
            value: function removeAllGroups(deleteMembers, _manipulateView) {
                this.groupManager.removeAllGroups(deleteMembers, _manipulateView, false);
            }
        }, {
            key: "removeFromGroup",
            value: function removeFromGroup(group, el, _doNotFireEvent) {
                this.groupManager.removeFromGroup(group, _doNotFireEvent, el);
                this._appendElement(el, this.getContainer());
                this.updateOffset({
                    recalc: true,
                    elId: this.getId(el)
                });
            }
        }, {
            key: "_paintEndpoint",
            value: function _paintEndpoint(endpoint, params) {
                function findConnectionToUseForDynamicAnchor(ep) {
                    var idx = 0;
                    if (params.elementWithPrecedence != null) {
                        for (var i = 0; i < ep.connections.length; i++) {
                            if (ep.connections[i].sourceId === params.elementWithPrecedence || ep.connections[i].targetId === params.elementWithPrecedence) {
                                idx = i;
                                break;
                            }
                        }
                    }
                    return ep.connections[idx];
                }
                params = params || {};
                var timestamp = params.timestamp, recalc = !(params.recalc === false);
                if (!timestamp || endpoint.timestamp !== timestamp) {
                    var info = this.viewport.getPosition(endpoint.elementId);
                    var xy = params.offset ? {
                        x: params.offset.x,
                        y: params.offset.y
                    } : {
                        x: info.x,
                        y: info.y
                    };
                    if (xy != null) {
                        var ap = params.anchorLoc;
                        if (ap == null) {
                            var anchorParams = {
                                xy: xy,
                                wh: info,
                                element: endpoint,
                                timestamp: timestamp
                            };
                            if (recalc && this.router.isDynamicAnchor(endpoint) && endpoint.connections.length > 0) {
                                var _c3 = findConnectionToUseForDynamicAnchor(endpoint), oIdx = _c3.endpoints[0] === endpoint ? 1 : 0, oId = oIdx === 0 ? _c3.sourceId : _c3.targetId, oInfo = this.viewport.getPosition(oId);
                                anchorParams.index = oIdx === 0 ? 1 : 0;
                                anchorParams.connection = _c3;
                                anchorParams.txy = oInfo;
                                anchorParams.twh = oInfo;
                                anchorParams.tElement = _c3.endpoints[oIdx];
                                anchorParams.tRotation = this._getRotations(oId);
                            }
                            else if (endpoint.connections.length > 0) {
                                anchorParams.connection = endpoint.connections[0];
                            }
                            anchorParams.rotation = this._getRotations(endpoint.elementId);
                            ap = this.router.computeAnchorLocation(endpoint._anchor, anchorParams);
                        }
                        endpoint.endpoint.compute(ap, this.router.getEndpointOrientation(endpoint), endpoint.paintStyleInUse);
                        this.renderEndpoint(endpoint, endpoint.paintStyleInUse);
                        endpoint.timestamp = timestamp;
                        for (var i in endpoint.overlays) {
                            if (endpoint.overlays.hasOwnProperty(i)) {
                                var _o = endpoint.overlays[i];
                                if (_o.isVisible()) {
                                    endpoint.overlayPlacements[i] = this.drawOverlay(_o, endpoint.endpoint, endpoint.paintStyleInUse, endpoint.getAbsoluteOverlayPosition(_o));
                                    this._paintOverlay(_o, endpoint.overlayPlacements[i], {
                                        xmin: 0,
                                        ymin: 0
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }, {
            key: "_paintConnection",
            value: function _paintConnection(connection, params) {
                if (!this._suspendDrawing && connection.visible !== false) {
                    params = params || {};
                    var timestamp = params.timestamp;
                    if (timestamp != null && timestamp === connection.lastPaintedAt) {
                        return;
                    }
                    if (timestamp == null || timestamp !== connection.lastPaintedAt) {
                        this.router.computePath(connection, timestamp);
                        var overlayExtents = {
                            xmin: Infinity,
                            ymin: Infinity,
                            xmax: -Infinity,
                            ymax: -Infinity
                        };
                        for (var i in connection.overlays) {
                            if (connection.overlays.hasOwnProperty(i)) {
                                var _o2 = connection.overlays[i];
                                if (_o2.isVisible()) {
                                    connection.overlayPlacements[i] = this.drawOverlay(_o2, connection.connector, connection.paintStyleInUse, connection.getAbsoluteOverlayPosition(_o2));
                                    overlayExtents.xmin = Math.min(overlayExtents.xmin, connection.overlayPlacements[i].xmin);
                                    overlayExtents.xmax = Math.max(overlayExtents.xmax, connection.overlayPlacements[i].xmax);
                                    overlayExtents.ymin = Math.min(overlayExtents.ymin, connection.overlayPlacements[i].ymin);
                                    overlayExtents.ymax = Math.max(overlayExtents.ymax, connection.overlayPlacements[i].ymax);
                                }
                            }
                        }
                        var lineWidth = parseFloat("" + connection.paintStyleInUse.strokeWidth || "1") / 2, outlineWidth = parseFloat("" + connection.paintStyleInUse.strokeWidth || "0"), _extents = {
                            xmin: Math.min(connection.connector.bounds.xmin - (lineWidth + outlineWidth), overlayExtents.xmin),
                            ymin: Math.min(connection.connector.bounds.ymin - (lineWidth + outlineWidth), overlayExtents.ymin),
                            xmax: Math.max(connection.connector.bounds.xmax + (lineWidth + outlineWidth), overlayExtents.xmax),
                            ymax: Math.max(connection.connector.bounds.ymax + (lineWidth + outlineWidth), overlayExtents.ymax)
                        };
                        this.paintConnector(connection.connector, connection.paintStyleInUse, _extents);
                        for (var j in connection.overlays) {
                            if (connection.overlays.hasOwnProperty(j)) {
                                var _p2 = connection.overlays[j];
                                if (_p2.isVisible()) {
                                    this._paintOverlay(_p2, connection.overlayPlacements[j], _extents);
                                }
                            }
                        }
                    }
                    connection.lastPaintedAt = timestamp;
                }
            }
        }, {
            key: "_refreshEndpoint",
            value: function _refreshEndpoint(endpoint) {
                if (!endpoint._anchor.isFloating) {
                    if (endpoint.connections.length > 0) {
                        this.addEndpointClass(endpoint, this.endpointConnectedClass);
                    }
                    else {
                        this.removeEndpointClass(endpoint, this.endpointConnectedClass);
                    }
                    if (endpoint.isFull()) {
                        this.addEndpointClass(endpoint, this.endpointFullClass);
                    }
                    else {
                        this.removeEndpointClass(endpoint, this.endpointFullClass);
                    }
                }
            }
        }, {
            key: "_makeConnector",
            value: function _makeConnector(connection, name, args) {
                return Connectors.get(connection, name, args);
            }
        }, {
            key: "addOverlay",
            value: function addOverlay(component, overlay, doNotRevalidate) {
                component.addOverlay(overlay);
                if (!doNotRevalidate) {
                    var relatedElement = component instanceof Endpoint ? component.element : component.source;
                    this.revalidate(relatedElement);
                }
            }
        }, {
            key: "removeOverlay",
            value: function removeOverlay(component, overlayId) {
                component.removeOverlay(overlayId);
                var relatedElement = component instanceof Endpoint ? component.element : component.source;
                this.revalidate(relatedElement);
            }
        }, {
            key: "setOutlineColor",
            value: function setOutlineColor(conn, color) {
                conn.paintStyleInUse.outlineStroke = color;
                this._paintConnection(conn);
            }
        }, {
            key: "setOutlineWidth",
            value: function setOutlineWidth(conn, width) {
                conn.paintStyleInUse.outlineWidth = width;
                this._paintConnection(conn);
            }
        }, {
            key: "setColor",
            value: function setColor(conn, color) {
                conn.paintStyleInUse.stroke = color;
                this._paintConnection(conn);
            }
        }, {
            key: "setLineWidth",
            value: function setLineWidth(conn, width) {
                conn.paintStyleInUse.strokeWidth = width;
                this._paintConnection(conn);
            }
        }, {
            key: "setLineStyle",
            value: function setLineStyle(conn, style) {
                if (style.lineWidth != null) {
                    conn.paintStyleInUse.strokeWidth = style.lineWidth;
                }
                if (style.outlineWidth != null) {
                    conn.paintStyleInUse.outlineWidth = style.outlineWidth;
                }
                if (style.color != null) {
                    conn.paintStyleInUse.stroke = style.color;
                }
                if (style.outlineColor != null) {
                    conn.paintStyleInUse.outlineStroke = style.outlineColor;
                }
                this._paintConnection(conn);
            }
        }, {
            key: "getPathData",
            value: function getPathData(connector) {
                var p = "";
                for (var i = 0; i < connector.segments.length; i++) {
                    p += connector.segments[i].getPath(i === 0);
                    p += " ";
                }
                return p;
            }
        }]);
    return JsPlumbInstance;
}(EventGenerator);
var VERY_SMALL_VALUE = 0.0000000001;
function gentleRound(n) {
    var f = Math.floor(n), r = Math.ceil(n);
    if (n - f < VERY_SMALL_VALUE) {
        return f;
    }
    else if (r - n < VERY_SMALL_VALUE) {
        return r;
    }
    return n;
}
var ArcSegment = function (_AbstractSegment) {
    _inherits$3(ArcSegment, _AbstractSegment);
    var _super = _createSuper$3(ArcSegment);
    function ArcSegment(params) {
        var _this;
        _classCallCheck$3(this, ArcSegment);
        _this = _super.call(this, params);
        _defineProperty$3(_assertThisInitialized$3(_this), "type", ArcSegment.segmentType);
        _defineProperty$3(_assertThisInitialized$3(_this), "cx", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "cy", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "radius", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "anticlockwise", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "startAngle", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "endAngle", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "sweep", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "length", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "circumference", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "frac", void 0);
        _this.cx = params.cx;
        _this.cy = params.cy;
        _this.radius = params.r;
        _this.anticlockwise = params.ac;
        if (params.startAngle && params.endAngle) {
            _this.startAngle = params.startAngle;
            _this.endAngle = params.endAngle;
            _this.x1 = _this.cx + _this.radius * Math.cos(_this.startAngle);
            _this.y1 = _this.cy + _this.radius * Math.sin(_this.startAngle);
            _this.x2 = _this.cx + _this.radius * Math.cos(_this.endAngle);
            _this.y2 = _this.cy + _this.radius * Math.sin(_this.endAngle);
        }
        else {
            _this.startAngle = _this._calcAngle(_this.x1, _this.y1);
            _this.endAngle = _this._calcAngle(_this.x2, _this.y2);
        }
        if (_this.endAngle < 0) {
            _this.endAngle += TWO_PI;
        }
        if (_this.startAngle < 0) {
            _this.startAngle += TWO_PI;
        }
        var ea = _this.endAngle < _this.startAngle ? _this.endAngle + TWO_PI : _this.endAngle;
        _this.sweep = Math.abs(ea - _this.startAngle);
        if (_this.anticlockwise) {
            _this.sweep = TWO_PI - _this.sweep;
        }
        _this.circumference = 2 * Math.PI * _this.radius;
        _this.frac = _this.sweep / TWO_PI;
        _this.length = _this.circumference * _this.frac;
        _this.extents = {
            xmin: _this.cx - _this.radius,
            xmax: _this.cx + _this.radius,
            ymin: _this.cy - _this.radius,
            ymax: _this.cy + _this.radius
        };
        return _this;
    }
    _createClass$3(ArcSegment, [{
            key: "_calcAngle",
            value: function _calcAngle(_x, _y) {
                return theta({
                    x: this.cx,
                    y: this.cy
                }, {
                    x: _x,
                    y: _y
                });
            }
        }, {
            key: "_calcAngleForLocation",
            value: function _calcAngleForLocation(segment, location) {
                if (segment.anticlockwise) {
                    var sa = segment.startAngle < segment.endAngle ? segment.startAngle + TWO_PI : segment.startAngle, s = Math.abs(sa - segment.endAngle);
                    return sa - s * location;
                }
                else {
                    var ea = segment.endAngle < segment.startAngle ? segment.endAngle + TWO_PI : segment.endAngle, ss = Math.abs(ea - segment.startAngle);
                    return segment.startAngle + ss * location;
                }
            }
        }, {
            key: "getPath",
            value: function getPath(isFirstSegment) {
                var laf = this.sweep > Math.PI ? 1 : 0, sf = this.anticlockwise ? 0 : 1;
                return (isFirstSegment ? "M" + this.x1 + " " + this.y1 + " " : "") + "A " + this.radius + " " + this.radius + " 0 " + laf + "," + sf + " " + this.x2 + " " + this.y2;
            }
        }, {
            key: "getLength",
            value: function getLength() {
                return this.length;
            }
        }, {
            key: "pointOnPath",
            value: function pointOnPath(location, absolute) {
                if (location === 0) {
                    return {
                        x: this.x1,
                        y: this.y1,
                        theta: this.startAngle
                    };
                }
                else if (location === 1) {
                    return {
                        x: this.x2,
                        y: this.y2,
                        theta: this.endAngle
                    };
                }
                if (absolute) {
                    location = location / length;
                }
                var angle = this._calcAngleForLocation(this, location), _x = this.cx + this.radius * Math.cos(angle), _y = this.cy + this.radius * Math.sin(angle);
                return {
                    x: gentleRound(_x),
                    y: gentleRound(_y),
                    theta: angle
                };
            }
        }, {
            key: "gradientAtPoint",
            value: function gradientAtPoint(location, absolute) {
                var p = this.pointOnPath(location, absolute);
                var m = normal({
                    x: this.cx,
                    y: this.cy
                }, p);
                if (!this.anticlockwise && (m === Infinity || m === -Infinity)) {
                    m *= -1;
                }
                return m;
            }
        }, {
            key: "pointAlongPathFrom",
            value: function pointAlongPathFrom(location, distance, absolute) {
                var p = this.pointOnPath(location, absolute), arcSpan = distance / this.circumference * 2 * Math.PI, dir = this.anticlockwise ? -1 : 1, startAngle = p.theta + dir * arcSpan, startX = this.cx + this.radius * Math.cos(startAngle), startY = this.cy + this.radius * Math.sin(startAngle);
                return {
                    x: startX,
                    y: startY
                };
            }
        }]);
    return ArcSegment;
}(AbstractSegment);
_defineProperty$3(ArcSegment, "segmentType", "Arc");
var DEFAULT_WIDTH = 20;
var DEFAULT_LENGTH = 20;
var ArrowOverlay = function (_Overlay) {
    _inherits$3(ArrowOverlay, _Overlay);
    var _super = _createSuper$3(ArrowOverlay);
    function ArrowOverlay(instance, component, p) {
        var _this;
        _classCallCheck$3(this, ArrowOverlay);
        _this = _super.call(this, instance, component, p);
        _this.instance = instance;
        _this.component = component;
        _defineProperty$3(_assertThisInitialized$3(_this), "width", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "length", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "foldback", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "direction", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "location", 0.5);
        _defineProperty$3(_assertThisInitialized$3(_this), "paintStyle", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "type", ArrowOverlay.type);
        _defineProperty$3(_assertThisInitialized$3(_this), "cachedDimensions", void 0);
        p = p || {};
        _this.width = p.width || DEFAULT_WIDTH;
        _this.length = p.length || DEFAULT_LENGTH;
        _this.direction = (p.direction || 1) < 0 ? -1 : 1;
        _this.foldback = p.foldback || 0.623;
        _this.paintStyle = p.paintStyle || {
            "strokeWidth": 1
        };
        _this.location = p.location == null ? _this.location : Array.isArray(p.location) ? p.location[0] : p.location;
        return _this;
    }
    _createClass$3(ArrowOverlay, [{
            key: "draw",
            value: function draw(component, currentConnectionPaintStyle, absolutePosition) {
                if (component instanceof AbstractConnector) {
                    var connector = component;
                    var hxy, mid, txy, tail, cxy;
                    if (this.location > 1 || this.location < 0) {
                        var fromLoc = this.location < 0 ? 1 : 0;
                        hxy = connector.pointAlongPathFrom(fromLoc, this.location, false);
                        mid = connector.pointAlongPathFrom(fromLoc, this.location - this.direction * this.length / 2, false);
                        txy = pointOnLine(hxy, mid, this.length);
                    }
                    else if (this.location === 1) {
                        hxy = connector.pointOnPath(this.location);
                        mid = connector.pointAlongPathFrom(this.location, -this.length);
                        txy = pointOnLine(hxy, mid, this.length);
                        if (this.direction === -1) {
                            var _ = txy;
                            txy = hxy;
                            hxy = _;
                        }
                    }
                    else if (this.location === 0) {
                        txy = connector.pointOnPath(this.location);
                        mid = connector.pointAlongPathFrom(this.location, this.length);
                        hxy = pointOnLine(txy, mid, this.length);
                        if (this.direction === -1) {
                            var __ = txy;
                            txy = hxy;
                            hxy = __;
                        }
                    }
                    else {
                        hxy = connector.pointAlongPathFrom(this.location, this.direction * this.length / 2);
                        mid = connector.pointOnPath(this.location);
                        txy = pointOnLine(hxy, mid, this.length);
                    }
                    tail = perpendicularLineTo(hxy, txy, this.width);
                    cxy = pointOnLine(hxy, txy, this.foldback * this.length);
                    var d = {
                        hxy: hxy,
                        tail: tail,
                        cxy: cxy
                    }, stroke = this.paintStyle.stroke || currentConnectionPaintStyle.stroke, fill = this.paintStyle.fill || currentConnectionPaintStyle.stroke, lineWidth = this.paintStyle.strokeWidth || currentConnectionPaintStyle.strokeWidth;
                    return {
                        component: component,
                        d: d,
                        "stroke-width": lineWidth,
                        stroke: stroke,
                        fill: fill,
                        xmin: Math.min(hxy.x, tail[0].x, tail[1].x),
                        xmax: Math.max(hxy.x, tail[0].x, tail[1].x),
                        ymin: Math.min(hxy.y, tail[0].y, tail[1].y),
                        ymax: Math.max(hxy.y, tail[0].y, tail[1].y)
                    };
                }
            }
        }, {
            key: "updateFrom",
            value: function updateFrom(d) { }
        }]);
    return ArrowOverlay;
}(Overlay);
_defineProperty$3(ArrowOverlay, "type", "Arrow");
function isArrowOverlay(o) {
    return o.type === ArrowOverlay.type;
}
OverlayFactory.register(ArrowOverlay.type, ArrowOverlay);
var PlainArrowOverlay = function (_ArrowOverlay) {
    _inherits$3(PlainArrowOverlay, _ArrowOverlay);
    var _super = _createSuper$3(PlainArrowOverlay);
    function PlainArrowOverlay(instance, component, p) {
        var _this;
        _classCallCheck$3(this, PlainArrowOverlay);
        _this = _super.call(this, instance, component, p);
        _this.instance = instance;
        _defineProperty$3(_assertThisInitialized$3(_this), "type", PlainArrowOverlay.type);
        _this.foldback = 1;
        return _this;
    }
    return PlainArrowOverlay;
}(ArrowOverlay);
_defineProperty$3(PlainArrowOverlay, "type", "PlainArrow");
function isPlainArrowOverlay(o) {
    return o.type === PlainArrowOverlay.type;
}
OverlayFactory.register("PlainArrow", PlainArrowOverlay);
var DiamondOverlay = function (_ArrowOverlay) {
    _inherits$3(DiamondOverlay, _ArrowOverlay);
    var _super = _createSuper$3(DiamondOverlay);
    function DiamondOverlay(instance, component, p) {
        var _this;
        _classCallCheck$3(this, DiamondOverlay);
        _this = _super.call(this, instance, component, p);
        _this.instance = instance;
        _defineProperty$3(_assertThisInitialized$3(_this), "type", DiamondOverlay.type);
        _this.length = _this.length / 2;
        _this.foldback = 2;
        return _this;
    }
    return DiamondOverlay;
}(ArrowOverlay);
_defineProperty$3(DiamondOverlay, "type", "Diamond");
function isDiamondOverlay(o) {
    return o.type === DiamondOverlay.type;
}
OverlayFactory.register(DiamondOverlay.type, DiamondOverlay);
var CustomOverlay = function (_Overlay) {
    _inherits$3(CustomOverlay, _Overlay);
    var _super = _createSuper$3(CustomOverlay);
    function CustomOverlay(instance, component, p) {
        var _this;
        _classCallCheck$3(this, CustomOverlay);
        _this = _super.call(this, instance, component, p);
        _this.instance = instance;
        _this.component = component;
        _defineProperty$3(_assertThisInitialized$3(_this), "create", void 0);
        _defineProperty$3(_assertThisInitialized$3(_this), "type", CustomOverlay.type);
        _this.create = p.create;
        return _this;
    }
    _createClass$3(CustomOverlay, [{
            key: "updateFrom",
            value: function updateFrom(d) { }
        }]);
    return CustomOverlay;
}(Overlay);
_defineProperty$3(CustomOverlay, "type", "Custom");
function isCustomOverlay(o) {
    return o.type === CustomOverlay.type;
}
OverlayFactory.register(CustomOverlay.type, CustomOverlay);
EndpointFactory.registerHandler(DotEndpointHandler);
EndpointFactory.registerHandler(RectangleEndpointHandler);
EndpointFactory.registerHandler(BlankEndpointHandler);
Connectors.register(StraightConnector.type, StraightConnector);
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
            return typeof obj;
        };
    }
    else {
        _typeof = function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
function _classCallCheck$2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$2(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
            descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass$2(Constructor, protoProps, staticProps) {
    if (protoProps)
        _defineProperties$2(Constructor.prototype, protoProps);
    if (staticProps)
        _defineProperties$2(Constructor, staticProps);
    return Constructor;
}
function _defineProperty$2(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    else {
        obj[key] = value;
    }
    return obj;
}
function _inherits$2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass)
        _setPrototypeOf$2(subClass, superClass);
}
function _getPrototypeOf$2(o) {
    _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$2(o);
}
function _setPrototypeOf$2(o, p) {
    _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf$2(o, p);
}
function _isNativeReflectConstruct$2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
    if (Reflect.construct.sham)
        return false;
    if (typeof Proxy === "function")
        return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { }));
        return true;
    }
    catch (e) {
        return false;
    }
}
function _assertThisInitialized$2(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _possibleConstructorReturn$2(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized$2(self);
}
function _createSuper$2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf$2(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf$2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        }
        else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$2(this, result);
    };
}
function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$2(object);
        if (object === null)
            break;
    }
    return object;
}
function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
    }
    else {
        _get = function _get(target, property, receiver) {
            var base = _superPropBase(target, property);
            if (!base)
                return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver);
            }
            return desc.value;
        };
    }
    return _get(target, property, receiver || target);
}
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
        return arr;
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
        return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
                break;
        }
    }
    catch (err) {
        _d = true;
        _e = err;
    }
    finally {
        try {
            if (!_n && _i["return"] != null)
                _i["return"]();
        }
        finally {
            if (_d)
                throw _e;
        }
    }
    return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o)
        return;
    if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
        n = o.constructor.name;
    if (n === "Map" || n === "Set")
        return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
        len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
    return arr2;
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function matchesSelector$1(el, selector, ctx) {
    ctx = ctx || el.parentNode;
    var possibles = ctx.querySelectorAll(selector);
    for (var i = 0; i < possibles.length; i++) {
        if (possibles[i] === el) {
            return true;
        }
    }
    return false;
}
function consume(e, doNotPreventDefault) {
    if (e.stopPropagation) {
        e.stopPropagation();
    }
    else {
        e.returnValue = false;
    }
    if (!doNotPreventDefault && e.preventDefault) {
        e.preventDefault();
    }
}
function findParent(el, selector, container, matchOnElementAlso) {
    if (matchOnElementAlso && matchesSelector$1(el, selector, container)) {
        return el;
    }
    else {
        el = el.parentNode;
    }
    while (el != null && el !== container) {
        if (matchesSelector$1(el, selector)) {
            return el;
        }
        else {
            el = el.parentNode;
        }
    }
}
function getEventSource(e) {
    return e.srcElement || e.target;
}
function _setClassName(el, cn, classList) {
    cn = fastTrim(cn);
    if (typeof el.className.baseVal !== "undefined") {
        el.className.baseVal = cn;
    }
    else {
        el.className = cn;
    }
    try {
        var cl = el.classList;
        if (cl != null) {
            while (cl.length > 0) {
                cl.remove(cl.item(0));
            }
            for (var i = 0; i < classList.length; i++) {
                if (classList[i]) {
                    cl.add(classList[i]);
                }
            }
        }
    }
    catch (e) {
        log("WARN: cannot set class list", e);
    }
}
function _getClassName(el) {
    return el.className != null ? typeof el.className.baseVal === "undefined" ? el.className : el.className.baseVal : "";
}
function _classManip(el, classesToAdd, classesToRemove) {
    var cta = classesToAdd == null ? [] : Array.isArray(classesToAdd) ? classesToAdd : classesToAdd.split(/\s+/);
    var ctr = classesToRemove == null ? [] : Array.isArray(classesToRemove) ? classesToRemove : classesToRemove.split(/\s+/);
    var className = _getClassName(el), curClasses = className.split(/\s+/);
    var _oneSet = function _oneSet(add, classes) {
        for (var i = 0; i < classes.length; i++) {
            if (add) {
                if (curClasses.indexOf(classes[i]) === -1) {
                    curClasses.push(classes[i]);
                }
            }
            else {
                var idx = curClasses.indexOf(classes[i]);
                if (idx !== -1) {
                    curClasses.splice(idx, 1);
                }
            }
        }
    };
    _oneSet(true, cta);
    _oneSet(false, ctr);
    _setClassName(el, curClasses.join(" "), curClasses);
}
function isNodeList(el) {
    return !isString$1(el) && !Array.isArray(el) && el.length != null && el.documentElement == null && el.nodeType == null;
}
function getClass(el) {
    return _getClassName(el);
}
function addClass(el, clazz) {
    var _one = function _one(el, clazz) {
        if (el != null && clazz != null && clazz.length > 0) {
            if (el.classList) {
                var parts = fastTrim(clazz).split(/\s+/);
                forEach$1(parts, function (part) {
                    el.classList.add(part);
                });
            }
            else {
                _classManip(el, clazz);
            }
        }
    };
    if (isNodeList(el)) {
        forEach$1(el, function (el) {
            return _one(el, clazz);
        });
    }
    else {
        _one(el, clazz);
    }
}
function hasClass(el, clazz) {
    if (el.classList) {
        return el.classList.contains(clazz);
    }
    else {
        return _getClassName(el).indexOf(clazz) !== -1;
    }
}
function removeClass(el, clazz) {
    var _one = function _one(el, clazz) {
        if (el != null && clazz != null && clazz.length > 0) {
            if (el.classList) {
                var parts = fastTrim(clazz).split(/\s+/);
                parts.forEach(function (part) {
                    el.classList.remove(part);
                });
            }
            else {
                _classManip(el, null, clazz);
            }
        }
    };
    if (isNodeList(el)) {
        forEach$1(el, function (el) {
            return _one(el, clazz);
        });
    }
    else {
        _one(el, clazz);
    }
}
function toggleClass(el, clazz) {
    var _this = this;
    var _one = function _one(el, clazz) {
        if (el != null && clazz != null && clazz.length > 0) {
            if (el.classList) {
                el.classList.toggle(clazz);
            }
            else {
                if (_this.hasClass(el, clazz)) {
                    _this.removeClass(el, clazz);
                }
                else {
                    _this.addClass(el, clazz);
                }
            }
        }
    };
    if (isNodeList(el)) {
        forEach$1(el, function (el) {
            return _one(el, clazz);
        });
    }
    else {
        _one(el, clazz);
    }
}
function createElement(tag, style, clazz, atts) {
    return createElementNS(null, tag, style, clazz, atts);
}
function createElementNS(ns, tag, style, clazz, atts) {
    var e = ns == null ? document.createElement(tag) : document.createElementNS(ns, tag);
    var i;
    style = style || {};
    for (i in style) {
        e.style[i] = style[i];
    }
    if (clazz) {
        e.className = clazz;
    }
    atts = atts || {};
    for (i in atts) {
        e.setAttribute(i, "" + atts[i]);
    }
    return e;
}
function offsetRelativeToRoot(el) {
    var box = el.getBoundingClientRect(), body = document.body, docElem = document.documentElement, scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop, scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft, clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0, top = box.top + scrollTop - clientTop, left = box.left + scrollLeft - clientLeft;
    return {
        x: Math.round(left),
        y: Math.round(top)
    };
}
function offsetSize(el) {
    return {
        w: el.offsetWidth,
        h: el.offsetHeight
    };
}
function svgWidthHeightSize(el) {
    try {
        return {
            w: parseFloat(el.width.baseVal.value),
            h: parseFloat(el.height.baseVal.value)
        };
    }
    catch (e) {
        return {
            w: 0,
            h: 0
        };
    }
}
function svgXYPosition(el) {
    try {
        return {
            x: parseFloat(el.x.baseVal.value),
            y: parseFloat(el.y.baseVal.value)
        };
    }
    catch (e) {
        return {
            x: 0,
            y: 0
        };
    }
}
function getElementPosition(el, instance) {
    var pc = instance.getContainer().getBoundingClientRect();
    var ec = el.getBoundingClientRect();
    var z = instance.currentZoom;
    return {
        x: (ec.left - pc.left) / z,
        y: (ec.top - pc.top) / z
    };
}
function getElementSize(el, instance) {
    var ec = el.getBoundingClientRect();
    var z = instance.currentZoom;
    return {
        w: ec.width / z,
        h: ec.height / z
    };
}
var ElementTypes;
(function (ElementTypes) {
    ElementTypes["SVG"] = "SVG";
    ElementTypes["HTML"] = "HTML";
})(ElementTypes || (ElementTypes = {}));
function getElementType(el) {
    return el instanceof SVGElement ? ElementTypes.SVG : ElementTypes.HTML;
}
function isSVGElement(el) {
    return getElementType(el) === ElementTypes.SVG;
}
var svgAttributeMap = {
    "stroke-linejoin": "stroke-linejoin",
    "stroke-dashoffset": "stroke-dashoffset",
    "stroke-linecap": "stroke-linecap"
};
var STROKE_DASHARRAY = "stroke-dasharray";
var DASHSTYLE = "dashstyle";
var FILL = "fill";
var STROKE = "stroke";
var STROKE_WIDTH = "stroke-width";
var LINE_WIDTH = "strokeWidth";
var ELEMENT_SVG = "svg";
var ELEMENT_PATH = "path";
var ns = {
    svg: "http://www.w3.org/2000/svg"
};
function _attr(node, attributes) {
    for (var i in attributes) {
        node.setAttribute(i, "" + attributes[i]);
    }
}
function _node(name, attributes) {
    attributes = attributes || {};
    attributes.version = "1.1";
    attributes.xmlns = ns.svg;
    return createElementNS(ns.svg, name, null, null, attributes);
}
function _pos(d) {
    return "position:absolute;left:" + d[0] + "px;top:" + d[1] + "px";
}
function _applyStyles(parent, node, style) {
    node.setAttribute(FILL, style.fill ? style.fill : NONE);
    node.setAttribute(STROKE, style.stroke ? style.stroke : NONE);
    if (style.strokeWidth) {
        node.setAttribute(STROKE_WIDTH, style.strokeWidth);
    }
    if (style[DASHSTYLE] && style[LINE_WIDTH] && !style[STROKE_DASHARRAY]) {
        var sep = style[DASHSTYLE].indexOf(",") === -1 ? " " : ",", parts = style[DASHSTYLE].split(sep), styleToUse = "";
        forEach$1(parts, function (p) {
            styleToUse += Math.floor(p * style.strokeWidth) + sep;
        });
        node.setAttribute(STROKE_DASHARRAY, styleToUse);
    }
    else if (style[STROKE_DASHARRAY]) {
        node.setAttribute(STROKE_DASHARRAY, style[STROKE_DASHARRAY]);
    }
    for (var i in svgAttributeMap) {
        if (style[i]) {
            node.setAttribute(svgAttributeMap[i], style[i]);
        }
    }
}
function _appendAtIndex(svg, path, idx) {
    if (svg.childNodes.length > idx) {
        svg.insertBefore(path, svg.childNodes[idx]);
    }
    else {
        svg.appendChild(path);
    }
}
function compoundEvent(stem, event, subevent) {
    var a = [stem, event];
    if (subevent) {
        a.push(subevent);
    }
    return a.join(":");
}
var ATTRIBUTE_CONTAINER = "data-jtk-container";
var ATTRIBUTE_GROUP_CONTENT = "data-jtk-group-content";
var ATTRIBUTE_JTK_ENABLED = "data-jtk-enabled";
var ATTRIBUTE_JTK_SCOPE = "data-jtk-scope";
var ENDPOINT = "endpoint";
var ELEMENT = "element";
var CONNECTION = "connection";
var ELEMENT_DIV = "div";
var EVENT_CLICK = "click";
var EVENT_CONTEXTMENU = "contextmenu";
var EVENT_DBL_CLICK = "dblclick";
var EVENT_DBL_TAP = "dbltap";
var EVENT_FOCUS = "focus";
var EVENT_MOUSEDOWN = "mousedown";
var EVENT_MOUSEENTER = "mouseenter";
var EVENT_MOUSEEXIT = "mouseexit";
var EVENT_MOUSEMOVE = "mousemove";
var EVENT_MOUSEUP = "mouseup";
var EVENT_MOUSEOUT = "mouseout";
var EVENT_MOUSEOVER = "mouseover";
var EVENT_TAP = "tap";
var EVENT_TOUCHSTART = "touchstart";
var EVENT_TOUCHEND = "touchend";
var EVENT_TOUCHMOVE = "touchmove";
var EVENT_DRAG_MOVE = "drag:move";
var EVENT_DRAG_STOP = "drag:stop";
var EVENT_DRAG_START = "drag:start";
var EVENT_REVERT = "revert";
var EVENT_CONNECTION_ABORT = "connection:abort";
var EVENT_CONNECTION_DRAG = "connection:drag";
var EVENT_ELEMENT_CLICK = compoundEvent(ELEMENT, EVENT_CLICK);
var EVENT_ELEMENT_DBL_CLICK = compoundEvent(ELEMENT, EVENT_DBL_CLICK);
var EVENT_ELEMENT_DBL_TAP = compoundEvent(ELEMENT, EVENT_DBL_TAP);
var EVENT_ELEMENT_MOUSE_OUT = compoundEvent(ELEMENT, EVENT_MOUSEOUT);
var EVENT_ELEMENT_MOUSE_OVER = compoundEvent(ELEMENT, EVENT_MOUSEOVER);
var EVENT_ELEMENT_MOUSE_MOVE = compoundEvent(ELEMENT, EVENT_MOUSEMOVE);
var EVENT_ELEMENT_MOUSE_UP = compoundEvent(ELEMENT, EVENT_MOUSEUP);
var EVENT_ELEMENT_MOUSE_DOWN = compoundEvent(ELEMENT, EVENT_MOUSEDOWN);
var EVENT_ELEMENT_CONTEXTMENU = compoundEvent(ELEMENT, EVENT_CONTEXTMENU);
var EVENT_ELEMENT_TAP = compoundEvent(ELEMENT, EVENT_TAP);
var EVENT_ENDPOINT_CLICK = compoundEvent(ENDPOINT, EVENT_CLICK);
var EVENT_ENDPOINT_DBL_CLICK = compoundEvent(ENDPOINT, EVENT_DBL_CLICK);
compoundEvent(ENDPOINT, EVENT_DBL_TAP);
var EVENT_ENDPOINT_MOUSEOUT = compoundEvent(ENDPOINT, EVENT_MOUSEOUT);
var EVENT_ENDPOINT_MOUSEOVER = compoundEvent(ENDPOINT, EVENT_MOUSEOVER);
var EVENT_ENDPOINT_MOUSEUP = compoundEvent(ENDPOINT, EVENT_MOUSEUP);
var EVENT_ENDPOINT_MOUSEDOWN = compoundEvent(ENDPOINT, EVENT_MOUSEDOWN);
compoundEvent(ENDPOINT, EVENT_TAP);
var EVENT_CONNECTION_CLICK = compoundEvent(CONNECTION, EVENT_CLICK);
var EVENT_CONNECTION_DBL_CLICK = compoundEvent(CONNECTION, EVENT_DBL_CLICK);
var EVENT_CONNECTION_DBL_TAP = compoundEvent(CONNECTION, EVENT_DBL_TAP);
var EVENT_CONNECTION_MOUSEOUT = compoundEvent(CONNECTION, EVENT_MOUSEOUT);
var EVENT_CONNECTION_MOUSEOVER = compoundEvent(CONNECTION, EVENT_MOUSEOVER);
var EVENT_CONNECTION_MOUSEUP = compoundEvent(CONNECTION, EVENT_MOUSEUP);
var EVENT_CONNECTION_MOUSEDOWN = compoundEvent(CONNECTION, EVENT_MOUSEDOWN);
var EVENT_CONNECTION_CONTEXTMENU = compoundEvent(CONNECTION, EVENT_CONTEXTMENU);
var EVENT_CONNECTION_TAP = compoundEvent(CONNECTION, EVENT_TAP);
var PROPERTY_POSITION = "position";
var SELECTOR_CONNECTOR = cls(CLASS_CONNECTOR);
var SELECTOR_ENDPOINT = cls(CLASS_ENDPOINT);
var SELECTOR_GROUP = att(ATTRIBUTE_GROUP);
var SELECTOR_GROUP_CONTAINER = att(ATTRIBUTE_GROUP_CONTENT);
var SELECTOR_OVERLAY = cls(CLASS_OVERLAY);
var _touchMap, _tapProfiles2;
function _touch(target, pageX, pageY, screenX, screenY, clientX, clientY) {
    return new Touch({
        target: target,
        identifier: uuid(),
        pageX: pageX,
        pageY: pageY,
        screenX: screenX,
        screenY: screenY,
        clientX: clientX || screenX,
        clientY: clientY || screenY
    });
}
function _touchList() {
    var list = [];
    list.push.apply(list, arguments);
    list.item = function (index) {
        return this[index];
    };
    return list;
}
function _touchAndList(target, pageX, pageY, screenX, screenY, clientX, clientY) {
    return _touchList(_touch(target, pageX, pageY, screenX, screenY, clientX, clientY));
}
function matchesSelector(el, selector, ctx) {
    ctx = ctx || el.parentNode;
    var possibles = ctx.querySelectorAll(selector);
    for (var i = 0; i < possibles.length; i++) {
        if (possibles[i] === el) {
            return true;
        }
    }
    return false;
}
function _t(e) {
    return e.srcElement || e.target;
}
function _pi(e, target, obj, doCompute) {
    if (!doCompute) {
        return {
            path: [target],
            end: 1
        };
    }
    else {
        var path = e.composedPath ? e.composedPath() : e.path;
        if (typeof path !== "undefined" && path.indexOf) {
            return {
                path: path,
                end: path.indexOf(obj)
            };
        }
        else {
            var out = {
                path: [],
                end: -1
            }, _one = function _one(el) {
                out.path.push(el);
                if (el === obj) {
                    out.end = out.path.length - 1;
                }
                else if (el.parentNode != null) {
                    _one(el.parentNode);
                }
            };
            _one(target);
            return out;
        }
    }
}
function _d(l, fn) {
    var i = 0, j;
    for (i = 0, j = l.length; i < j; i++) {
        if (l[i][0] === fn) {
            break;
        }
    }
    if (i < l.length) {
        l.splice(i, 1);
    }
}
var guid = 1;
function isTouchDevice() {
    return "ontouchstart" in document.documentElement || navigator.maxTouchPoints != null && navigator.maxTouchPoints > 0;
}
function isMouseDevice() {
    return "onmousedown" in document.documentElement;
}
var touchMap = (_touchMap = {}, _defineProperty$2(_touchMap, EVENT_MOUSEDOWN, EVENT_TOUCHSTART), _defineProperty$2(_touchMap, EVENT_MOUSEUP, EVENT_TOUCHEND), _defineProperty$2(_touchMap, EVENT_MOUSEMOVE, EVENT_TOUCHMOVE), _touchMap);
var PAGE = "page";
var SCREEN = "screen";
var CLIENT = "client";
function _genLoc(e, prefix) {
    if (e == null)
        return {
            x: 0,
            y: 0
        };
    var ts = touches(e), t = getTouch(ts, 0);
    return {
        x: t[prefix + "X"],
        y: t[prefix + "Y"]
    };
}
function pageLocation(e) {
    return _genLoc(e, PAGE);
}
function screenLocation(e) {
    return _genLoc(e, SCREEN);
}
function clientLocation(e) {
    return _genLoc(e, CLIENT);
}
function getTouch(touches, idx) {
    return touches.item ? touches.item(idx) : touches[idx];
}
function touches(e) {
    return e.touches && e.touches.length > 0 ? e.touches : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches : e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches : [e];
}
function touchCount(e) {
    return touches(e).length;
}
function _bind(obj, type, fn, originalFn, options) {
    _store(obj, type, fn);
    originalFn.__tauid = fn.__tauid;
    if (obj.addEventListener) {
        obj.addEventListener(type, fn, false, options);
    }
    else if (obj.attachEvent) {
        var key = type + fn.__tauid;
        obj["e" + key] = fn;
        obj[key] = function () {
            obj["e" + key] && obj["e" + key](window.event);
        };
        obj.attachEvent("on" + type, obj[key]);
    }
}
function _unbind(obj, type, fn) {
    var _this = this;
    if (fn == null)
        return;
    _each$1(obj, function (_el) {
        _unstore(_el, type, fn);
        if (fn.__tauid != null) {
            if (_el.removeEventListener) {
                _el.removeEventListener(type, fn, false);
                if (isTouchDevice() && touchMap[type])
                    _el.removeEventListener(touchMap[type], fn, false);
            }
            else if (_this.detachEvent) {
                var key = type + fn.__tauid;
                _el[key] && _el.detachEvent("on" + type, _el[key]);
                _el[key] = null;
                _el["e" + key] = null;
            }
        }
        if (fn.__taTouchProxy) {
            _unbind(obj, fn.__taTouchProxy[1], fn.__taTouchProxy[0]);
        }
    });
}
function _each$1(obj, fn) {
    if (obj == null)
        return;
    var entries = typeof obj === "string" ? document.querySelectorAll(obj) : obj.length != null ? obj : [obj];
    for (var i = 0; i < entries.length; i++) {
        fn(entries[i]);
    }
}
function _store(obj, event, fn) {
    var g = guid++;
    obj.__ta = obj.__ta || {};
    obj.__ta[event] = obj.__ta[event] || {};
    obj.__ta[event][g] = fn;
    fn.__tauid = g;
    return g;
}
function _unstore(obj, event, fn) {
    obj.__ta && obj.__ta[event] && delete obj.__ta[event][fn.__tauid];
    if (fn.__taExtra) {
        for (var i = 0; i < fn.__taExtra.length; i++) {
            _unbind(obj, fn.__taExtra[i][0], fn.__taExtra[i][1]);
        }
        fn.__taExtra.length = 0;
    }
    fn.__taUnstore && fn.__taUnstore();
}
var NOT_SELECTOR_REGEX = /:not\(([^)]+)\)/;
function _curryChildFilter(children, obj, fn, evt) {
    if (children == null) {
        return fn;
    }
    else {
        var c = children.split(","), pc = [], nc = [];
        forEach$1(c, function (sel) {
            var m = sel.match(NOT_SELECTOR_REGEX);
            if (m != null) {
                nc.push(m[1]);
            }
            else {
                pc.push(sel);
            }
        });
        if (nc.length > 0 && pc.length === 0) {
            pc.push(WILDCARD);
        }
        var _fn = function _fn(e) {
            _fn.__tauid = fn.__tauid;
            var t = _t(e);
            var done = false;
            var target = t;
            var pathInfo = _pi(e, t, obj, children != null);
            if (pathInfo.end != -1) {
                for (var p = 0; !done && p < pathInfo.end; p++) {
                    target = pathInfo.path[p];
                    for (var i = 0; i < nc.length; i++) {
                        if (matchesSelector(target, nc[i], obj)) {
                            return;
                        }
                    }
                    for (var _i = 0; !done && _i < pc.length; _i++) {
                        if (matchesSelector(target, pc[_i], obj)) {
                            fn.apply(target, [e, target]);
                            done = true;
                            break;
                        }
                    }
                }
            }
        };
        registerExtraFunction(fn, evt, _fn);
        return _fn;
    }
}
function registerExtraFunction(fn, evt, newFn) {
    fn.__taExtra = fn.__taExtra || [];
    fn.__taExtra.push([evt, newFn]);
}
var DefaultHandler = function DefaultHandler(obj, evt, fn, children, options) {
    if (isTouchDevice() && touchMap[evt]) {
        var tfn = _curryChildFilter(children, obj, fn, touchMap[evt]);
        _bind(obj, touchMap[evt], tfn, fn, options);
    }
    if (evt === EVENT_FOCUS && obj.getAttribute(ATTRIBUTE_TABINDEX) == null) {
        obj.setAttribute(ATTRIBUTE_TABINDEX, "1");
    }
    _bind(obj, evt, _curryChildFilter(children, obj, fn, evt), fn, options);
};
var _tapProfiles = (_tapProfiles2 = {}, _defineProperty$2(_tapProfiles2, EVENT_TAP, {
    touches: 1,
    taps: 1
}), _defineProperty$2(_tapProfiles2, EVENT_DBL_TAP, {
    touches: 1,
    taps: 2
}), _defineProperty$2(_tapProfiles2, EVENT_CONTEXTMENU, {
    touches: 2,
    taps: 1
}), _tapProfiles2);
function meeHelper(type, evt, obj, target) {
    for (var i in obj.__tamee[type]) {
        if (obj.__tamee[type].hasOwnProperty(i)) {
            obj.__tamee[type][i].apply(target, [evt]);
        }
    }
}
var TapHandler = function () {
    function TapHandler() {
        _classCallCheck$2(this, TapHandler);
    }
    _createClass$2(TapHandler, null, [{
            key: "generate",
            value: function generate(clickThreshold, dblClickThreshold) {
                return function (obj, evt, fn, children) {
                    if (evt == EVENT_CONTEXTMENU && isMouseDevice())
                        DefaultHandler(obj, evt, fn, children);
                    else {
                        if (obj.__taTapHandler == null) {
                            var tt = obj.__taTapHandler = {
                                tap: [],
                                dbltap: [],
                                down: false,
                                taps: 0,
                                downSelectors: []
                            };
                            var down = function down(e) {
                                var target = _t(e), pathInfo = _pi(e, target, obj, children != null), finished = false;
                                for (var p = 0; p < pathInfo.end; p++) {
                                    if (finished)
                                        return;
                                    target = pathInfo.path[p];
                                    for (var i = 0; i < tt.downSelectors.length; i++) {
                                        if (tt.downSelectors[i] == null || matchesSelector(target, tt.downSelectors[i], obj)) {
                                            tt.down = true;
                                            setTimeout(clearSingle, clickThreshold);
                                            setTimeout(clearDouble, dblClickThreshold);
                                            finished = true;
                                            break;
                                        }
                                    }
                                }
                            }, up = function up(e) {
                                if (tt.down) {
                                    var target = _t(e), currentTarget, pathInfo;
                                    tt.taps++;
                                    var tc = touchCount(e);
                                    for (var eventId in _tapProfiles) {
                                        if (_tapProfiles.hasOwnProperty(eventId)) {
                                            var p = _tapProfiles[eventId];
                                            if (p.touches === tc && (p.taps === 1 || p.taps === tt.taps)) {
                                                for (var i = 0; i < tt[eventId].length; i++) {
                                                    pathInfo = _pi(e, target, obj, tt[eventId][i][1] != null);
                                                    for (var pLoop = 0; pLoop < pathInfo.end; pLoop++) {
                                                        currentTarget = pathInfo.path[pLoop];
                                                        if (tt[eventId][i][1] == null || matchesSelector(currentTarget, tt[eventId][i][1], obj)) {
                                                            tt[eventId][i][0].apply(currentTarget, [e, currentTarget]);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }, clearSingle = function clearSingle() {
                                tt.down = false;
                            }, clearDouble = function clearDouble() {
                                tt.taps = 0;
                            };
                            obj.__taTapHandler.downHandler = down;
                            obj.__taTapHandler.upHandler = up;
                            DefaultHandler(obj, EVENT_MOUSEDOWN, down);
                            DefaultHandler(obj, EVENT_MOUSEUP, up);
                        }
                        obj.__taTapHandler.downSelectors.push(children);
                        obj.__taTapHandler[evt].push([fn, children]);
                        fn.__taUnstore = function () {
                            if (obj.__taTapHandler != null) {
                                removeWithFunction(obj.__taTapHandler.downSelectors, function (ds) {
                                    return ds === children;
                                });
                                _d(obj.__taTapHandler[evt], fn);
                                if (obj.__taTapHandler.downSelectors.length === 0) {
                                    _unbind(obj, EVENT_MOUSEDOWN, obj.__taTapHandler.downHandler);
                                    _unbind(obj, EVENT_MOUSEUP, obj.__taTapHandler.upHandler);
                                    delete obj.__taTapHandler;
                                }
                            }
                        };
                    }
                };
            }
        }]);
    return TapHandler;
}();
var MouseEnterExitHandler = function () {
    function MouseEnterExitHandler() {
        _classCallCheck$2(this, MouseEnterExitHandler);
    }
    _createClass$2(MouseEnterExitHandler, null, [{
            key: "generate",
            value: function generate() {
                var activeElements = [];
                return function (obj, evt, fn, children) {
                    if (!obj.__tamee) {
                        obj.__tamee = {
                            over: false,
                            mouseenter: [],
                            mouseexit: []
                        };
                        var over = function over(e) {
                            var t = _t(e);
                            if (children == null && t == obj && !obj.__tamee.over || matchesSelector(t, children, obj) && (t.__tamee == null || !t.__tamee.over)) {
                                meeHelper(EVENT_MOUSEENTER, e, obj, t);
                                t.__tamee = t.__tamee || {};
                                t.__tamee.over = true;
                                activeElements.push(t);
                            }
                        }, out = function out(e) {
                            var t = _t(e);
                            for (var i = 0; i < activeElements.length; i++) {
                                if (t == activeElements[i] && !matchesSelector(e.relatedTarget || e.toElement, "*", t)) {
                                    t.__tamee.over = false;
                                    activeElements.splice(i, 1);
                                    meeHelper(EVENT_MOUSEEXIT, e, obj, t);
                                }
                            }
                        };
                        _bind(obj, EVENT_MOUSEOVER, _curryChildFilter(children, obj, over, EVENT_MOUSEOVER), over);
                        _bind(obj, EVENT_MOUSEOUT, _curryChildFilter(children, obj, out, EVENT_MOUSEOUT), out);
                    }
                    fn.__taUnstore = function () {
                        delete obj.__tamee[evt][fn.__tauid];
                    };
                    _store(obj, evt, fn);
                    obj.__tamee[evt][fn.__tauid] = fn;
                };
            }
        }]);
    return MouseEnterExitHandler;
}();
var EventManager = function () {
    function EventManager(params) {
        _classCallCheck$2(this, EventManager);
        _defineProperty$2(this, "clickThreshold", void 0);
        _defineProperty$2(this, "dblClickThreshold", void 0);
        _defineProperty$2(this, "tapHandler", void 0);
        _defineProperty$2(this, "mouseEnterExitHandler", void 0);
        params = params || {};
        this.clickThreshold = params.clickThreshold || 250;
        this.dblClickThreshold = params.dblClickThreshold || 450;
        this.mouseEnterExitHandler = MouseEnterExitHandler.generate();
        this.tapHandler = TapHandler.generate(this.clickThreshold, this.dblClickThreshold);
    }
    _createClass$2(EventManager, [{
            key: "_doBind",
            value: function _doBind(el, evt, fn, children, options) {
                if (fn == null)
                    return;
                var jel = el;
                if (evt === EVENT_TAP || evt === EVENT_DBL_TAP || evt === EVENT_CONTEXTMENU) {
                    this.tapHandler(jel, evt, fn, children, options);
                }
                else if (evt === EVENT_MOUSEENTER || evt == EVENT_MOUSEEXIT)
                    this.mouseEnterExitHandler(jel, evt, fn, children, options);
                else {
                    DefaultHandler(jel, evt, fn, children, options);
                }
            }
        }, {
            key: "on",
            value: function on(el, event, children, fn, options) {
                var _c = fn == null ? null : children, _f = fn == null ? children : fn;
                this._doBind(el, event, _f, _c, options);
                return this;
            }
        }, {
            key: "off",
            value: function off(el, event, fn) {
                _unbind(el, event, fn);
                return this;
            }
        }, {
            key: "trigger",
            value: function trigger(el, event, originalEvent, payload, detail) {
                var originalIsMouse = isMouseDevice() && (typeof MouseEvent === "undefined" || originalEvent == null || originalEvent.constructor === MouseEvent);
                var eventToBind = isTouchDevice() && !isMouseDevice() && touchMap[event] ? touchMap[event] : event, bindingAMouseEvent = !(isTouchDevice() && !isMouseDevice() && touchMap[event]);
                var pl = pageLocation(originalEvent), sl = screenLocation(originalEvent), cl = clientLocation(originalEvent);
                _each$1(el, function (_el) {
                    var evt;
                    originalEvent = originalEvent || {
                        screenX: sl.x,
                        screenY: sl.y,
                        clientX: cl.x,
                        clientY: cl.y
                    };
                    var _decorate = function _decorate(_evt) {
                        if (payload) {
                            _evt.payload = payload;
                        }
                    };
                    var eventGenerators = {
                        "TouchEvent": function TouchEvent(evt) {
                            var touchList = _touchAndList(_el, pl.x, pl.y, sl.x, sl.y, cl.x, cl.y), init = evt.initTouchEvent || evt.initEvent;
                            init(eventToBind, true, true, window, null, sl.x, sl.y, cl.x, cl.y, false, false, false, false, touchList, touchList, touchList, 1, 0);
                        },
                        "MouseEvents": function MouseEvents(evt) {
                            evt.initMouseEvent(eventToBind, true, true, window, detail == null ? 1 : detail, sl.x, sl.y, cl.x, cl.y, false, false, false, false, 1, _el);
                        }
                    };
                    var ite = !bindingAMouseEvent && !originalIsMouse && isTouchDevice() && touchMap[event], evtName = ite ? "TouchEvent" : "MouseEvents";
                    evt = document.createEvent(evtName);
                    eventGenerators[evtName](evt);
                    _decorate(evt);
                    _el.dispatchEvent(evt);
                });
                return this;
            }
        }]);
    return EventManager;
}();
function findDelegateElement(parentElement, childElement, selector) {
    if (matchesSelector$1(childElement, selector, parentElement)) {
        return childElement;
    }
    else {
        var currentParent = childElement.parentNode;
        while (currentParent != null && currentParent !== parentElement) {
            if (matchesSelector$1(currentParent, selector, parentElement)) {
                return currentParent;
            }
            else {
                currentParent = currentParent.parentNode;
            }
        }
    }
}
function _assignId(obj) {
    if (typeof obj === "function") {
        obj._katavorioId = uuid();
        return obj._katavorioId;
    }
    else {
        return obj;
    }
}
function isInsideParent(instance, _el, pos) {
    var p = _el.parentNode, s = instance.getSize(p), ss = instance.getSize(_el), leftEdge = pos.x, rightEdge = leftEdge + ss.w, topEdge = pos.y, bottomEdge = topEdge + ss.h;
    return rightEdge > 0 && leftEdge < s.w && bottomEdge > 0 && topEdge < s.h;
}
function findMatchingSelector(availableSelectors, parentElement, childElement) {
    var el = null;
    var draggableId = parentElement.getAttribute("katavorio-draggable"), prefix = draggableId != null ? "[katavorio-draggable='" + draggableId + "'] " : "";
    for (var i = 0; i < availableSelectors.length; i++) {
        el = findDelegateElement(parentElement, childElement, prefix + availableSelectors[i].selector);
        if (el != null) {
            if (availableSelectors[i].filter) {
                var matches = matchesSelector$1(childElement, availableSelectors[i].filter, el), exclude = availableSelectors[i].filterExclude === true;
                if (exclude && !matches || matches) {
                    return null;
                }
            }
            return [availableSelectors[i], el];
        }
    }
    return null;
}
var EVENT_START = "start";
var EVENT_BEFORE_START = "beforeStart";
var EVENT_DRAG = "drag";
var EVENT_DROP = "drop";
var EVENT_OVER = "over";
var EVENT_OUT = "out";
var EVENT_STOP = "stop";
var ATTRIBUTE_DRAGGABLE = "katavorio-draggable";
var CLASS_DRAGGABLE$1 = ATTRIBUTE_DRAGGABLE;
var DEFAULT_GRID_X = 10;
var DEFAULT_GRID_Y = 10;
var TRUE = function TRUE() {
    return true;
};
var FALSE = function FALSE() {
    return false;
};
var _classes = {
    delegatedDraggable: "katavorio-delegated-draggable",
    draggable: CLASS_DRAGGABLE$1,
    drag: "katavorio-drag",
    selected: "katavorio-drag-selected",
    noSelect: "katavorio-drag-no-select",
    ghostProxy: "katavorio-ghost-proxy",
    clonedDrag: "katavorio-clone-drag"
};
var PositioningStrategies;
(function (PositioningStrategies) {
    PositioningStrategies["absolutePosition"] = "absolutePosition";
    PositioningStrategies["transform"] = "transform";
    PositioningStrategies["xyAttributes"] = "xyAttributes";
})(PositioningStrategies || (PositioningStrategies = {}));
var positionerSetters = new Map();
positionerSetters.set(PositioningStrategies.absolutePosition, function (el, p) {
    el.style.left = "".concat(p.x, "px");
    el.style.top = "".concat(p.y, "px");
});
positionerSetters.set(PositioningStrategies.xyAttributes, function (el, p) {
    el.setAttribute("x", "".concat(p.x));
    el.setAttribute("y", "".concat(p.y));
});
var positionerGetters = new Map();
positionerGetters.set(PositioningStrategies.absolutePosition, function (el) {
    return {
        x: el.offsetLeft,
        y: el.offsetTop
    };
});
positionerGetters.set(PositioningStrategies.xyAttributes, function (el) {
    return {
        x: parseFloat(el.getAttribute("x")),
        y: parseFloat(el.getAttribute("y"))
    };
});
var sizeSetters = new Map();
sizeSetters.set(PositioningStrategies.absolutePosition, function (el, s) {
    el.style.width = "".concat(s.w, "px");
    el.style.height = "".concat(s.h, "px");
});
sizeSetters.set(PositioningStrategies.xyAttributes, function (el, s) {
    el.setAttribute("width", "".concat(s.w));
    el.setAttribute("height", "".concat(s.h));
});
var sizeGetters = new Map();
sizeGetters.set(PositioningStrategies.absolutePosition, function (el) {
    return {
        w: el.offsetWidth,
        h: el.offsetHeight
    };
});
sizeGetters.set(PositioningStrategies.xyAttributes, function (el) {
    return {
        w: parseFloat(el.getAttribute("width")),
        h: parseFloat(el.getAttribute("height"))
    };
});
var _events = [EVENT_STOP, EVENT_START, EVENT_DRAG, EVENT_DROP, EVENT_OVER, EVENT_OUT, EVENT_BEFORE_START];
var _devNull = function _devNull() { };
var _each = function _each(obj, fn) {
    if (obj == null)
        return;
    obj = !isString$1(obj) && obj.tagName == null && obj.length != null ? obj : [obj];
    for (var i = 0; i < obj.length; i++) {
        fn.apply(obj[i], [obj[i]]);
    }
};
var _inputFilter = function _inputFilter(e, el, collicat) {
    var t = e.srcElement || e.target;
    return !matchesSelector$1(t, collicat.getInputFilterSelector(), el);
};
var Base = function () {
    function Base(el, manager) {
        _classCallCheck$2(this, Base);
        this.el = el;
        this.manager = manager;
        _defineProperty$2(this, "_class", void 0);
        _defineProperty$2(this, "uuid", uuid());
        _defineProperty$2(this, "enabled", true);
        _defineProperty$2(this, "scopes", []);
        _defineProperty$2(this, "eventManager", void 0);
        this.eventManager = manager.eventManager;
    }
    _createClass$2(Base, [{
            key: "setEnabled",
            value: function setEnabled(e) {
                this.enabled = e;
            }
        }, {
            key: "isEnabled",
            value: function isEnabled() {
                return this.enabled;
            }
        }, {
            key: "toggleEnabled",
            value: function toggleEnabled() {
                this.enabled = !this.enabled;
            }
        }, {
            key: "addScope",
            value: function addScope(scopes) {
                var m = {};
                _each(this.scopes, function (s) {
                    m[s] = true;
                });
                _each(scopes ? scopes.split(/\s+/) : [], function (s) {
                    m[s] = true;
                });
                this.scopes.length = 0;
                for (var i in m) {
                    this.scopes.push(i);
                }
            }
        }, {
            key: "removeScope",
            value: function removeScope(scopes) {
                var m = {};
                _each(this.scopes, function (s) {
                    m[s] = true;
                });
                _each(scopes ? scopes.split(/\s+/) : [], function (s) {
                    delete m[s];
                });
                this.scopes.length = 0;
                for (var i in m) {
                    this.scopes.push(i);
                }
            }
        }, {
            key: "toggleScope",
            value: function toggleScope(scopes) {
                var m = {};
                _each(this.scopes, function (s) {
                    m[s] = true;
                });
                _each(scopes ? scopes.split(/\s+/) : [], function (s) {
                    if (m[s])
                        delete m[s];
                    else
                        m[s] = true;
                });
                this.scopes.length = 0;
                for (var i in m) {
                    this.scopes.push(i);
                }
            }
        }]);
    return Base;
}();
function getConstrainingRectangle(el) {
    return {
        w: el.parentNode.offsetWidth + el.parentNode.scrollLeft,
        h: el.parentNode.offsetHeight + el.parentNode.scrollTop
    };
}
var ContainmentType;
(function (ContainmentType) {
    ContainmentType["notNegative"] = "notNegative";
    ContainmentType["parent"] = "parent";
    ContainmentType["parentEnclosed"] = "parentEnclosed";
})(ContainmentType || (ContainmentType = {}));
var Drag = function (_Base) {
    _inherits$2(Drag, _Base);
    var _super = _createSuper$2(Drag);
    function Drag(el, params, manager) {
        var _this;
        _classCallCheck$2(this, Drag);
        _this = _super.call(this, el, manager);
        _defineProperty$2(_assertThisInitialized$2(_this), "_class", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "rightButtonCanDrag", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "consumeStartEvent", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "clone", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "scroll", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "trackScroll", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_downAt", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_posAtDown", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_pagePosAtDown", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_pageDelta", {
            x: 0,
            y: 0
        });
        _defineProperty$2(_assertThisInitialized$2(_this), "_moving", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_lastPosition", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_lastScrollValues", {
            x: 0,
            y: 0
        });
        _defineProperty$2(_assertThisInitialized$2(_this), "_initialScroll", {
            x: 0,
            y: 0
        });
        _defineProperty$2(_assertThisInitialized$2(_this), "_size", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_currentParentPosition", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_ghostParentPosition", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_dragEl", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_multipleDrop", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_ghostProxyOffsets", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_ghostDx", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_ghostDy", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_isConstrained", false);
        _defineProperty$2(_assertThisInitialized$2(_this), "_ghostProxyParent", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_useGhostProxy", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_ghostProxyFunction", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_activeSelectorParams", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_availableSelectors", []);
        _defineProperty$2(_assertThisInitialized$2(_this), "_canDrag", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_consumeFilteredEvents", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_parent", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_ignoreZoom", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_filters", {});
        _defineProperty$2(_assertThisInitialized$2(_this), "_constrainRect", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_elementToDrag", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "downListener", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "moveListener", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "upListener", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "scrollTracker", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "listeners", {
            "start": [],
            "drag": [],
            "stop": [],
            "over": [],
            "out": [],
            "beforeStart": [],
            "revert": []
        });
        _this._class = _this.manager.css.draggable;
        addClass(_this.el, _this._class);
        _this.downListener = _this._downListener.bind(_assertThisInitialized$2(_this));
        _this.upListener = _this._upListener.bind(_assertThisInitialized$2(_this));
        _this.moveListener = _this._moveListener.bind(_assertThisInitialized$2(_this));
        _this.rightButtonCanDrag = params.rightButtonCanDrag === true;
        _this.consumeStartEvent = params.consumeStartEvent !== false;
        _this._dragEl = _this.el;
        _this.clone = params.clone === true;
        _this.scroll = params.scroll === true;
        _this.trackScroll = params.trackScroll !== false;
        _this._multipleDrop = params.multipleDrop !== false;
        _this._canDrag = params.canDrag || TRUE;
        _this._consumeFilteredEvents = params.consumeFilteredEvents;
        _this._parent = params.parent;
        _this._ignoreZoom = params.ignoreZoom === true;
        _this._ghostProxyParent = params.ghostProxyParent;
        if (_this.trackScroll) {
            _this.scrollTracker = _this._trackScroll.bind(_assertThisInitialized$2(_this));
            document.addEventListener("scroll", _this.scrollTracker);
        }
        if (params.ghostProxy === true) {
            _this._useGhostProxy = TRUE;
        }
        else {
            if (params.ghostProxy && typeof params.ghostProxy === "function") {
                _this._useGhostProxy = params.ghostProxy;
            }
            else {
                _this._useGhostProxy = function (container, dragEl) {
                    if (_this._activeSelectorParams && _this._activeSelectorParams.useGhostProxy) {
                        return _this._activeSelectorParams.useGhostProxy(container, dragEl);
                    }
                    else {
                        return false;
                    }
                };
            }
        }
        if (params.makeGhostProxy) {
            _this._ghostProxyFunction = params.makeGhostProxy;
        }
        else {
            _this._ghostProxyFunction = function (el) {
                if (_this._activeSelectorParams && _this._activeSelectorParams.makeGhostProxy) {
                    return _this._activeSelectorParams.makeGhostProxy(el);
                }
                else {
                    return el.cloneNode(true);
                }
            };
        }
        if (params.selector) {
            var draggableId = _this.el.getAttribute(ATTRIBUTE_DRAGGABLE);
            if (draggableId == null) {
                draggableId = "" + new Date().getTime();
                _this.el.setAttribute("katavorio-draggable", draggableId);
            }
            _this._availableSelectors.push(params);
        }
        _this.eventManager.on(_this.el, EVENT_MOUSEDOWN, _this.downListener);
        return _this;
    }
    _createClass$2(Drag, [{
            key: "_trackScroll",
            value: function _trackScroll(e) {
                if (this._moving) {
                    var currentScrollValues = {
                        x: document.documentElement.scrollLeft,
                        y: document.documentElement.scrollTop
                    }, dsx = currentScrollValues.x - this._lastScrollValues.x, dsy = currentScrollValues.y - this._lastScrollValues.y, _pos = {
                        x: dsx + this._lastPosition.x,
                        y: dsy + this._lastPosition.y
                    }, dx = _pos.x - this._downAt.x, dy = _pos.y - this._downAt.y, _z = this._ignoreZoom ? 1 : this.manager.getZoom();
                    if (this._dragEl && this._dragEl.parentNode) {
                        dx += this._dragEl.parentNode.scrollLeft - this._initialScroll.x;
                        dy += this._dragEl.parentNode.scrollTop - this._initialScroll.y;
                    }
                    dx /= _z;
                    dy /= _z;
                    this.moveBy(dx, dy, e);
                    this._lastPosition = _pos;
                    this._lastScrollValues = currentScrollValues;
                }
            }
        }, {
            key: "on",
            value: function on(evt, fn) {
                if (this.listeners[evt]) {
                    this.listeners[evt].push(fn);
                }
            }
        }, {
            key: "off",
            value: function off(evt, fn) {
                if (this.listeners[evt]) {
                    var l = [];
                    for (var i = 0; i < this.listeners[evt].length; i++) {
                        if (this.listeners[evt][i] !== fn) {
                            l.push(this.listeners[evt][i]);
                        }
                    }
                    this.listeners[evt] = l;
                }
            }
        }, {
            key: "_upListener",
            value: function _upListener(e) {
                if (this._downAt) {
                    this._downAt = null;
                    this.eventManager.off(document, EVENT_MOUSEMOVE, this.moveListener);
                    this.eventManager.off(document, EVENT_MOUSEUP, this.upListener);
                    removeClass(document.body, _classes.noSelect);
                    this.unmark(e);
                    this.stop(e);
                    this._moving = false;
                    if (this.clone) {
                        this._dragEl && this._dragEl.parentNode && this._dragEl.parentNode.removeChild(this._dragEl);
                        this._dragEl = null;
                    }
                    else {
                        if (this._activeSelectorParams && this._activeSelectorParams.revertFunction) {
                            if (this._activeSelectorParams.revertFunction(this._dragEl, this.manager.getPosition(this._dragEl)) === true) {
                                this.manager.setPosition(this._dragEl, this._posAtDown);
                                this._dispatch(EVENT_REVERT, this._dragEl);
                            }
                        }
                    }
                }
            }
        }, {
            key: "_downListener",
            value: function _downListener(e) {
                if (e.defaultPrevented) {
                    return;
                }
                var isNotRightClick = this.rightButtonCanDrag || e.which !== 3 && e.button !== 2;
                if (isNotRightClick && this.isEnabled() && this._canDrag()) {
                    var _f = this._testFilter(e) && _inputFilter(e, this.el, this.manager);
                    if (_f) {
                        this._activeSelectorParams = null;
                        this._elementToDrag = null;
                        if (this._availableSelectors.length === 0) {
                            console.log("JSPLUMB: no available drag selectors");
                        }
                        var eventTarget = e.target || e.srcElement;
                        var match = findMatchingSelector(this._availableSelectors, this.el, eventTarget);
                        if (match != null) {
                            this._activeSelectorParams = match[0];
                            this._elementToDrag = match[1];
                        }
                        if (this._activeSelectorParams == null || this._elementToDrag == null) {
                            return;
                        }
                        var initial = this._activeSelectorParams.dragInit ? this._activeSelectorParams.dragInit(this._elementToDrag, e) : null;
                        if (initial != null) {
                            this._elementToDrag = initial;
                        }
                        if (this.clone) {
                            this._dragEl = this._elementToDrag.cloneNode(true);
                            addClass(this._dragEl, _classes.clonedDrag);
                            this._dragEl.setAttribute("id", null);
                            this._dragEl.style.position = "absolute";
                            if (this._parent != null) {
                                var _p2 = this.manager.getPosition(this.el);
                                this._dragEl.style.left = _p2.x + "px";
                                this._dragEl.style.top = _p2.y + "px";
                                this._parent.appendChild(this._dragEl);
                            }
                            else {
                                var b = offsetRelativeToRoot(this._elementToDrag);
                                this._dragEl.style.left = b.x + "px";
                                this._dragEl.style.top = b.y + "px";
                                document.body.appendChild(this._dragEl);
                            }
                        }
                        else {
                            this._dragEl = this._elementToDrag;
                        }
                        if (this.consumeStartEvent) {
                            consume(e);
                        }
                        this._downAt = pageLocation(e);
                        if (this._dragEl && this._dragEl.parentNode) {
                            this._initialScroll = {
                                x: this._dragEl.parentNode.scrollLeft,
                                y: this._dragEl.parentNode.scrollTop
                            };
                        }
                        this._posAtDown = this.manager.getPosition(this._dragEl);
                        this._pagePosAtDown = offsetRelativeToRoot(this._dragEl);
                        this._pageDelta = {
                            x: this._pagePosAtDown.x - this._posAtDown.x,
                            y: this._pagePosAtDown.y - this._posAtDown.y
                        };
                        this._size = this.manager.getSize(this._dragEl);
                        this.eventManager.on(document, EVENT_MOUSEMOVE, this.moveListener);
                        this.eventManager.on(document, EVENT_MOUSEUP, this.upListener);
                        addClass(document.body, _classes.noSelect);
                        this._dispatch(EVENT_BEFORE_START, {
                            el: this.el,
                            pos: this._posAtDown,
                            e: e,
                            drag: this,
                            size: this._size
                        });
                    }
                    else if (this._consumeFilteredEvents) {
                        consume(e);
                    }
                }
            }
        }, {
            key: "_moveListener",
            value: function _moveListener(e) {
                if (this._downAt) {
                    if (!this._moving) {
                        var dispatchResult = this._dispatch(EVENT_START, {
                            el: this.el,
                            pos: this._posAtDown,
                            e: e,
                            drag: this,
                            size: this._size
                        });
                        if (dispatchResult !== false) {
                            if (!this._downAt) {
                                return;
                            }
                            this.mark(dispatchResult);
                            this._moving = true;
                        }
                        else {
                            this.abort();
                        }
                    }
                    if (this._downAt) {
                        var _pos2 = pageLocation(e), dx = _pos2.x - this._downAt.x, dy = _pos2.y - this._downAt.y, _z2 = this._ignoreZoom ? 1 : this.manager.getZoom();
                        this._lastPosition = {
                            x: _pos2.x,
                            y: _pos2.y
                        };
                        this._lastScrollValues = {
                            x: document.documentElement.scrollLeft,
                            y: document.documentElement.scrollTop
                        };
                        if (this._dragEl && this._dragEl.parentNode) {
                            dx += this._dragEl.parentNode.scrollLeft - this._initialScroll.x;
                            dy += this._dragEl.parentNode.scrollTop - this._initialScroll.y;
                        }
                        dx /= _z2;
                        dy /= _z2;
                        this.moveBy(dx, dy, e);
                    }
                }
            }
        }, {
            key: "getDragDelta",
            value: function getDragDelta() {
                if (this._posAtDown != null && this._downAt != null) {
                    return {
                        x: this._downAt.x - this._posAtDown.x,
                        y: this._downAt.y - this._posAtDown.y
                    };
                }
                else {
                    return {
                        x: 0,
                        y: 0
                    };
                }
            }
        }, {
            key: "mark",
            value: function mark(payload) {
                this._posAtDown = this.manager.getPosition(this._dragEl);
                this._pagePosAtDown = offsetRelativeToRoot(this._dragEl);
                this._pageDelta = {
                    x: this._pagePosAtDown.x - this._posAtDown.x,
                    y: this._pagePosAtDown.y - this._posAtDown.y
                };
                this._size = this.manager.getSize(this._dragEl);
                addClass(this._dragEl, this.manager.css.drag);
                this._constrainRect = getConstrainingRectangle(this._dragEl);
                this._ghostDx = 0;
                this._ghostDy = 0;
            }
        }, {
            key: "unmark",
            value: function unmark(e) {
                if (this._isConstrained && this._useGhostProxy(this._elementToDrag, this._dragEl)) {
                    this._ghostProxyOffsets = {
                        x: this._dragEl.offsetLeft - this._ghostDx,
                        y: this._dragEl.offsetTop - this._ghostDy
                    };
                    this._dragEl.parentNode.removeChild(this._dragEl);
                    this._dragEl = this._elementToDrag;
                }
                else {
                    this._ghostProxyOffsets = null;
                }
                removeClass(this._dragEl, this.manager.css.drag);
                this._isConstrained = false;
            }
        }, {
            key: "moveBy",
            value: function moveBy(dx, dy, e) {
                var desiredLoc = this.toGrid({
                    x: this._posAtDown.x + dx,
                    y: this._posAtDown.y + dy
                }), cPos = this._doConstrain(desiredLoc, this._dragEl, this._constrainRect, this._size, e);
                if (cPos != null) {
                    if (this._useGhostProxy(this.el, this._dragEl)) {
                        if (desiredLoc.x !== cPos.x || desiredLoc.y !== cPos.y) {
                            if (!this._isConstrained) {
                                var gp = this._ghostProxyFunction(this._elementToDrag);
                                addClass(gp, _classes.ghostProxy);
                                if (this._ghostProxyParent) {
                                    this._ghostProxyParent.appendChild(gp);
                                    this._currentParentPosition = offsetRelativeToRoot(this._elementToDrag.parentNode);
                                    this._ghostParentPosition = offsetRelativeToRoot(this._ghostProxyParent);
                                    this._ghostDx = this._currentParentPosition.x - this._ghostParentPosition.x;
                                    this._ghostDy = this._currentParentPosition.y - this._ghostParentPosition.y;
                                }
                                else {
                                    this._elementToDrag.parentNode.appendChild(gp);
                                }
                                this._dragEl = gp;
                                this._isConstrained = true;
                            }
                            cPos = desiredLoc;
                        }
                        else {
                            if (this._isConstrained) {
                                this._dragEl.parentNode.removeChild(this._dragEl);
                                this._dragEl = this._elementToDrag;
                                this._isConstrained = false;
                                this._currentParentPosition = null;
                                this._ghostParentPosition = null;
                                this._ghostDx = 0;
                                this._ghostDy = 0;
                            }
                        }
                    }
                    this.manager.setPosition(this._dragEl, {
                        x: cPos.x + this._ghostDx,
                        y: cPos.y + this._ghostDy
                    });
                    this._dispatch(EVENT_DRAG, {
                        el: this.el,
                        pos: cPos,
                        e: e,
                        drag: this,
                        size: this._size,
                        originalPos: this._posAtDown
                    });
                }
            }
        }, {
            key: "abort",
            value: function abort() {
                if (this._downAt != null) {
                    this._upListener();
                }
            }
        }, {
            key: "getDragElement",
            value: function getDragElement(retrieveOriginalElement) {
                return retrieveOriginalElement ? this._elementToDrag || this.el : this._dragEl || this.el;
            }
        }, {
            key: "stop",
            value: function stop(e, force) {
                if (force || this._moving) {
                    var positions = [], dPos = this.manager.getPosition(this._dragEl);
                    positions.push([this._dragEl, dPos, this, this._size]);
                    this._dispatch(EVENT_STOP, {
                        el: this._dragEl,
                        pos: this._ghostProxyOffsets || dPos,
                        finalPos: dPos,
                        e: e,
                        drag: this,
                        selection: positions,
                        size: this._size,
                        originalPos: {
                            x: this._posAtDown.x,
                            y: this._posAtDown.y
                        }
                    });
                }
                else if (!this._moving) {
                    this._activeSelectorParams.dragAbort ? this._activeSelectorParams.dragAbort(this._elementToDrag) : null;
                }
            }
        }, {
            key: "_dispatch",
            value: function _dispatch(evt, value) {
                var result = null;
                if (this._activeSelectorParams && this._activeSelectorParams[evt]) {
                    result = this._activeSelectorParams[evt](value);
                }
                else if (this.listeners[evt]) {
                    for (var i = 0; i < this.listeners[evt].length; i++) {
                        try {
                            var v = this.listeners[evt][i](value);
                            if (v != null) {
                                result = v;
                            }
                        }
                        catch (e) { }
                    }
                }
                return result;
            }
        }, {
            key: "resolveGrid",
            value: function resolveGrid() {
                var out = {
                    grid: null,
                    thresholdX: DEFAULT_GRID_X / 2,
                    thresholdY: DEFAULT_GRID_Y / 2
                };
                if (this._activeSelectorParams != null && this._activeSelectorParams.grid != null) {
                    out.grid = this._activeSelectorParams.grid;
                    if (this._activeSelectorParams.snapThreshold != null) {
                        out.thresholdX = this._activeSelectorParams.snapThreshold;
                        out.thresholdY = this._activeSelectorParams.snapThreshold;
                    }
                }
                return out;
            }
        }, {
            key: "toGrid",
            value: function toGrid(pos) {
                var _this$resolveGrid = this.resolveGrid(), grid = _this$resolveGrid.grid, thresholdX = _this$resolveGrid.thresholdX, thresholdY = _this$resolveGrid.thresholdY;
                if (grid == null) {
                    return pos;
                }
                else {
                    var tx = grid ? grid.w / 2 : thresholdX, ty = grid ? grid.h / 2 : thresholdY;
                    return snapToGrid(pos, grid, tx, ty);
                }
            }
        }, {
            key: "setUseGhostProxy",
            value: function setUseGhostProxy(val) {
                this._useGhostProxy = val ? TRUE : FALSE;
            }
        }, {
            key: "_doConstrain",
            value: function _doConstrain(pos, dragEl, _constrainRect, _size, e) {
                if (this._activeSelectorParams != null && this._activeSelectorParams.constrainFunction && typeof this._activeSelectorParams.constrainFunction === "function") {
                    return this._activeSelectorParams.constrainFunction(pos, dragEl, _constrainRect, _size, e);
                }
                else {
                    return pos;
                }
            }
        }, {
            key: "_testFilter",
            value: function _testFilter(e) {
                for (var key in this._filters) {
                    var f = this._filters[key];
                    var rv = f[0](e);
                    if (f[1]) {
                        rv = !rv;
                    }
                    if (!rv) {
                        return false;
                    }
                }
                return true;
            }
        }, {
            key: "addFilter",
            value: function addFilter(f, _exclude) {
                var _this2 = this;
                if (f) {
                    var key = _assignId(f);
                    this._filters[key] = [function (e) {
                            var t = e.srcElement || e.target;
                            var m;
                            if (isString$1(f)) {
                                m = matchesSelector$1(t, f, _this2.el);
                            }
                            else if (typeof f === "function") {
                                m = f(e, _this2.el);
                            }
                            return m;
                        }, _exclude !== false];
                }
            }
        }, {
            key: "removeFilter",
            value: function removeFilter(f) {
                var key = typeof f === "function" ? f._katavorioId : f;
                delete this._filters[key];
            }
        }, {
            key: "clearAllFilters",
            value: function clearAllFilters() {
                this._filters = {};
            }
        }, {
            key: "addSelector",
            value: function addSelector(params, atStart) {
                if (params.selector) {
                    if (atStart) {
                        this._availableSelectors.unshift(params);
                    }
                    else {
                        this._availableSelectors.push(params);
                    }
                }
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.eventManager.off(this.el, EVENT_MOUSEDOWN, this.downListener);
                this.eventManager.off(document, EVENT_MOUSEMOVE, this.moveListener);
                this.eventManager.off(document, EVENT_MOUSEUP, this.upListener);
                this.downListener = null;
                this.upListener = null;
                this.moveListener = null;
                if (this.scrollTracker != null) {
                    document.removeEventListener("scroll", this.scrollTracker);
                }
            }
        }]);
    return Drag;
}(Base);
var DEFAULT_INPUTS = ["input", "textarea", "select", "button", "option"];
var DEFAULT_INPUT_FILTER_SELECTOR = DEFAULT_INPUTS.join(",");
var Collicat = function () {
    function Collicat(options) {
        _classCallCheck$2(this, Collicat);
        _defineProperty$2(this, "eventManager", void 0);
        _defineProperty$2(this, "zoom", 1);
        _defineProperty$2(this, "css", {});
        _defineProperty$2(this, "inputFilterSelector", void 0);
        _defineProperty$2(this, "positioningStrategy", void 0);
        _defineProperty$2(this, "_positionSetter", void 0);
        _defineProperty$2(this, "_positionGetter", void 0);
        _defineProperty$2(this, "_sizeSetter", void 0);
        _defineProperty$2(this, "_sizeGetter", void 0);
        options = options || {};
        this.inputFilterSelector = options.inputFilterSelector || DEFAULT_INPUT_FILTER_SELECTOR;
        this.eventManager = new EventManager();
        this.zoom = options.zoom || 1;
        this.positioningStrategy = options.positioningStrategy || PositioningStrategies.absolutePosition;
        this._positionGetter = positionerGetters.get(this.positioningStrategy);
        this._positionSetter = positionerSetters.get(this.positioningStrategy);
        this._sizeGetter = sizeGetters.get(this.positioningStrategy);
        this._sizeSetter = sizeSetters.get(this.positioningStrategy);
        var _c = options.css || {};
        extend(this.css, _c);
    }
    _createClass$2(Collicat, [{
            key: "getPosition",
            value: function getPosition(el) {
                return this._positionGetter(el);
            }
        }, {
            key: "setPosition",
            value: function setPosition(el, p) {
                this._positionSetter(el, p);
            }
        }, {
            key: "getSize",
            value: function getSize(el) {
                return this._sizeGetter(el);
            }
        }, {
            key: "getZoom",
            value: function getZoom() {
                return this.zoom;
            }
        }, {
            key: "setZoom",
            value: function setZoom(z) {
                this.zoom = z;
            }
        }, {
            key: "_prepareParams",
            value: function _prepareParams(p) {
                p = p || {};
                var _p = {
                    events: {}
                }, i;
                for (i in p) {
                    _p[i] = p[i];
                }
                for (i = 0; i < _events.length; i++) {
                    _p.events[_events[i]] = p[_events[i]] || _devNull;
                }
                return _p;
            }
        }, {
            key: "getInputFilterSelector",
            value: function getInputFilterSelector() {
                return this.inputFilterSelector;
            }
        }, {
            key: "setInputFilterSelector",
            value: function setInputFilterSelector(selector) {
                this.inputFilterSelector = selector;
                return this;
            }
        }, {
            key: "draggable",
            value: function draggable(el, params) {
                if (el._katavorioDrag == null) {
                    var _p3 = this._prepareParams(params);
                    var d = new Drag(el, _p3, this);
                    addClass(el, _classes.delegatedDraggable);
                    el._katavorioDrag = d;
                    return d;
                }
                else {
                    return el._katavorioDrag;
                }
            }
        }, {
            key: "destroyDraggable",
            value: function destroyDraggable(el) {
                if (el._katavorioDrag) {
                    el._katavorioDrag.destroy();
                    delete el._katavorioDrag;
                }
            }
        }]);
    return Collicat;
}();
var CLASS_DRAG_SELECTED = "jtk-drag-selected";
var DragSelection = function () {
    function DragSelection(instance) {
        _classCallCheck$2(this, DragSelection);
        this.instance = instance;
        _defineProperty$2(this, "_dragSelection", []);
        _defineProperty$2(this, "_dragSizes", new Map());
        _defineProperty$2(this, "_dragElements", new Map());
        _defineProperty$2(this, "_dragElementStartPositions", new Map());
        _defineProperty$2(this, "_dragElementPositions", new Map());
        _defineProperty$2(this, "__activeSet", void 0);
    }
    _createClass$2(DragSelection, [{
            key: "_activeSet",
            get: function get() {
                if (this.__activeSet == null) {
                    return this._dragSelection;
                }
                else {
                    return this.__activeSet;
                }
            }
        }, {
            key: "length",
            get: function get() {
                return this._dragSelection.length;
            }
        }, {
            key: "filterActiveSet",
            value: function filterActiveSet(fn) {
                var _this = this;
                this.__activeSet = [];
                forEach$1(this._dragSelection, function (p) {
                    if (fn(p)) {
                        _this.__activeSet.push(p);
                    }
                });
            }
        }, {
            key: "clear",
            value: function clear() {
                var _this2 = this;
                this.reset();
                forEach$1(this._dragSelection, function (p) {
                    return _this2.instance.removeClass(p.jel, CLASS_DRAG_SELECTED);
                });
                this._dragSelection.length = 0;
            }
        }, {
            key: "reset",
            value: function reset() {
                this._dragElementStartPositions.clear();
                this._dragElementPositions.clear();
                this._dragSizes.clear();
                this._dragElements.clear();
                this.__activeSet = null;
            }
        }, {
            key: "initialisePositions",
            value: function initialisePositions() {
                var _this3 = this;
                forEach$1(this._activeSet, function (p) {
                    var vp = _this3.instance.viewport.getPosition(p.id);
                    var off = {
                        x: parseInt("" + p.jel.offsetLeft, 10),
                        y: parseInt("" + p.jel.offsetTop, 10)
                    };
                    _this3._dragElementStartPositions.set(p.id, off);
                    _this3._dragElementPositions.set(p.id, off);
                    _this3._dragSizes.set(p.id, {
                        w: vp.w,
                        h: vp.h
                    });
                });
            }
        }, {
            key: "updatePositions",
            value: function updatePositions(currentPosition, originalPosition, callback) {
                var _this4 = this;
                var dx = currentPosition.x - originalPosition.x, dy = currentPosition.y - originalPosition.y;
                forEach$1(this._activeSet, function (p) {
                    var op = _this4._dragElementStartPositions.get(p.id);
                    if (op) {
                        var x = op.x + dx, y = op.y + dy;
                        var _s = _this4._dragSizes.get(p.id);
                        var _b = {
                            x: x,
                            y: y,
                            w: _s.w,
                            h: _s.h
                        };
                        if (p.jel._jsPlumbParentGroup && p.jel._jsPlumbParentGroup.constrain) {
                            var constrainRect = {
                                w: p.jel.parentNode.offsetWidth + p.jel.parentNode.scrollLeft,
                                h: p.jel.parentNode.offsetHeight + p.jel.parentNode.scrollTop
                            };
                            _b.x = Math.max(_b.x, 0);
                            _b.y = Math.max(_b.y, 0);
                            _b.x = Math.min(_b.x, constrainRect.w - _s.w);
                            _b.y = Math.min(_b.y, constrainRect.h - _s.h);
                        }
                        _this4._dragElementPositions.set(p.id, {
                            x: x,
                            y: y
                        });
                        p.jel.style.left = _b.x + "px";
                        p.jel.style.top = _b.y + "px";
                        callback(p.jel, p.id, _s, _b);
                    }
                });
            }
        }, {
            key: "each",
            value: function each(f) {
                var _this5 = this;
                forEach$1(this._activeSet, function (p) {
                    var s = _this5._dragSizes.get(p.id);
                    var o = _this5._dragElementPositions.get(p.id);
                    var orig = _this5._dragElementStartPositions.get(p.id);
                    f(p.jel, p.id, o, s, orig);
                });
            }
        }, {
            key: "add",
            value: function add(el, id) {
                var jel = el;
                id = id || this.instance.getId(jel);
                var idx = findWithFunction(this._dragSelection, function (p) {
                    return p.id === id;
                });
                if (idx === -1) {
                    this.instance.addClass(el, CLASS_DRAG_SELECTED);
                    this._dragSelection.push({
                        id: id,
                        jel: jel
                    });
                }
            }
        }, {
            key: "remove",
            value: function remove(el) {
                var _this6 = this;
                var jel = el;
                this._dragSelection = this._dragSelection.filter(function (p) {
                    var out = p.jel !== jel;
                    if (!out) {
                        _this6.instance.removeClass(p.jel, CLASS_DRAG_SELECTED);
                    }
                    return out;
                });
            }
        }, {
            key: "toggle",
            value: function toggle(el) {
                var jel = el;
                var idx = findWithFunction(this._dragSelection, function (p) {
                    return p.jel === jel;
                });
                if (idx !== -1) {
                    this.remove(jel);
                }
                else {
                    this.add(el);
                }
            }
        }]);
    return DragSelection;
}();
var CLASS_DELEGATED_DRAGGABLE = "jtk-delegated-draggable";
var CLASS_DRAGGABLE = "jtk-draggable";
var CLASS_DRAG_CONTAINER = "jtk-drag";
var CLASS_GHOST_PROXY = "jtk-ghost-proxy";
var CLASS_DRAG_ACTIVE = "jtk-drag-active";
var CLASS_DRAGGED = "jtk-dragged";
var CLASS_DRAG_HOVER = "jtk-drag-hover";
var DragManager = function () {
    function DragManager(instance, dragSelection, options) {
        var _this = this;
        _classCallCheck$2(this, DragManager);
        this.instance = instance;
        this.dragSelection = dragSelection;
        _defineProperty$2(this, "collicat", void 0);
        _defineProperty$2(this, "drag", void 0);
        _defineProperty$2(this, "_draggables", {});
        _defineProperty$2(this, "_dlist", []);
        _defineProperty$2(this, "_elementsWithEndpoints", {});
        _defineProperty$2(this, "_draggablesForElements", {});
        _defineProperty$2(this, "handlers", []);
        _defineProperty$2(this, "_trackScroll", void 0);
        _defineProperty$2(this, "_filtersToAdd", []);
        this.collicat = new Collicat({
            zoom: this.instance.currentZoom,
            css: {
                noSelect: this.instance.dragSelectClass,
                delegatedDraggable: CLASS_DELEGATED_DRAGGABLE,
                draggable: CLASS_DRAGGABLE,
                drag: CLASS_DRAG_CONTAINER,
                selected: CLASS_DRAG_SELECTED,
                active: CLASS_DRAG_ACTIVE,
                hover: CLASS_DRAG_HOVER,
                ghostProxy: CLASS_GHOST_PROXY
            }
        });
        this.instance.bind(EVENT_ZOOM, function (z) {
            _this.collicat.setZoom(z);
        });
        options = options || {};
        this._trackScroll = options.trackScroll !== false;
    }
    _createClass$2(DragManager, [{
            key: "addHandler",
            value: function addHandler(handler, dragOptions) {
                var _this2 = this;
                var o = extend({
                    selector: handler.selector
                }, dragOptions || {});
                o.start = wrap$1(o.start, function (p) {
                    return handler.onStart(p);
                }, false);
                o.drag = wrap$1(o.drag, function (p) {
                    return handler.onDrag(p);
                });
                o.stop = wrap$1(o.stop, function (p) {
                    return handler.onStop(p);
                });
                var handlerBeforeStart = (handler.onBeforeStart || function (p) { }).bind(handler);
                o.beforeStart = wrap$1(o.beforeStart, function (p) {
                    return handlerBeforeStart(p);
                });
                o.dragInit = function (el, e) {
                    return handler.onDragInit(el, e);
                };
                o.dragAbort = function (el) {
                    return handler.onDragAbort(el);
                };
                if (handler.useGhostProxy) {
                    o.useGhostProxy = handler.useGhostProxy;
                    o.makeGhostProxy = handler.makeGhostProxy;
                }
                if (o.constrainFunction == null && o.containment != null) {
                    switch (o.containment) {
                        case ContainmentType.notNegative:
                            {
                                o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {
                                    return {
                                        x: Math.max(0, Math.min(pos.x)),
                                        y: Math.max(0, Math.min(pos.y))
                                    };
                                };
                                break;
                            }
                        case ContainmentType.parent:
                            {
                                var padding = o.containmentPadding || 5;
                                o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {
                                    var x = pos.x < 0 ? 0 : pos.x > _constrainRect.w - padding ? _constrainRect.w - padding : pos.x;
                                    var y = pos.y < 0 ? 0 : pos.y > _constrainRect.h - padding ? _constrainRect.h - padding : pos.y;
                                    return {
                                        x: x,
                                        y: y
                                    };
                                };
                                break;
                            }
                        case ContainmentType.parentEnclosed:
                            {
                                o.constrainFunction = function (pos, dragEl, _constrainRect, _size) {
                                    var x = pos.x < 0 ? 0 : pos.x + _size.w > _constrainRect.w ? _constrainRect.w - _size.w : pos.x;
                                    var y = pos.y < 0 ? 0 : pos.y + _size.h > _constrainRect.h ? _constrainRect.h - _size.h : pos.y;
                                    return {
                                        x: x,
                                        y: y
                                    };
                                };
                                break;
                            }
                    }
                }
                if (this.drag == null) {
                    o.trackScroll = this._trackScroll;
                    this.drag = this.collicat.draggable(this.instance.getContainer(), o);
                    forEach$1(this._filtersToAdd, function (filterToAdd) {
                        return _this2.drag.addFilter(filterToAdd[0], filterToAdd[1]);
                    });
                    this.drag.on(EVENT_REVERT, function (el) {
                        _this2.instance.revalidate(el);
                    });
                }
                else {
                    this.drag.addSelector(o);
                }
                this.handlers.push({
                    handler: handler,
                    options: o
                });
                handler.init(this.drag);
            }
        }, {
            key: "addSelector",
            value: function addSelector(params, atStart) {
                this.drag && this.drag.addSelector(params, atStart);
            }
        }, {
            key: "addFilter",
            value: function addFilter(filter, exclude) {
                if (this.drag == null) {
                    this._filtersToAdd.push([filter, exclude === true]);
                }
                else {
                    this.drag.addFilter(filter, exclude);
                }
            }
        }, {
            key: "removeFilter",
            value: function removeFilter(filter) {
                if (this.drag != null) {
                    this.drag.removeFilter(filter);
                }
            }
        }, {
            key: "setFilters",
            value: function setFilters(filters) {
                var _this3 = this;
                forEach$1(filters, function (f) {
                    _this3.drag.addFilter(f[0], f[1]);
                });
            }
        }, {
            key: "reset",
            value: function reset() {
                var out = [];
                forEach$1(this.handlers, function (p) {
                    p.handler.reset();
                });
                this.handlers.length = 0;
                if (this.drag != null) {
                    var currentFilters = this.drag._filters;
                    for (var f in currentFilters) {
                        out.push([f, currentFilters[f][1]]);
                    }
                    this.collicat.destroyDraggable(this.instance.getContainer());
                }
                delete this.drag;
                return out;
            }
        }, {
            key: "setOption",
            value: function setOption(handler, options) {
                var handlerAndOptions = getWithFunction(this.handlers, function (p) {
                    return p.handler === handler;
                });
                if (handlerAndOptions != null) {
                    extend(handlerAndOptions.options, options || {});
                }
            }
        }]);
    return DragManager;
}();
function decodeDragGroupSpec(instance, spec) {
    if (isString$1(spec)) {
        return {
            id: spec,
            active: true
        };
    }
    else {
        return {
            id: spec.id,
            active: spec.active
        };
    }
}
function isActiveDragGroupMember(dragGroup, el) {
    var details = getFromSetWithFunction(dragGroup.members, function (m) {
        return m.el === el;
    });
    if (details !== null) {
        return details.active === true;
    }
    else {
        return false;
    }
}
function getAncestors(el) {
    var ancestors = [];
    var p = el._jsPlumbParentGroup;
    while (p != null) {
        ancestors.push(p.el);
        p = p.group;
    }
    return ancestors;
}
var ElementDragHandler = function () {
    function ElementDragHandler(instance, _dragSelection) {
        _classCallCheck$2(this, ElementDragHandler);
        this.instance = instance;
        this._dragSelection = _dragSelection;
        _defineProperty$2(this, "selector", "> " + SELECTOR_MANAGED_ELEMENT + ":not(" + cls(CLASS_OVERLAY) + ")");
        _defineProperty$2(this, "_dragOffset", null);
        _defineProperty$2(this, "_groupLocations", []);
        _defineProperty$2(this, "_intersectingGroups", []);
        _defineProperty$2(this, "_currentDragParentGroup", null);
        _defineProperty$2(this, "_dragGroupByElementIdMap", {});
        _defineProperty$2(this, "_dragGroupMap", {});
        _defineProperty$2(this, "_currentDragGroup", null);
        _defineProperty$2(this, "_currentDragGroupOffsets", new Map());
        _defineProperty$2(this, "_currentDragGroupSizes", new Map());
        _defineProperty$2(this, "_currentDragGroupOriginalPositions", new Map());
        _defineProperty$2(this, "_dragPayload", null);
        _defineProperty$2(this, "drag", void 0);
        _defineProperty$2(this, "originalPosition", void 0);
    }
    _createClass$2(ElementDragHandler, [{
            key: "onDragInit",
            value: function onDragInit(el) {
                return null;
            }
        }, {
            key: "onDragAbort",
            value: function onDragAbort(el) {
                return null;
            }
        }, {
            key: "getDropGroup",
            value: function getDropGroup() {
                var dropGroup = null;
                if (this._intersectingGroups.length > 0) {
                    var targetGroup = this._intersectingGroups[0].groupLoc.group;
                    var intersectingElement = this._intersectingGroups[0].intersectingElement;
                    var currentGroup = intersectingElement._jsPlumbParentGroup;
                    if (currentGroup !== targetGroup) {
                        if (currentGroup == null || !currentGroup.overrideDrop(intersectingElement, targetGroup)) {
                            dropGroup = this._intersectingGroups[0];
                        }
                    }
                }
                return dropGroup;
            }
        }, {
            key: "onStop",
            value: function onStop(params) {
                var _this$_currentDragGro, _this = this;
                var jel = params.drag.getDragElement();
                var dropGroup = this.getDropGroup();
                var elementsToProcess = [];
                elementsToProcess.push({
                    el: jel,
                    id: this.instance.getId(jel),
                    pos: params.finalPos,
                    originalGroup: jel._jsPlumbParentGroup,
                    redrawResult: null,
                    originalPos: params.originalPos,
                    reverted: false,
                    dropGroup: dropGroup != null ? dropGroup.groupLoc.group : null
                });
                function addElementToProcess(el, id, currentPos, s, originalPosition) {
                    var x = currentPos.x, y = currentPos.y;
                    if (el._jsPlumbParentGroup && el._jsPlumbParentGroup.constrain) {
                        var constrainRect = {
                            w: el.parentNode.offsetWidth + el.parentNode.scrollLeft,
                            h: el.parentNode.offsetHeight + el.parentNode.scrollTop
                        };
                        x = Math.max(x, 0);
                        y = Math.max(y, 0);
                        x = Math.min(x, constrainRect.w - s.w);
                        y = Math.min(y, constrainRect.h - s.h);
                        currentPos.x = x;
                        currentPos.y = y;
                    }
                    elementsToProcess.push({
                        el: el,
                        id: id,
                        pos: currentPos,
                        originalPos: originalPosition,
                        originalGroup: el._jsPlumbParentGroup,
                        redrawResult: null,
                        reverted: false,
                        dropGroup: dropGroup === null || dropGroup === void 0 ? void 0 : dropGroup.groupLoc.group
                    });
                }
                this._dragSelection.each(function (el, id, o, s, originalPosition) {
                    if (el !== params.el) {
                        addElementToProcess(el, id, {
                            x: o.x,
                            y: o.y
                        }, s, originalPosition);
                    }
                });
                (_this$_currentDragGro = this._currentDragGroup) === null || _this$_currentDragGro === void 0 ? void 0 : _this$_currentDragGro.members.forEach(function (d) {
                    if (d.el !== params.el) {
                        var offset = _this._currentDragGroupOffsets.get(d.elId);
                        var s = _this._currentDragGroupSizes.get(d.elId);
                        var pp = {
                            x: params.finalPos.x + offset[0].x,
                            y: params.finalPos.y + offset[0].y
                        };
                        addElementToProcess(d.el, d.elId, pp, s, _this._currentDragGroupOriginalPositions.get(d.elId));
                    }
                });
                forEach$1(elementsToProcess, function (p) {
                    var wasInGroup = p.originalGroup != null, isInOriginalGroup = wasInGroup && isInsideParent(_this.instance, p.el, p.pos), parentOffset = {
                        x: 0,
                        y: 0
                    };
                    if (wasInGroup && !isInOriginalGroup) {
                        if (dropGroup == null) {
                            var orphanedPosition = _this._pruneOrOrphan(p, true, true);
                            if (orphanedPosition.pos != null) {
                                p.pos = orphanedPosition.pos.pos;
                            }
                            else {
                                if (!orphanedPosition.pruned && p.originalGroup.revert) {
                                    p.pos = p.originalPos;
                                    p.reverted = true;
                                }
                            }
                        }
                    }
                    else if (wasInGroup && isInOriginalGroup) {
                        parentOffset = _this._computeOffsetByParentGroup(p.originalGroup);
                    }
                    if (dropGroup != null && !isInOriginalGroup) {
                        _this.instance.groupManager.addToGroup(dropGroup.groupLoc.group, false, p.el);
                    }
                    else {
                        p.dropGroup = null;
                    }
                    if (p.reverted) {
                        _this.instance.setPosition(p.el, p.pos);
                    }
                    p.redrawResult = _this.instance.setElementPosition(p.el, p.pos.x + parentOffset.x, p.pos.y + parentOffset.y);
                    _this.instance.removeClass(p.el, CLASS_DRAGGED);
                    _this.instance.select({
                        source: p.el
                    }).removeClass(_this.instance.elementDraggingClass + " " + _this.instance.sourceElementDraggingClass, true);
                    _this.instance.select({
                        target: p.el
                    }).removeClass(_this.instance.elementDraggingClass + " " + _this.instance.targetElementDraggingClass, true);
                });
                if (elementsToProcess[0].originalGroup != null) {
                    var currentGroup = jel._jsPlumbParentGroup;
                    if (currentGroup !== elementsToProcess[0].originalGroup) {
                        var originalElement = params.drag.getDragElement(true);
                        if (elementsToProcess[0].originalGroup.ghost) {
                            var o1 = this.instance.getPosition(this.instance.getGroupContentArea(currentGroup));
                            var o2 = this.instance.getPosition(this.instance.getGroupContentArea(elementsToProcess[0].originalGroup));
                            var o = {
                                x: o2.x + params.pos.x - o1.x,
                                y: o2.y + params.pos.y - o1.y
                            };
                            originalElement.style.left = o.x + "px";
                            originalElement.style.top = o.y + "px";
                            this.instance.revalidate(originalElement);
                        }
                    }
                }
                this.instance.fire(EVENT_DRAG_STOP, {
                    elements: elementsToProcess,
                    e: params.e,
                    el: jel,
                    payload: this._dragPayload
                });
                this._cleanup();
            }
        }, {
            key: "_cleanup",
            value: function _cleanup() {
                var _this2 = this;
                forEach$1(this._groupLocations, function (groupLoc) {
                    _this2.instance.removeClass(groupLoc.el, CLASS_DRAG_ACTIVE);
                    _this2.instance.removeClass(groupLoc.el, CLASS_DRAG_HOVER);
                });
                this._currentDragParentGroup = null;
                this._groupLocations.length = 0;
                this.instance.hoverSuspended = false;
                this._dragOffset = null;
                this._dragSelection.reset();
                this._dragPayload = null;
                this._currentDragGroupOffsets.clear();
                this._currentDragGroupSizes.clear();
                this._currentDragGroupOriginalPositions.clear();
                this._currentDragGroup = null;
            }
        }, {
            key: "reset",
            value: function reset() { }
        }, {
            key: "init",
            value: function init(drag) {
                this.drag = drag;
            }
        }, {
            key: "onDrag",
            value: function onDrag(params) {
                var _this3 = this;
                var el = params.drag.getDragElement();
                var id = this.instance.getId(el);
                var finalPos = params.pos;
                var elSize = this.instance.viewport.getPosition(id);
                var ui = {
                    x: finalPos.x,
                    y: finalPos.y
                };
                this._intersectingGroups.length = 0;
                if (this._dragOffset != null) {
                    ui.x += this._dragOffset.x;
                    ui.y += this._dragOffset.y;
                }
                var _one = function _one(el, bounds, findIntersectingGroups) {
                    if (findIntersectingGroups) {
                        var ancestorsOfIntersectingGroups = new Set();
                        forEach$1(_this3._groupLocations, function (groupLoc) {
                            if (!ancestorsOfIntersectingGroups.has(groupLoc.group.id) && intersects(bounds, groupLoc.r)) {
                                if (groupLoc.group !== _this3._currentDragParentGroup) {
                                    _this3.instance.addClass(groupLoc.el, CLASS_DRAG_HOVER);
                                }
                                _this3._intersectingGroups.push({
                                    groupLoc: groupLoc,
                                    intersectingElement: params.drag.getDragElement(true),
                                    d: 0
                                });
                                forEach$1(_this3.instance.groupManager.getAncestors(groupLoc.group), function (g) {
                                    return ancestorsOfIntersectingGroups.add(g.id);
                                });
                            }
                            else {
                                _this3.instance.removeClass(groupLoc.el, CLASS_DRAG_HOVER);
                            }
                        });
                    }
                    _this3.instance.setElementPosition(el, bounds.x, bounds.y);
                    _this3.instance.fire(EVENT_DRAG_MOVE, {
                        el: el,
                        e: params.e,
                        pos: {
                            x: bounds.x,
                            y: bounds.y
                        },
                        originalPosition: _this3.originalPosition,
                        payload: _this3._dragPayload
                    });
                };
                var elBounds = {
                    x: ui.x,
                    y: ui.y,
                    w: elSize.w,
                    h: elSize.h
                };
                _one(el, elBounds, true);
                this._dragSelection.updatePositions(finalPos, this.originalPosition, function (el, id, s, b) {
                    _one(el, b, false);
                });
                this._currentDragGroupOffsets.forEach(function (v, k) {
                    var s = _this3._currentDragGroupSizes.get(k);
                    var _b = {
                        x: elBounds.x + v[0].x,
                        y: elBounds.y + v[0].y,
                        w: s.w,
                        h: s.h
                    };
                    v[1].style.left = _b.x + "px";
                    v[1].style.top = _b.y + "px";
                    _one(v[1], _b, false);
                });
            }
        }, {
            key: "_computeOffsetByParentGroup",
            value: function _computeOffsetByParentGroup(group) {
                var parentGroupOffset = this.instance.getPosition(group.el);
                var contentArea = group.contentArea;
                if (contentArea !== group.el) {
                    var caOffset = this.instance.getPosition(contentArea);
                    parentGroupOffset.x += caOffset.x;
                    parentGroupOffset.y += caOffset.y;
                }
                if (group.el._jsPlumbParentGroup) {
                    var ancestorOffset = this._computeOffsetByParentGroup(group.el._jsPlumbParentGroup);
                    parentGroupOffset.x += ancestorOffset.x;
                    parentGroupOffset.y += ancestorOffset.y;
                }
                return parentGroupOffset;
            }
        }, {
            key: "onStart",
            value: function onStart(params) {
                var _this4 = this;
                var el = params.drag.getDragElement();
                var elOffset = this.instance.getPosition(el);
                this.originalPosition = {
                    x: params.pos.x,
                    y: params.pos.y
                };
                if (el._jsPlumbParentGroup) {
                    this._dragOffset = this._computeOffsetByParentGroup(el._jsPlumbParentGroup);
                    this._currentDragParentGroup = el._jsPlumbParentGroup;
                }
                var cont = true;
                var nd = el.getAttribute(ATTRIBUTE_NOT_DRAGGABLE);
                if (this.instance.elementsDraggable === false || nd != null && nd !== FALSE$1) {
                    cont = false;
                }
                if (cont) {
                    this._groupLocations.length = 0;
                    this._intersectingGroups.length = 0;
                    this.instance.hoverSuspended = true;
                    var originalElement = params.drag.getDragElement(true), descendants = originalElement.querySelectorAll(SELECTOR_MANAGED_ELEMENT), ancestors = getAncestors(originalElement), a = [];
                    Array.prototype.push.apply(a, descendants);
                    Array.prototype.push.apply(a, ancestors);
                    this._dragSelection.filterActiveSet(function (p) {
                        return a.indexOf(p.jel) === -1;
                    });
                    this._dragSelection.initialisePositions();
                    var _one = function _one(_el, dragGroup, dragGroupMemberSpec) {
                        if (!_el._isJsPlumbGroup || _this4.instance.allowNestedGroups) {
                            var isNotInAGroup = !_el._jsPlumbParentGroup;
                            var membersAreDroppable = isNotInAGroup || _el._jsPlumbParentGroup.dropOverride !== true;
                            var isGhostOrNotConstrained = !isNotInAGroup && (_el._jsPlumbParentGroup.ghost || _el._jsPlumbParentGroup.constrain !== true);
                            if (isNotInAGroup || membersAreDroppable && isGhostOrNotConstrained) {
                                forEach$1(_this4.instance.groupManager.getGroups(), function (group) {
                                    var elementGroup = _el._jsPlumbGroup;
                                    if (group.droppable !== false && group.enabled !== false && _el._jsPlumbGroup !== group && !_this4.instance.groupManager.isDescendant(group, elementGroup)) {
                                        var groupEl = group.el, groupElId = _this4.instance.getId(groupEl), p = _this4.instance.viewport.getPosition(groupElId), boundingRect = {
                                            x: p.x,
                                            y: p.y,
                                            w: p.w,
                                            h: p.h
                                        };
                                        var groupLocation = {
                                            el: groupEl,
                                            r: boundingRect,
                                            group: group
                                        };
                                        _this4._groupLocations.push(groupLocation);
                                        if (group !== _this4._currentDragParentGroup) {
                                            _this4.instance.addClass(groupEl, CLASS_DRAG_ACTIVE);
                                        }
                                    }
                                });
                                _this4._groupLocations.sort(function (a, b) {
                                    if (_this4.instance.groupManager.isDescendant(a.group, b.group)) {
                                        return -1;
                                    }
                                    else if (_this4.instance.groupManager.isAncestor(b.group, a.group)) {
                                        return 1;
                                    }
                                    else {
                                        return 0;
                                    }
                                });
                            }
                        }
                        _this4.instance.select({
                            source: _el
                        }).addClass(_this4.instance.elementDraggingClass + " " + _this4.instance.sourceElementDraggingClass, true);
                        _this4.instance.select({
                            target: _el
                        }).addClass(_this4.instance.elementDraggingClass + " " + _this4.instance.targetElementDraggingClass, true);
                        return _this4.instance.fire(EVENT_DRAG_START, {
                            el: _el,
                            e: params.e,
                            originalPosition: _this4.originalPosition,
                            pos: _this4.originalPosition,
                            dragGroup: dragGroup,
                            dragGroupMemberSpec: dragGroupMemberSpec
                        });
                    };
                    var elId = this.instance.getId(el);
                    this._currentDragGroup = this._dragGroupByElementIdMap[elId];
                    if (this._currentDragGroup && !isActiveDragGroupMember(this._currentDragGroup, el)) {
                        this._currentDragGroup = null;
                    }
                    var dragStartReturn = _one(el);
                    if (dragStartReturn === false) {
                        this._cleanup();
                        return false;
                    }
                    else {
                        this._dragPayload = dragStartReturn;
                    }
                    if (this._currentDragGroup != null) {
                        this._currentDragGroupOffsets.clear();
                        this._currentDragGroupSizes.clear();
                        this._currentDragGroup.members.forEach(function (jel) {
                            var vp = _this4.instance.viewport.getPosition(jel.elId);
                            _this4._currentDragGroupOffsets.set(jel.elId, [{
                                    x: vp.x - elOffset.x,
                                    y: vp.y - elOffset.y
                                }, jel.el]);
                            _this4._currentDragGroupSizes.set(jel.elId, vp);
                            _this4._currentDragGroupOriginalPositions.set(jel.elId, {
                                x: vp.x,
                                y: vp.y
                            });
                            _one(jel.el, _this4._currentDragGroup, jel);
                        });
                    }
                }
                return cont;
            }
        }, {
            key: "addToDragGroup",
            value: function addToDragGroup(spec) {
                var _this5 = this;
                var details = decodeDragGroupSpec(this.instance, spec);
                var dragGroup = this._dragGroupMap[details.id];
                if (dragGroup == null) {
                    dragGroup = {
                        id: details.id,
                        members: new Set()
                    };
                    this._dragGroupMap[details.id] = dragGroup;
                }
                for (var _len = arguments.length, els = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    els[_key - 1] = arguments[_key];
                }
                this.removeFromDragGroup.apply(this, els);
                forEach$1(els, function (el) {
                    var elId = _this5.instance.getId(el);
                    dragGroup.members.add({
                        elId: elId,
                        el: el,
                        active: details.active
                    });
                    _this5._dragGroupByElementIdMap[elId] = dragGroup;
                });
            }
        }, {
            key: "removeFromDragGroup",
            value: function removeFromDragGroup() {
                var _this6 = this;
                for (var _len2 = arguments.length, els = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    els[_key2] = arguments[_key2];
                }
                forEach$1(els, function (el) {
                    var id = _this6.instance.getId(el);
                    var dragGroup = _this6._dragGroupByElementIdMap[id];
                    if (dragGroup != null) {
                        var s = new Set();
                        dragGroup.members.forEach(function (member) {
                            if (member.el !== el) {
                                s.add(member);
                            }
                        });
                        dragGroup.members = s;
                        delete _this6._dragGroupByElementIdMap[id];
                    }
                });
            }
        }, {
            key: "setDragGroupState",
            value: function setDragGroupState(active) {
                var _this7 = this;
                for (var _len3 = arguments.length, els = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                    els[_key3 - 1] = arguments[_key3];
                }
                var elementIds = els.map(function (el) {
                    return _this7.instance.getId(el);
                });
                forEach$1(elementIds, function (id) {
                    var dragGroup = _this7._dragGroupByElementIdMap[id];
                    if (dragGroup != null) {
                        var member = getFromSetWithFunction(dragGroup.members, function (m) {
                            return m.elId === id;
                        });
                        if (member != null) {
                            member.active = active;
                        }
                    }
                });
            }
        }, {
            key: "clearDragGroup",
            value: function clearDragGroup(name) {
                var _this8 = this;
                var dragGroup = this._dragGroupMap[name];
                if (dragGroup != null) {
                    dragGroup.members.forEach(function (member) {
                        delete _this8._dragGroupByElementIdMap[member.elId];
                    });
                    dragGroup.members.clear();
                }
            }
        }, {
            key: "_pruneOrOrphan",
            value: function _pruneOrOrphan(params, doNotTransferToAncestor, isDefinitelyNotInsideParent) {
                var jel = params.el;
                var orphanedPosition = {
                    pruned: false,
                    pos: null
                };
                if (isDefinitelyNotInsideParent || !isInsideParent(this.instance, jel, params.pos)) {
                    var group = jel._jsPlumbParentGroup;
                    if (group.prune) {
                        if (jel._isJsPlumbGroup) {
                            this.instance.removeGroup(jel._jsPlumbGroup);
                        }
                        else {
                            group.remove(params.el, true);
                        }
                        orphanedPosition.pruned = true;
                    }
                    else if (group.orphan) {
                        orphanedPosition.pos = this.instance.groupManager.orphan(params.el, doNotTransferToAncestor);
                        if (jel._isJsPlumbGroup) {
                            group.removeGroup(jel._jsPlumbGroup);
                        }
                        else {
                            group.remove(params.el);
                        }
                    }
                }
                return orphanedPosition;
            }
        }]);
    return ElementDragHandler;
}();
function _makeFloatingEndpoint(ep, endpoint, referenceCanvas, sourceElement, sourceElementId, instance) {
    var floatingAnchor = createFloatingAnchor(instance, sourceElement, sourceElementId);
    var p = {
        paintStyle: ep.getPaintStyle(),
        preparedAnchor: floatingAnchor,
        element: sourceElement,
        scope: ep.scope,
        cssClass: [CLASS_ENDPOINT_FLOATING, ep.cssClass].join(" ")
    };
    if (endpoint != null) {
        if (isAssignableFrom(endpoint, EndpointRepresentation)) {
            p.existingEndpoint = endpoint;
        }
        else {
            p.endpoint = endpoint;
        }
    }
    var actualEndpoint = instance._internal_newEndpoint(p);
    instance._paintEndpoint(actualEndpoint, {});
    return actualEndpoint;
}
function selectorFilter(evt, _el, selector, _instance, negate) {
    var t = evt.target || evt.srcElement, ok = false, sel = _instance.getSelector(_el, selector);
    for (var j = 0; j < sel.length; j++) {
        if (sel[j] === t) {
            ok = true;
            break;
        }
    }
    return negate ? !ok : ok;
}
var SELECTOR_DRAG_ACTIVE_OR_HOVER = cls(CLASS_DRAG_ACTIVE, CLASS_DRAG_HOVER);
var SOURCE_SELECTOR_UNIQUE_ENDPOINT_DATA = "sourceSelectorEndpoint";
var EndpointDragHandler = function () {
    function EndpointDragHandler(instance) {
        _classCallCheck$2(this, EndpointDragHandler);
        this.instance = instance;
        _defineProperty$2(this, "jpc", void 0);
        _defineProperty$2(this, "existingJpc", void 0);
        _defineProperty$2(this, "_originalAnchorSpec", void 0);
        _defineProperty$2(this, "ep", void 0);
        _defineProperty$2(this, "endpointRepresentation", void 0);
        _defineProperty$2(this, "canvasElement", void 0);
        _defineProperty$2(this, "_activeDefinition", void 0);
        _defineProperty$2(this, "placeholderInfo", {
            id: null,
            element: null
        });
        _defineProperty$2(this, "floatingIndex", void 0);
        _defineProperty$2(this, "floatingId", void 0);
        _defineProperty$2(this, "floatingElement", void 0);
        _defineProperty$2(this, "floatingEndpoint", void 0);
        _defineProperty$2(this, "floatingAnchor", void 0);
        _defineProperty$2(this, "_stopped", void 0);
        _defineProperty$2(this, "inPlaceCopy", void 0);
        _defineProperty$2(this, "endpointDropTargets", []);
        _defineProperty$2(this, "currentDropTarget", null);
        _defineProperty$2(this, "payload", void 0);
        _defineProperty$2(this, "floatingConnections", {});
        _defineProperty$2(this, "_forceReattach", void 0);
        _defineProperty$2(this, "_forceDetach", void 0);
        _defineProperty$2(this, "mousedownHandler", void 0);
        _defineProperty$2(this, "mouseupHandler", void 0);
        _defineProperty$2(this, "selector", cls(CLASS_ENDPOINT));
        var container = instance.getContainer();
        this.mousedownHandler = this._mousedownHandler.bind(this);
        this.mouseupHandler = this._mouseupHandler.bind(this);
        instance.on(container, EVENT_MOUSEDOWN, SELECTOR_MANAGED_ELEMENT, this.mousedownHandler);
        instance.on(container, EVENT_MOUSEUP, [SELECTOR_MANAGED_ELEMENT, cls(CLASS_ENDPOINT)].join(","), this.mouseupHandler);
    }
    _createClass$2(EndpointDragHandler, [{
            key: "_resolveDragParent",
            value: function _resolveDragParent(def, eventTarget) {
                var container = this.instance.getContainer();
                var parent = findParent(eventTarget, SELECTOR_MANAGED_ELEMENT, container, true);
                if (def.parentSelector != null) {
                    var child = findParent(eventTarget, def.parentSelector, container, true);
                    if (child != null) {
                        parent = findParent(child.parentNode, SELECTOR_MANAGED_ELEMENT, container, false);
                    }
                    return child || parent;
                }
                else {
                    return parent;
                }
            }
        }, {
            key: "_mousedownHandler",
            value: function _mousedownHandler(e) {
                var sourceEl;
                var sourceSelector;
                if (e.which === 3 || e.button === 2) {
                    return;
                }
                var eventTarget = e.target || e.srcElement;
                sourceSelector = this._getSourceDefinition(e);
                if (sourceSelector != null) {
                    sourceEl = this._resolveDragParent(sourceSelector.def.def, eventTarget);
                    if (sourceEl == null || sourceEl.getAttribute(ATTRIBUTE_JTK_ENABLED) === FALSE$1) {
                        return;
                    }
                }
                if (sourceSelector) {
                    var sourceElement = e.currentTarget, def;
                    if (eventTarget.getAttribute(ATTRIBUTE_JTK_ENABLED) !== FALSE$1) {
                        consume(e);
                        this._activeDefinition = sourceSelector;
                        def = sourceSelector.def.def;
                        if (def.canAcceptNewConnection != null && !def.canAcceptNewConnection(sourceEl, e)) {
                            return false;
                        }
                        var elxy = getPositionOnElement(e, sourceEl, this.instance.currentZoom);
                        var tempEndpointParams = {
                            element: sourceEl
                        };
                        extend(tempEndpointParams, def);
                        tempEndpointParams.isTemporarySource = true;
                        if (def.scope) {
                            tempEndpointParams.scope = def.scope;
                        }
                        else {
                            var scopeFromElement = eventTarget.getAttribute(ATTRIBUTE_JTK_SCOPE);
                            if (scopeFromElement != null) {
                                tempEndpointParams.scope = scopeFromElement;
                            }
                        }
                        var extractedParameters = def.parameterExtractor ? def.parameterExtractor(sourceEl, eventTarget, e) : {};
                        tempEndpointParams = merge$1(tempEndpointParams, extractedParameters);
                        if (tempEndpointParams.maxConnections != null && tempEndpointParams.maxConnections >= 0) {
                            var sourceCount = this.instance.select({
                                source: sourceEl
                            }).length;
                            if (sourceCount >= tempEndpointParams.maxConnections) {
                                consume(e);
                                if (def.onMaxConnections) {
                                    def.onMaxConnections({
                                        element: sourceEl,
                                        maxConnections: tempEndpointParams.maxConnections
                                    }, e);
                                }
                                e.stopImmediatePropagation && e.stopImmediatePropagation();
                                return false;
                            }
                        }
                        if (def.anchorPositionFinder) {
                            var maybeAnchorSpec = def.anchorPositionFinder(sourceEl, elxy, def, e);
                            if (maybeAnchorSpec != null) {
                                tempEndpointParams.anchor = maybeAnchorSpec;
                            }
                        }
                        this._originalAnchorSpec = tempEndpointParams.anchor || (this.instance.areDefaultAnchorsSet() ? this.instance.defaults.anchors[0] : this.instance.defaults.anchor);
                        var _originalAnchor = this.instance.router.prepareAnchor(this._originalAnchorSpec);
                        var anchorSpecToUse = [elxy.x, elxy.y, 0, 0];
                        if (_originalAnchor.locations.length > 0) {
                            anchorSpecToUse[2] = _originalAnchor.locations[0].ox;
                            anchorSpecToUse[3] = _originalAnchor.locations[0].oy;
                        }
                        else if (_originalAnchor.isContinuous) {
                            var dx = elxy.x < 0.5 ? elxy.x : 1 - elxy.x;
                            var dy = elxy.y < 0.5 ? elxy.y : 1 - elxy.y;
                            anchorSpecToUse[2] = dx < dy ? elxy.x < 0.5 ? -1 : 1 : 0;
                            anchorSpecToUse[3] = dy < dx ? elxy.y < 0.5 ? -1 : 1 : 0;
                        }
                        tempEndpointParams.anchor = anchorSpecToUse;
                        tempEndpointParams.deleteOnEmpty = true;
                        this.ep = this.instance._internal_newEndpoint(tempEndpointParams);
                        var payload = {};
                        if (def.extract) {
                            for (var att in def.extract) {
                                var v = eventTarget.getAttribute(att);
                                if (v) {
                                    payload[def.extract[att]] = v;
                                }
                            }
                            this.ep.mergeParameters(payload);
                        }
                        if (tempEndpointParams.uniqueEndpoint) {
                            var elementId = this.ep.elementId;
                            var existingUniqueEndpoint = this.instance.getManagedData(elementId, SOURCE_SELECTOR_UNIQUE_ENDPOINT_DATA, sourceSelector.id);
                            if (existingUniqueEndpoint == null) {
                                this.instance.setManagedData(elementId, SOURCE_SELECTOR_UNIQUE_ENDPOINT_DATA, sourceSelector.id, this.ep);
                                this.ep.deleteOnEmpty = false;
                            }
                            else {
                                this.ep.finalEndpoint = existingUniqueEndpoint;
                            }
                        }
                        sourceElement._jsPlumbOrphanedEndpoints = sourceElement._jsPlumbOrphanedEndpoints || [];
                        sourceElement._jsPlumbOrphanedEndpoints.push(this.ep);
                        this.instance.trigger(this.ep.endpoint.canvas, EVENT_MOUSEDOWN, e, payload);
                    }
                }
            }
        }, {
            key: "_mouseupHandler",
            value: function _mouseupHandler(e) {
                var el = e.currentTarget || e.srcElement;
                if (el._jsPlumbOrphanedEndpoints) {
                    each(el._jsPlumbOrphanedEndpoints, this.instance._maybePruneEndpoint.bind(this.instance));
                    el._jsPlumbOrphanedEndpoints.length = 0;
                }
                this._activeDefinition = null;
            }
        }, {
            key: "onDragInit",
            value: function onDragInit(el) {
                var ipco = getElementPosition(el, this.instance), ips = getElementSize(el, this.instance);
                this._makeDraggablePlaceholder(ipco, ips);
                this.placeholderInfo.element.jtk = el.jtk;
                return this.placeholderInfo.element;
            }
        }, {
            key: "onDragAbort",
            value: function onDragAbort(el) {
                this._cleanupDraggablePlaceholder();
            }
        }, {
            key: "_makeDraggablePlaceholder",
            value: function _makeDraggablePlaceholder(ipco, ips) {
                this.placeholderInfo = this.placeholderInfo || {};
                var n = createElement(ELEMENT_DIV, {
                    position: "absolute"
                });
                this.instance._appendElementToContainer(n);
                var id = this.instance.getId(n);
                this.instance.setPosition(n, ipco);
                n.style.width = ips.w + "px";
                n.style.height = ips.h + "px";
                this.instance.manage(n);
                this.placeholderInfo.id = id;
                this.placeholderInfo.element = n;
                return n;
            }
        }, {
            key: "_cleanupDraggablePlaceholder",
            value: function _cleanupDraggablePlaceholder() {
                if (this.placeholderInfo.element) {
                    this.instance.unmanage(this.placeholderInfo.element, true);
                    delete this.placeholderInfo.element;
                    delete this.placeholderInfo.id;
                }
            }
        }, {
            key: "reset",
            value: function reset() {
                var c = this.instance.getContainer();
                this.instance.off(c, EVENT_MOUSEUP, this.mouseupHandler);
                this.instance.off(c, EVENT_MOUSEDOWN, this.mousedownHandler);
            }
        }, {
            key: "init",
            value: function init(drag) { }
        }, {
            key: "startNewConnectionDrag",
            value: function startNewConnectionDrag(scope, data) {
                this.jpc = this.instance._newConnection({
                    sourceEndpoint: this.ep,
                    targetEndpoint: this.floatingEndpoint,
                    source: this.ep.element,
                    target: this.placeholderInfo.element,
                    paintStyle: this.ep.connectorStyle,
                    hoverPaintStyle: this.ep.connectorHoverStyle,
                    connector: this.ep.connector,
                    overlays: this.ep.connectorOverlays,
                    type: this.ep.edgeType,
                    cssClass: this.ep.connectorClass,
                    hoverClass: this.ep.connectorHoverClass,
                    scope: scope,
                    data: data
                });
                this.jpc.pending = true;
                this.jpc.addClass(this.instance.draggingClass);
                this.ep.addClass(this.instance.draggingClass);
                this.instance.fire(EVENT_CONNECTION_DRAG, this.jpc);
            }
        }, {
            key: "startExistingConnectionDrag",
            value: function startExistingConnectionDrag() {
                this.existingJpc = true;
                this.instance.setHover(this.jpc, false);
                var anchorIdx = this.jpc.endpoints[0].id === this.ep.id ? 0 : 1;
                this.ep.detachFromConnection(this.jpc, null, true);
                this.floatingEndpoint.addConnection(this.jpc);
                this.instance.fire(EVENT_CONNECTION_DRAG, this.jpc);
                this.instance.sourceOrTargetChanged(this.jpc.endpoints[anchorIdx].elementId, this.placeholderInfo.id, this.jpc, this.placeholderInfo.element, anchorIdx);
                this.jpc.suspendedEndpoint = this.jpc.endpoints[anchorIdx];
                this.jpc.suspendedElement = this.jpc.endpoints[anchorIdx].element;
                this.jpc.suspendedElementId = this.jpc.endpoints[anchorIdx].elementId;
                this.jpc.suspendedElementType = anchorIdx === 0 ? SOURCE : TARGET;
                this.instance.setHover(this.jpc.suspendedEndpoint, false);
                this.floatingEndpoint.referenceEndpoint = this.jpc.suspendedEndpoint;
                this.floatingEndpoint.mergeParameters(this.jpc.suspendedEndpoint.parameters);
                this.jpc.endpoints[anchorIdx] = this.floatingEndpoint;
                this.jpc.addClass(this.instance.draggingClass);
                this.floatingId = this.placeholderInfo.id;
                this.floatingIndex = anchorIdx;
                this.instance._refreshEndpoint(this.ep);
            }
        }, {
            key: "_shouldStartDrag",
            value: function _shouldStartDrag() {
                var _continue = true;
                if (!this.ep.enabled) {
                    _continue = false;
                }
                if (this.jpc == null && !this.ep.isSource && !this.ep.isTemporarySource) {
                    _continue = false;
                }
                if (this.ep.isSource && this.ep.isFull() && !(this.jpc != null && this.ep.dragAllowedWhenFull)) {
                    _continue = false;
                }
                if (this.jpc != null && !this.jpc.isDetachable(this.ep)) {
                    if (this.ep.isFull()) {
                        _continue = false;
                    }
                    else {
                        this.jpc = null;
                    }
                }
                var payload = {};
                var beforeDrag = this.instance.checkCondition(this.jpc == null ? INTERCEPT_BEFORE_DRAG : INTERCEPT_BEFORE_START_DETACH, {
                    endpoint: this.ep,
                    source: this.ep.element,
                    sourceId: this.ep.elementId,
                    connection: this.jpc
                });
                if (beforeDrag === false) {
                    _continue = false;
                }
                else if (_typeof(beforeDrag) === "object") {
                    payload = beforeDrag;
                    extend(payload, this.payload || {});
                }
                else {
                    payload = this.payload || {};
                }
                return [_continue, payload];
            }
        }, {
            key: "_createFloatingEndpoint",
            value: function _createFloatingEndpoint(canvasElement) {
                var endpointToFloat = this.ep.endpoint;
                if (this.ep.edgeType != null) {
                    var aae = this.instance._deriveEndpointAndAnchorSpec(this.ep.edgeType);
                    endpointToFloat = aae.endpoints[1];
                }
                this.floatingEndpoint = _makeFloatingEndpoint(this.ep, endpointToFloat, canvasElement, this.placeholderInfo.element, this.placeholderInfo.id, this.instance);
                this.floatingAnchor = this.floatingEndpoint._anchor;
                this.floatingEndpoint.deleteOnEmpty = true;
                this.floatingElement = this.floatingEndpoint.endpoint.canvas;
                this.floatingId = this.instance.getId(this.floatingElement);
            }
        }, {
            key: "_populateTargets",
            value: function _populateTargets(canvasElement, event) {
                var _this = this;
                var isSourceDrag = this.jpc && this.jpc.endpoints[0] === this.ep;
                var boundingRect;
                var matchingEndpoints = this.instance.getContainer().querySelectorAll([".", CLASS_ENDPOINT, "[", ATTRIBUTE_SCOPE_PREFIX, this.ep.scope, "]:not(.", CLASS_ENDPOINT_FLOATING, ")"].join(""));
                forEach$1(matchingEndpoints, function (candidate) {
                    if ((_this.jpc != null || candidate !== canvasElement) && candidate !== _this.floatingElement && (_this.jpc != null || !candidate.jtk.endpoint.isFull())) {
                        if (isSourceDrag && candidate.jtk.endpoint.isSource || !isSourceDrag && candidate.jtk.endpoint.isTarget) {
                            var o = getElementPosition(candidate, _this.instance), s = getElementSize(candidate, _this.instance);
                            boundingRect = {
                                x: o.x,
                                y: o.y,
                                w: s.w,
                                h: s.h
                            };
                            _this.endpointDropTargets.push({
                                el: candidate,
                                targetEl: candidate,
                                r: boundingRect,
                                endpoint: candidate.jtk.endpoint,
                                def: null
                            });
                            _this.instance.addClass(candidate, CLASS_DRAG_ACTIVE);
                        }
                    }
                });
                if (isSourceDrag) {
                    var sourceDef = getWithFunction(this.instance.sourceSelectors, function (sSel) {
                        return sSel.isEnabled() && (sSel.def.def.scope == null || sSel.def.def.scope === _this.ep.scope);
                    });
                    if (sourceDef != null) {
                        var targetZones = this._findTargetZones(sourceDef);
                        forEach$1(targetZones, function (el) {
                            if (el.getAttribute(ATTRIBUTE_JTK_ENABLED) !== FALSE$1) {
                                var scopeFromElement = el.getAttribute(ATTRIBUTE_JTK_SCOPE);
                                if (scopeFromElement != null && scopeFromElement !== _this.ep.scope) {
                                    return;
                                }
                                var d = {
                                    r: null,
                                    el: el
                                };
                                d.targetEl = findParent(el, SELECTOR_MANAGED_ELEMENT, _this.instance.getContainer(), true);
                                var o = getElementPosition(d.el, _this.instance), s = getElementSize(d.el, _this.instance);
                                d.r = {
                                    x: o.x,
                                    y: o.y,
                                    w: s.w,
                                    h: s.h
                                };
                                if (sourceDef.def.def.rank != null) {
                                    d.rank = sourceDef.def.def.rank;
                                }
                                d.def = sourceDef.def;
                                _this.endpointDropTargets.push(d);
                                _this.instance.addClass(d.targetEl, CLASS_DRAG_ACTIVE);
                            }
                        });
                    }
                }
                else {
                    var targetDefs = getAllWithFunction(this.instance.targetSelectors, function (tSel) {
                        return tSel.isEnabled();
                    });
                    targetDefs.forEach(function (targetDef) {
                        var targetZones = _this._findTargetZones(targetDef);
                        forEach$1(targetZones, function (el) {
                            if (el.getAttribute(ATTRIBUTE_JTK_ENABLED) !== FALSE$1) {
                                var scopeFromElement = el.getAttribute(ATTRIBUTE_JTK_SCOPE);
                                if (scopeFromElement != null && scopeFromElement !== _this.ep.scope) {
                                    return;
                                }
                                var d = {
                                    r: null,
                                    el: el
                                };
                                if (targetDef.def.def.parentSelector != null) {
                                    d.targetEl = findParent(el, targetDef.def.def.parentSelector, _this.instance.getContainer(), true);
                                }
                                if (d.targetEl == null) {
                                    d.targetEl = findParent(el, SELECTOR_MANAGED_ELEMENT, _this.instance.getContainer(), true);
                                }
                                if (targetDef.def.def.allowLoopback === false || _this._activeDefinition && _this._activeDefinition.def.def.allowLoopback === false) {
                                    if (d.targetEl === _this.ep.element) {
                                        return;
                                    }
                                }
                                if (targetDef.def.def.canAcceptNewConnection != null && !targetDef.def.def.canAcceptNewConnection(d.targetEl, event)) {
                                    return;
                                }
                                var maxConnections = targetDef.def.def.maxConnections;
                                if (maxConnections != null && maxConnections !== -1) {
                                    if (_this.instance.select({
                                        target: d.targetEl
                                    }).length >= maxConnections) {
                                        return;
                                    }
                                }
                                var o = getElementPosition(el, _this.instance), s = getElementSize(el, _this.instance);
                                d.r = {
                                    x: o.x,
                                    y: o.y,
                                    w: s.w,
                                    h: s.h
                                };
                                d.def = targetDef.def;
                                if (targetDef.def.def.rank != null) {
                                    d.rank = targetDef.def.def.rank;
                                }
                                _this.endpointDropTargets.push(d);
                                _this.instance.addClass(d.targetEl, CLASS_DRAG_ACTIVE);
                            }
                        });
                    });
                }
                this.endpointDropTargets.sort(function (a, b) {
                    if (a.targetEl._isJsPlumbGroup && !b.targetEl._isJsPlumbGroup) {
                        return 1;
                    }
                    else if (!a.targetEl._isJsPlumbGroup && b.targetEl._isJsPlumbGroup) {
                        return -1;
                    }
                    else {
                        if (a.targetEl._isJsPlumbGroup && b.targetEl._isJsPlumbGroup) {
                            if (_this.instance.groupManager.isAncestor(a.targetEl._jsPlumbGroup, b.targetEl._jsPlumbGroup)) {
                                return -1;
                            }
                            else if (_this.instance.groupManager.isAncestor(b.targetEl._jsPlumbGroup, a.targetEl._jsPlumbGroup)) {
                                return 1;
                            }
                        }
                        else {
                            if (a.rank != null && b.rank != null) {
                                if (a.rank > b.rank) {
                                    return -1;
                                }
                                else if (a.rank < b.rank) {
                                    return 1;
                                }
                                else
                                    ;
                            }
                            else {
                                return 0;
                            }
                        }
                    }
                });
            }
        }, {
            key: "_findTargetZones",
            value: function _findTargetZones(dragSelector) {
                var targetZonesSelector;
                if (dragSelector.redrop === REDROP_POLICY_ANY) {
                    var t = this.instance.targetSelectors.map(function (s) {
                        return s.selector;
                    });
                    t.push.apply(t, _toConsumableArray(this.instance.sourceSelectors.map(function (s) {
                        return s.selector;
                    })));
                    t.push(SELECTOR_MANAGED_ELEMENT);
                    targetZonesSelector = t.join(",");
                }
                else if (dragSelector.redrop === REDROP_POLICY_STRICT) {
                    targetZonesSelector = dragSelector.selector;
                }
                else if (dragSelector.redrop === REDROP_POLICY_ANY_SOURCE) {
                    targetZonesSelector = this.instance.sourceSelectors.map(function (s) {
                        return s.selector;
                    }).join(",");
                }
                else if (dragSelector.redrop === REDROP_POLICY_ANY_TARGET) {
                    targetZonesSelector = this.instance.targetSelectors.map(function (s) {
                        return s.selector;
                    }).join(",");
                }
                else if (dragSelector.redrop === REDROP_POLICY_ANY_SOURCE_OR_TARGET) {
                    var _t = this.instance.targetSelectors.map(function (s) {
                        return s.selector;
                    });
                    _t.push.apply(_t, _toConsumableArray(this.instance.sourceSelectors.map(function (s) {
                        return s.selector;
                    })));
                    targetZonesSelector = _t.join(",");
                }
                return this.instance.getContainer().querySelectorAll(targetZonesSelector);
            }
        }, {
            key: "onStart",
            value: function onStart(p) {
                this.endpointDropTargets.length = 0;
                this.currentDropTarget = null;
                this._stopped = false;
                var dragEl = p.drag.getDragElement();
                this.ep = dragEl.jtk.endpoint;
                if (!this.ep) {
                    return false;
                }
                this.endpointRepresentation = this.ep.endpoint;
                this.canvasElement = this.endpointRepresentation.canvas;
                this.jpc = this.ep.connectorSelector();
                var _this$_shouldStartDra = this._shouldStartDrag(), _this$_shouldStartDra2 = _slicedToArray(_this$_shouldStartDra, 2), _continue = _this$_shouldStartDra2[0], payload = _this$_shouldStartDra2[1];
                if (_continue === false) {
                    this._stopped = true;
                    return false;
                }
                this.instance.setHover(this.ep, false);
                this.instance.isConnectionBeingDragged = true;
                if (this.jpc && !this.ep.isFull() && this.ep.isSource) {
                    this.jpc = null;
                }
                this._createFloatingEndpoint(this.canvasElement);
                this._populateTargets(this.canvasElement, p.e);
                if (this.jpc == null) {
                    this.startNewConnectionDrag(this.ep.scope, payload);
                }
                else {
                    this.startExistingConnectionDrag();
                }
                this._registerFloatingConnection(this.placeholderInfo, this.jpc);
                this.instance.currentlyDragging = true;
            }
        }, {
            key: "onBeforeStart",
            value: function onBeforeStart(beforeStartParams) {
                this.payload = beforeStartParams.e.payload || {};
            }
        }, {
            key: "onDrag",
            value: function onDrag(params) {
                if (this._stopped) {
                    return true;
                }
                if (this.placeholderInfo.element) {
                    var floatingElementSize = getElementSize(this.floatingElement, this.instance);
                    this.instance.setElementPosition(this.placeholderInfo.element, params.pos.x, params.pos.y);
                    var boundingRect = {
                        x: params.pos.x,
                        y: params.pos.y,
                        w: floatingElementSize.w,
                        h: floatingElementSize.h
                    }, newDropTarget, idx, _cont;
                    for (var i = 0; i < this.endpointDropTargets.length; i++) {
                        if (intersects(boundingRect, this.endpointDropTargets[i].r)) {
                            newDropTarget = this.endpointDropTargets[i];
                            break;
                        }
                    }
                    if (newDropTarget !== this.currentDropTarget && this.currentDropTarget != null) {
                        idx = this._getFloatingAnchorIndex();
                        this.instance.removeClass(this.currentDropTarget.el, CLASS_DRAG_HOVER);
                        if (this.currentDropTarget.endpoint) {
                            this.currentDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropAllowedClass);
                            this.currentDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropForbiddenClass);
                        }
                        this.floatingAnchor.out();
                    }
                    if (newDropTarget != null) {
                        this.instance.addClass(newDropTarget.el, CLASS_DRAG_HOVER);
                        idx = this._getFloatingAnchorIndex();
                        if (newDropTarget.endpoint != null) {
                            _cont = newDropTarget.endpoint.isSource && idx === 0 || newDropTarget.endpoint.isTarget && idx !== 0 || this.jpc.suspendedEndpoint && newDropTarget.endpoint.referenceEndpoint && newDropTarget.endpoint.referenceEndpoint.id === this.jpc.suspendedEndpoint.id;
                            if (_cont) {
                                var bb = this.instance.checkCondition(CHECK_DROP_ALLOWED, {
                                    sourceEndpoint: this.jpc.endpoints[idx],
                                    targetEndpoint: newDropTarget.endpoint.endpoint,
                                    connection: this.jpc
                                });
                                if (bb) {
                                    newDropTarget.endpoint.endpoint.addClass(this.instance.endpointDropAllowedClass);
                                    newDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropForbiddenClass);
                                }
                                else {
                                    newDropTarget.endpoint.endpoint.removeClass(this.instance.endpointDropAllowedClass);
                                    newDropTarget.endpoint.endpoint.addClass(this.instance.endpointDropForbiddenClass);
                                }
                                this.floatingAnchor.over(newDropTarget.endpoint);
                                this.instance._paintConnection(this.jpc);
                            }
                            else {
                                newDropTarget = null;
                            }
                        }
                    }
                    this.currentDropTarget = newDropTarget;
                }
            }
        }, {
            key: "_maybeCleanup",
            value: function _maybeCleanup(ep) {
                if (ep._mtNew && ep.connections.length === 0) {
                    this.instance.deleteEndpoint(ep);
                }
                else {
                    delete ep._mtNew;
                }
            }
        }, {
            key: "_reattachOrDiscard",
            value: function _reattachOrDiscard(originalEvent) {
                var existingConnection = this.jpc.suspendedEndpoint != null;
                var idx = this._getFloatingAnchorIndex();
                if (existingConnection && this._shouldReattach()) {
                    if (idx === 0) {
                        this.jpc.source = this.jpc.suspendedElement;
                        this.jpc.sourceId = this.jpc.suspendedElementId;
                    }
                    else {
                        this.jpc.target = this.jpc.suspendedElement;
                        this.jpc.targetId = this.jpc.suspendedElementId;
                    }
                    this._doForceReattach(idx);
                    return true;
                }
                else {
                    this._discard(idx, originalEvent);
                    return false;
                }
            }
        }, {
            key: "onStop",
            value: function onStop(p) {
                var _this2 = this;
                var originalEvent = p.e;
                this.instance.isConnectionBeingDragged = false;
                this.instance.currentlyDragging = false;
                var classesToRemove = classList(CLASS_DRAG_HOVER, CLASS_DRAG_ACTIVE);
                var matchingSelectors = this.instance.getContainer().querySelectorAll(SELECTOR_DRAG_ACTIVE_OR_HOVER);
                forEach$1(matchingSelectors, function (el) {
                    _this2.instance.removeClass(el, classesToRemove);
                });
                if (this.jpc && this.jpc.endpoints != null) {
                    var existingConnection = this.jpc.suspendedEndpoint != null;
                    var idx = this._getFloatingAnchorIndex();
                    var suspendedEndpoint = this.jpc.suspendedEndpoint;
                    var dropEndpoint;
                    if (this.currentDropTarget != null) {
                        dropEndpoint = this._getDropEndpoint(p, this.jpc);
                        if (dropEndpoint == null) {
                            this._reattachOrDiscard(p.e);
                        }
                        else {
                            if (suspendedEndpoint && suspendedEndpoint.id === dropEndpoint.id) {
                                this._doForceReattach(idx);
                            }
                            else {
                                if (!dropEndpoint.enabled) {
                                    this._reattachOrDiscard(p.e);
                                }
                                else if (dropEndpoint.isFull()) {
                                    dropEndpoint.fire(EVENT_MAX_CONNECTIONS, {
                                        endpoint: this,
                                        connection: this.jpc,
                                        maxConnections: this.instance.defaults.maxConnections
                                    }, originalEvent);
                                    this._reattachOrDiscard(p.e);
                                }
                                else {
                                    if (idx === 0) {
                                        this.jpc.source = dropEndpoint.element;
                                        this.jpc.sourceId = dropEndpoint.elementId;
                                    }
                                    else {
                                        this.jpc.target = dropEndpoint.element;
                                        this.jpc.targetId = dropEndpoint.elementId;
                                    }
                                    var _doContinue = true;
                                    if (existingConnection && this.jpc.suspendedEndpoint.id !== dropEndpoint.id) {
                                        if (!this.jpc.isDetachAllowed(this.jpc) || !this.jpc.endpoints[idx].isDetachAllowed(this.jpc) || !this.jpc.suspendedEndpoint.isDetachAllowed(this.jpc) || !this.instance.checkCondition("beforeDetach", this.jpc)) {
                                            _doContinue = false;
                                        }
                                    }
                                    _doContinue = _doContinue && dropEndpoint.isDropAllowed(this.jpc.sourceId, this.jpc.targetId, this.jpc.scope, this.jpc, dropEndpoint);
                                    if (_doContinue) {
                                        this._drop(dropEndpoint, idx, originalEvent, _doContinue);
                                    }
                                    else {
                                        this._reattachOrDiscard(p.e);
                                    }
                                }
                            }
                        }
                    }
                    else {
                        this._reattachOrDiscard(p.e);
                    }
                    this.instance._refreshEndpoint(this.ep);
                    this.ep.removeClass(this.instance.draggingClass);
                    this._cleanupDraggablePlaceholder();
                    this.jpc.removeClass(this.instance.draggingClass);
                    delete this.jpc.suspendedEndpoint;
                    delete this.jpc.suspendedElement;
                    delete this.jpc.suspendedElementType;
                    delete this.jpc.suspendedElementId;
                    delete this.jpc.suspendedIndex;
                    delete this.floatingId;
                    delete this.floatingIndex;
                    delete this.floatingElement;
                    delete this.floatingEndpoint;
                    delete this.floatingAnchor;
                    delete this.jpc.pending;
                    if (dropEndpoint != null) {
                        this._maybeCleanup(dropEndpoint);
                    }
                }
            }
        }, {
            key: "_getSourceDefinition",
            value: function _getSourceDefinition(evt) {
                var selector;
                var container = this.instance.getContainer();
                for (var i = 0; i < this.instance.sourceSelectors.length; i++) {
                    selector = this.instance.sourceSelectors[i];
                    if (selector.isEnabled()) {
                        var r = selectorFilter(evt, container, selector.selector, this.instance, selector.exclude);
                        if (r !== false) {
                            return selector;
                        }
                    }
                }
            }
        }, {
            key: "_getDropEndpoint",
            value: function _getDropEndpoint(p, jpc) {
                var dropEndpoint;
                if (this.currentDropTarget.endpoint == null) {
                    var targetDefinition = this.currentDropTarget.def;
                    var eventTarget = p.e.target || p.e.srcElement;
                    if (targetDefinition == null) {
                        return null;
                    }
                    var targetElement = this.currentDropTarget.targetEl;
                    var elxy = getPositionOnElement(p.e, targetElement, this.instance.currentZoom);
                    var eps = this.instance._deriveEndpointAndAnchorSpec(jpc.getType().join(" "), true);
                    var pp = eps.endpoints ? extend(p, {
                        endpoint: targetDefinition.def.endpoint || eps.endpoints[1],
                        cssClass: targetDefinition.def.cssClass || "",
                        source: targetDefinition.def.source === true,
                        target: targetDefinition.def.target === true
                    }) : p;
                    var anchorsToUse = this.instance.validAnchorsSpec(eps.anchors) ? eps.anchors : this.instance.areDefaultAnchorsSet() ? this.instance.defaults.anchors : null;
                    var anchorFromDef = targetDefinition.def.anchor;
                    var anchorFromPositionFinder = targetDefinition.def.anchorPositionFinder ? targetDefinition.def.anchorPositionFinder(targetElement, elxy, targetDefinition.def, p.e) : null;
                    var dropAnchor = anchorFromPositionFinder != null ? anchorFromPositionFinder : anchorFromDef != null ? anchorFromDef : anchorsToUse != null && anchorsToUse[1] != null ? anchorsToUse[1] : null;
                    if (dropAnchor != null) {
                        pp = extend(pp, {
                            anchor: dropAnchor
                        });
                    }
                    if (targetDefinition.def.portId != null) {
                        pp.portId = targetDefinition.def.portId;
                    }
                    var extractedParameters = targetDefinition.def.parameterExtractor ? targetDefinition.def.parameterExtractor(this.currentDropTarget.el, eventTarget, p.e) : {};
                    pp = merge$1(pp, extractedParameters);
                    pp.element = targetElement;
                    dropEndpoint = this.instance._internal_newEndpoint(pp);
                    dropEndpoint._mtNew = true;
                    dropEndpoint.deleteOnEmpty = true;
                    if (targetDefinition.def.parameters) {
                        dropEndpoint.mergeParameters(targetDefinition.def.parameters);
                    }
                    if (targetDefinition.def.extract) {
                        var tpayload = {};
                        for (var att in targetDefinition.def.extract) {
                            var v = this.currentDropTarget.el.getAttribute(att);
                            if (v) {
                                tpayload[targetDefinition.def.extract[att]] = v;
                            }
                        }
                        dropEndpoint.mergeParameters(tpayload);
                    }
                }
                else {
                    dropEndpoint = this.currentDropTarget.endpoint;
                }
                if (dropEndpoint) {
                    dropEndpoint.removeClass(this.instance.endpointDropAllowedClass);
                    dropEndpoint.removeClass(this.instance.endpointDropForbiddenClass);
                }
                return dropEndpoint;
            }
        }, {
            key: "_doForceReattach",
            value: function _doForceReattach(idx) {
                this.floatingEndpoint.detachFromConnection(this.jpc, null, true);
                this.jpc.endpoints[idx] = this.jpc.suspendedEndpoint;
                this.instance.setHover(this.jpc, false);
                this.jpc._forceDetach = true;
                this.jpc.suspendedEndpoint.addConnection(this.jpc);
                this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.suspendedEndpoint.elementId, this.jpc, this.jpc.suspendedEndpoint.element, idx);
                this.instance.deleteEndpoint(this.floatingEndpoint);
                this.instance.repaint(this.jpc.source);
                delete this.jpc._forceDetach;
            }
        }, {
            key: "_shouldReattach",
            value: function _shouldReattach() {
                if (this.jpc.isReattach() || this.jpc._forceReattach) {
                    return true;
                }
                else {
                    var suspendedEndpoint = this.jpc.suspendedEndpoint, otherEndpointIdx = this.jpc.suspendedElementType == SOURCE ? 1 : 0, otherEndpoint = this.jpc.endpoints[otherEndpointIdx];
                    return !functionChain(true, false, [[suspendedEndpoint, IS_DETACH_ALLOWED, [this.jpc]], [otherEndpoint, IS_DETACH_ALLOWED, [this.jpc]], [this.jpc, IS_DETACH_ALLOWED, [this.jpc]], [this.instance, CHECK_CONDITION, [INTERCEPT_BEFORE_DETACH, this.jpc]]]);
                }
            }
        }, {
            key: "_discard",
            value: function _discard(idx, originalEvent) {
                if (this.jpc.pending) {
                    this.instance.fire(EVENT_CONNECTION_ABORT, this.jpc, originalEvent);
                }
                else {
                    if (idx === 0) {
                        this.jpc.source = this.jpc.suspendedEndpoint.element;
                        this.jpc.sourceId = this.jpc.suspendedEndpoint.elementId;
                    }
                    else {
                        this.jpc.target = this.jpc.suspendedEndpoint.element;
                        this.jpc.targetId = this.jpc.suspendedEndpoint.elementId;
                    }
                    this.jpc.endpoints[idx] = this.jpc.suspendedEndpoint;
                }
                if (this.floatingEndpoint) {
                    this.floatingEndpoint.detachFromConnection(this.jpc);
                }
                this.instance.deleteConnection(this.jpc, {
                    originalEvent: originalEvent,
                    force: true
                });
            }
        }, {
            key: "_drop",
            value: function _drop(dropEndpoint, idx, originalEvent, optionalData) {
                this.jpc.endpoints[idx].detachFromConnection(this.jpc);
                if (this.jpc.suspendedEndpoint) {
                    this.jpc.suspendedEndpoint.detachFromConnection(this.jpc);
                }
                this.jpc.endpoints[idx] = dropEndpoint;
                dropEndpoint.addConnection(this.jpc);
                if (this.jpc.suspendedEndpoint) {
                    var suspendedElementId = this.jpc.suspendedEndpoint.elementId;
                    this.instance.fireMoveEvent({
                        index: idx,
                        originalSourceId: idx === 0 ? suspendedElementId : this.jpc.sourceId,
                        newSourceId: idx === 0 ? dropEndpoint.elementId : this.jpc.sourceId,
                        originalTargetId: idx === 1 ? suspendedElementId : this.jpc.targetId,
                        newTargetId: idx === 1 ? dropEndpoint.elementId : this.jpc.targetId,
                        originalEndpoint: this.jpc.suspendedEndpoint,
                        connection: this.jpc,
                        newEndpoint: dropEndpoint
                    }, originalEvent);
                }
                if (idx === 1) {
                    this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.targetId, this.jpc, this.jpc.target, 1);
                }
                else {
                    this.instance.sourceOrTargetChanged(this.floatingId, this.jpc.sourceId, this.jpc, this.jpc.source, 0);
                }
                if (this.jpc.endpoints[0].finalEndpoint) {
                    var _toDelete = this.jpc.endpoints[0];
                    _toDelete.detachFromConnection(this.jpc);
                    this.jpc.endpoints[0] = this.jpc.endpoints[0].finalEndpoint;
                    this.jpc.endpoints[0].addConnection(this.jpc);
                }
                if (isObject$1(optionalData)) {
                    this.jpc.mergeData(optionalData);
                }
                if (this._originalAnchorSpec) {
                    this.jpc.endpoints[0].setAnchor(this._originalAnchorSpec);
                    this._originalAnchorSpec = null;
                }
                this.instance._finaliseConnection(this.jpc, null, originalEvent);
                this.instance.setHover(this.jpc, false);
                this.instance.revalidate(this.jpc.endpoints[0].element);
            }
        }, {
            key: "_registerFloatingConnection",
            value: function _registerFloatingConnection(info, conn) {
                this.floatingConnections[info.id] = conn;
            }
        }, {
            key: "_getFloatingAnchorIndex",
            value: function _getFloatingAnchorIndex() {
                return this.floatingIndex == null ? 1 : this.floatingIndex;
            }
        }]);
    return EndpointDragHandler;
}();
var GroupDragHandler = function (_ElementDragHandler) {
    _inherits$2(GroupDragHandler, _ElementDragHandler);
    var _super = _createSuper$2(GroupDragHandler);
    function GroupDragHandler(instance, dragSelection) {
        var _this;
        _classCallCheck$2(this, GroupDragHandler);
        _this = _super.call(this, instance, dragSelection);
        _this.instance = instance;
        _this.dragSelection = dragSelection;
        _defineProperty$2(_assertThisInitialized$2(_this), "selector", [">", SELECTOR_GROUP, SELECTOR_MANAGED_ELEMENT].join(" "));
        _defineProperty$2(_assertThisInitialized$2(_this), "doRevalidate", void 0);
        _this.doRevalidate = _this._revalidate.bind(_assertThisInitialized$2(_this));
        return _this;
    }
    _createClass$2(GroupDragHandler, [{
            key: "reset",
            value: function reset() {
                this.drag.off(EVENT_REVERT, this.doRevalidate);
            }
        }, {
            key: "_revalidate",
            value: function _revalidate(el) {
                this.instance.revalidate(el);
            }
        }, {
            key: "init",
            value: function init(drag) {
                this.drag = drag;
                drag.on(EVENT_REVERT, this.doRevalidate);
            }
        }, {
            key: "useGhostProxy",
            value: function useGhostProxy(container, dragEl) {
                var group = dragEl._jsPlumbParentGroup;
                return group == null ? false : group.ghost === true;
            }
        }, {
            key: "makeGhostProxy",
            value: function makeGhostProxy(el) {
                var jel = el;
                var newEl = jel.cloneNode(true);
                newEl._jsPlumbParentGroup = jel._jsPlumbParentGroup;
                return newEl;
            }
        }]);
    return GroupDragHandler;
}(ElementDragHandler);
var HTMLElementOverlay = function () {
    function HTMLElementOverlay(instance, overlay) {
        _classCallCheck$2(this, HTMLElementOverlay);
        this.instance = instance;
        this.overlay = overlay;
        _defineProperty$2(this, "htmlElementOverlay", void 0);
        this.htmlElementOverlay = overlay;
    }
    _createClass$2(HTMLElementOverlay, null, [{
            key: "getElement",
            value: function getElement(o, component, elementCreator) {
                if (o.canvas == null) {
                    if (elementCreator && component) {
                        o.canvas = elementCreator(component);
                        var cls = o.instance.overlayClass + " " + (o.cssClass ? o.cssClass : "");
                        o.instance.addClass(o.canvas, cls);
                    }
                    else {
                        o.canvas = createElement(ELEMENT_DIV, {}, o.instance.overlayClass + " " + (o.cssClass ? o.cssClass : ""));
                    }
                    o.instance.setAttribute(o.canvas, "jtk-overlay-id", o.id);
                    for (var att in o.attributes) {
                        o.instance.setAttribute(o.canvas, att, o.attributes[att]);
                    }
                    o.canvas.style.position = ABSOLUTE;
                    o.instance._appendElement(o.canvas, o.instance.getContainer());
                    o.instance.getId(o.canvas);
                    var ts = "translate(-50%, -50%)";
                    o.canvas.style.webkitTransform = ts;
                    o.canvas.style.mozTransform = ts;
                    o.canvas.style.msTransform = ts;
                    o.canvas.style.oTransform = ts;
                    o.canvas.style.transform = ts;
                    if (!o.isVisible()) {
                        o.canvas.style.display = NONE;
                    }
                    o.canvas.jtk = {
                        overlay: o
                    };
                }
                return o.canvas;
            }
        }, {
            key: "destroy",
            value: function destroy(o) {
                o.canvas && o.canvas.parentNode && o.canvas.parentNode.removeChild(o.canvas);
                delete o.canvas;
                delete o.cachedDimensions;
            }
        }, {
            key: "_getDimensions",
            value: function _getDimensions(o, forceRefresh) {
                if (o.cachedDimensions == null || forceRefresh) {
                    o.cachedDimensions = {
                        w: 1,
                        h: 1
                    };
                }
                return o.cachedDimensions;
            }
        }]);
    return HTMLElementOverlay;
}();
function ensureSVGOverlayPath(o) {
    if (o.path == null) {
        var atts = extend({
            "jtk-overlay-id": o.id
        }, o.attributes);
        o.path = _node(ELEMENT_PATH, atts);
        var cls = o.instance.overlayClass + " " + (o.cssClass ? o.cssClass : "");
        o.instance.addClass(o.path, cls);
        o.path.jtk = {
            overlay: o
        };
    }
    var parent = o.path.parentNode;
    if (parent == null) {
        if (o.component instanceof Connection) {
            var connector = o.component.connector;
            parent = connector != null ? connector.canvas : null;
        }
        else if (o.component instanceof Endpoint) {
            var endpoint = o.component.endpoint;
            parent = endpoint != null ? endpoint.canvas : endpoint;
        }
        if (parent != null) {
            _appendAtIndex(parent, o.path, 1);
        }
    }
    return o.path;
}
function paintSVGOverlay(o, path, params, extents) {
    ensureSVGOverlayPath(o);
    var offset = [0, 0];
    if (extents.xmin < 0) {
        offset[0] = -extents.xmin;
    }
    if (extents.ymin < 0) {
        offset[1] = -extents.ymin;
    }
    var a = {
        "d": path,
        stroke: params.stroke ? params.stroke : null,
        fill: params.fill ? params.fill : null,
        transform: "translate(" + offset[0] + "," + offset[1] + ")",
        "pointer-events": "visibleStroke"
    };
    _attr(o.path, a);
}
function destroySVGOverlay(o, force) {
    var _o = o;
    if (_o.path != null && _o.path.parentNode != null) {
        _o.path.parentNode.removeChild(_o.path);
    }
    if (_o.bgPath != null && _o.bgPath.parentNode != null) {
        _o.bgPath.parentNode.removeChild(_o.bgPath);
    }
    delete _o.path;
    delete _o.bgPath;
}
(function (_Overlay) {
    _inherits$2(SVGElementOverlay, _Overlay);
    var _super = _createSuper$2(SVGElementOverlay);
    function SVGElementOverlay() {
        var _this;
        _classCallCheck$2(this, SVGElementOverlay);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty$2(_assertThisInitialized$2(_this), "path", void 0);
        return _this;
    }
    return SVGElementOverlay;
})(Overlay);
var SvgComponent = function () {
    function SvgComponent() {
        _classCallCheck$2(this, SvgComponent);
    }
    _createClass$2(SvgComponent, null, [{
            key: "paint",
            value: function paint(connector, instance, paintStyle, extents) {
                if (paintStyle != null) {
                    var xy = [connector.x, connector.y], wh = [connector.w, connector.h];
                    if (extents != null) {
                        if (extents.xmin < 0) {
                            xy[0] += extents.xmin;
                        }
                        if (extents.ymin < 0) {
                            xy[1] += extents.ymin;
                        }
                        wh[0] = extents.xmax + (extents.xmin < 0 ? -extents.xmin : 0);
                        wh[1] = extents.ymax + (extents.ymin < 0 ? -extents.ymin : 0);
                    }
                    if (isFinite(wh[0]) && isFinite(wh[1])) {
                        var attrs = {
                            "width": "" + (wh[0] || 0),
                            "height": "" + (wh[1] || 0)
                        };
                        if (instance.containerType === ElementTypes.HTML) {
                            _attr(connector.canvas, extend(attrs, {
                                style: _pos([xy[0], xy[1]])
                            }));
                        }
                        else {
                            _attr(connector.canvas, extend(attrs, {
                                x: xy[0],
                                y: xy[1]
                            }));
                        }
                    }
                }
            }
        }]);
    return SvgComponent;
}();
function paintSvgConnector(instance, connector, paintStyle, extents) {
    getConnectorElement(instance, connector);
    SvgComponent.paint(connector, instance, paintStyle, extents);
    var p = "", offset = [0, 0];
    if (extents.xmin < 0) {
        offset[0] = -extents.xmin;
    }
    if (extents.ymin < 0) {
        offset[1] = -extents.ymin;
    }
    if (connector.segments.length > 0) {
        p = instance.getPathData(connector);
        var a = {
            d: p,
            transform: "translate(" + offset[0] + "," + offset[1] + ")",
            "pointer-events": "visibleStroke"
        }, outlineStyle = null;
        if (paintStyle.outlineStroke) {
            var outlineWidth = paintStyle.outlineWidth || 1, outlineStrokeWidth = paintStyle.strokeWidth + 2 * outlineWidth;
            outlineStyle = extend({}, paintStyle);
            outlineStyle.stroke = paintStyle.outlineStroke;
            outlineStyle.strokeWidth = outlineStrokeWidth;
            if (connector.bgPath == null) {
                connector.bgPath = _node(ELEMENT_PATH, a);
                instance.addClass(connector.bgPath, instance.connectorOutlineClass);
                _appendAtIndex(connector.canvas, connector.bgPath, 0);
            }
            else {
                _attr(connector.bgPath, a);
            }
            _applyStyles(connector.canvas, connector.bgPath, outlineStyle);
        }
        var cany = connector;
        if (cany.path == null) {
            cany.path = _node(ELEMENT_PATH, a);
            _appendAtIndex(cany.canvas, cany.path, paintStyle.outlineStroke ? 1 : 0);
        }
        else {
            if (cany.path.parentNode !== cany.canvas) {
                _appendAtIndex(cany.canvas, cany.path, paintStyle.outlineStroke ? 1 : 0);
            }
            _attr(connector.path, a);
        }
        _applyStyles(connector.canvas, connector.path, paintStyle);
    }
}
function getConnectorElement(instance, c) {
    if (c.canvas != null) {
        return c.canvas;
    }
    else {
        var svg = _node(ELEMENT_SVG, {
            "style": "",
            "width": "0",
            "height": "0",
            "pointer-events": NONE,
            "position": ABSOLUTE
        });
        c.canvas = svg;
        instance._appendElement(c.canvas, instance.getContainer());
        if (c.cssClass != null) {
            instance.addClass(svg, c.cssClass);
        }
        instance.addClass(svg, instance.connectorClass);
        svg.jtk = svg.jtk || {};
        svg.jtk.connector = c;
        return svg;
    }
}
var SvgEndpoint = function () {
    function SvgEndpoint() {
        _classCallCheck$2(this, SvgEndpoint);
    }
    _createClass$2(SvgEndpoint, null, [{
            key: "getEndpointElement",
            value: function getEndpointElement(ep) {
                if (ep.canvas != null) {
                    return ep.canvas;
                }
                else {
                    var canvas = _node(ELEMENT_SVG, {
                        "style": "",
                        "width": "0",
                        "height": "0",
                        "pointer-events": "all",
                        "position": ABSOLUTE
                    });
                    ep.canvas = canvas;
                    var classes = ep.classes.join(" ");
                    ep.instance.addClass(canvas, classes);
                    var scopes = ep.endpoint.scope.split(/\s/);
                    for (var i = 0; i < scopes.length; i++) {
                        ep.instance.setAttribute(canvas, ATTRIBUTE_SCOPE_PREFIX + scopes[i], TRUE$1);
                    }
                    ep.instance._appendElementToContainer(canvas);
                    if (ep.cssClass != null) {
                        ep.instance.addClass(canvas, ep.cssClass);
                    }
                    ep.instance.addClass(canvas, ep.instance.endpointClass);
                    canvas.jtk = canvas.jtk || {};
                    canvas.jtk.endpoint = ep.endpoint;
                    canvas.style.display = ep.endpoint.visible !== false ? BLOCK : NONE;
                    return canvas;
                }
            }
        }, {
            key: "paint",
            value: function paint(ep, handlers, paintStyle) {
                if (ep.endpoint.deleted !== true) {
                    this.getEndpointElement(ep);
                    SvgComponent.paint(ep, ep.instance, paintStyle);
                    var s = extend({}, paintStyle);
                    if (s.outlineStroke) {
                        s.stroke = s.outlineStroke;
                    }
                    if (ep.node == null) {
                        ep.node = handlers.makeNode(ep, s);
                        ep.canvas.appendChild(ep.node);
                    }
                    else if (handlers.updateNode != null) {
                        handlers.updateNode(ep, ep.node);
                    }
                    _applyStyles(ep.canvas, ep.node, s);
                }
            }
        }]);
    return SvgEndpoint;
}();
var endpointMap = {};
function registerEndpointRenderer(name, fns) {
    endpointMap[name] = fns;
}
function getPositionOnElement(evt, el, zoom) {
    var jel = el;
    var box = _typeof(el.getBoundingClientRect) !== UNDEFINED ? el.getBoundingClientRect() : {
        left: 0,
        top: 0,
        width: 0,
        height: 0
    }, body = document.body, docElem = document.documentElement, scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop, scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft, clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0, pst = 0, psl = 0, top = box.top + scrollTop - clientTop + pst * zoom, left = box.left + scrollLeft - clientLeft + psl * zoom, cl = pageLocation(evt), w = box.width || jel.offsetWidth * zoom, h = box.height || jel.offsetHeight * zoom, x = (cl.x - left) / w, y = (cl.y - top) / h;
    return {
        x: x,
        y: y
    };
}
function isSVGElementOverlay(o) {
    return isArrowOverlay(o) || isDiamondOverlay(o) || isPlainArrowOverlay(o);
}
function setVisible(component, v) {
    if (component.canvas) {
        component.canvas.style.display = v ? "block" : "none";
    }
}
function cleanup(component) {
    if (component.canvas) {
        component.canvas.parentNode.removeChild(component.canvas);
    }
    delete component.canvas;
}
function getEndpointCanvas(ep) {
    return ep.canvas;
}
function getLabelElement(o) {
    return HTMLElementOverlay.getElement(o);
}
function getCustomElement(o) {
    return HTMLElementOverlay.getElement(o, o.component, function (c) {
        var el = o.create(c);
        o.instance.addClass(el, o.instance.overlayClass);
        return el;
    });
}
function groupDragConstrain(desiredLoc, dragEl, constrainRect, size) {
    var x = desiredLoc.x, y = desiredLoc.y;
    if (dragEl._jsPlumbParentGroup && dragEl._jsPlumbParentGroup.constrain) {
        x = Math.max(desiredLoc.x, 0);
        y = Math.max(desiredLoc.y, 0);
        x = Math.min(x, constrainRect.w - size.w);
        y = Math.min(y, constrainRect.h - size.h);
    }
    return {
        x: x,
        y: y
    };
}
var BrowserJsPlumbInstance = function (_JsPlumbInstance) {
    _inherits$2(BrowserJsPlumbInstance, _JsPlumbInstance);
    var _super = _createSuper$2(BrowserJsPlumbInstance);
    function BrowserJsPlumbInstance(_instanceIndex, defaults) {
        var _this;
        _classCallCheck$2(this, BrowserJsPlumbInstance);
        _this = _super.call(this, _instanceIndex, defaults);
        _this._instanceIndex = _instanceIndex;
        _defineProperty$2(_assertThisInitialized$2(_this), "containerType", null);
        _defineProperty$2(_assertThisInitialized$2(_this), "dragSelection", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "dragManager", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_connectorClick", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_connectorDblClick", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_connectorTap", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_connectorDblTap", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_endpointClick", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_endpointDblClick", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_overlayClick", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_overlayDblClick", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_overlayTap", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_overlayDblTap", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_connectorMouseover", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_connectorMouseout", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_endpointMouseover", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_endpointMouseout", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_connectorContextmenu", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_connectorMousedown", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_connectorMouseup", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_endpointMousedown", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_endpointMouseup", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_overlayMouseover", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_overlayMouseout", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_elementClick", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_elementTap", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_elementDblTap", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_elementMouseenter", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_elementMouseexit", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_elementMousemove", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_elementMouseup", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_elementMousedown", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_elementContextmenu", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "_resizeObserver", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "eventManager", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "draggingClass", "jtk-dragging");
        _defineProperty$2(_assertThisInitialized$2(_this), "elementDraggingClass", "jtk-element-dragging");
        _defineProperty$2(_assertThisInitialized$2(_this), "hoverClass", "jtk-hover");
        _defineProperty$2(_assertThisInitialized$2(_this), "sourceElementDraggingClass", "jtk-source-element-dragging");
        _defineProperty$2(_assertThisInitialized$2(_this), "targetElementDraggingClass", "jtk-target-element-dragging");
        _defineProperty$2(_assertThisInitialized$2(_this), "hoverSourceClass", "jtk-source-hover");
        _defineProperty$2(_assertThisInitialized$2(_this), "hoverTargetClass", "jtk-target-hover");
        _defineProperty$2(_assertThisInitialized$2(_this), "dragSelectClass", "jtk-drag-select");
        _defineProperty$2(_assertThisInitialized$2(_this), "managedElementsSelector", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "elementsDraggable", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "elementDragHandler", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "groupDragOptions", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "elementDragOptions", void 0);
        _defineProperty$2(_assertThisInitialized$2(_this), "svg", {
            node: function node(name, attributes) {
                return _node(name, attributes);
            },
            attr: function attr(node, attributes) {
                return _attr(node, attributes);
            },
            pos: function pos(d) {
                return _pos(d);
            }
        });
        defaults = defaults || {};
        _this.containerType = getElementType(_this.getContainer());
        _this.elementsDraggable = defaults && defaults.elementsDraggable !== false;
        _this.managedElementsSelector = defaults ? defaults.managedElementsSelector || SELECTOR_MANAGED_ELEMENT : SELECTOR_MANAGED_ELEMENT;
        _this.eventManager = new EventManager();
        _this.dragSelection = new DragSelection(_assertThisInitialized$2(_this));
        _this.dragManager = new DragManager(_assertThisInitialized$2(_this), _this.dragSelection);
        _this.dragManager.addHandler(new EndpointDragHandler(_assertThisInitialized$2(_this)));
        _this.groupDragOptions = {
            constrainFunction: groupDragConstrain
        };
        _this.dragManager.addHandler(new GroupDragHandler(_assertThisInitialized$2(_this), _this.dragSelection), _this.groupDragOptions);
        _this.elementDragHandler = new ElementDragHandler(_assertThisInitialized$2(_this), _this.dragSelection);
        _this.elementDragOptions = defaults && defaults.dragOptions || {};
        _this.dragManager.addHandler(_this.elementDragHandler, _this.elementDragOptions);
        if (defaults && defaults.dragOptions && defaults.dragOptions.filter) {
            _this.dragManager.addFilter(defaults.dragOptions.filter);
        }
        _this._createEventListeners();
        _this._attachEventDelegates();
        if (defaults.resizeObserver !== false) {
            try {
                _this._resizeObserver = new ResizeObserver(function (entries) {
                    var updates = entries.filter(function (e) {
                        var a = _this.getAttribute(e.target, ATTRIBUTE_MANAGED);
                        if (a != null) {
                            var v = _this.viewport._elementMap.get(a);
                            return v ? v.w !== e.contentRect.width || v.h !== e.contentRect.height : false;
                        }
                        else {
                            return false;
                        }
                    });
                    updates.forEach(function (el) {
                        return _this.revalidate(el.target);
                    });
                });
            }
            catch (e) {
                log("WARN: ResizeObserver could not be attached.");
            }
        }
        return _this;
    }
    _createClass$2(BrowserJsPlumbInstance, [{
            key: "fireOverlayMethod",
            value: function fireOverlayMethod(overlay, event, e) {
                var stem = overlay.component instanceof Connection ? CONNECTION : ENDPOINT;
                var mappedEvent = compoundEvent(stem, event);
                e._jsPlumbOverlay = overlay;
                overlay.fire(event, {
                    e: e,
                    overlay: overlay
                });
                this.fire(mappedEvent, overlay.component, e);
            }
        }, {
            key: "addDragFilter",
            value: function addDragFilter(filter, exclude) {
                this.dragManager.addFilter(filter, exclude);
            }
        }, {
            key: "removeDragFilter",
            value: function removeDragFilter(filter) {
                this.dragManager.removeFilter(filter);
            }
        }, {
            key: "setDragGrid",
            value: function setDragGrid(grid) {
                this.dragManager.setOption(this.elementDragHandler, {
                    grid: grid
                });
            }
        }, {
            key: "setDragConstrainFunction",
            value: function setDragConstrainFunction(constrainFunction) {
                this.dragManager.setOption(this.elementDragHandler, {
                    constrainFunction: constrainFunction
                });
            }
        }, {
            key: "_removeElement",
            value: function _removeElement(element) {
                element.parentNode && element.parentNode.removeChild(element);
            }
        }, {
            key: "_appendElement",
            value: function _appendElement(el, parent) {
                if (parent) {
                    parent.appendChild(el);
                }
            }
        }, {
            key: "_appendElementToGroup",
            value: function _appendElementToGroup(group, el) {
                this.getGroupContentArea(group).appendChild(el);
            }
        }, {
            key: "_appendElementToContainer",
            value: function _appendElementToContainer(el) {
                this._appendElement(el, this.getContainer());
            }
        }, {
            key: "_getAssociatedElements",
            value: function _getAssociatedElements(el) {
                var a = [];
                if (el.nodeType !== 3 && el.nodeType !== 8) {
                    var els = el.querySelectorAll(SELECTOR_MANAGED_ELEMENT);
                    Array.prototype.push.apply(a, els);
                }
                return a.filter(function (_a) {
                    return _a.nodeType !== 3 && _a.nodeType !== 8;
                });
            }
        }, {
            key: "shouldFireEvent",
            value: function shouldFireEvent(event, value, originalEvent) {
                return true;
            }
        }, {
            key: "getClass",
            value: function getClass$1(el) {
                return getClass(el);
            }
        }, {
            key: "addClass",
            value: function addClass$1(el, clazz) {
                addClass(el, clazz);
            }
        }, {
            key: "hasClass",
            value: function hasClass$1(el, clazz) {
                return hasClass(el, clazz);
            }
        }, {
            key: "removeClass",
            value: function removeClass$1(el, clazz) {
                removeClass(el, clazz);
            }
        }, {
            key: "toggleClass",
            value: function toggleClass$1(el, clazz) {
                toggleClass(el, clazz);
            }
        }, {
            key: "setAttribute",
            value: function setAttribute(el, name, value) {
                el.setAttribute(name, value);
            }
        }, {
            key: "getAttribute",
            value: function getAttribute(el, name) {
                return el.getAttribute(name);
            }
        }, {
            key: "setAttributes",
            value: function setAttributes(el, atts) {
                for (var i in atts) {
                    el.setAttribute(i, atts[i]);
                }
            }
        }, {
            key: "removeAttribute",
            value: function removeAttribute(el, attName) {
                el.removeAttribute && el.removeAttribute(attName);
            }
        }, {
            key: "on",
            value: function on(el, event, callbackOrSelector, callback) {
                var _this2 = this;
                var _one = function _one(_el) {
                    if (callback == null) {
                        _this2.eventManager.on(_el, event, callbackOrSelector);
                    }
                    else {
                        _this2.eventManager.on(_el, event, callbackOrSelector, callback);
                    }
                };
                if (isNodeList(el)) {
                    forEach$1(el, function (el) {
                        return _one(el);
                    });
                }
                else {
                    _one(el);
                }
                return this;
            }
        }, {
            key: "off",
            value: function off(el, event, callback) {
                var _this3 = this;
                if (isNodeList(el)) {
                    forEach$1(el, function (_el) {
                        return _this3.eventManager.off(_el, event, callback);
                    });
                }
                else {
                    this.eventManager.off(el, event, callback);
                }
                return this;
            }
        }, {
            key: "trigger",
            value: function trigger(el, event, originalEvent, payload, detail) {
                this.eventManager.trigger(el, event, originalEvent, payload, detail);
            }
        }, {
            key: "getOffsetRelativeToRoot",
            value: function getOffsetRelativeToRoot(el) {
                return offsetRelativeToRoot(el);
            }
        }, {
            key: "getOffset",
            value: function getOffset(el) {
                var jel = el;
                var container = this.getContainer();
                var out = this.getPosition(jel), op = el !== container && jel.offsetParent !== container ? jel.offsetParent : null, _maybeAdjustScroll = function _maybeAdjustScroll(offsetParent) {
                    if (offsetParent != null && offsetParent !== document.body && (offsetParent.scrollTop > 0 || offsetParent.scrollLeft > 0)) {
                        out.x -= offsetParent.scrollLeft;
                        out.y -= offsetParent.scrollTop;
                    }
                };
                while (op != null) {
                    out.x += op.offsetLeft;
                    out.y += op.offsetTop;
                    _maybeAdjustScroll(op);
                    op = op.offsetParent === container ? null : op.offsetParent;
                }
                if (container != null && (container.scrollTop > 0 || container.scrollLeft > 0)) {
                    var pp = jel.offsetParent != null ? this.getStyle(jel.offsetParent, PROPERTY_POSITION) : STATIC, p = this.getStyle(jel, PROPERTY_POSITION);
                    if (p !== ABSOLUTE && p !== FIXED && pp !== ABSOLUTE && pp !== FIXED) {
                        out.x -= container.scrollLeft;
                        out.y -= container.scrollTop;
                    }
                }
                return out;
            }
        }, {
            key: "getSize",
            value: function getSize(el) {
                var _el = el;
                if (_el.offsetWidth != null) {
                    return offsetSize(el);
                }
                else if (_el.width && _el.width.baseVal) {
                    return svgWidthHeightSize(_el);
                }
            }
        }, {
            key: "getPosition",
            value: function getPosition(el) {
                var _el = el;
                if (_el.offsetLeft != null) {
                    return {
                        x: parseFloat(_el.offsetLeft),
                        y: parseFloat(_el.offsetTop)
                    };
                }
                else if (_el.x && _el.x.baseVal) {
                    return svgXYPosition(_el);
                }
            }
        }, {
            key: "getStyle",
            value: function getStyle(el, prop) {
                if (_typeof(window.getComputedStyle) !== UNDEFINED) {
                    return getComputedStyle(el, null).getPropertyValue(prop);
                }
                else {
                    return el.currentStyle[prop];
                }
            }
        }, {
            key: "getGroupContentArea",
            value: function getGroupContentArea(group) {
                var da = this.getSelector(group.el, SELECTOR_GROUP_CONTAINER);
                return da && da.length > 0 ? da[0] : group.el;
            }
        }, {
            key: "getSelector",
            value: function getSelector(ctx, spec) {
                var sel = null;
                if (arguments.length === 1) {
                    if (!isString$1(ctx)) {
                        var nodeList = document.createDocumentFragment();
                        nodeList.appendChild(ctx);
                        return fromArray(nodeList.childNodes);
                    }
                    sel = fromArray(document.querySelectorAll(ctx));
                }
                else {
                    sel = fromArray(ctx.querySelectorAll(spec));
                }
                return sel;
            }
        }, {
            key: "setPosition",
            value: function setPosition(el, p) {
                var jel = el;
                jel.style.left = p.x + "px";
                jel.style.top = p.y + "px";
            }
        }, {
            key: "setDraggable",
            value: function setDraggable(element, draggable) {
                if (draggable) {
                    this.removeAttribute(element, ATTRIBUTE_NOT_DRAGGABLE);
                }
                else {
                    this.setAttribute(element, ATTRIBUTE_NOT_DRAGGABLE, TRUE$1);
                }
            }
        }, {
            key: "isDraggable",
            value: function isDraggable(el) {
                var d = this.getAttribute(el, ATTRIBUTE_NOT_DRAGGABLE);
                return d == null || d === FALSE$1;
            }
        }, {
            key: "toggleDraggable",
            value: function toggleDraggable(el) {
                var state = this.isDraggable(el);
                this.setDraggable(el, !state);
                return !state;
            }
        }, {
            key: "_createEventListeners",
            value: function _createEventListeners() {
                var _connClick = function _connClick(event, e) {
                    if (!e.defaultPrevented && e._jsPlumbOverlay == null) {
                        var connectorElement = findParent(getEventSource(e), SELECTOR_CONNECTOR, this.getContainer(), true);
                        this.fire(event, connectorElement.jtk.connector.connection, e);
                    }
                };
                this._connectorClick = _connClick.bind(this, EVENT_CONNECTION_CLICK);
                this._connectorDblClick = _connClick.bind(this, EVENT_CONNECTION_DBL_CLICK);
                this._connectorTap = _connClick.bind(this, EVENT_CONNECTION_TAP);
                this._connectorDblTap = _connClick.bind(this, EVENT_CONNECTION_DBL_TAP);
                var _connectorHover = function _connectorHover(state, e) {
                    var el = getEventSource(e).parentNode;
                    if (el.jtk && el.jtk.connector) {
                        var connector = el.jtk.connector;
                        var connection = connector.connection;
                        this.setConnectorHover(connector, state);
                        if (state) {
                            this.addClass(connection.source, this.hoverSourceClass);
                            this.addClass(connection.target, this.hoverTargetClass);
                        }
                        else {
                            this.removeClass(connection.source, this.hoverSourceClass);
                            this.removeClass(connection.target, this.hoverTargetClass);
                        }
                        this.fire(state ? EVENT_CONNECTION_MOUSEOVER : EVENT_CONNECTION_MOUSEOUT, el.jtk.connector.connection, e);
                    }
                };
                this._connectorMouseover = _connectorHover.bind(this, true);
                this._connectorMouseout = _connectorHover.bind(this, false);
                var _connectorMouseupdown = function _connectorMouseupdown(state, e) {
                    var el = getEventSource(e).parentNode;
                    if (el.jtk && el.jtk.connector) {
                        this.fire(state ? EVENT_CONNECTION_MOUSEUP : EVENT_CONNECTION_MOUSEDOWN, el.jtk.connector.connection, e);
                    }
                };
                this._connectorMouseup = _connectorMouseupdown.bind(this, true);
                this._connectorMousedown = _connectorMouseupdown.bind(this, false);
                this._connectorContextmenu = function (e) {
                    var el = getEventSource(e).parentNode;
                    if (el.jtk && el.jtk.connector) {
                        this.fire(EVENT_CONNECTION_CONTEXTMENU, el.jtk.connector.connection, e);
                    }
                }.bind(this);
                var _epClick = function _epClick(event, e, endpointElement) {
                    if (!e.defaultPrevented && e._jsPlumbOverlay == null) {
                        this.fire(event, endpointElement.jtk.endpoint, e);
                    }
                };
                this._endpointClick = _epClick.bind(this, EVENT_ENDPOINT_CLICK);
                this._endpointDblClick = _epClick.bind(this, EVENT_ENDPOINT_DBL_CLICK);
                var _endpointHover = function _endpointHover(state, e) {
                    var el = getEventSource(e);
                    if (el.jtk && el.jtk.endpoint) {
                        this.setEndpointHover(el.jtk.endpoint, state);
                        this.fire(state ? EVENT_ENDPOINT_MOUSEOVER : EVENT_ENDPOINT_MOUSEOUT, el.jtk.endpoint, e);
                    }
                };
                this._endpointMouseover = _endpointHover.bind(this, true);
                this._endpointMouseout = _endpointHover.bind(this, false);
                var _endpointMouseupdown = function _endpointMouseupdown(state, e) {
                    var el = getEventSource(e);
                    if (el.jtk && el.jtk.endpoint) {
                        this.fire(state ? EVENT_ENDPOINT_MOUSEUP : EVENT_ENDPOINT_MOUSEDOWN, el.jtk.endpoint, e);
                    }
                };
                this._endpointMouseup = _endpointMouseupdown.bind(this, true);
                this._endpointMousedown = _endpointMouseupdown.bind(this, false);
                var _oClick = function (method, e) {
                    var overlayElement = findParent(getEventSource(e), SELECTOR_OVERLAY, this.getContainer(), true);
                    var overlay = overlayElement.jtk.overlay;
                    if (overlay) {
                        this.fireOverlayMethod(overlay, method, e);
                    }
                }.bind(this);
                this._overlayClick = _oClick.bind(this, EVENT_CLICK);
                this._overlayDblClick = _oClick.bind(this, EVENT_DBL_CLICK);
                this._overlayTap = _oClick.bind(this, EVENT_TAP);
                this._overlayDblTap = _oClick.bind(this, EVENT_DBL_TAP);
                var _overlayHover = function _overlayHover(state, e) {
                    var overlayElement = findParent(getEventSource(e), SELECTOR_OVERLAY, this.getContainer(), true);
                    var overlay = overlayElement.jtk.overlay;
                    if (overlay) {
                        this.setOverlayHover(overlay, state);
                    }
                };
                this._overlayMouseover = _overlayHover.bind(this, true);
                this._overlayMouseout = _overlayHover.bind(this, false);
                var _elementClick = function _elementClick(event, e, target) {
                    if (!e.defaultPrevented) {
                        this.fire(e.detail === 1 ? EVENT_ELEMENT_CLICK : EVENT_ELEMENT_DBL_CLICK, target, e);
                    }
                };
                this._elementClick = _elementClick.bind(this, EVENT_ELEMENT_CLICK);
                var _elementTap = function _elementTap(event, e, target) {
                    if (!e.defaultPrevented) {
                        this.fire(EVENT_ELEMENT_TAP, target, e);
                    }
                };
                this._elementTap = _elementTap.bind(this, EVENT_ELEMENT_TAP);
                var _elementDblTap = function _elementDblTap(event, e, target) {
                    if (!e.defaultPrevented) {
                        this.fire(EVENT_ELEMENT_DBL_TAP, target, e);
                    }
                };
                this._elementDblTap = _elementDblTap.bind(this, EVENT_ELEMENT_DBL_TAP);
                var _elementHover = function _elementHover(state, e) {
                    this.fire(state ? EVENT_ELEMENT_MOUSE_OVER : EVENT_ELEMENT_MOUSE_OUT, getEventSource(e), e);
                };
                this._elementMouseenter = _elementHover.bind(this, true);
                this._elementMouseexit = _elementHover.bind(this, false);
                this._elementMousemove = function (e) {
                    this.fire(EVENT_ELEMENT_MOUSE_MOVE, getEventSource(e), e);
                }.bind(this);
                this._elementMouseup = function (e) {
                    this.fire(EVENT_ELEMENT_MOUSE_UP, getEventSource(e), e);
                }.bind(this);
                this._elementMousedown = function (e) {
                    this.fire(EVENT_ELEMENT_MOUSE_DOWN, getEventSource(e), e);
                }.bind(this);
                this._elementContextmenu = function (e) {
                    this.fire(EVENT_ELEMENT_CONTEXTMENU, getEventSource(e), e);
                }.bind(this);
            }
        }, {
            key: "_attachEventDelegates",
            value: function _attachEventDelegates() {
                var currentContainer = this.getContainer();
                this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_OVERLAY, this._overlayClick);
                this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_OVERLAY, this._overlayDblClick);
                this.eventManager.on(currentContainer, EVENT_TAP, SELECTOR_OVERLAY, this._overlayTap);
                this.eventManager.on(currentContainer, EVENT_DBL_TAP, SELECTOR_OVERLAY, this._overlayDblTap);
                this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_CONNECTOR, this._connectorClick);
                this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_CONNECTOR, this._connectorDblClick);
                this.eventManager.on(currentContainer, EVENT_TAP, SELECTOR_CONNECTOR, this._connectorTap);
                this.eventManager.on(currentContainer, EVENT_DBL_TAP, SELECTOR_CONNECTOR, this._connectorDblTap);
                this.eventManager.on(currentContainer, EVENT_CLICK, SELECTOR_ENDPOINT, this._endpointClick);
                this.eventManager.on(currentContainer, EVENT_DBL_CLICK, SELECTOR_ENDPOINT, this._endpointDblClick);
                this.eventManager.on(currentContainer, EVENT_CLICK, this.managedElementsSelector, this._elementClick);
                this.eventManager.on(currentContainer, EVENT_TAP, this.managedElementsSelector, this._elementTap);
                this.eventManager.on(currentContainer, EVENT_DBL_TAP, this.managedElementsSelector, this._elementDblTap);
                this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_CONNECTOR, this._connectorMouseover);
                this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_CONNECTOR, this._connectorMouseout);
                this.eventManager.on(currentContainer, EVENT_CONTEXTMENU, SELECTOR_CONNECTOR, this._connectorContextmenu);
                this.eventManager.on(currentContainer, EVENT_MOUSEUP, SELECTOR_CONNECTOR, this._connectorMouseup);
                this.eventManager.on(currentContainer, EVENT_MOUSEDOWN, SELECTOR_CONNECTOR, this._connectorMousedown);
                this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_ENDPOINT, this._endpointMouseover);
                this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_ENDPOINT, this._endpointMouseout);
                this.eventManager.on(currentContainer, EVENT_MOUSEUP, SELECTOR_ENDPOINT, this._endpointMouseup);
                this.eventManager.on(currentContainer, EVENT_MOUSEDOWN, SELECTOR_ENDPOINT, this._endpointMousedown);
                this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_OVERLAY, this._overlayMouseover);
                this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_OVERLAY, this._overlayMouseout);
                this.eventManager.on(currentContainer, EVENT_MOUSEOVER, SELECTOR_MANAGED_ELEMENT, this._elementMouseenter);
                this.eventManager.on(currentContainer, EVENT_MOUSEOUT, SELECTOR_MANAGED_ELEMENT, this._elementMouseexit);
                this.eventManager.on(currentContainer, EVENT_MOUSEMOVE, SELECTOR_MANAGED_ELEMENT, this._elementMousemove);
                this.eventManager.on(currentContainer, EVENT_MOUSEUP, SELECTOR_MANAGED_ELEMENT, this._elementMouseup);
                this.eventManager.on(currentContainer, EVENT_MOUSEDOWN, SELECTOR_MANAGED_ELEMENT, this._elementMousedown);
                this.eventManager.on(currentContainer, EVENT_CONTEXTMENU, SELECTOR_MANAGED_ELEMENT, this._elementContextmenu);
            }
        }, {
            key: "_detachEventDelegates",
            value: function _detachEventDelegates() {
                var currentContainer = this.getContainer();
                if (currentContainer) {
                    this.eventManager.off(currentContainer, EVENT_CLICK, this._connectorClick);
                    this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._connectorDblClick);
                    this.eventManager.off(currentContainer, EVENT_TAP, this._connectorTap);
                    this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._connectorDblTap);
                    this.eventManager.off(currentContainer, EVENT_CLICK, this._endpointClick);
                    this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._endpointDblClick);
                    this.eventManager.off(currentContainer, EVENT_CLICK, this._overlayClick);
                    this.eventManager.off(currentContainer, EVENT_DBL_CLICK, this._overlayDblClick);
                    this.eventManager.off(currentContainer, EVENT_TAP, this._overlayTap);
                    this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._overlayDblTap);
                    this.eventManager.off(currentContainer, EVENT_CLICK, this._elementClick);
                    this.eventManager.off(currentContainer, EVENT_TAP, this._elementTap);
                    this.eventManager.off(currentContainer, EVENT_DBL_TAP, this._elementDblTap);
                    this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._connectorMouseover);
                    this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._connectorMouseout);
                    this.eventManager.off(currentContainer, EVENT_CONTEXTMENU, this._connectorContextmenu);
                    this.eventManager.off(currentContainer, EVENT_MOUSEUP, this._connectorMouseup);
                    this.eventManager.off(currentContainer, EVENT_MOUSEDOWN, this._connectorMousedown);
                    this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._endpointMouseover);
                    this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._endpointMouseout);
                    this.eventManager.off(currentContainer, EVENT_MOUSEUP, this._endpointMouseup);
                    this.eventManager.off(currentContainer, EVENT_MOUSEDOWN, this._endpointMousedown);
                    this.eventManager.off(currentContainer, EVENT_MOUSEOVER, this._overlayMouseover);
                    this.eventManager.off(currentContainer, EVENT_MOUSEOUT, this._overlayMouseout);
                    this.eventManager.off(currentContainer, EVENT_MOUSEENTER, this._elementMouseenter);
                    this.eventManager.off(currentContainer, EVENT_MOUSEEXIT, this._elementMouseexit);
                    this.eventManager.off(currentContainer, EVENT_MOUSEMOVE, this._elementMousemove);
                    this.eventManager.off(currentContainer, EVENT_MOUSEUP, this._elementMouseup);
                    this.eventManager.off(currentContainer, EVENT_MOUSEDOWN, this._elementMousedown);
                    this.eventManager.off(currentContainer, EVENT_CONTEXTMENU, this._elementContextmenu);
                }
            }
        }, {
            key: "setContainer",
            value: function setContainer(newContainer) {
                var _this4 = this;
                if (newContainer === document || newContainer === document.body) {
                    throw new Error("Cannot set document or document.body as container element");
                }
                this._detachEventDelegates();
                var dragFilters;
                if (this.dragManager != null) {
                    dragFilters = this.dragManager.reset();
                }
                this.setAttribute(newContainer, ATTRIBUTE_CONTAINER, uuid().replace("-", ""));
                var currentContainer = this.getContainer();
                if (currentContainer != null) {
                    currentContainer.removeAttribute(ATTRIBUTE_CONTAINER);
                    var children = fromArray(currentContainer.childNodes).filter(function (cn) {
                        return cn != null && (_this4.hasClass(cn, CLASS_CONNECTOR) || _this4.hasClass(cn, CLASS_ENDPOINT) || _this4.hasClass(cn, CLASS_OVERLAY) || cn.getAttribute && cn.getAttribute(ATTRIBUTE_MANAGED) != null);
                    });
                    forEach$1(children, function (el) {
                        newContainer.appendChild(el);
                    });
                }
                _get(_getPrototypeOf$2(BrowserJsPlumbInstance.prototype), "setContainer", this).call(this, newContainer);
                this.containerType = getElementType(newContainer);
                if (this.eventManager != null) {
                    this._attachEventDelegates();
                }
                if (this.dragManager != null) {
                    this.dragManager.addHandler(new EndpointDragHandler(this));
                    this.dragManager.addHandler(new GroupDragHandler(this, this.dragSelection), this.groupDragOptions);
                    this.elementDragHandler = new ElementDragHandler(this, this.dragSelection);
                    this.dragManager.addHandler(this.elementDragHandler, this.elementDragOptions);
                    if (dragFilters != null) {
                        this.dragManager.setFilters(dragFilters);
                    }
                }
            }
        }, {
            key: "reset",
            value: function reset() {
                _get(_getPrototypeOf$2(BrowserJsPlumbInstance.prototype), "reset", this).call(this);
                if (this._resizeObserver) {
                    this._resizeObserver.disconnect();
                }
                var container = this.getContainer();
                var els = container.querySelectorAll([SELECTOR_MANAGED_ELEMENT, SELECTOR_ENDPOINT, SELECTOR_CONNECTOR, SELECTOR_OVERLAY].join(","));
                forEach$1(els, function (el) {
                    return el.parentNode && el.parentNode.removeChild(el);
                });
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this._detachEventDelegates();
                if (this.dragManager != null) {
                    this.dragManager.reset();
                }
                this.clearDragSelection();
                _get(_getPrototypeOf$2(BrowserJsPlumbInstance.prototype), "destroy", this).call(this);
            }
        }, {
            key: "unmanage",
            value: function unmanage(el, removeElement) {
                if (this._resizeObserver != null) {
                    this._resizeObserver.unobserve(el);
                }
                this.removeFromDragSelection(el);
                _get(_getPrototypeOf$2(BrowserJsPlumbInstance.prototype), "unmanage", this).call(this, el, removeElement);
            }
        }, {
            key: "addToDragSelection",
            value: function addToDragSelection() {
                var _this5 = this;
                for (var _len = arguments.length, el = new Array(_len), _key = 0; _key < _len; _key++) {
                    el[_key] = arguments[_key];
                }
                forEach$1(el, function (_el) {
                    return _this5.dragSelection.add(_el);
                });
            }
        }, {
            key: "clearDragSelection",
            value: function clearDragSelection() {
                this.dragSelection.clear();
            }
        }, {
            key: "removeFromDragSelection",
            value: function removeFromDragSelection() {
                var _this6 = this;
                for (var _len2 = arguments.length, el = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    el[_key2] = arguments[_key2];
                }
                forEach$1(el, function (_el) {
                    return _this6.dragSelection.remove(_el);
                });
            }
        }, {
            key: "toggleDragSelection",
            value: function toggleDragSelection() {
                var _this7 = this;
                for (var _len3 = arguments.length, el = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                    el[_key3] = arguments[_key3];
                }
                forEach$1(el, function (_el) {
                    return _this7.dragSelection.toggle(_el);
                });
            }
        }, {
            key: "addToDragGroup",
            value: function addToDragGroup(spec) {
                var _this$elementDragHand;
                for (var _len4 = arguments.length, els = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
                    els[_key4 - 1] = arguments[_key4];
                }
                (_this$elementDragHand = this.elementDragHandler).addToDragGroup.apply(_this$elementDragHand, [spec].concat(els));
            }
        }, {
            key: "removeFromDragGroup",
            value: function removeFromDragGroup() {
                var _this$elementDragHand2;
                (_this$elementDragHand2 = this.elementDragHandler).removeFromDragGroup.apply(_this$elementDragHand2, arguments);
            }
        }, {
            key: "setDragGroupState",
            value: function setDragGroupState(state) {
                var _this$elementDragHand3;
                for (var _len5 = arguments.length, els = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
                    els[_key5 - 1] = arguments[_key5];
                }
                (_this$elementDragHand3 = this.elementDragHandler).setDragGroupState.apply(_this$elementDragHand3, [state].concat(els));
            }
        }, {
            key: "clearDragGroup",
            value: function clearDragGroup(name) {
                this.elementDragHandler.clearDragGroup(name);
            }
        }, {
            key: "consume",
            value: function consume$1(e, doNotPreventDefault) {
                consume(e, doNotPreventDefault);
            }
        }, {
            key: "rotate",
            value: function rotate(element, rotation, doNotRepaint) {
                var elementId = this.getId(element);
                if (this._managedElements[elementId]) {
                    this._managedElements[elementId].el.style.transform = "rotate(" + rotation + "deg)";
                    this._managedElements[elementId].el.style.transformOrigin = "center center";
                    return _get(_getPrototypeOf$2(BrowserJsPlumbInstance.prototype), "rotate", this).call(this, element, rotation, doNotRepaint);
                }
                return {
                    c: new Set(),
                    e: new Set()
                };
            }
        }, {
            key: "addOverlayClass",
            value: function addOverlayClass(o, clazz) {
                if (isLabelOverlay(o)) {
                    o.instance.addClass(getLabelElement(o), clazz);
                }
                else if (isSVGElementOverlay(o)) {
                    o.instance.addClass(ensureSVGOverlayPath(o), clazz);
                }
                else if (isCustomOverlay(o)) {
                    o.instance.addClass(getCustomElement(o), clazz);
                }
                else {
                    throw "Could not add class to overlay of type [" + o.type + "]";
                }
            }
        }, {
            key: "removeOverlayClass",
            value: function removeOverlayClass(o, clazz) {
                if (isLabelOverlay(o)) {
                    o.instance.removeClass(getLabelElement(o), clazz);
                }
                else if (isSVGElementOverlay(o)) {
                    o.instance.removeClass(ensureSVGOverlayPath(o), clazz);
                }
                else if (isCustomOverlay(o)) {
                    o.instance.removeClass(getCustomElement(o), clazz);
                }
                else {
                    throw "Could not remove class from overlay of type [" + o.type + "]";
                }
            }
        }, {
            key: "_paintOverlay",
            value: function _paintOverlay(o, params, extents) {
                if (isLabelOverlay(o)) {
                    getLabelElement(o);
                    var XY = o.component.getXY();
                    o.canvas.style.left = XY.x + params.d.minx + "px";
                    o.canvas.style.top = XY.y + params.d.miny + "px";
                }
                else if (isSVGElementOverlay(o)) {
                    var path = isNaN(params.d.cxy.x) || isNaN(params.d.cxy.y) ? "M 0 0" : "M" + params.d.hxy.x + "," + params.d.hxy.y + " L" + params.d.tail[0].x + "," + params.d.tail[0].y + " L" + params.d.cxy.x + "," + params.d.cxy.y + " L" + params.d.tail[1].x + "," + params.d.tail[1].y + " Z";
                    paintSVGOverlay(o, path, params, extents);
                }
                else if (isCustomOverlay(o)) {
                    getCustomElement(o);
                    var _XY = o.component.getXY();
                    o.canvas.style.left = _XY.x + params.d.minx + "px";
                    o.canvas.style.top = _XY.y + params.d.miny + "px";
                }
                else {
                    throw "Could not paint overlay of type [" + o.type + "]";
                }
            }
        }, {
            key: "setOverlayVisible",
            value: function setOverlayVisible(o, visible) {
                var d = visible ? "block" : "none";
                function s(el) {
                    if (el != null) {
                        el.style.display = d;
                    }
                }
                if (isLabelOverlay(o)) {
                    s(getLabelElement(o));
                }
                else if (isCustomOverlay(o)) {
                    s(getCustomElement(o));
                }
                else if (isSVGElementOverlay(o)) {
                    s(o.path);
                }
            }
        }, {
            key: "reattachOverlay",
            value: function reattachOverlay(o, c) {
                if (isLabelOverlay(o)) {
                    o.instance._appendElement(getLabelElement(o), this.getContainer());
                }
                else if (isCustomOverlay(o)) {
                    o.instance._appendElement(getCustomElement(o), this.getContainer());
                }
                else if (isSVGElementOverlay(o)) {
                    this._appendElement(ensureSVGOverlayPath(o), c.connector.canvas);
                }
            }
        }, {
            key: "setOverlayHover",
            value: function setOverlayHover(o, hover) {
                var canvas;
                if (isLabelOverlay(o)) {
                    canvas = getLabelElement(o);
                }
                else if (isCustomOverlay(o)) {
                    canvas = getCustomElement(o);
                }
                else if (isSVGElementOverlay(o)) {
                    canvas = ensureSVGOverlayPath(o);
                }
                if (canvas != null) {
                    if (this.hoverClass != null) {
                        if (hover) {
                            this.addClass(canvas, this.hoverClass);
                        }
                        else {
                            this.removeClass(canvas, this.hoverClass);
                        }
                    }
                    this.setHover(o.component, hover);
                }
            }
        }, {
            key: "destroyOverlay",
            value: function destroyOverlay(o) {
                if (isLabelOverlay(o)) {
                    var _el2 = getLabelElement(o);
                    _el2.parentNode.removeChild(_el2);
                    delete o.canvas;
                    delete o.cachedDimensions;
                }
                else if (isArrowOverlay(o) || isDiamondOverlay(o) || isPlainArrowOverlay(o)) {
                    destroySVGOverlay(o);
                }
                else if (isCustomOverlay(o)) {
                    var _el3 = getCustomElement(o);
                    _el3.parentNode.removeChild(_el3);
                    delete o.canvas;
                    delete o.cachedDimensions;
                }
            }
        }, {
            key: "drawOverlay",
            value: function drawOverlay(o, component, paintStyle, absolutePosition) {
                if (isLabelOverlay(o) || isCustomOverlay(o)) {
                    var td = HTMLElementOverlay._getDimensions(o);
                    if (td != null && td.w != null && td.h != null) {
                        var cxy = {
                            x: 0,
                            y: 0
                        };
                        if (absolutePosition) {
                            cxy = {
                                x: absolutePosition.x,
                                y: absolutePosition.y
                            };
                        }
                        else if (component instanceof EndpointRepresentation) {
                            var locToUse = Array.isArray(o.location) ? o.location : [o.location, o.location];
                            cxy = {
                                x: locToUse[0] * component.w,
                                y: locToUse[1] * component.h
                            };
                        }
                        else {
                            var loc = o.location, absolute = false;
                            if (isString$1(o.location) || o.location < 0 || o.location > 1) {
                                loc = parseInt("" + o.location, 10);
                                absolute = true;
                            }
                            cxy = component.pointOnPath(loc, absolute);
                        }
                        var minx = cxy.x - td.w / 2, miny = cxy.y - td.h / 2;
                        return {
                            component: o,
                            d: {
                                minx: minx,
                                miny: miny,
                                td: td,
                                cxy: cxy
                            },
                            xmin: minx,
                            xmax: minx + td.w,
                            ymin: miny,
                            ymax: miny + td.h
                        };
                    }
                    else {
                        return {
                            xmin: 0,
                            xmax: 0,
                            ymin: 0,
                            ymax: 0
                        };
                    }
                }
                else if (isArrowOverlay(o) || isDiamondOverlay(o) || isPlainArrowOverlay(o)) {
                    return o.draw(component, paintStyle, absolutePosition);
                }
                else {
                    throw "Could not draw overlay of type [" + o.type + "]";
                }
            }
        }, {
            key: "updateLabel",
            value: function updateLabel(o) {
                if (isFunction$1(o.label)) {
                    var lt = o.label(this);
                    if (lt != null) {
                        getLabelElement(o).innerText = lt;
                    }
                    else {
                        getLabelElement(o).innerText = "";
                    }
                }
                else {
                    if (o.labelText == null) {
                        o.labelText = o.label;
                        if (o.labelText != null) {
                            getLabelElement(o).innerText = o.labelText;
                        }
                        else {
                            getLabelElement(o).innerText = "";
                        }
                    }
                }
            }
        }, {
            key: "setHover",
            value: function setHover(component, hover) {
                component._hover = hover;
                if (component instanceof Endpoint && component.endpoint != null) {
                    this.setEndpointHover(component, hover, -1);
                }
                else if (component instanceof Connection && component.connector != null) {
                    this.setConnectorHover(component.connector, hover);
                }
            }
        }, {
            key: "paintConnector",
            value: function paintConnector(connector, paintStyle, extents) {
                paintSvgConnector(this, connector, paintStyle, extents);
            }
        }, {
            key: "setConnectorHover",
            value: function setConnectorHover(connector, hover, sourceEndpoint) {
                if (hover === false || !this.currentlyDragging && !this.isHoverSuspended()) {
                    var canvas = connector.canvas;
                    if (canvas != null) {
                        if (connector.hoverClass != null) {
                            if (hover) {
                                this.addClass(canvas, connector.hoverClass);
                            }
                            else {
                                this.removeClass(canvas, connector.hoverClass);
                            }
                        }
                        if (hover) {
                            this.addClass(canvas, this.hoverClass);
                        }
                        else {
                            this.removeClass(canvas, this.hoverClass);
                        }
                    }
                    if (connector.connection.hoverPaintStyle != null) {
                        connector.connection.paintStyleInUse = hover ? connector.connection.hoverPaintStyle : connector.connection.paintStyle;
                        if (!this._suspendDrawing) {
                            this._paintConnection(connector.connection);
                        }
                    }
                    if (connector.connection.endpoints[0] !== sourceEndpoint) {
                        this.setEndpointHover(connector.connection.endpoints[0], hover, 0, true);
                    }
                    if (connector.connection.endpoints[1] !== sourceEndpoint) {
                        this.setEndpointHover(connector.connection.endpoints[1], hover, 1, true);
                    }
                }
            }
        }, {
            key: "destroyConnector",
            value: function destroyConnector(connection) {
                if (connection.connector != null) {
                    cleanup(connection.connector);
                }
            }
        }, {
            key: "addConnectorClass",
            value: function addConnectorClass(connector, clazz) {
                if (connector.canvas) {
                    this.addClass(connector.canvas, clazz);
                }
            }
        }, {
            key: "removeConnectorClass",
            value: function removeConnectorClass(connector, clazz) {
                if (connector.canvas) {
                    this.removeClass(connector.canvas, clazz);
                }
            }
        }, {
            key: "getConnectorClass",
            value: function getConnectorClass(connector) {
                if (connector.canvas) {
                    return connector.canvas.className.baseVal;
                }
                else {
                    return "";
                }
            }
        }, {
            key: "setConnectorVisible",
            value: function setConnectorVisible(connector, v) {
                setVisible(connector, v);
            }
        }, {
            key: "applyConnectorType",
            value: function applyConnectorType(connector, t) {
                if (connector.canvas && t.cssClass) {
                    var classes = Array.isArray(t.cssClass) ? t.cssClass : [t.cssClass];
                    this.addClass(connector.canvas, classes.join(" "));
                }
            }
        }, {
            key: "addEndpointClass",
            value: function addEndpointClass(ep, c) {
                var canvas = getEndpointCanvas(ep.endpoint);
                if (canvas != null) {
                    this.addClass(canvas, c);
                }
            }
        }, {
            key: "applyEndpointType",
            value: function applyEndpointType(ep, t) {
                if (t.cssClass) {
                    var canvas = getEndpointCanvas(ep.endpoint);
                    if (canvas) {
                        var classes = Array.isArray(t.cssClass) ? t.cssClass : [t.cssClass];
                        this.addClass(canvas, classes.join(" "));
                    }
                }
            }
        }, {
            key: "destroyEndpoint",
            value: function destroyEndpoint(ep) {
                var anchorClass = this.endpointAnchorClassPrefix + (ep.currentAnchorClass ? "-" + ep.currentAnchorClass : "");
                this.removeClass(ep.element, anchorClass);
                cleanup(ep.endpoint);
            }
        }, {
            key: "renderEndpoint",
            value: function renderEndpoint(ep, paintStyle) {
                var renderer = endpointMap[ep.endpoint.type];
                if (renderer != null) {
                    SvgEndpoint.paint(ep.endpoint, renderer, paintStyle);
                }
                else {
                    log("jsPlumb: no endpoint renderer found for type [" + ep.endpoint.type + "]");
                }
            }
        }, {
            key: "removeEndpointClass",
            value: function removeEndpointClass(ep, c) {
                var canvas = getEndpointCanvas(ep.endpoint);
                if (canvas != null) {
                    this.removeClass(canvas, c);
                }
            }
        }, {
            key: "getEndpointClass",
            value: function getEndpointClass(ep) {
                var canvas = getEndpointCanvas(ep.endpoint);
                if (canvas != null) {
                    return canvas.className;
                }
                else {
                    return "";
                }
            }
        }, {
            key: "setEndpointHover",
            value: function setEndpointHover(endpoint, hover, endpointIndex, doNotCascade) {
                if (endpoint != null && (hover === false || !this.currentlyDragging && !this.isHoverSuspended())) {
                    var canvas = getEndpointCanvas(endpoint.endpoint);
                    if (canvas != null) {
                        if (endpoint.hoverClass != null) {
                            if (hover) {
                                this.addClass(canvas, endpoint.hoverClass);
                            }
                            else {
                                this.removeClass(canvas, endpoint.hoverClass);
                            }
                        }
                        if (endpointIndex === 0 || endpointIndex === 1) {
                            var genericHoverClass = endpointIndex === 0 ? this.hoverSourceClass : this.hoverTargetClass;
                            if (hover) {
                                this.addClass(canvas, genericHoverClass);
                            }
                            else {
                                this.removeClass(canvas, genericHoverClass);
                            }
                        }
                    }
                    if (endpoint.hoverPaintStyle != null) {
                        endpoint.paintStyleInUse = hover ? endpoint.hoverPaintStyle : endpoint.paintStyle;
                        if (!this._suspendDrawing) {
                            this.renderEndpoint(endpoint, endpoint.paintStyleInUse);
                        }
                    }
                    if (!doNotCascade) {
                        for (var i = 0; i < endpoint.connections.length; i++) {
                            this.setConnectorHover(endpoint.connections[i].connector, hover, endpoint);
                        }
                    }
                }
            }
        }, {
            key: "setEndpointVisible",
            value: function setEndpointVisible(ep, v) {
                setVisible(ep.endpoint, v);
            }
        }, {
            key: "setGroupVisible",
            value: function setGroupVisible(group, state) {
                var m = group.el.querySelectorAll(SELECTOR_MANAGED_ELEMENT);
                for (var i = 0; i < m.length; i++) {
                    if (state) {
                        this.show(m[i], true);
                    }
                    else {
                        this.hide(m[i], true);
                    }
                }
            }
        }, {
            key: "deleteConnection",
            value: function deleteConnection(connection, params) {
                if (connection != null && connection.deleted !== true) {
                    if (connection.endpoints[0].deleted !== true) {
                        this.setEndpointHover(connection.endpoints[0], false, 0, true);
                    }
                    if (connection.endpoints[1].deleted !== true) {
                        this.setEndpointHover(connection.endpoints[1], false, 1, true);
                    }
                    return _get(_getPrototypeOf$2(BrowserJsPlumbInstance.prototype), "deleteConnection", this).call(this, connection, params);
                }
                else {
                    return false;
                }
            }
        }, {
            key: "addSourceSelector",
            value: function addSourceSelector(selector, params, exclude) {
                this.addDragFilter(selector);
                return _get(_getPrototypeOf$2(BrowserJsPlumbInstance.prototype), "addSourceSelector", this).call(this, selector, params, exclude);
            }
        }, {
            key: "removeSourceSelector",
            value: function removeSourceSelector(selector) {
                this.removeDragFilter(selector.selector);
                _get(_getPrototypeOf$2(BrowserJsPlumbInstance.prototype), "removeSourceSelector", this).call(this, selector);
            }
        }, {
            key: "manage",
            value: function manage(element, internalId, _recalc) {
                if (this.containerType === ElementTypes.SVG && !isSVGElement(element)) {
                    throw new Error("ERROR: cannot manage non-svg element when container is an SVG element.");
                }
                var managedElement = _get(_getPrototypeOf$2(BrowserJsPlumbInstance.prototype), "manage", this).call(this, element, internalId, _recalc);
                if (managedElement != null) {
                    if (this._resizeObserver != null) {
                        this._resizeObserver.observe(managedElement.el);
                    }
                }
                return managedElement;
            }
        }]);
    return BrowserJsPlumbInstance;
}(JsPlumbInstance);
var CIRCLE = "circle";
var register$2 = function register() {
    registerEndpointRenderer(DotEndpoint.type, {
        makeNode: function makeNode(ep, style) {
            return _node(CIRCLE, {
                "cx": ep.w / 2,
                "cy": ep.h / 2,
                "r": ep.radius
            });
        },
        updateNode: function updateNode(ep, node) {
            _attr(node, {
                "cx": "" + ep.w / 2,
                "cy": "" + ep.h / 2,
                "r": "" + ep.radius
            });
        }
    });
};
var RECT = "rect";
var register$1 = function register() {
    registerEndpointRenderer(RectangleEndpoint.type, {
        makeNode: function makeNode(ep, style) {
            return _node(RECT, {
                "width": ep.w,
                "height": ep.h
            });
        },
        updateNode: function updateNode(ep, node) {
            _attr(node, {
                "width": ep.w,
                "height": ep.h
            });
        }
    });
};
var BLANK_ATTRIBUTES = {
    "width": 10,
    "height": 0,
    "fill": "transparent",
    "stroke": "transparent"
};
var register = function register() {
    registerEndpointRenderer(BlankEndpoint.type, {
        makeNode: function makeNode(ep, style) {
            return _node("rect", BLANK_ATTRIBUTES);
        },
        updateNode: function updateNode(ep, node) {
            _attr(node, BLANK_ATTRIBUTES);
        }
    });
};
register$2();
register();
register$1();
var _jsPlumbInstanceIndex = 0;
function getInstanceIndex() {
    var i = _jsPlumbInstanceIndex + 1;
    _jsPlumbInstanceIndex++;
    return i;
}
function newInstance(defaults) {
    return new BrowserJsPlumbInstance(getInstanceIndex(), defaults);
}
function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
            descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps)
        _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps)
        _defineProperties$1(Constructor, staticProps);
    return Constructor;
}
function _defineProperty$1(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    else {
        obj[key] = value;
    }
    return obj;
}
function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass)
        _setPrototypeOf$1(subClass, superClass);
}
function _getPrototypeOf$1(o) {
    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$1(o);
}
function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf$1(o, p);
}
function _isNativeReflectConstruct$1() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
    if (Reflect.construct.sham)
        return false;
    if (typeof Proxy === "function")
        return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { }));
        return true;
    }
    catch (e) {
        return false;
    }
}
function _assertThisInitialized$1(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _possibleConstructorReturn$1(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized$1(self);
}
function _createSuper$1(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf$1(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf$1(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        }
        else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$1(this, result);
    };
}
var AbstractBezierConnector = function (_AbstractConnector) {
    _inherits$1(AbstractBezierConnector, _AbstractConnector);
    var _super = _createSuper$1(AbstractBezierConnector);
    function AbstractBezierConnector(connection, params) {
        var _this;
        _classCallCheck$1(this, AbstractBezierConnector);
        _this = _super.call(this, connection, params);
        _this.connection = connection;
        _defineProperty$1(_assertThisInitialized$1(_this), "showLoopback", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "curviness", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "margin", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "proximityLimit", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "orientation", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "loopbackRadius", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "clockwise", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "isLoopbackCurrently", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "geometry", null);
        params = params || {};
        _this.showLoopback = params.showLoopback !== false;
        _this.curviness = params.curviness || 10;
        _this.margin = params.margin || 5;
        _this.proximityLimit = params.proximityLimit || 80;
        _this.clockwise = params.orientation && params.orientation === "clockwise";
        _this.loopbackRadius = params.loopbackRadius || 25;
        _this.isLoopbackCurrently = false;
        return _this;
    }
    _createClass$1(AbstractBezierConnector, [{
            key: "getDefaultStubs",
            value: function getDefaultStubs() {
                return [0, 0];
            }
        }, {
            key: "_compute",
            value: function _compute(paintInfo, p) {
                var sp = p.sourcePos, tp = p.targetPos, _w = Math.abs(sp.curX - tp.curX), _h = Math.abs(sp.curY - tp.curY);
                if (!this.showLoopback || p.sourceEndpoint.elementId !== p.targetEndpoint.elementId) {
                    this.isLoopbackCurrently = false;
                    this._computeBezier(paintInfo, p, sp, tp, _w, _h);
                }
                else {
                    this.isLoopbackCurrently = true;
                    var x1 = p.sourcePos.curX, y1 = p.sourcePos.curY - this.margin, cx = x1, cy = y1 - this.loopbackRadius, _x = cx - this.loopbackRadius, _y = cy - this.loopbackRadius;
                    _w = 2 * this.loopbackRadius;
                    _h = 2 * this.loopbackRadius;
                    paintInfo.points[0] = _x;
                    paintInfo.points[1] = _y;
                    paintInfo.points[2] = _w;
                    paintInfo.points[3] = _h;
                    this._addSegment(ArcSegment, {
                        loopback: true,
                        x1: x1 - _x + 4,
                        y1: y1 - _y,
                        startAngle: 0,
                        endAngle: 2 * Math.PI,
                        r: this.loopbackRadius,
                        ac: !this.clockwise,
                        x2: x1 - _x - 4,
                        y2: y1 - _y,
                        cx: cx - _x,
                        cy: cy - _y
                    });
                }
            }
        }, {
            key: "exportGeometry",
            value: function exportGeometry() {
                if (this.geometry == null) {
                    return null;
                }
                else {
                    return {
                        controlPoints: [extend({}, this.geometry.controlPoints[0]), extend({}, this.geometry.controlPoints[1])],
                        source: extend({}, this.geometry.source),
                        target: extend({}, this.geometry.target)
                    };
                }
            }
        }, {
            key: "transformGeometry",
            value: function transformGeometry(g, dx, dy) {
                return {
                    controlPoints: [{
                            x: g.controlPoints[0].x + dx,
                            y: g.controlPoints[0].y + dy
                        }, {
                            x: g.controlPoints[1].x + dx,
                            y: g.controlPoints[1].y + dy
                        }],
                    source: this.transformAnchorPlacement(g.source, dx, dy),
                    target: this.transformAnchorPlacement(g.target, dx, dy)
                };
            }
        }, {
            key: "importGeometry",
            value: function importGeometry(geometry) {
                if (geometry != null) {
                    if (geometry.controlPoints == null || geometry.controlPoints.length != 2) {
                        log("jsPlumb Bezier: cannot import geometry; controlPoints missing or does not have length 2");
                        this.setGeometry(null, true);
                        return false;
                    }
                    if (geometry.controlPoints[0].x == null || geometry.controlPoints[0].y == null || geometry.controlPoints[1].x == null || geometry.controlPoints[1].y == null) {
                        log("jsPlumb Bezier: cannot import geometry; controlPoints malformed");
                        this.setGeometry(null, true);
                        return false;
                    }
                    if (geometry.source == null || geometry.source.curX == null || geometry.source.curY == null) {
                        log("jsPlumb Bezier: cannot import geometry; source missing or malformed");
                        this.setGeometry(null, true);
                        return false;
                    }
                    if (geometry.target == null || geometry.target.curX == null || geometry.target.curY == null) {
                        log("jsPlumb Bezier: cannot import geometry; target missing or malformed");
                        this.setGeometry(null, true);
                        return false;
                    }
                    this.setGeometry(geometry, false);
                    return true;
                }
                else {
                    return false;
                }
            }
        }]);
    return AbstractBezierConnector;
}(AbstractConnector);
var Vectors = {
    subtract: function subtract(v1, v2) {
        return {
            x: v1.x - v2.x,
            y: v1.y - v2.y
        };
    },
    dotProduct: function dotProduct(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y;
    },
    square: function square(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
    },
    scale: function scale(v, s) {
        return {
            x: v.x * s,
            y: v.y * s
        };
    }
};
var maxRecursion = 64;
var flatnessTolerance = Math.pow(2.0, -maxRecursion - 1);
function distanceFromCurve(point, curve) {
    var candidates = [], w = _convertToBezier(point, curve), degree = curve.length - 1, higherDegree = 2 * degree - 1, numSolutions = _findRoots(w, higherDegree, candidates, 0), v = Vectors.subtract(point, curve[0]), dist = Vectors.square(v), t = 0.0, newDist;
    for (var i = 0; i < numSolutions; i++) {
        v = Vectors.subtract(point, _bezier(curve, degree, candidates[i], null, null));
        newDist = Vectors.square(v);
        if (newDist < dist) {
            dist = newDist;
            t = candidates[i];
        }
    }
    v = Vectors.subtract(point, curve[degree]);
    newDist = Vectors.square(v);
    if (newDist < dist) {
        dist = newDist;
        t = 1.0;
    }
    return {
        location: t,
        distance: dist
    };
}
function nearestPointOnCurve(point, curve) {
    var td = distanceFromCurve(point, curve);
    return {
        point: _bezier(curve, curve.length - 1, td.location, null, null),
        location: td.location
    };
}
function _convertToBezier(point, curve) {
    var degree = curve.length - 1, higherDegree = 2 * degree - 1, c = [], d = [], cdTable = [], w = [], z = [[1.0, 0.6, 0.3, 0.1], [0.4, 0.6, 0.6, 0.4], [0.1, 0.3, 0.6, 1.0]];
    for (var i = 0; i <= degree; i++) {
        c[i] = Vectors.subtract(curve[i], point);
    }
    for (var _i = 0; _i <= degree - 1; _i++) {
        d[_i] = Vectors.subtract(curve[_i + 1], curve[_i]);
        d[_i] = Vectors.scale(d[_i], 3.0);
    }
    for (var row = 0; row <= degree - 1; row++) {
        for (var column = 0; column <= degree; column++) {
            if (!cdTable[row])
                cdTable[row] = [];
            cdTable[row][column] = Vectors.dotProduct(d[row], c[column]);
        }
    }
    for (var _i2 = 0; _i2 <= higherDegree; _i2++) {
        if (!w[_i2]) {
            w[_i2] = [];
        }
        w[_i2].y = 0.0;
        w[_i2].x = parseFloat("" + _i2) / higherDegree;
    }
    var n = degree, m = degree - 1;
    for (var k = 0; k <= n + m; k++) {
        var lb = Math.max(0, k - m), ub = Math.min(k, n);
        for (var _i3 = lb; _i3 <= ub; _i3++) {
            var j = k - _i3;
            w[_i3 + j].y += cdTable[j][_i3] * z[j][_i3];
        }
    }
    return w;
}
function _findRoots(w, degree, t, depth) {
    var left = [], right = [], left_count, right_count, left_t = [], right_t = [];
    switch (_getCrossingCount(w, degree)) {
        case 0:
            {
                return 0;
            }
        case 1:
            {
                if (depth >= maxRecursion) {
                    t[0] = (w[0].x + w[degree].x) / 2.0;
                    return 1;
                }
                if (_isFlatEnough(w, degree)) {
                    t[0] = _computeXIntercept(w, degree);
                    return 1;
                }
                break;
            }
    }
    _bezier(w, degree, 0.5, left, right);
    left_count = _findRoots(left, degree, left_t, depth + 1);
    right_count = _findRoots(right, degree, right_t, depth + 1);
    for (var i = 0; i < left_count; i++) {
        t[i] = left_t[i];
    }
    for (var _i4 = 0; _i4 < right_count; _i4++) {
        t[_i4 + left_count] = right_t[_i4];
    }
    return left_count + right_count;
}
function _getCrossingCount(curve, degree) {
    var n_crossings = 0, sign, old_sign;
    sign = old_sign = sgn$1(curve[0].y);
    for (var i = 1; i <= degree; i++) {
        sign = sgn$1(curve[i].y);
        if (sign != old_sign)
            n_crossings++;
        old_sign = sign;
    }
    return n_crossings;
}
function _isFlatEnough(curve, degree) {
    var error, intercept_1, intercept_2, left_intercept, right_intercept, a, b, c, det, dInv, a1, b1, c1, a2, b2, c2;
    a = curve[0].y - curve[degree].y;
    b = curve[degree].x - curve[0].x;
    c = curve[0].x * curve[degree].y - curve[degree].x * curve[0].y;
    var max_distance_above, max_distance_below;
    max_distance_above = max_distance_below = 0.0;
    for (var i = 1; i < degree; i++) {
        var value = a * curve[i].x + b * curve[i].y + c;
        if (value > max_distance_above) {
            max_distance_above = value;
        }
        else if (value < max_distance_below) {
            max_distance_below = value;
        }
    }
    a1 = 0.0;
    b1 = 1.0;
    c1 = 0.0;
    a2 = a;
    b2 = b;
    c2 = c - max_distance_above;
    det = a1 * b2 - a2 * b1;
    dInv = 1.0 / det;
    intercept_1 = (b1 * c2 - b2 * c1) * dInv;
    a2 = a;
    b2 = b;
    c2 = c - max_distance_below;
    det = a1 * b2 - a2 * b1;
    dInv = 1.0 / det;
    intercept_2 = (b1 * c2 - b2 * c1) * dInv;
    left_intercept = Math.min(intercept_1, intercept_2);
    right_intercept = Math.max(intercept_1, intercept_2);
    error = right_intercept - left_intercept;
    return error < flatnessTolerance ? 1 : 0;
}
function _computeXIntercept(curve, degree) {
    var XLK = 1.0, YLK = 0.0, XNM = curve[degree].x - curve[0].x, YNM = curve[degree].y - curve[0].y, XMK = curve[0].x - 0.0, YMK = curve[0].y - 0.0, det = XNM * YLK - YNM * XLK, detInv = 1.0 / det, S = (XNM * YMK - YNM * XMK) * detInv;
    return 0.0 + XLK * S;
}
function _bezier(curve, degree, t, left, right) {
    var temp = [[]];
    for (var j = 0; j <= degree; j++) {
        temp[0][j] = curve[j];
    }
    for (var i = 1; i <= degree; i++) {
        for (var _j = 0; _j <= degree - i; _j++) {
            if (!temp[i])
                temp[i] = [];
            if (!temp[i][_j])
                temp[i][_j] = {};
            temp[i][_j].x = (1.0 - t) * temp[i - 1][_j].x + t * temp[i - 1][_j + 1].x;
            temp[i][_j].y = (1.0 - t) * temp[i - 1][_j].y + t * temp[i - 1][_j + 1].y;
        }
    }
    if (left != null) {
        for (var _j2 = 0; _j2 <= degree; _j2++) {
            left[_j2] = temp[_j2][0];
        }
    }
    if (right != null) {
        for (var _j3 = 0; _j3 <= degree; _j3++) {
            right[_j3] = temp[degree - _j3][_j3];
        }
    }
    return temp[degree][0];
}
function _getLUT(steps, curve) {
    var out = [];
    steps--;
    for (var n = 0; n <= steps; n++) {
        out.push(_computeLookup(n / steps, curve));
    }
    return out;
}
function _computeLookup(e, curve) {
    var EMPTY_POINT = {
        x: 0,
        y: 0
    };
    if (e === 0) {
        return curve[0];
    }
    var degree = curve.length - 1;
    if (e === 1) {
        return curve[degree];
    }
    var o = curve;
    var s = 1 - e;
    if (degree === 0) {
        return curve[0];
    }
    if (degree === 1) {
        return {
            x: s * o[0].x + e * o[1].x,
            y: s * o[0].y + e * o[1].y
        };
    }
    if (4 > degree) {
        var l = s * s, h = e * e, u = 0, m, g, f;
        if (degree === 2) {
            o = [o[0], o[1], o[2], EMPTY_POINT];
            m = l;
            g = 2 * (s * e);
            f = h;
        }
        else if (degree === 3) {
            m = l * s;
            g = 3 * (l * e);
            f = 3 * (s * h);
            u = e * h;
        }
        return {
            x: m * o[0].x + g * o[1].x + f * o[2].x + u * o[3].x,
            y: m * o[0].y + g * o[1].y + f * o[2].y + u * o[3].y
        };
    }
    else {
        return EMPTY_POINT;
    }
}
function computeBezierLength(curve) {
    var length = 0;
    if (!isPoint(curve)) {
        var steps = 16;
        var lut = _getLUT(steps, curve);
        for (var i = 0; i < steps - 1; i++) {
            var a = lut[i], b = lut[i + 1];
            length += dist(a, b);
        }
    }
    return length;
}
var _curveFunctionCache = new Map();
function _getCurveFunctions(order) {
    var fns = _curveFunctionCache.get(order);
    if (!fns) {
        fns = [];
        var f_term = function f_term() {
            return function (t) {
                return Math.pow(t, order);
            };
        }, l_term = function l_term() {
            return function (t) {
                return Math.pow(1 - t, order);
            };
        }, c_term = function c_term(c) {
            return function (t) {
                return c;
            };
        }, t_term = function t_term() {
            return function (t) {
                return t;
            };
        }, one_minus_t_term = function one_minus_t_term() {
            return function (t) {
                return 1 - t;
            };
        }, _termFunc = function _termFunc(terms) {
            return function (t) {
                var p = 1;
                for (var i = 0; i < terms.length; i++) {
                    p = p * terms[i](t);
                }
                return p;
            };
        };
        fns.push(f_term());
        for (var i = 1; i < order; i++) {
            var terms = [c_term(order)];
            for (var j = 0; j < order - i; j++) {
                terms.push(t_term());
            }
            for (var _j4 = 0; _j4 < i; _j4++) {
                terms.push(one_minus_t_term());
            }
            fns.push(_termFunc(terms));
        }
        fns.push(l_term());
        _curveFunctionCache.set(order, fns);
    }
    return fns;
}
function pointOnCurve(curve, location) {
    var cc = _getCurveFunctions(curve.length - 1), _x = 0, _y = 0;
    for (var i = 0; i < curve.length; i++) {
        _x = _x + curve[i].x * cc[i](location);
        _y = _y + curve[i].y * cc[i](location);
    }
    return {
        x: _x,
        y: _y
    };
}
function dist(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function isPoint(curve) {
    return curve[0].x === curve[1].x && curve[0].y === curve[1].y;
}
function pointAlongPath(curve, location, distance) {
    if (isPoint(curve)) {
        return {
            point: curve[0],
            location: location
        };
    }
    var prev = pointOnCurve(curve, location), tally = 0, curLoc = location, direction = distance > 0 ? 1 : -1, cur = null;
    while (tally < Math.abs(distance)) {
        curLoc += 0.005 * direction;
        cur = pointOnCurve(curve, curLoc);
        tally += dist(cur, prev);
        prev = cur;
    }
    return {
        point: cur,
        location: curLoc
    };
}
function pointAlongCurveFrom(curve, location, distance) {
    return pointAlongPath(curve, location, distance).point;
}
function locationAlongCurveFrom(curve, location, distance) {
    return pointAlongPath(curve, location, distance).location;
}
function gradientAtPoint(curve, location) {
    var p1 = pointOnCurve(curve, location), p2 = pointOnCurve(curve.slice(0, curve.length - 1), location), dy = p2.y - p1.y, dx = p2.x - p1.x;
    return dy === 0 ? Infinity : Math.atan(dy / dx);
}
function bezierLineIntersection(x1, y1, x2, y2, curve) {
    var a = y2 - y1, b = x1 - x2, c = x1 * (y1 - y2) + y1 * (x2 - x1), coeffs = _computeCoefficients(curve), p = [a * coeffs[0][0] + b * coeffs[1][0], a * coeffs[0][1] + b * coeffs[1][1], a * coeffs[0][2] + b * coeffs[1][2], a * coeffs[0][3] + b * coeffs[1][3] + c], r = _cubicRoots.apply(null, p), intersections = [];
    if (r != null) {
        for (var i = 0; i < 3; i++) {
            var _t = r[i], t2 = Math.pow(_t, 2), t3 = Math.pow(_t, 3), x = {
                x: coeffs[0][0] * t3 + coeffs[0][1] * t2 + coeffs[0][2] * _t + coeffs[0][3],
                y: coeffs[1][0] * t3 + coeffs[1][1] * t2 + coeffs[1][2] * _t + coeffs[1][3]
            };
            var s = void 0;
            if (x2 - x1 !== 0) {
                s = (x[0] - x1) / (x2 - x1);
            }
            else {
                s = (x[1] - y1) / (y2 - y1);
            }
            if (_t >= 0 && _t <= 1.0 && s >= 0 && s <= 1.0) {
                intersections.push(x);
            }
        }
    }
    return intersections;
}
function _computeCoefficientsForAxis(curve, axis) {
    return [-curve[0][axis] + 3 * curve[1][axis] + -3 * curve[2][axis] + curve[3][axis], 3 * curve[0][axis] - 6 * curve[1][axis] + 3 * curve[2][axis], -3 * curve[0][axis] + 3 * curve[1][axis], curve[0][axis]];
}
function _computeCoefficients(curve) {
    return [_computeCoefficientsForAxis(curve, "x"), _computeCoefficientsForAxis(curve, "y")];
}
function _cubicRoots(a, b, c, d) {
    var A = b / a, B = c / a, C = d / a, Q = (3 * B - Math.pow(A, 2)) / 9, R = (9 * A * B - 27 * C - 2 * Math.pow(A, 3)) / 54, D = Math.pow(Q, 3) + Math.pow(R, 2), S, T, t = [0, 0, 0];
    if (D >= 0) {
        S = sgn$1(R + Math.sqrt(D)) * Math.pow(Math.abs(R + Math.sqrt(D)), 1 / 3);
        T = sgn$1(R - Math.sqrt(D)) * Math.pow(Math.abs(R - Math.sqrt(D)), 1 / 3);
        t[0] = -A / 3 + (S + T);
        t[1] = -A / 3 - (S + T) / 2;
        t[2] = -A / 3 - (S + T) / 2;
        if (Math.abs(Math.sqrt(3) * (S - T) / 2) !== 0) {
            t[1] = -1;
            t[2] = -1;
        }
    }
    else {
        var th = Math.acos(R / Math.sqrt(-Math.pow(Q, 3)));
        t[0] = 2 * Math.sqrt(-Q) * Math.cos(th / 3) - A / 3;
        t[1] = 2 * Math.sqrt(-Q) * Math.cos((th + 2 * Math.PI) / 3) - A / 3;
        t[2] = 2 * Math.sqrt(-Q) * Math.cos((th + 4 * Math.PI) / 3) - A / 3;
    }
    for (var i = 0; i < 3; i++) {
        if (t[i] < 0 || t[i] > 1.0) {
            t[i] = -1;
        }
    }
    return t;
}
var BezierSegment = function (_AbstractSegment) {
    _inherits$1(BezierSegment, _AbstractSegment);
    var _super = _createSuper$1(BezierSegment);
    function BezierSegment(params) {
        var _this;
        _classCallCheck$1(this, BezierSegment);
        _this = _super.call(this, params);
        _defineProperty$1(_assertThisInitialized$1(_this), "curve", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "cp1x", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "cp1y", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "cp2x", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "cp2y", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "length", 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "type", BezierSegment.segmentType);
        _this.cp1x = params.cp1x;
        _this.cp1y = params.cp1y;
        _this.cp2x = params.cp2x;
        _this.cp2y = params.cp2y;
        _this.x1 = params.x1;
        _this.x2 = params.x2;
        _this.y1 = params.y1;
        _this.y2 = params.y2;
        _this.curve = [{
                x: _this.x1,
                y: _this.y1
            }, {
                x: _this.cp1x,
                y: _this.cp1y
            }, {
                x: _this.cp2x,
                y: _this.cp2y
            }, {
                x: _this.x2,
                y: _this.y2
            }];
        _this.extents = {
            xmin: Math.min(_this.x1, _this.x2, _this.cp1x, _this.cp2x),
            ymin: Math.min(_this.y1, _this.y2, _this.cp1y, _this.cp2y),
            xmax: Math.max(_this.x1, _this.x2, _this.cp1x, _this.cp2x),
            ymax: Math.max(_this.y1, _this.y2, _this.cp1y, _this.cp2y)
        };
        return _this;
    }
    _createClass$1(BezierSegment, [{
            key: "getPath",
            value: function getPath(isFirstSegment) {
                return (isFirstSegment ? "M " + this.x2 + " " + this.y2 + " " : "") + "C " + this.cp2x + " " + this.cp2y + " " + this.cp1x + " " + this.cp1y + " " + this.x1 + " " + this.y1;
            }
        }, {
            key: "pointOnPath",
            value: function pointOnPath(location, absolute) {
                location = BezierSegment._translateLocation(this.curve, location, absolute);
                return pointOnCurve(this.curve, location);
            }
        }, {
            key: "gradientAtPoint",
            value: function gradientAtPoint$1(location, absolute) {
                location = BezierSegment._translateLocation(this.curve, location, absolute);
                return gradientAtPoint(this.curve, location);
            }
        }, {
            key: "pointAlongPathFrom",
            value: function pointAlongPathFrom(location, distance, absolute) {
                location = BezierSegment._translateLocation(this.curve, location, absolute);
                return pointAlongCurveFrom(this.curve, location, distance);
            }
        }, {
            key: "getLength",
            value: function getLength() {
                if (this.length == null || this.length === 0) {
                    this.length = computeBezierLength(this.curve);
                }
                return this.length;
            }
        }, {
            key: "findClosestPointOnPath",
            value: function findClosestPointOnPath(x, y) {
                var p = nearestPointOnCurve({
                    x: x,
                    y: y
                }, this.curve);
                return {
                    d: Math.sqrt(Math.pow(p.point.x - x, 2) + Math.pow(p.point.y - y, 2)),
                    x: p.point.x,
                    y: p.point.y,
                    l: 1 - p.location,
                    s: this,
                    x1: null,
                    y1: null,
                    x2: null,
                    y2: null
                };
            }
        }, {
            key: "lineIntersection",
            value: function lineIntersection(x1, y1, x2, y2) {
                return bezierLineIntersection(x1, y1, x2, y2, this.curve);
            }
        }], [{
            key: "_translateLocation",
            value: function _translateLocation(_curve, location, absolute) {
                if (absolute) {
                    location = locationAlongCurveFrom(_curve, location > 0 ? 0 : 1, location);
                }
                return location;
            }
        }]);
    return BezierSegment;
}(AbstractSegment);
_defineProperty$1(BezierSegment, "segmentType", "Bezier");
var BezierConnector = function (_AbstractBezierConnec) {
    _inherits$1(BezierConnector, _AbstractBezierConnec);
    var _super = _createSuper$1(BezierConnector);
    function BezierConnector(connection, params) {
        var _this;
        _classCallCheck$1(this, BezierConnector);
        _this = _super.call(this, connection, params);
        _this.connection = connection;
        _defineProperty$1(_assertThisInitialized$1(_this), "type", BezierConnector.type);
        _defineProperty$1(_assertThisInitialized$1(_this), "majorAnchor", void 0);
        _defineProperty$1(_assertThisInitialized$1(_this), "minorAnchor", void 0);
        params = params || {};
        _this.majorAnchor = params.curviness || 150;
        _this.minorAnchor = 10;
        return _this;
    }
    _createClass$1(BezierConnector, [{
            key: "getCurviness",
            value: function getCurviness() {
                return this.majorAnchor;
            }
        }, {
            key: "_findControlPoint",
            value: function _findControlPoint(point, sourceAnchorPosition, targetAnchorPosition, soo, too) {
                var perpendicular = soo[0] !== too[0] || soo[1] === too[1], p = {
                    x: 0,
                    y: 0
                };
                if (!perpendicular) {
                    if (soo[0] === 0) {
                        p.x = sourceAnchorPosition.curX < targetAnchorPosition.curX ? point.x + this.minorAnchor : point.x - this.minorAnchor;
                    }
                    else {
                        p.x = point.x - this.majorAnchor * soo[0];
                    }
                    if (soo[1] === 0) {
                        p.y = sourceAnchorPosition.curY < targetAnchorPosition.curY ? point.y + this.minorAnchor : point.y - this.minorAnchor;
                    }
                    else {
                        p.y = point.y + this.majorAnchor * too[1];
                    }
                }
                else {
                    if (too[0] === 0) {
                        p.x = targetAnchorPosition.curX < sourceAnchorPosition.curX ? point.x + this.minorAnchor : point.x - this.minorAnchor;
                    }
                    else {
                        p.x = point.x + this.majorAnchor * too[0];
                    }
                    if (too[1] === 0) {
                        p.y = targetAnchorPosition.curY < sourceAnchorPosition.curY ? point.y + this.minorAnchor : point.y - this.minorAnchor;
                    }
                    else {
                        p.y = point.y + this.majorAnchor * soo[1];
                    }
                }
                return p;
            }
        }, {
            key: "_computeBezier",
            value: function _computeBezier(paintInfo, p, sp, tp, _w, _h) {
                var _CP, _CP2, _sx = sp.curX < tp.curX ? _w : 0, _sy = sp.curY < tp.curY ? _h : 0, _tx = sp.curX < tp.curX ? 0 : _w, _ty = sp.curY < tp.curY ? 0 : _h;
                if (this.edited !== true) {
                    _CP = this._findControlPoint({
                        x: _sx,
                        y: _sy
                    }, sp, tp, paintInfo.so, paintInfo.to);
                    _CP2 = this._findControlPoint({
                        x: _tx,
                        y: _ty
                    }, tp, sp, paintInfo.to, paintInfo.so);
                }
                else {
                    _CP = this.geometry.controlPoints[0];
                    _CP2 = this.geometry.controlPoints[1];
                }
                this.geometry = {
                    controlPoints: [_CP, _CP2],
                    source: p.sourcePos,
                    target: p.targetPos
                };
                this._addSegment(BezierSegment, {
                    x1: _sx,
                    y1: _sy,
                    x2: _tx,
                    y2: _ty,
                    cp1x: _CP.x,
                    cp1y: _CP.y,
                    cp2x: _CP2.x,
                    cp2y: _CP2.y
                });
            }
        }]);
    return BezierConnector;
}(AbstractBezierConnector);
_defineProperty$1(BezierConnector, "type", "Bezier");
function _segment(x1, y1, x2, y2) {
    if (x1 <= x2 && y2 <= y1) {
        return 1;
    }
    else if (x1 <= x2 && y1 <= y2) {
        return 2;
    }
    else if (x2 <= x1 && y2 >= y1) {
        return 3;
    }
    return 4;
}
function _findControlPoint(midx, midy, segment, sourceEdge, targetEdge, dx, dy, distance, proximityLimit) {
    if (distance <= proximityLimit) {
        return {
            x: midx,
            y: midy
        };
    }
    if (segment === 1) {
        if (sourceEdge.curY <= 0 && targetEdge.curY >= 1) {
            return {
                x: midx + (sourceEdge.x < 0.5 ? -1 * dx : dx),
                y: midy
            };
        }
        else if (sourceEdge.curX >= 1 && targetEdge.curX <= 0) {
            return {
                x: midx,
                y: midy + (sourceEdge.y < 0.5 ? -1 * dy : dy)
            };
        }
        else {
            return {
                x: midx + -1 * dx,
                y: midy + -1 * dy
            };
        }
    }
    else if (segment === 2) {
        if (sourceEdge.curY >= 1 && targetEdge.curY <= 0) {
            return {
                x: midx + (sourceEdge.x < 0.5 ? -1 * dx : dx),
                y: midy
            };
        }
        else if (sourceEdge.curX >= 1 && targetEdge.curX <= 0) {
            return {
                x: midx,
                y: midy + (sourceEdge.y < 0.5 ? -1 * dy : dy)
            };
        }
        else {
            return {
                x: midx + dx,
                y: midy + -1 * dy
            };
        }
    }
    else if (segment === 3) {
        if (sourceEdge.curY >= 1 && targetEdge.curY <= 0) {
            return {
                x: midx + (sourceEdge.x < 0.5 ? -1 * dx : dx),
                y: midy
            };
        }
        else if (sourceEdge.curX <= 0 && targetEdge.curX >= 1) {
            return {
                x: midx,
                y: midy + (sourceEdge.y < 0.5 ? -1 * dy : dy)
            };
        }
        else {
            return {
                x: midx + -1 * dx,
                y: midy + -1 * dy
            };
        }
    }
    else if (segment === 4) {
        if (sourceEdge.curY <= 0 && targetEdge.curY >= 1) {
            return {
                x: midx + (sourceEdge.x < 0.5 ? -1 * dx : dx),
                y: midy
            };
        }
        else if (sourceEdge.curX <= 0 && targetEdge.curX >= 1) {
            return {
                x: midx,
                y: midy + (sourceEdge.y < 0.5 ? -1 * dy : dy)
            };
        }
        else {
            return {
                x: midx + dx,
                y: midy + -1 * dy
            };
        }
    }
}
var StateMachineConnector = function (_AbstractBezierConnec) {
    _inherits$1(StateMachineConnector, _AbstractBezierConnec);
    var _super = _createSuper$1(StateMachineConnector);
    function StateMachineConnector(connection, params) {
        var _this;
        _classCallCheck$1(this, StateMachineConnector);
        _this = _super.call(this, connection, params);
        _this.connection = connection;
        _defineProperty$1(_assertThisInitialized$1(_this), "type", StateMachineConnector.type);
        _defineProperty$1(_assertThisInitialized$1(_this), "_controlPoint", void 0);
        _this.curviness = params.curviness || 10;
        _this.margin = params.margin || 5;
        _this.proximityLimit = params.proximityLimit || 80;
        _this.clockwise = params.orientation && params.orientation === "clockwise";
        return _this;
    }
    _createClass$1(StateMachineConnector, [{
            key: "_computeBezier",
            value: function _computeBezier(paintInfo, params, sp, tp, w, h) {
                var _sx = sp.curX < tp.curX ? 0 : w, _sy = sp.curY < tp.curY ? 0 : h, _tx = sp.curX < tp.curX ? w : 0, _ty = sp.curY < tp.curY ? h : 0;
                if (sp.x === 0) {
                    _sx -= this.margin;
                }
                if (sp.x === 1) {
                    _sx += this.margin;
                }
                if (sp.y === 0) {
                    _sy -= this.margin;
                }
                if (sp.y === 1) {
                    _sy += this.margin;
                }
                if (tp.x === 0) {
                    _tx -= this.margin;
                }
                if (tp.x === 1) {
                    _tx += this.margin;
                }
                if (tp.y === 0) {
                    _ty -= this.margin;
                }
                if (tp.y === 1) {
                    _ty += this.margin;
                }
                if (this.edited !== true) {
                    var _midx = (_sx + _tx) / 2, _midy = (_sy + _ty) / 2, segment = _segment(_sx, _sy, _tx, _ty), distance = Math.sqrt(Math.pow(_tx - _sx, 2) + Math.pow(_ty - _sy, 2));
                    this._controlPoint = _findControlPoint(_midx, _midy, segment, params.sourcePos, params.targetPos, this.curviness, this.curviness, distance, this.proximityLimit);
                }
                else {
                    this._controlPoint = this.geometry.controlPoints[0];
                }
                var cp1x, cp2x, cp1y, cp2y;
                cp1x = this._controlPoint.x;
                cp2x = this._controlPoint.x;
                cp1y = this._controlPoint.y;
                cp2y = this._controlPoint.y;
                this.geometry = {
                    controlPoints: [this._controlPoint, this._controlPoint],
                    source: params.sourcePos,
                    target: params.targetPos
                };
                this._addSegment(BezierSegment, {
                    x1: _tx,
                    y1: _ty,
                    x2: _sx,
                    y2: _sy,
                    cp1x: cp1x,
                    cp1y: cp1y,
                    cp2x: cp2x,
                    cp2y: cp2y
                });
            }
        }]);
    return StateMachineConnector;
}(AbstractBezierConnector);
_defineProperty$1(StateMachineConnector, "type", "StateMachine");
Connectors.register(BezierConnector.type, BezierConnector);
Connectors.register(StateMachineConnector.type, StateMachineConnector);
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
            descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
        _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    else {
        obj[key] = value;
    }
    return obj;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass)
        _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
    if (Reflect.construct.sham)
        return false;
    if (typeof Proxy === "function")
        return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { }));
        return true;
    }
    catch (e) {
        return false;
    }
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized(self);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        }
        else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}
function sgn(n) {
    return n < 0 ? -1 : n === 0 ? 0 : 1;
}
function segmentDirections(segment) {
    return [sgn(segment[2] - segment[0]), sgn(segment[3] - segment[1])];
}
function segLength(s) {
    return Math.sqrt(Math.pow(s[0] - s[2], 2) + Math.pow(s[1] - s[3], 2));
}
function _cloneArray(a) {
    var _a = [];
    _a.push.apply(_a, a);
    return _a;
}
var FlowchartConnector = function (_AbstractConnector) {
    _inherits(FlowchartConnector, _AbstractConnector);
    var _super = _createSuper(FlowchartConnector);
    function FlowchartConnector(connection, params) {
        var _this;
        _classCallCheck(this, FlowchartConnector);
        _this = _super.call(this, connection, params);
        _this.connection = connection;
        _defineProperty(_assertThisInitialized(_this), "type", FlowchartConnector.type);
        _defineProperty(_assertThisInitialized(_this), "internalSegments", []);
        _defineProperty(_assertThisInitialized(_this), "midpoint", void 0);
        _defineProperty(_assertThisInitialized(_this), "alwaysRespectStubs", void 0);
        _defineProperty(_assertThisInitialized(_this), "cornerRadius", void 0);
        _defineProperty(_assertThisInitialized(_this), "lastx", void 0);
        _defineProperty(_assertThisInitialized(_this), "lasty", void 0);
        _defineProperty(_assertThisInitialized(_this), "lastOrientation", void 0);
        _defineProperty(_assertThisInitialized(_this), "loopbackRadius", void 0);
        _defineProperty(_assertThisInitialized(_this), "isLoopbackCurrently", void 0);
        _this.midpoint = params.midpoint == null || isNaN(params.midpoint) ? 0.5 : params.midpoint;
        _this.cornerRadius = params.cornerRadius != null ? params.cornerRadius : 0;
        _this.alwaysRespectStubs = params.alwaysRespectStubs === true;
        _this.lastx = null;
        _this.lasty = null;
        _this.lastOrientation = null;
        _this.loopbackRadius = params.loopbackRadius || 25;
        _this.isLoopbackCurrently = false;
        return _this;
    }
    _createClass(FlowchartConnector, [{
            key: "getDefaultStubs",
            value: function getDefaultStubs() {
                return [30, 30];
            }
        }, {
            key: "addASegment",
            value: function addASegment(x, y, paintInfo) {
                if (this.lastx === x && this.lasty === y) {
                    return;
                }
                var lx = this.lastx == null ? paintInfo.sx : this.lastx, ly = this.lasty == null ? paintInfo.sy : this.lasty, o = lx === x ? "v" : "h";
                this.lastx = x;
                this.lasty = y;
                this.internalSegments.push([lx, ly, x, y, o]);
            }
        }, {
            key: "writeSegments",
            value: function writeSegments(paintInfo) {
                var current = null, next, currentDirection, nextDirection;
                for (var i = 0; i < this.internalSegments.length - 1; i++) {
                    current = current || _cloneArray(this.internalSegments[i]);
                    next = _cloneArray(this.internalSegments[i + 1]);
                    currentDirection = segmentDirections(current);
                    nextDirection = segmentDirections(next);
                    if (this.cornerRadius > 0 && current[4] !== next[4]) {
                        var minSegLength = Math.min(segLength(current), segLength(next));
                        var radiusToUse = Math.min(this.cornerRadius, minSegLength / 2);
                        current[2] -= currentDirection[0] * radiusToUse;
                        current[3] -= currentDirection[1] * radiusToUse;
                        next[0] += nextDirection[0] * radiusToUse;
                        next[1] += nextDirection[1] * radiusToUse;
                        var ac = currentDirection[1] === nextDirection[0] && nextDirection[0] === 1 || currentDirection[1] === nextDirection[0] && nextDirection[0] === 0 && currentDirection[0] !== nextDirection[1] || currentDirection[1] === nextDirection[0] && nextDirection[0] === -1, sgny = next[1] > current[3] ? 1 : -1, sgnx = next[0] > current[2] ? 1 : -1, sgnEqual = sgny === sgnx, cx = sgnEqual && ac || !sgnEqual && !ac ? next[0] : current[2], cy = sgnEqual && ac || !sgnEqual && !ac ? current[3] : next[1];
                        this._addSegment(StraightSegment, {
                            x1: current[0],
                            y1: current[1],
                            x2: current[2],
                            y2: current[3]
                        });
                        this._addSegment(ArcSegment, {
                            r: radiusToUse,
                            x1: current[2],
                            y1: current[3],
                            x2: next[0],
                            y2: next[1],
                            cx: cx,
                            cy: cy,
                            ac: ac
                        });
                    }
                    else {
                        this._addSegment(StraightSegment, {
                            x1: current[0],
                            y1: current[1],
                            x2: current[2],
                            y2: current[3]
                        });
                    }
                    current = next;
                }
                if (next != null) {
                    this._addSegment(StraightSegment, {
                        x1: next[0],
                        y1: next[1],
                        x2: next[2],
                        y2: next[3]
                    });
                }
            }
        }, {
            key: "_compute",
            value: function _compute(paintInfo, params) {
                var _this2 = this;
                this.internalSegments.length = 0;
                this.lastx = null;
                this.lasty = null;
                this.lastOrientation = null;
                var commonStubCalculator = function commonStubCalculator(axis) {
                    return [paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY];
                }, stubCalculators = {
                    perpendicular: commonStubCalculator,
                    orthogonal: commonStubCalculator,
                    opposite: function opposite(axis) {
                        var pi = paintInfo, idx = axis === "x" ? 0 : 1, areInProximity = {
                            "x": function x() {
                                return pi.so[idx] === 1 && (pi.startStubX > pi.endStubX && pi.tx > pi.startStubX || pi.sx > pi.endStubX && pi.tx > pi.sx) || pi.so[idx] === -1 && (pi.startStubX < pi.endStubX && pi.tx < pi.startStubX || pi.sx < pi.endStubX && pi.tx < pi.sx);
                            },
                            "y": function y() {
                                return pi.so[idx] === 1 && (pi.startStubY > pi.endStubY && pi.ty > pi.startStubY || pi.sy > pi.endStubY && pi.ty > pi.sy) || pi.so[idx] === -1 && (pi.startStubY < pi.endStubY && pi.ty < pi.startStubY || pi.sy < pi.endStubY && pi.ty < pi.sy);
                            }
                        };
                        if (!_this2.alwaysRespectStubs && areInProximity[axis]()) {
                            return {
                                "x": [(paintInfo.sx + paintInfo.tx) / 2, paintInfo.startStubY, (paintInfo.sx + paintInfo.tx) / 2, paintInfo.endStubY],
                                "y": [paintInfo.startStubX, (paintInfo.sy + paintInfo.ty) / 2, paintInfo.endStubX, (paintInfo.sy + paintInfo.ty) / 2]
                            }[axis];
                        }
                        else {
                            return [paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY];
                        }
                    }
                };
                var stubs = stubCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis), idx = paintInfo.sourceAxis === "x" ? 0 : 1, oidx = paintInfo.sourceAxis === "x" ? 1 : 0, ss = stubs[idx], oss = stubs[oidx], es = stubs[idx + 2], oes = stubs[oidx + 2];
                this.addASegment(stubs[0], stubs[1], paintInfo);
                var midx = paintInfo.startStubX + (paintInfo.endStubX - paintInfo.startStubX) * this.midpoint, midy = paintInfo.startStubY + (paintInfo.endStubY - paintInfo.startStubY) * this.midpoint;
                var orientations = {
                    x: [0, 1],
                    y: [1, 0]
                }, lineCalculators = {
                    perpendicular: function perpendicular(axis, ss, oss, es, oes) {
                        var pi = paintInfo, sis = {
                            x: [[[1, 2, 3, 4], null, [2, 1, 4, 3]], null, [[4, 3, 2, 1], null, [3, 4, 1, 2]]],
                            y: [[[3, 2, 1, 4], null, [2, 3, 4, 1]], null, [[4, 1, 2, 3], null, [1, 4, 3, 2]]]
                        }, stubs = {
                            x: [[pi.startStubX, pi.endStubX], null, [pi.endStubX, pi.startStubX]],
                            y: [[pi.startStubY, pi.endStubY], null, [pi.endStubY, pi.startStubY]]
                        }, midLines = {
                            x: [[midx, pi.startStubY], [midx, pi.endStubY]],
                            y: [[pi.startStubX, midy], [pi.endStubX, midy]]
                        }, linesToEnd = {
                            x: [[pi.endStubX, pi.startStubY]],
                            y: [[pi.startStubX, pi.endStubY]]
                        }, startToEnd = {
                            x: [[pi.startStubX, pi.endStubY], [pi.endStubX, pi.endStubY]],
                            y: [[pi.endStubX, pi.startStubY], [pi.endStubX, pi.endStubY]]
                        }, startToMidToEnd = {
                            x: [[pi.startStubX, midy], [pi.endStubX, midy], [pi.endStubX, pi.endStubY]],
                            y: [[midx, pi.startStubY], [midx, pi.endStubY], [pi.endStubX, pi.endStubY]]
                        }, otherStubs = {
                            x: [pi.startStubY, pi.endStubY],
                            y: [pi.startStubX, pi.endStubX]
                        }, soIdx = orientations[axis][0], toIdx = orientations[axis][1], _so = pi.so[soIdx] + 1, _to = pi.to[toIdx] + 1, otherFlipped = pi.to[toIdx] === -1 && otherStubs[axis][1] < otherStubs[axis][0] || pi.to[toIdx] === 1 && otherStubs[axis][1] > otherStubs[axis][0], stub1 = stubs[axis][_so][0], stub2 = stubs[axis][_so][1], segmentIndexes = sis[axis][_so][_to];
                        if (pi.segment === segmentIndexes[3] || pi.segment === segmentIndexes[2] && otherFlipped) {
                            return midLines[axis];
                        }
                        else if (pi.segment === segmentIndexes[2] && stub2 < stub1) {
                            return linesToEnd[axis];
                        }
                        else if (pi.segment === segmentIndexes[2] && stub2 >= stub1 || pi.segment === segmentIndexes[1] && !otherFlipped) {
                            return startToMidToEnd[axis];
                        }
                        else if (pi.segment === segmentIndexes[0] || pi.segment === segmentIndexes[1] && otherFlipped) {
                            return startToEnd[axis];
                        }
                    },
                    orthogonal: function orthogonal(axis, startStub, otherStartStub, endStub, otherEndStub) {
                        var pi = paintInfo, extent = {
                            "x": pi.so[0] === -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub),
                            "y": pi.so[1] === -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub)
                        }[axis];
                        return {
                            "x": [[extent, otherStartStub], [extent, otherEndStub], [endStub, otherEndStub]],
                            "y": [[otherStartStub, extent], [otherEndStub, extent], [otherEndStub, endStub]]
                        }[axis];
                    },
                    opposite: function opposite(axis, ss, oss, es, oes) {
                        var pi = paintInfo, otherAxis = {
                            "x": "y",
                            "y": "x"
                        }[axis], dim = {
                            "x": "h",
                            "y": "w"
                        }[axis], comparator = pi["is" + axis.toUpperCase() + "GreaterThanStubTimes2"];
                        if (params.sourceEndpoint.elementId === params.targetEndpoint.elementId) {
                            var _val = oss + (1 - params.sourceEndpoint._anchor.computedPosition[otherAxis]) * params.sourceInfo[dim] + _this2.maxStub;
                            return {
                                "x": [[ss, _val], [es, _val]],
                                "y": [[_val, ss], [_val, es]]
                            }[axis];
                        }
                        else if (!comparator || pi.so[idx] === 1 && ss > es || pi.so[idx] === -1 && ss < es) {
                            return {
                                "x": [[ss, midy], [es, midy]],
                                "y": [[midx, ss], [midx, es]]
                            }[axis];
                        }
                        else if (pi.so[idx] === 1 && ss < es || pi.so[idx] === -1 && ss > es) {
                            return {
                                "x": [[midx, pi.sy], [midx, pi.ty]],
                                "y": [[pi.sx, midy], [pi.tx, midy]]
                            }[axis];
                        }
                    }
                };
                var p = lineCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis, ss, oss, es, oes);
                if (p) {
                    for (var i = 0; i < p.length; i++) {
                        this.addASegment(p[i][0], p[i][1], paintInfo);
                    }
                }
                this.addASegment(stubs[2], stubs[3], paintInfo);
                this.addASegment(paintInfo.tx, paintInfo.ty, paintInfo);
                this.writeSegments(paintInfo);
            }
        }, {
            key: "transformGeometry",
            value: function transformGeometry(g, dx, dy) {
                return g;
            }
        }]);
    return FlowchartConnector;
}(AbstractConnector);
_defineProperty(FlowchartConnector, "type", "Flowchart");
Connectors.register(FlowchartConnector.type, FlowchartConnector);
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
var interact_min = { exports: {} };
(function (module, exports) {
    !function (t) { module.exports = t(); }((function () { var t = {}; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0, t.default = function (t) { return !(!t || !t.Window) && t instanceof t.Window; }; var e = {}; Object.defineProperty(e, "__esModule", { value: !0 }), e.getWindow = function (e) { return (0, t.default)(e) ? e : (e.ownerDocument || e).defaultView || r.window; }, e.init = o, e.window = e.realWindow = void 0; var n = void 0; e.realWindow = n; var r = void 0; function o(t) { e.realWindow = n = t; var o = t.document.createTextNode(""); o.ownerDocument !== t.document && "function" == typeof t.wrap && t.wrap(o) === o && (t = t.wrap(t)), e.window = r = t; } e.window = r, "undefined" != typeof window && window && o(window); var i = {}; function a(t) { return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t; } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }, a(t); } Object.defineProperty(i, "__esModule", { value: !0 }), i.default = void 0; var s = function (t) { return !!t && "object" === a(t); }, l = function (t) { return "function" == typeof t; }, u = { window: function (n) { return n === e.window || (0, t.default)(n); }, docFrag: function (t) { return s(t) && 11 === t.nodeType; }, object: s, func: l, number: function (t) { return "number" == typeof t; }, bool: function (t) { return "boolean" == typeof t; }, string: function (t) { return "string" == typeof t; }, element: function (t) { if (!t || "object" !== a(t))
            return !1; var n = e.getWindow(t) || e.window; return /object|function/.test("undefined" == typeof Element ? "undefined" : a(Element)) ? t instanceof Element || t instanceof n.Element : 1 === t.nodeType && "string" == typeof t.nodeName; }, plainObject: function (t) { return s(t) && !!t.constructor && /function Object\b/.test(t.constructor.toString()); }, array: function (t) { return s(t) && void 0 !== t.length && l(t.splice); } }; i.default = u; var c = {}; function f(t) { var e = t.interaction; if ("drag" === e.prepared.name) {
        var n = e.prepared.axis;
        "x" === n ? (e.coords.cur.page.y = e.coords.start.page.y, e.coords.cur.client.y = e.coords.start.client.y, e.coords.velocity.client.y = 0, e.coords.velocity.page.y = 0) : "y" === n && (e.coords.cur.page.x = e.coords.start.page.x, e.coords.cur.client.x = e.coords.start.client.x, e.coords.velocity.client.x = 0, e.coords.velocity.page.x = 0);
    } } function d(t) { var e = t.iEvent, n = t.interaction; if ("drag" === n.prepared.name) {
        var r = n.prepared.axis;
        if ("x" === r || "y" === r) {
            var o = "x" === r ? "y" : "x";
            e.page[o] = n.coords.start.page[o], e.client[o] = n.coords.start.client[o], e.delta[o] = 0;
        }
    } } Object.defineProperty(c, "__esModule", { value: !0 }), c.default = void 0; var p = { id: "actions/drag", install: function (t) { var e = t.actions, n = t.Interactable, r = t.defaults; n.prototype.draggable = p.draggable, e.map.drag = p, e.methodDict.drag = "draggable", r.actions.drag = p.defaults; }, listeners: { "interactions:before-action-move": f, "interactions:action-resume": f, "interactions:action-move": d, "auto-start:check": function (t) { var e = t.interaction, n = t.interactable, r = t.buttons, o = n.options.drag; if (o && o.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || 0 != (r & n.options.drag.mouseButtons)))
                return t.action = { name: "drag", axis: "start" === o.lockAxis ? o.startAxis : o.lockAxis }, !1; } }, draggable: function (t) { return i.default.object(t) ? (this.options.drag.enabled = !1 !== t.enabled, this.setPerAction("drag", t), this.setOnEvents("drag", t), /^(xy|x|y|start)$/.test(t.lockAxis) && (this.options.drag.lockAxis = t.lockAxis), /^(xy|x|y)$/.test(t.startAxis) && (this.options.drag.startAxis = t.startAxis), this) : i.default.bool(t) ? (this.options.drag.enabled = t, this) : this.options.drag; }, beforeMove: f, move: d, defaults: { startAxis: "xy", lockAxis: "xy" }, getCursor: function () { return "move"; } }, v = p; c.default = v; var h = {}; Object.defineProperty(h, "__esModule", { value: !0 }), h.default = void 0; var g = { init: function (t) { var e = t; g.document = e.document, g.DocumentFragment = e.DocumentFragment || y, g.SVGElement = e.SVGElement || y, g.SVGSVGElement = e.SVGSVGElement || y, g.SVGElementInstance = e.SVGElementInstance || y, g.Element = e.Element || y, g.HTMLElement = e.HTMLElement || g.Element, g.Event = e.Event, g.Touch = e.Touch || y, g.PointerEvent = e.PointerEvent || e.MSPointerEvent; }, document: null, DocumentFragment: null, SVGElement: null, SVGSVGElement: null, SVGElementInstance: null, Element: null, HTMLElement: null, Event: null, Touch: null, PointerEvent: null }; function y() { } var m = g; h.default = m; var b = {}; Object.defineProperty(b, "__esModule", { value: !0 }), b.default = void 0; var x = { init: function (t) { var e = h.default.Element, n = t.navigator || {}; x.supportsTouch = "ontouchstart" in t || i.default.func(t.DocumentTouch) && h.default.document instanceof t.DocumentTouch, x.supportsPointerEvent = !1 !== n.pointerEnabled && !!h.default.PointerEvent, x.isIOS = /iP(hone|od|ad)/.test(n.platform), x.isIOS7 = /iP(hone|od|ad)/.test(n.platform) && /OS 7[^\d]/.test(n.appVersion), x.isIe9 = /MSIE 9/.test(n.userAgent), x.isOperaMobile = "Opera" === n.appName && x.supportsTouch && /Presto/.test(n.userAgent), x.prefixedMatchesSelector = "matches" in e.prototype ? "matches" : "webkitMatchesSelector" in e.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in e.prototype ? "mozMatchesSelector" : "oMatchesSelector" in e.prototype ? "oMatchesSelector" : "msMatchesSelector", x.pEventTypes = x.supportsPointerEvent ? h.default.PointerEvent === t.MSPointerEvent ? { up: "MSPointerUp", down: "MSPointerDown", over: "mouseover", out: "mouseout", move: "MSPointerMove", cancel: "MSPointerCancel" } : { up: "pointerup", down: "pointerdown", over: "pointerover", out: "pointerout", move: "pointermove", cancel: "pointercancel" } : null, x.wheelEvent = h.default.document && "onmousewheel" in h.default.document ? "mousewheel" : "wheel"; }, supportsTouch: null, supportsPointerEvent: null, isIOS7: null, isIOS: null, isIe9: null, isOperaMobile: null, prefixedMatchesSelector: null, pEventTypes: null, wheelEvent: null }, w = x; b.default = w; var _ = {}; function P(t) { var e = t.parentNode; if (i.default.docFrag(e)) {
        for (; (e = e.host) && i.default.docFrag(e);)
            ;
        return e;
    } return e; } function O(t, n) { return e.window !== e.realWindow && (n = n.replace(/\/deep\//g, " ")), t[b.default.prefixedMatchesSelector](n); } Object.defineProperty(_, "__esModule", { value: !0 }), _.closest = function (t, e) { for (; i.default.element(t);) {
        if (O(t, e))
            return t;
        t = P(t);
    } return null; }, _.getActualElement = function (t) { return t.correspondingUseElement || t; }, _.getElementClientRect = j, _.getElementRect = function (t) { var n = j(t); if (!b.default.isIOS7 && n) {
        var r = T(e.getWindow(t));
        n.left += r.x, n.right += r.x, n.top += r.y, n.bottom += r.y;
    } return n; }, _.getPath = function (t) { for (var e = []; t;)
        e.push(t), t = P(t); return e; }, _.getScrollXY = T, _.indexOfDeepestElement = function (t) { for (var n, r = [], o = 0; o < t.length; o++) {
        var i = t[o], a = t[n];
        if (i && o !== n)
            if (a) {
                var s = E(i), l = E(a);
                if (s !== i.ownerDocument)
                    if (l !== i.ownerDocument)
                        if (s !== l) {
                            r = r.length ? r : S(a);
                            var u = void 0;
                            if (a instanceof h.default.HTMLElement && i instanceof h.default.SVGElement && !(i instanceof h.default.SVGSVGElement)) {
                                if (i === l)
                                    continue;
                                u = i.ownerSVGElement;
                            }
                            else
                                u = i;
                            for (var c = S(u, a.ownerDocument), f = 0; c[f] && c[f] === r[f];)
                                f++;
                            var d = [c[f - 1], c[f], r[f]];
                            if (d[0])
                                for (var p = d[0].lastChild; p;) {
                                    if (p === d[1]) {
                                        n = o, r = c;
                                        break;
                                    }
                                    if (p === d[2])
                                        break;
                                    p = p.previousSibling;
                                }
                        }
                        else
                            v = i, g = a, (parseInt(e.getWindow(v).getComputedStyle(v).zIndex, 10) || 0) >= (parseInt(e.getWindow(g).getComputedStyle(g).zIndex, 10) || 0) && (n = o);
                    else
                        n = o;
            }
            else
                n = o;
    } var v, g; return n; }, _.matchesSelector = O, _.matchesUpTo = function (t, e, n) { for (; i.default.element(t);) {
        if (O(t, e))
            return !0;
        if ((t = P(t)) === n)
            return O(t, e);
    } return !1; }, _.nodeContains = function (t, e) { if (t.contains)
        return t.contains(e); for (; e;) {
        if (e === t)
            return !0;
        e = e.parentNode;
    } return !1; }, _.parentNode = P, _.trySelector = function (t) { return !!i.default.string(t) && (h.default.document.querySelector(t), !0); }; var E = function (t) { return t.parentNode || t.host; }; function S(t, e) { for (var n, r = [], o = t; (n = E(o)) && o !== e && n !== o.ownerDocument;)
        r.unshift(o), o = n; return r; } function T(t) { return { x: (t = t || e.window).scrollX || t.document.documentElement.scrollLeft, y: t.scrollY || t.document.documentElement.scrollTop }; } function j(t) { var e = t instanceof h.default.SVGElement ? t.getBoundingClientRect() : t.getClientRects()[0]; return e && { left: e.left, right: e.right, top: e.top, bottom: e.bottom, width: e.width || e.right - e.left, height: e.height || e.bottom - e.top }; } var M = {}; Object.defineProperty(M, "__esModule", { value: !0 }), M.default = function (t, e) { for (var n in e)
        t[n] = e[n]; return t; }; var k = {}; function I(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)
        r[n] = t[n]; return r; } function D(t, e, n) { return "parent" === t ? (0, _.parentNode)(n) : "self" === t ? e.getRect(n) : (0, _.closest)(n, t); } Object.defineProperty(k, "__esModule", { value: !0 }), k.addEdges = function (t, e, n) { t.left && (e.left += n.x), t.right && (e.right += n.x), t.top && (e.top += n.y), t.bottom && (e.bottom += n.y), e.width = e.right - e.left, e.height = e.bottom - e.top; }, k.getStringOptionResult = D, k.rectToXY = function (t) { return t && { x: "x" in t ? t.x : t.left, y: "y" in t ? t.y : t.top }; }, k.resolveRectLike = function (t, e, n, r) { var o, a = t; return i.default.string(a) ? a = D(a, e, n) : i.default.func(a) && (a = a.apply(void 0, function (t) { if (Array.isArray(t))
        return I(t); }(o = r) || function (t) { if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"])
        return Array.from(t); }(o) || function (t, e) { if (t) {
        if ("string" == typeof t)
            return I(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? I(t, e) : void 0;
    } }(o) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }())), i.default.element(a) && (a = (0, _.getElementRect)(a)), a; }, k.tlbrToXywh = function (t) { return !t || "x" in t && "y" in t || ((t = (0, M.default)({}, t)).x = t.left || 0, t.y = t.top || 0, t.width = t.width || (t.right || 0) - t.x, t.height = t.height || (t.bottom || 0) - t.y), t; }, k.xywhToTlbr = function (t) { return !t || "left" in t && "top" in t || ((t = (0, M.default)({}, t)).left = t.x || 0, t.top = t.y || 0, t.right = t.right || t.left + t.width, t.bottom = t.bottom || t.top + t.height), t; }; var A = {}; Object.defineProperty(A, "__esModule", { value: !0 }), A.default = function (t, e, n) { var r = t.options[n], o = r && r.origin || t.options.origin, i = (0, k.resolveRectLike)(o, t, e, [t && e]); return (0, k.rectToXY)(i) || { x: 0, y: 0 }; }; var z = {}; function C(t) { return t.trim().split(/ +/); } Object.defineProperty(z, "__esModule", { value: !0 }), z.default = function t(e, n, r) { if (r = r || {}, i.default.string(e) && -1 !== e.search(" ") && (e = C(e)), i.default.array(e))
        return e.reduce((function (e, o) { return (0, M.default)(e, t(o, n, r)); }), r); if (i.default.object(e) && (n = e, e = ""), i.default.func(n))
        r[e] = r[e] || [], r[e].push(n);
    else if (i.default.array(n))
        for (var o = 0; o < n.length; o++) {
            var a;
            a = n[o], t(e, a, r);
        }
    else if (i.default.object(n))
        for (var s in n) {
            var l = C(s).map((function (t) { return "".concat(e).concat(t); }));
            t(l, n[s], r);
        } return r; }; var R = {}; Object.defineProperty(R, "__esModule", { value: !0 }), R.default = void 0, R.default = function (t, e) { return Math.sqrt(t * t + e * e); }; var F = {}; Object.defineProperty(F, "__esModule", { value: !0 }), F.default = function (t, e) { t.__set || (t.__set = {}); var n = function (n) { "function" != typeof t[n] && "__set" !== n && Object.defineProperty(t, n, { get: function () { return n in t.__set ? t.__set[n] : t.__set[n] = e[n]; }, set: function (e) { t.__set[n] = e; }, configurable: !0 }); }; for (var r in e)
        n(r); return t; }; var X = {}; function B(t) { return t instanceof h.default.Event || t instanceof h.default.Touch; } function Y(t, e, n) { return t = t || "page", (n = n || {}).x = e[t + "X"], n.y = e[t + "Y"], n; } function W(t, e) { return e = e || { x: 0, y: 0 }, b.default.isOperaMobile && B(t) ? (Y("screen", t, e), e.x += window.scrollX, e.y += window.scrollY) : Y("page", t, e), e; } function L(t, e) { return e = e || {}, b.default.isOperaMobile && B(t) ? Y("screen", t, e) : Y("client", t, e), e; } function U(t) { var e = []; return i.default.array(t) ? (e[0] = t[0], e[1] = t[1]) : "touchend" === t.type ? 1 === t.touches.length ? (e[0] = t.touches[0], e[1] = t.changedTouches[0]) : 0 === t.touches.length && (e[0] = t.changedTouches[0], e[1] = t.changedTouches[1]) : (e[0] = t.touches[0], e[1] = t.touches[1]), e; } function V(t) { for (var e = { pageX: 0, pageY: 0, clientX: 0, clientY: 0, screenX: 0, screenY: 0 }, n = 0; n < t.length; n++) {
        var r = t[n];
        for (var o in e)
            e[o] += r[o];
    } for (var i in e)
        e[i] /= t.length; return e; } Object.defineProperty(X, "__esModule", { value: !0 }), X.coordsToEvent = function (t) { return { coords: t, get page() { return this.coords.page; }, get client() { return this.coords.client; }, get timeStamp() { return this.coords.timeStamp; }, get pageX() { return this.coords.page.x; }, get pageY() { return this.coords.page.y; }, get clientX() { return this.coords.client.x; }, get clientY() { return this.coords.client.y; }, get pointerId() { return this.coords.pointerId; }, get target() { return this.coords.target; }, get type() { return this.coords.type; }, get pointerType() { return this.coords.pointerType; }, get buttons() { return this.coords.buttons; }, preventDefault: function () { } }; }, X.copyCoords = function (t, e) { t.page = t.page || {}, t.page.x = e.page.x, t.page.y = e.page.y, t.client = t.client || {}, t.client.x = e.client.x, t.client.y = e.client.y, t.timeStamp = e.timeStamp; }, X.getClientXY = L, X.getEventTargets = function (t) { var e = i.default.func(t.composedPath) ? t.composedPath() : t.path; return [_.getActualElement(e ? e[0] : t.target), _.getActualElement(t.currentTarget)]; }, X.getPageXY = W, X.getPointerId = function (t) { return i.default.number(t.pointerId) ? t.pointerId : t.identifier; }, X.getPointerType = function (t) { return i.default.string(t.pointerType) ? t.pointerType : i.default.number(t.pointerType) ? [void 0, void 0, "touch", "pen", "mouse"][t.pointerType] : /touch/.test(t.type || "") || t instanceof h.default.Touch ? "touch" : "mouse"; }, X.getTouchPair = U, X.getXY = Y, X.isNativePointer = B, X.newCoords = function () { return { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }; }, X.pointerAverage = V, Object.defineProperty(X, "pointerExtend", { enumerable: !0, get: function () { return F.default; } }), X.setCoordDeltas = function (t, e, n) { t.page.x = n.page.x - e.page.x, t.page.y = n.page.y - e.page.y, t.client.x = n.client.x - e.client.x, t.client.y = n.client.y - e.client.y, t.timeStamp = n.timeStamp - e.timeStamp; }, X.setCoordVelocity = function (t, e) { var n = Math.max(e.timeStamp / 1e3, .001); t.page.x = e.page.x / n, t.page.y = e.page.y / n, t.client.x = e.client.x / n, t.client.y = e.client.y / n, t.timeStamp = n; }, X.setCoords = function (t, e, n) { var r = e.length > 1 ? V(e) : e[0]; W(r, t.page), L(r, t.client), t.timeStamp = n; }, X.setZeroCoords = function (t) { t.page.x = 0, t.page.y = 0, t.client.x = 0, t.client.y = 0; }, X.touchAngle = function (t, e) { var n = e + "X", r = e + "Y", o = U(t), i = o[1][n] - o[0][n], a = o[1][r] - o[0][r]; return 180 * Math.atan2(a, i) / Math.PI; }, X.touchBBox = function (t) { if (!t.length)
        return null; var e = U(t), n = Math.min(e[0].pageX, e[1].pageX), r = Math.min(e[0].pageY, e[1].pageY), o = Math.max(e[0].pageX, e[1].pageX), i = Math.max(e[0].pageY, e[1].pageY); return { x: n, y: r, left: n, top: r, right: o, bottom: i, width: o - n, height: i - r }; }, X.touchDistance = function (t, e) { var n = e + "X", r = e + "Y", o = U(t), i = o[0][n] - o[1][n], a = o[0][r] - o[1][r]; return (0, R.default)(i, a); }; var N = {}; function q(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function G(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } Object.defineProperty(N, "__esModule", { value: !0 }), N.BaseEvent = void 0; var $ = function () { function t(e) { !function (t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); }(this, t), G(this, "immediatePropagationStopped", !1), G(this, "propagationStopped", !1), this._interaction = e; } var e, n; return e = t, (n = [{ key: "preventDefault", value: function () { } }, { key: "stopPropagation", value: function () { this.propagationStopped = !0; } }, { key: "stopImmediatePropagation", value: function () { this.immediatePropagationStopped = this.propagationStopped = !0; } }]) && q(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t; }(); N.BaseEvent = $, Object.defineProperty($.prototype, "interaction", { get: function () { return this._interaction._proxy; }, set: function () { } }); var H = {}; Object.defineProperty(H, "__esModule", { value: !0 }), H.remove = H.merge = H.from = H.findIndex = H.find = H.contains = void 0, H.contains = function (t, e) { return -1 !== t.indexOf(e); }, H.remove = function (t, e) { return t.splice(t.indexOf(e), 1); }; var K = function (t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        t.push(r);
    } return t; }; H.merge = K, H.from = function (t) { return K([], t); }; var Z = function (t, e) { for (var n = 0; n < t.length; n++)
        if (e(t[n], n, t))
            return n; return -1; }; H.findIndex = Z, H.find = function (t, e) { return t[Z(t, e)]; }; var J = {}; function Q(t) { return Q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t; } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }, Q(t); } function tt(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function et(t, e) { return et = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, et(t, e); } function nt(t, e) { if (e && ("object" === Q(e) || "function" == typeof e))
        return e; if (void 0 !== e)
        throw new TypeError("Derived constructors may only return object or undefined"); return rt(t); } function rt(t) { if (void 0 === t)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; } function ot(t) { return ot = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, ot(t); } function it(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } Object.defineProperty(J, "__esModule", { value: !0 }), J.DropEvent = void 0; var at = function (t) { !function (t, e) { if ("function" != typeof e && null !== e)
        throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && et(t, e); }(a, t); var e, n, r, o, i = (r = a, o = function () { if ("undefined" == typeof Reflect || !Reflect.construct)
        return !1; if (Reflect.construct.sham)
        return !1; if ("function" == typeof Proxy)
        return !0; try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0;
    }
    catch (t) {
        return !1;
    } }(), function () { var t, e = ot(r); if (o) {
        var n = ot(this).constructor;
        t = Reflect.construct(e, arguments, n);
    }
    else
        t = e.apply(this, arguments); return nt(this, t); }); function a(t, e, n) { var r; !function (t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); }(this, a), it(rt(r = i.call(this, e._interaction)), "dropzone", void 0), it(rt(r), "dragEvent", void 0), it(rt(r), "relatedTarget", void 0), it(rt(r), "draggable", void 0), it(rt(r), "propagationStopped", !1), it(rt(r), "immediatePropagationStopped", !1); var o = "dragleave" === n ? t.prev : t.cur, s = o.element, l = o.dropzone; return r.type = n, r.target = s, r.currentTarget = s, r.dropzone = l, r.dragEvent = e, r.relatedTarget = e.target, r.draggable = e.interactable, r.timeStamp = e.timeStamp, r; } return e = a, (n = [{ key: "reject", value: function () { var t = this, e = this._interaction.dropState; if ("dropactivate" === this.type || this.dropzone && e.cur.dropzone === this.dropzone && e.cur.element === this.target)
                if (e.prev.dropzone = this.dropzone, e.prev.element = this.target, e.rejected = !0, e.events.enter = null, this.stopImmediatePropagation(), "dropactivate" === this.type) {
                    var n = e.activeDrops, r = H.findIndex(n, (function (e) { var n = e.dropzone, r = e.element; return n === t.dropzone && r === t.target; }));
                    e.activeDrops.splice(r, 1);
                    var o = new a(e, this.dragEvent, "dropdeactivate");
                    o.dropzone = this.dropzone, o.target = this.target, this.dropzone.fire(o);
                }
                else
                    this.dropzone.fire(new a(e, this.dragEvent, "dragleave")); } }, { key: "preventDefault", value: function () { } }, { key: "stopPropagation", value: function () { this.propagationStopped = !0; } }, { key: "stopImmediatePropagation", value: function () { this.immediatePropagationStopped = this.propagationStopped = !0; } }]) && tt(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), a; }(N.BaseEvent); J.DropEvent = at; var st = {}; function lt(t, e) { for (var n = 0; n < t.slice().length; n++) {
        var r = t.slice()[n], o = r.dropzone, i = r.element;
        e.dropzone = o, e.target = i, o.fire(e), e.propagationStopped = e.immediatePropagationStopped = !1;
    } } function ut(t, e) { for (var n = function (t, e) { for (var n = t.interactables, r = [], o = 0; o < n.list.length; o++) {
        var a = n.list[o];
        if (a.options.drop.enabled) {
            var s = a.options.drop.accept;
            if (!(i.default.element(s) && s !== e || i.default.string(s) && !_.matchesSelector(e, s) || i.default.func(s) && !s({ dropzone: a, draggableElement: e })))
                for (var l = i.default.string(a.target) ? a._context.querySelectorAll(a.target) : i.default.array(a.target) ? a.target : [a.target], u = 0; u < l.length; u++) {
                    var c = l[u];
                    c !== e && r.push({ dropzone: a, element: c, rect: a.getRect(c) });
                }
        }
    } return r; }(t, e), r = 0; r < n.length; r++) {
        var o = n[r];
        o.rect = o.dropzone.getRect(o.element);
    } return n; } function ct(t, e, n) { for (var r = t.dropState, o = t.interactable, i = t.element, a = [], s = 0; s < r.activeDrops.length; s++) {
        var l = r.activeDrops[s], u = l.dropzone, c = l.element, f = l.rect;
        a.push(u.dropCheck(e, n, o, i, c, f) ? c : null);
    } var d = _.indexOfDeepestElement(a); return r.activeDrops[d] || null; } function ft(t, e, n) { var r = t.dropState, o = { enter: null, leave: null, activate: null, deactivate: null, move: null, drop: null }; return "dragstart" === n.type && (o.activate = new J.DropEvent(r, n, "dropactivate"), o.activate.target = null, o.activate.dropzone = null), "dragend" === n.type && (o.deactivate = new J.DropEvent(r, n, "dropdeactivate"), o.deactivate.target = null, o.deactivate.dropzone = null), r.rejected || (r.cur.element !== r.prev.element && (r.prev.dropzone && (o.leave = new J.DropEvent(r, n, "dragleave"), n.dragLeave = o.leave.target = r.prev.element, n.prevDropzone = o.leave.dropzone = r.prev.dropzone), r.cur.dropzone && (o.enter = new J.DropEvent(r, n, "dragenter"), n.dragEnter = r.cur.element, n.dropzone = r.cur.dropzone)), "dragend" === n.type && r.cur.dropzone && (o.drop = new J.DropEvent(r, n, "drop"), n.dropzone = r.cur.dropzone, n.relatedTarget = r.cur.element), "dragmove" === n.type && r.cur.dropzone && (o.move = new J.DropEvent(r, n, "dropmove"), o.move.dragmove = n, n.dropzone = r.cur.dropzone)), o; } function dt(t, e) { var n = t.dropState, r = n.activeDrops, o = n.cur, i = n.prev; e.leave && i.dropzone.fire(e.leave), e.enter && o.dropzone.fire(e.enter), e.move && o.dropzone.fire(e.move), e.drop && o.dropzone.fire(e.drop), e.deactivate && lt(r, e.deactivate), n.prev.dropzone = o.dropzone, n.prev.element = o.element; } function pt(t, e) { var n = t.interaction, r = t.iEvent, o = t.event; if ("dragmove" === r.type || "dragend" === r.type) {
        var i = n.dropState;
        e.dynamicDrop && (i.activeDrops = ut(e, n.element));
        var a = r, s = ct(n, a, o);
        i.rejected = i.rejected && !!s && s.dropzone === i.cur.dropzone && s.element === i.cur.element, i.cur.dropzone = s && s.dropzone, i.cur.element = s && s.element, i.events = ft(n, 0, a);
    } } Object.defineProperty(st, "__esModule", { value: !0 }), st.default = void 0; var vt = { id: "actions/drop", install: function (t) { var e = t.actions, n = t.interactStatic, r = t.Interactable, o = t.defaults; t.usePlugin(c.default), r.prototype.dropzone = function (t) { return function (t, e) { if (i.default.object(e)) {
            if (t.options.drop.enabled = !1 !== e.enabled, e.listeners) {
                var n = (0, z.default)(e.listeners), r = Object.keys(n).reduce((function (t, e) { return t[/^(enter|leave)/.test(e) ? "drag".concat(e) : /^(activate|deactivate|move)/.test(e) ? "drop".concat(e) : e] = n[e], t; }), {});
                t.off(t.options.drop.listeners), t.on(r), t.options.drop.listeners = r;
            }
            return i.default.func(e.ondrop) && t.on("drop", e.ondrop), i.default.func(e.ondropactivate) && t.on("dropactivate", e.ondropactivate), i.default.func(e.ondropdeactivate) && t.on("dropdeactivate", e.ondropdeactivate), i.default.func(e.ondragenter) && t.on("dragenter", e.ondragenter), i.default.func(e.ondragleave) && t.on("dragleave", e.ondragleave), i.default.func(e.ondropmove) && t.on("dropmove", e.ondropmove), /^(pointer|center)$/.test(e.overlap) ? t.options.drop.overlap = e.overlap : i.default.number(e.overlap) && (t.options.drop.overlap = Math.max(Math.min(1, e.overlap), 0)), "accept" in e && (t.options.drop.accept = e.accept), "checker" in e && (t.options.drop.checker = e.checker), t;
        } return i.default.bool(e) ? (t.options.drop.enabled = e, t) : t.options.drop; }(this, t); }, r.prototype.dropCheck = function (t, e, n, r, o, a) { return function (t, e, n, r, o, a, s) { var l = !1; if (!(s = s || t.getRect(a)))
            return !!t.options.drop.checker && t.options.drop.checker(e, n, l, t, a, r, o); var u = t.options.drop.overlap; if ("pointer" === u) {
            var c = (0, A.default)(r, o, "drag"), f = X.getPageXY(e);
            f.x += c.x, f.y += c.y;
            var d = f.x > s.left && f.x < s.right, p = f.y > s.top && f.y < s.bottom;
            l = d && p;
        } var v = r.getRect(o); if (v && "center" === u) {
            var h = v.left + v.width / 2, g = v.top + v.height / 2;
            l = h >= s.left && h <= s.right && g >= s.top && g <= s.bottom;
        } return v && i.default.number(u) && (l = Math.max(0, Math.min(s.right, v.right) - Math.max(s.left, v.left)) * Math.max(0, Math.min(s.bottom, v.bottom) - Math.max(s.top, v.top)) / (v.width * v.height) >= u), t.options.drop.checker && (l = t.options.drop.checker(e, n, l, t, a, r, o)), l; }(this, t, e, n, r, o, a); }, n.dynamicDrop = function (e) { return i.default.bool(e) ? (t.dynamicDrop = e, n) : t.dynamicDrop; }, (0, M.default)(e.phaselessTypes, { dragenter: !0, dragleave: !0, dropactivate: !0, dropdeactivate: !0, dropmove: !0, drop: !0 }), e.methodDict.drop = "dropzone", t.dynamicDrop = !1, o.actions.drop = vt.defaults; }, listeners: { "interactions:before-action-start": function (t) { var e = t.interaction; "drag" === e.prepared.name && (e.dropState = { cur: { dropzone: null, element: null }, prev: { dropzone: null, element: null }, rejected: null, events: null, activeDrops: [] }); }, "interactions:after-action-start": function (t, e) { var n = t.interaction, r = (t.event, t.iEvent); if ("drag" === n.prepared.name) {
                var o = n.dropState;
                o.activeDrops = null, o.events = null, o.activeDrops = ut(e, n.element), o.events = ft(n, 0, r), o.events.activate && (lt(o.activeDrops, o.events.activate), e.fire("actions/drop:start", { interaction: n, dragEvent: r }));
            } }, "interactions:action-move": pt, "interactions:after-action-move": function (t, e) { var n = t.interaction, r = t.iEvent; "drag" === n.prepared.name && (dt(n, n.dropState.events), e.fire("actions/drop:move", { interaction: n, dragEvent: r }), n.dropState.events = {}); }, "interactions:action-end": function (t, e) { if ("drag" === t.interaction.prepared.name) {
                var n = t.interaction, r = t.iEvent;
                pt(t, e), dt(n, n.dropState.events), e.fire("actions/drop:end", { interaction: n, dragEvent: r });
            } }, "interactions:stop": function (t) { var e = t.interaction; if ("drag" === e.prepared.name) {
                var n = e.dropState;
                n && (n.activeDrops = null, n.events = null, n.cur.dropzone = null, n.cur.element = null, n.prev.dropzone = null, n.prev.element = null, n.rejected = !1);
            } } }, getActiveDrops: ut, getDrop: ct, getDropEvents: ft, fireDropEvents: dt, defaults: { enabled: !1, accept: null, overlap: "pointer" } }, ht = vt; st.default = ht; var gt = {}; function yt(t) { var e = t.interaction, n = t.iEvent, r = t.phase; if ("gesture" === e.prepared.name) {
        var o = e.pointers.map((function (t) { return t.pointer; })), a = "start" === r, s = "end" === r, l = e.interactable.options.deltaSource;
        if (n.touches = [o[0], o[1]], a)
            n.distance = X.touchDistance(o, l), n.box = X.touchBBox(o), n.scale = 1, n.ds = 0, n.angle = X.touchAngle(o, l), n.da = 0, e.gesture.startDistance = n.distance, e.gesture.startAngle = n.angle;
        else if (s) {
            var u = e.prevEvent;
            n.distance = u.distance, n.box = u.box, n.scale = u.scale, n.ds = 0, n.angle = u.angle, n.da = 0;
        }
        else
            n.distance = X.touchDistance(o, l), n.box = X.touchBBox(o), n.scale = n.distance / e.gesture.startDistance, n.angle = X.touchAngle(o, l), n.ds = n.scale - e.gesture.scale, n.da = n.angle - e.gesture.angle;
        e.gesture.distance = n.distance, e.gesture.angle = n.angle, i.default.number(n.scale) && n.scale !== 1 / 0 && !isNaN(n.scale) && (e.gesture.scale = n.scale);
    } } Object.defineProperty(gt, "__esModule", { value: !0 }), gt.default = void 0; var mt = { id: "actions/gesture", before: ["actions/drag", "actions/resize"], install: function (t) { var e = t.actions, n = t.Interactable, r = t.defaults; n.prototype.gesturable = function (t) { return i.default.object(t) ? (this.options.gesture.enabled = !1 !== t.enabled, this.setPerAction("gesture", t), this.setOnEvents("gesture", t), this) : i.default.bool(t) ? (this.options.gesture.enabled = t, this) : this.options.gesture; }, e.map.gesture = mt, e.methodDict.gesture = "gesturable", r.actions.gesture = mt.defaults; }, listeners: { "interactions:action-start": yt, "interactions:action-move": yt, "interactions:action-end": yt, "interactions:new": function (t) { t.interaction.gesture = { angle: 0, distance: 0, scale: 1, startAngle: 0, startDistance: 0 }; }, "auto-start:check": function (t) { if (!(t.interaction.pointers.length < 2)) {
                var e = t.interactable.options.gesture;
                if (e && e.enabled)
                    return t.action = { name: "gesture" }, !1;
            } } }, defaults: {}, getCursor: function () { return ""; } }, bt = mt; gt.default = bt; var xt = {}; function wt(t, e, n, r, o, a, s) { if (!e)
        return !1; if (!0 === e) {
        var l = i.default.number(a.width) ? a.width : a.right - a.left, u = i.default.number(a.height) ? a.height : a.bottom - a.top;
        if (s = Math.min(s, Math.abs(("left" === t || "right" === t ? l : u) / 2)), l < 0 && ("left" === t ? t = "right" : "right" === t && (t = "left")), u < 0 && ("top" === t ? t = "bottom" : "bottom" === t && (t = "top")), "left" === t) {
            var c = l >= 0 ? a.left : a.right;
            return n.x < c + s;
        }
        if ("top" === t) {
            var f = u >= 0 ? a.top : a.bottom;
            return n.y < f + s;
        }
        if ("right" === t)
            return n.x > (l >= 0 ? a.right : a.left) - s;
        if ("bottom" === t)
            return n.y > (u >= 0 ? a.bottom : a.top) - s;
    } return !!i.default.element(r) && (i.default.element(e) ? e === r : _.matchesUpTo(r, e, o)); } function _t(t) { var e = t.iEvent, n = t.interaction; if ("resize" === n.prepared.name && n.resizeAxes) {
        var r = e;
        n.interactable.options.resize.square ? ("y" === n.resizeAxes ? r.delta.x = r.delta.y : r.delta.y = r.delta.x, r.axes = "xy") : (r.axes = n.resizeAxes, "x" === n.resizeAxes ? r.delta.y = 0 : "y" === n.resizeAxes && (r.delta.x = 0));
    } } Object.defineProperty(xt, "__esModule", { value: !0 }), xt.default = void 0; var Pt = { id: "actions/resize", before: ["actions/drag"], install: function (t) { var e = t.actions, n = t.browser, r = t.Interactable, o = t.defaults; Pt.cursors = function (t) { return t.isIe9 ? { x: "e-resize", y: "s-resize", xy: "se-resize", top: "n-resize", left: "w-resize", bottom: "s-resize", right: "e-resize", topleft: "se-resize", bottomright: "se-resize", topright: "ne-resize", bottomleft: "ne-resize" } : { x: "ew-resize", y: "ns-resize", xy: "nwse-resize", top: "ns-resize", left: "ew-resize", bottom: "ns-resize", right: "ew-resize", topleft: "nwse-resize", bottomright: "nwse-resize", topright: "nesw-resize", bottomleft: "nesw-resize" }; }(n), Pt.defaultMargin = n.supportsTouch || n.supportsPointerEvent ? 20 : 10, r.prototype.resizable = function (e) { return function (t, e, n) { return i.default.object(e) ? (t.options.resize.enabled = !1 !== e.enabled, t.setPerAction("resize", e), t.setOnEvents("resize", e), i.default.string(e.axis) && /^x$|^y$|^xy$/.test(e.axis) ? t.options.resize.axis = e.axis : null === e.axis && (t.options.resize.axis = n.defaults.actions.resize.axis), i.default.bool(e.preserveAspectRatio) ? t.options.resize.preserveAspectRatio = e.preserveAspectRatio : i.default.bool(e.square) && (t.options.resize.square = e.square), t) : i.default.bool(e) ? (t.options.resize.enabled = e, t) : t.options.resize; }(this, e, t); }, e.map.resize = Pt, e.methodDict.resize = "resizable", o.actions.resize = Pt.defaults; }, listeners: { "interactions:new": function (t) { t.interaction.resizeAxes = "xy"; }, "interactions:action-start": function (t) { !function (t) { var e = t.iEvent, n = t.interaction; if ("resize" === n.prepared.name && n.prepared.edges) {
                var r = e, o = n.rect;
                n._rects = { start: (0, M.default)({}, o), corrected: (0, M.default)({}, o), previous: (0, M.default)({}, o), delta: { left: 0, right: 0, width: 0, top: 0, bottom: 0, height: 0 } }, r.edges = n.prepared.edges, r.rect = n._rects.corrected, r.deltaRect = n._rects.delta;
            } }(t), _t(t); }, "interactions:action-move": function (t) { !function (t) { var e = t.iEvent, n = t.interaction; if ("resize" === n.prepared.name && n.prepared.edges) {
                var r = e, o = n.interactable.options.resize.invert, i = "reposition" === o || "negate" === o, a = n.rect, s = n._rects, l = s.start, u = s.corrected, c = s.delta, f = s.previous;
                if ((0, M.default)(f, u), i) {
                    if ((0, M.default)(u, a), "reposition" === o) {
                        if (u.top > u.bottom) {
                            var d = u.top;
                            u.top = u.bottom, u.bottom = d;
                        }
                        if (u.left > u.right) {
                            var p = u.left;
                            u.left = u.right, u.right = p;
                        }
                    }
                }
                else
                    u.top = Math.min(a.top, l.bottom), u.bottom = Math.max(a.bottom, l.top), u.left = Math.min(a.left, l.right), u.right = Math.max(a.right, l.left);
                for (var v in u.width = u.right - u.left, u.height = u.bottom - u.top, u)
                    c[v] = u[v] - f[v];
                r.edges = n.prepared.edges, r.rect = u, r.deltaRect = c;
            } }(t), _t(t); }, "interactions:action-end": function (t) { var e = t.iEvent, n = t.interaction; if ("resize" === n.prepared.name && n.prepared.edges) {
                var r = e;
                r.edges = n.prepared.edges, r.rect = n._rects.corrected, r.deltaRect = n._rects.delta;
            } }, "auto-start:check": function (t) { var e = t.interaction, n = t.interactable, r = t.element, o = t.rect, a = t.buttons; if (o) {
                var s = (0, M.default)({}, e.coords.cur.page), l = n.options.resize;
                if (l && l.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || 0 != (a & l.mouseButtons))) {
                    if (i.default.object(l.edges)) {
                        var u = { left: !1, right: !1, top: !1, bottom: !1 };
                        for (var c in u)
                            u[c] = wt(c, l.edges[c], s, e._latestPointer.eventTarget, r, o, l.margin || Pt.defaultMargin);
                        u.left = u.left && !u.right, u.top = u.top && !u.bottom, (u.left || u.right || u.top || u.bottom) && (t.action = { name: "resize", edges: u });
                    }
                    else {
                        var f = "y" !== l.axis && s.x > o.right - Pt.defaultMargin, d = "x" !== l.axis && s.y > o.bottom - Pt.defaultMargin;
                        (f || d) && (t.action = { name: "resize", axes: (f ? "x" : "") + (d ? "y" : "") });
                    }
                    return !t.action && void 0;
                }
            } } }, defaults: { square: !1, preserveAspectRatio: !1, axis: "xy", margin: NaN, edges: null, invert: "none" }, cursors: null, getCursor: function (t) { var e = t.edges, n = t.axis, r = t.name, o = Pt.cursors, i = null; if (n)
            i = o[r + n];
        else if (e) {
            for (var a = "", s = ["top", "bottom", "left", "right"], l = 0; l < s.length; l++) {
                var u = s[l];
                e[u] && (a += u);
            }
            i = o[a];
        } return i; }, defaultMargin: null }, Ot = Pt; xt.default = Ot; var Et = {}; Object.defineProperty(Et, "__esModule", { value: !0 }), Et.default = void 0; var St = { id: "actions", install: function (t) { t.usePlugin(gt.default), t.usePlugin(xt.default), t.usePlugin(c.default), t.usePlugin(st.default); } }; Et.default = St; var Tt = {}; Object.defineProperty(Tt, "__esModule", { value: !0 }), Tt.default = void 0; var jt, Mt, kt = 0, It = { request: function (t) { return jt(t); }, cancel: function (t) { return Mt(t); }, init: function (t) { if (jt = t.requestAnimationFrame, Mt = t.cancelAnimationFrame, !jt)
            for (var e = ["ms", "moz", "webkit", "o"], n = 0; n < e.length; n++) {
                var r = e[n];
                jt = t["".concat(r, "RequestAnimationFrame")], Mt = t["".concat(r, "CancelAnimationFrame")] || t["".concat(r, "CancelRequestAnimationFrame")];
            } jt = jt && jt.bind(t), Mt = Mt && Mt.bind(t), jt || (jt = function (e) { var n = Date.now(), r = Math.max(0, 16 - (n - kt)), o = t.setTimeout((function () { e(n + r); }), r); return kt = n + r, o; }, Mt = function (t) { return clearTimeout(t); }); } }; Tt.default = It; var Dt = {}; Object.defineProperty(Dt, "__esModule", { value: !0 }), Dt.default = void 0, Dt.getContainer = zt, Dt.getScroll = Ct, Dt.getScrollSize = function (t) { return i.default.window(t) && (t = window.document.body), { x: t.scrollWidth, y: t.scrollHeight }; }, Dt.getScrollSizeDelta = function (t, e) { var n = t.interaction, r = t.element, o = n && n.interactable.options[n.prepared.name].autoScroll; if (!o || !o.enabled)
        return e(), { x: 0, y: 0 }; var i = zt(o.container, n.interactable, r), a = Ct(i); e(); var s = Ct(i); return { x: s.x - a.x, y: s.y - a.y }; }; var At = { defaults: { enabled: !1, margin: 60, container: null, speed: 300 }, now: Date.now, interaction: null, i: 0, x: 0, y: 0, isScrolling: !1, prevTime: 0, margin: 0, speed: 0, start: function (t) { At.isScrolling = !0, Tt.default.cancel(At.i), t.autoScroll = At, At.interaction = t, At.prevTime = At.now(), At.i = Tt.default.request(At.scroll); }, stop: function () { At.isScrolling = !1, At.interaction && (At.interaction.autoScroll = null), Tt.default.cancel(At.i); }, scroll: function () { var t = At.interaction, e = t.interactable, n = t.element, r = t.prepared.name, o = e.options[r].autoScroll, a = zt(o.container, e, n), s = At.now(), l = (s - At.prevTime) / 1e3, u = o.speed * l; if (u >= 1) {
            var c = { x: At.x * u, y: At.y * u };
            if (c.x || c.y) {
                var f = Ct(a);
                i.default.window(a) ? a.scrollBy(c.x, c.y) : a && (a.scrollLeft += c.x, a.scrollTop += c.y);
                var d = Ct(a), p = { x: d.x - f.x, y: d.y - f.y };
                (p.x || p.y) && e.fire({ type: "autoscroll", target: n, interactable: e, delta: p, interaction: t, container: a });
            }
            At.prevTime = s;
        } At.isScrolling && (Tt.default.cancel(At.i), At.i = Tt.default.request(At.scroll)); }, check: function (t, e) { var n; return null == (n = t.options[e].autoScroll) ? void 0 : n.enabled; }, onInteractionMove: function (t) { var e = t.interaction, n = t.pointer; if (e.interacting() && At.check(e.interactable, e.prepared.name))
            if (e.simulation)
                At.x = At.y = 0;
            else {
                var r, o, a, s, l = e.interactable, u = e.element, c = e.prepared.name, f = l.options[c].autoScroll, d = zt(f.container, l, u);
                if (i.default.window(d))
                    s = n.clientX < At.margin, r = n.clientY < At.margin, o = n.clientX > d.innerWidth - At.margin, a = n.clientY > d.innerHeight - At.margin;
                else {
                    var p = _.getElementClientRect(d);
                    s = n.clientX < p.left + At.margin, r = n.clientY < p.top + At.margin, o = n.clientX > p.right - At.margin, a = n.clientY > p.bottom - At.margin;
                }
                At.x = o ? 1 : s ? -1 : 0, At.y = a ? 1 : r ? -1 : 0, At.isScrolling || (At.margin = f.margin, At.speed = f.speed, At.start(e));
            } } }; function zt(t, n, r) { return (i.default.string(t) ? (0, k.getStringOptionResult)(t, n, r) : t) || (0, e.getWindow)(r); } function Ct(t) { return i.default.window(t) && (t = window.document.body), { x: t.scrollLeft, y: t.scrollTop }; } var Rt = { id: "auto-scroll", install: function (t) { var e = t.defaults, n = t.actions; t.autoScroll = At, At.now = function () { return t.now(); }, n.phaselessTypes.autoscroll = !0, e.perAction.autoScroll = At.defaults; }, listeners: { "interactions:new": function (t) { t.interaction.autoScroll = null; }, "interactions:destroy": function (t) { t.interaction.autoScroll = null, At.stop(), At.interaction && (At.interaction = null); }, "interactions:stop": At.stop, "interactions:action-move": function (t) { return At.onInteractionMove(t); } } }, Ft = Rt; Dt.default = Ft; var Xt = {}; Object.defineProperty(Xt, "__esModule", { value: !0 }), Xt.copyAction = function (t, e) { return t.name = e.name, t.axis = e.axis, t.edges = e.edges, t; }, Xt.sign = void 0, Xt.warnOnce = function (t, n) { var r = !1; return function () { return r || (e.window.console.warn(n), r = !0), t.apply(this, arguments); }; }, Xt.sign = function (t) { return t >= 0 ? 1 : -1; }; var Bt = {}; function Yt(t) { return i.default.bool(t) ? (this.options.styleCursor = t, this) : null === t ? (delete this.options.styleCursor, this) : this.options.styleCursor; } function Wt(t) { return i.default.func(t) ? (this.options.actionChecker = t, this) : null === t ? (delete this.options.actionChecker, this) : this.options.actionChecker; } Object.defineProperty(Bt, "__esModule", { value: !0 }), Bt.default = void 0; var Lt = { id: "auto-start/interactableMethods", install: function (t) { var e = t.Interactable; e.prototype.getAction = function (e, n, r, o) { var i = function (t, e, n, r, o) { var i = t.getRect(r), a = { action: null, interactable: t, interaction: n, element: r, rect: i, buttons: e.buttons || { 0: 1, 1: 4, 3: 8, 4: 16 }[e.button] }; return o.fire("auto-start:check", a), a.action; }(this, n, r, o, t); return this.options.actionChecker ? this.options.actionChecker(e, n, i, this, o, r) : i; }, e.prototype.ignoreFrom = (0, Xt.warnOnce)((function (t) { return this._backCompatOption("ignoreFrom", t); }), "Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."), e.prototype.allowFrom = (0, Xt.warnOnce)((function (t) { return this._backCompatOption("allowFrom", t); }), "Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."), e.prototype.actionChecker = Wt, e.prototype.styleCursor = Yt; } }; Bt.default = Lt; var Ut = {}; function Vt(t, e, n, r, o) { return e.testIgnoreAllow(e.options[t.name], n, r) && e.options[t.name].enabled && $t(e, n, t, o) ? t : null; } function Nt(t, e, n, r, o, i, a) { for (var s = 0, l = r.length; s < l; s++) {
        var u = r[s], c = o[s], f = u.getAction(e, n, t, c);
        if (f) {
            var d = Vt(f, u, c, i, a);
            if (d)
                return { action: d, interactable: u, element: c };
        }
    } return { action: null, interactable: null, element: null }; } function qt(t, e, n, r, o) { var a = [], s = [], l = r; function u(t) { a.push(t), s.push(l); } for (; i.default.element(l);) {
        a = [], s = [], o.interactables.forEachMatch(l, u);
        var c = Nt(t, e, n, a, s, r, o);
        if (c.action && !c.interactable.options[c.action.name].manualStart)
            return c;
        l = _.parentNode(l);
    } return { action: null, interactable: null, element: null }; } function Gt(t, e, n) { var r = e.action, o = e.interactable, i = e.element; r = r || { name: null }, t.interactable = o, t.element = i, (0, Xt.copyAction)(t.prepared, r), t.rect = o && r.name ? o.getRect(i) : null, Zt(t, n), n.fire("autoStart:prepared", { interaction: t }); } function $t(t, e, n, r) { var o = t.options, i = o[n.name].max, a = o[n.name].maxPerElement, s = r.autoStart.maxInteractions, l = 0, u = 0, c = 0; if (!(i && a && s))
        return !1; for (var f = 0; f < r.interactions.list.length; f++) {
        var d = r.interactions.list[f], p = d.prepared.name;
        if (d.interacting()) {
            if (++l >= s)
                return !1;
            if (d.interactable === t) {
                if ((u += p === n.name ? 1 : 0) >= i)
                    return !1;
                if (d.element === e && (c++, p === n.name && c >= a))
                    return !1;
            }
        }
    } return s > 0; } function Ht(t, e) { return i.default.number(t) ? (e.autoStart.maxInteractions = t, this) : e.autoStart.maxInteractions; } function Kt(t, e, n) { var r = n.autoStart.cursorElement; r && r !== t && (r.style.cursor = ""), t.ownerDocument.documentElement.style.cursor = e, t.style.cursor = e, n.autoStart.cursorElement = e ? t : null; } function Zt(t, e) { var n = t.interactable, r = t.element, o = t.prepared; if ("mouse" === t.pointerType && n && n.options.styleCursor) {
        var a = "";
        if (o.name) {
            var s = n.options[o.name].cursorChecker;
            a = i.default.func(s) ? s(o, n, r, t._interacting) : e.actions.map[o.name].getCursor(o);
        }
        Kt(t.element, a || "", e);
    }
    else
        e.autoStart.cursorElement && Kt(e.autoStart.cursorElement, "", e); } Object.defineProperty(Ut, "__esModule", { value: !0 }), Ut.default = void 0; var Jt = { id: "auto-start/base", before: ["actions"], install: function (t) { var e = t.interactStatic, n = t.defaults; t.usePlugin(Bt.default), n.base.actionChecker = null, n.base.styleCursor = !0, (0, M.default)(n.perAction, { manualStart: !1, max: 1 / 0, maxPerElement: 1, allowFrom: null, ignoreFrom: null, mouseButtons: 1 }), e.maxInteractions = function (e) { return Ht(e, t); }, t.autoStart = { maxInteractions: 1 / 0, withinInteractionLimit: $t, cursorElement: null }; }, listeners: { "interactions:down": function (t, e) { var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget; n.interacting() || Gt(n, qt(n, r, o, i, e), e); }, "interactions:move": function (t, e) { !function (t, e) { var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget; "mouse" !== n.pointerType || n.pointerIsDown || n.interacting() || Gt(n, qt(n, r, o, i, e), e); }(t, e), function (t, e) { var n = t.interaction; if (n.pointerIsDown && !n.interacting() && n.pointerWasMoved && n.prepared.name) {
                e.fire("autoStart:before-start", t);
                var r = n.interactable, o = n.prepared.name;
                o && r && (r.options[o].manualStart || !$t(r, n.element, n.prepared, e) ? n.stop() : (n.start(n.prepared, r, n.element), Zt(n, e)));
            } }(t, e); }, "interactions:stop": function (t, e) { var n = t.interaction, r = n.interactable; r && r.options.styleCursor && Kt(n.element, "", e); } }, maxInteractions: Ht, withinInteractionLimit: $t, validateAction: Vt }, Qt = Jt; Ut.default = Qt; var te = {}; Object.defineProperty(te, "__esModule", { value: !0 }), te.default = void 0; var ee = { id: "auto-start/dragAxis", listeners: { "autoStart:before-start": function (t, e) { var n = t.interaction, r = t.eventTarget, o = t.dx, a = t.dy; if ("drag" === n.prepared.name) {
                var s = Math.abs(o), l = Math.abs(a), u = n.interactable.options.drag, c = u.startAxis, f = s > l ? "x" : s < l ? "y" : "xy";
                if (n.prepared.axis = "start" === u.lockAxis ? f[0] : u.lockAxis, "xy" !== f && "xy" !== c && c !== f) {
                    n.prepared.name = null;
                    for (var d = r, p = function (t) { if (t !== n.interactable) {
                        var o = n.interactable.options.drag;
                        if (!o.manualStart && t.testIgnoreAllow(o, d, r)) {
                            var i = t.getAction(n.downPointer, n.downEvent, n, d);
                            if (i && "drag" === i.name && function (t, e) { if (!e)
                                return !1; var n = e.options.drag.startAxis; return "xy" === t || "xy" === n || n === t; }(f, t) && Ut.default.validateAction(i, t, d, r, e))
                                return t;
                        }
                    } }; i.default.element(d);) {
                        var v = e.interactables.forEachMatch(d, p);
                        if (v) {
                            n.prepared.name = "drag", n.interactable = v, n.element = d;
                            break;
                        }
                        d = (0, _.parentNode)(d);
                    }
                }
            } } } }; te.default = ee; var ne = {}; function re(t) { var e = t.prepared && t.prepared.name; if (!e)
        return null; var n = t.interactable.options; return n[e].hold || n[e].delay; } Object.defineProperty(ne, "__esModule", { value: !0 }), ne.default = void 0; var oe = { id: "auto-start/hold", install: function (t) { var e = t.defaults; t.usePlugin(Ut.default), e.perAction.hold = 0, e.perAction.delay = 0; }, listeners: { "interactions:new": function (t) { t.interaction.autoStartHoldTimer = null; }, "autoStart:prepared": function (t) { var e = t.interaction, n = re(e); n > 0 && (e.autoStartHoldTimer = setTimeout((function () { e.start(e.prepared, e.interactable, e.element); }), n)); }, "interactions:move": function (t) { var e = t.interaction, n = t.duplicate; e.autoStartHoldTimer && e.pointerWasMoved && !n && (clearTimeout(e.autoStartHoldTimer), e.autoStartHoldTimer = null); }, "autoStart:before-start": function (t) { var e = t.interaction; re(e) > 0 && (e.prepared.name = null); } }, getHoldDuration: re }, ie = oe; ne.default = ie; var ae = {}; Object.defineProperty(ae, "__esModule", { value: !0 }), ae.default = void 0; var se = { id: "auto-start", install: function (t) { t.usePlugin(Ut.default), t.usePlugin(ne.default), t.usePlugin(te.default); } }; ae.default = se; var le = {}; function ue(t) { return /^(always|never|auto)$/.test(t) ? (this.options.preventDefault = t, this) : i.default.bool(t) ? (this.options.preventDefault = t ? "always" : "never", this) : this.options.preventDefault; } function ce(t) { var e = t.interaction, n = t.event; e.interactable && e.interactable.checkAndPreventDefault(n); } function fe(t) { var n = t.Interactable; n.prototype.preventDefault = ue, n.prototype.checkAndPreventDefault = function (n) { return function (t, n, r) { var o = t.options.preventDefault; if ("never" !== o)
        if ("always" !== o) {
            if (n.events.supportsPassive && /^touch(start|move)$/.test(r.type)) {
                var a = (0, e.getWindow)(r.target).document, s = n.getDocOptions(a);
                if (!s || !s.events || !1 !== s.events.passive)
                    return;
            }
            /^(mouse|pointer|touch)*(down|start)/i.test(r.type) || i.default.element(r.target) && (0, _.matchesSelector)(r.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *") || r.preventDefault();
        }
        else
            r.preventDefault(); }(this, t, n); }, t.interactions.docEvents.push({ type: "dragstart", listener: function (e) { for (var n = 0; n < t.interactions.list.length; n++) {
            var r = t.interactions.list[n];
            if (r.element && (r.element === e.target || (0, _.nodeContains)(r.element, e.target)))
                return void r.interactable.checkAndPreventDefault(e);
        } } }); } Object.defineProperty(le, "__esModule", { value: !0 }), le.default = void 0, le.install = fe; var de = { id: "core/interactablePreventDefault", install: fe, listeners: ["down", "move", "up", "cancel"].reduce((function (t, e) { return t["interactions:".concat(e)] = ce, t; }), {}) }; le.default = de; var pe = {}; Object.defineProperty(pe, "__esModule", { value: !0 }), pe.default = void 0, pe.default = {}; var ve, he = {}; Object.defineProperty(he, "__esModule", { value: !0 }), he.default = void 0, function (t) { t.touchAction = "touchAction", t.boxSizing = "boxSizing", t.noListeners = "noListeners"; }(ve || (ve = {})); ve.touchAction, ve.boxSizing, ve.noListeners; var ge = { id: "dev-tools", install: function () { } }; he.default = ge; var ye = {}; Object.defineProperty(ye, "__esModule", { value: !0 }), ye.default = function t(e) { var n = {}; for (var r in e) {
        var o = e[r];
        i.default.plainObject(o) ? n[r] = t(o) : i.default.array(o) ? n[r] = H.from(o) : n[r] = o;
    } return n; }; var me = {}; function be(t, e) { return function (t) { if (Array.isArray(t))
        return t; }(t) || function (t, e) { var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (null != n) {
        var r, o, i = [], a = !0, s = !1;
        try {
            for (n = n.call(t); !(a = (r = n.next()).done) && (i.push(r.value), !e || i.length !== e); a = !0)
                ;
        }
        catch (t) {
            s = !0, o = t;
        }
        finally {
            try {
                a || null == n.return || n.return();
            }
            finally {
                if (s)
                    throw o;
            }
        }
        return i;
    } }(t, e) || function (t, e) { if (t) {
        if ("string" == typeof t)
            return xe(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? xe(t, e) : void 0;
    } }(t, e) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }(); } function xe(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)
        r[n] = t[n]; return r; } function we(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function _e(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } Object.defineProperty(me, "__esModule", { value: !0 }), me.default = void 0, me.getRectOffset = Ee; var Pe = function () { function t(e) { !function (t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); }(this, t), _e(this, "states", []), _e(this, "startOffset", { left: 0, right: 0, top: 0, bottom: 0 }), _e(this, "startDelta", void 0), _e(this, "result", void 0), _e(this, "endResult", void 0), _e(this, "edges", void 0), _e(this, "interaction", void 0), this.interaction = e, this.result = Oe(); } var e, n; return e = t, (n = [{ key: "start", value: function (t, e) { var n = t.phase, r = this.interaction, o = function (t) { var e = t.interactable.options[t.prepared.name], n = e.modifiers; return n && n.length ? n : ["snap", "snapSize", "snapEdges", "restrict", "restrictEdges", "restrictSize"].map((function (t) { var n = e[t]; return n && n.enabled && { options: n, methods: n._methods }; })).filter((function (t) { return !!t; })); }(r); this.prepareStates(o), this.edges = (0, M.default)({}, r.edges), this.startOffset = Ee(r.rect, e), this.startDelta = { x: 0, y: 0 }; var i = this.fillArg({ phase: n, pageCoords: e, preEnd: !1 }); return this.result = Oe(), this.startAll(i), this.result = this.setAll(i); } }, { key: "fillArg", value: function (t) { var e = this.interaction; return t.interaction = e, t.interactable = e.interactable, t.element = e.element, t.rect = t.rect || e.rect, t.edges = this.edges, t.startOffset = this.startOffset, t; } }, { key: "startAll", value: function (t) { for (var e = 0; e < this.states.length; e++) {
                var n = this.states[e];
                n.methods.start && (t.state = n, n.methods.start(t));
            } } }, { key: "setAll", value: function (t) { var e = t.phase, n = t.preEnd, r = t.skipModifiers, o = t.rect; t.coords = (0, M.default)({}, t.pageCoords), t.rect = (0, M.default)({}, o); for (var i = r ? this.states.slice(r) : this.states, a = Oe(t.coords, t.rect), s = 0; s < i.length; s++) {
                var l, u = i[s], c = u.options, f = (0, M.default)({}, t.coords), d = null;
                null != (l = u.methods) && l.set && this.shouldDo(c, n, e) && (t.state = u, d = u.methods.set(t), k.addEdges(this.interaction.edges, t.rect, { x: t.coords.x - f.x, y: t.coords.y - f.y })), a.eventProps.push(d);
            } a.delta.x = t.coords.x - t.pageCoords.x, a.delta.y = t.coords.y - t.pageCoords.y, a.rectDelta.left = t.rect.left - o.left, a.rectDelta.right = t.rect.right - o.right, a.rectDelta.top = t.rect.top - o.top, a.rectDelta.bottom = t.rect.bottom - o.bottom; var p = this.result.coords, v = this.result.rect; if (p && v) {
                var h = a.rect.left !== v.left || a.rect.right !== v.right || a.rect.top !== v.top || a.rect.bottom !== v.bottom;
                a.changed = h || p.x !== a.coords.x || p.y !== a.coords.y;
            } return a; } }, { key: "applyToInteraction", value: function (t) { var e = this.interaction, n = t.phase, r = e.coords.cur, o = e.coords.start, i = this.result, a = this.startDelta, s = i.delta; "start" === n && (0, M.default)(this.startDelta, i.delta); for (var l = 0; l < [[o, a], [r, s]].length; l++) {
                var u = be([[o, a], [r, s]][l], 2), c = u[0], f = u[1];
                c.page.x += f.x, c.page.y += f.y, c.client.x += f.x, c.client.y += f.y;
            } var d = this.result.rectDelta, p = t.rect || e.rect; p.left += d.left, p.right += d.right, p.top += d.top, p.bottom += d.bottom, p.width = p.right - p.left, p.height = p.bottom - p.top; } }, { key: "setAndApply", value: function (t) { var e = this.interaction, n = t.phase, r = t.preEnd, o = t.skipModifiers, i = this.setAll(this.fillArg({ preEnd: r, phase: n, pageCoords: t.modifiedCoords || e.coords.cur.page })); if (this.result = i, !i.changed && (!o || o < this.states.length) && e.interacting())
                return !1; if (t.modifiedCoords) {
                var a = e.coords.cur.page, s = { x: t.modifiedCoords.x - a.x, y: t.modifiedCoords.y - a.y };
                i.coords.x += s.x, i.coords.y += s.y, i.delta.x += s.x, i.delta.y += s.y;
            } this.applyToInteraction(t); } }, { key: "beforeEnd", value: function (t) { var e = t.interaction, n = t.event, r = this.states; if (r && r.length) {
                for (var o = !1, i = 0; i < r.length; i++) {
                    var a = r[i];
                    t.state = a;
                    var s = a.options, l = a.methods, u = l.beforeEnd && l.beforeEnd(t);
                    if (u)
                        return this.endResult = u, !1;
                    o = o || !o && this.shouldDo(s, !0, t.phase, !0);
                }
                o && e.move({ event: n, preEnd: !0 });
            } } }, { key: "stop", value: function (t) { var e = t.interaction; if (this.states && this.states.length) {
                var n = (0, M.default)({ states: this.states, interactable: e.interactable, element: e.element, rect: null }, t);
                this.fillArg(n);
                for (var r = 0; r < this.states.length; r++) {
                    var o = this.states[r];
                    n.state = o, o.methods.stop && o.methods.stop(n);
                }
                this.states = null, this.endResult = null;
            } } }, { key: "prepareStates", value: function (t) { this.states = []; for (var e = 0; e < t.length; e++) {
                var n = t[e], r = n.options, o = n.methods, i = n.name;
                this.states.push({ options: r, methods: o, index: e, name: i });
            } return this.states; } }, { key: "restoreInteractionCoords", value: function (t) { var e = t.interaction, n = e.coords, r = e.rect, o = e.modification; if (o.result) {
                for (var i = o.startDelta, a = o.result, s = a.delta, l = a.rectDelta, u = [[n.start, i], [n.cur, s]], c = 0; c < u.length; c++) {
                    var f = be(u[c], 2), d = f[0], p = f[1];
                    d.page.x -= p.x, d.page.y -= p.y, d.client.x -= p.x, d.client.y -= p.y;
                }
                r.left -= l.left, r.right -= l.right, r.top -= l.top, r.bottom -= l.bottom;
            } } }, { key: "shouldDo", value: function (t, e, n, r) { return !(!t || !1 === t.enabled || r && !t.endOnly || t.endOnly && !e || "start" === n && !t.setStart); } }, { key: "copyFrom", value: function (t) { this.startOffset = t.startOffset, this.startDelta = t.startDelta, this.edges = t.edges, this.states = t.states.map((function (t) { return (0, ye.default)(t); })), this.result = Oe((0, M.default)({}, t.result.coords), (0, M.default)({}, t.result.rect)); } }, { key: "destroy", value: function () { for (var t in this)
                this[t] = null; } }]) && we(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t; }(); function Oe(t, e) { return { rect: e, coords: t, delta: { x: 0, y: 0 }, rectDelta: { left: 0, right: 0, top: 0, bottom: 0 }, eventProps: [], changed: !0 }; } function Ee(t, e) { return t ? { left: e.x - t.left, top: e.y - t.top, right: t.right - e.x, bottom: t.bottom - e.y } : { left: 0, top: 0, right: 0, bottom: 0 }; } me.default = Pe; var Se = {}; function Te(t) { var e = t.iEvent, n = t.interaction.modification.result; n && (e.modifiers = n.eventProps); } Object.defineProperty(Se, "__esModule", { value: !0 }), Se.addEventModifiers = Te, Se.default = void 0, Se.makeModifier = function (t, e) { var n = t.defaults, r = { start: t.start, set: t.set, beforeEnd: t.beforeEnd, stop: t.stop }, o = function (t) { var o = t || {}; for (var i in o.enabled = !1 !== o.enabled, n)
        i in o || (o[i] = n[i]); var a = { options: o, methods: r, name: e, enable: function () { return o.enabled = !0, a; }, disable: function () { return o.enabled = !1, a; } }; return a; }; return e && "string" == typeof e && (o._defaults = n, o._methods = r), o; }; var je = { id: "modifiers/base", before: ["actions"], install: function (t) { t.defaults.perAction.modifiers = []; }, listeners: { "interactions:new": function (t) { var e = t.interaction; e.modification = new me.default(e); }, "interactions:before-action-start": function (t) { var e = t.interaction.modification; e.start(t, t.interaction.coords.start.page), t.interaction.edges = e.edges, e.applyToInteraction(t); }, "interactions:before-action-move": function (t) { return t.interaction.modification.setAndApply(t); }, "interactions:before-action-end": function (t) { return t.interaction.modification.beforeEnd(t); }, "interactions:action-start": Te, "interactions:action-move": Te, "interactions:action-end": Te, "interactions:after-action-start": function (t) { return t.interaction.modification.restoreInteractionCoords(t); }, "interactions:after-action-move": function (t) { return t.interaction.modification.restoreInteractionCoords(t); }, "interactions:stop": function (t) { return t.interaction.modification.stop(t); } } }, Me = je; Se.default = Me; var ke = {}; Object.defineProperty(ke, "__esModule", { value: !0 }), ke.defaults = void 0, ke.defaults = { base: { preventDefault: "auto", deltaSource: "page" }, perAction: { enabled: !1, origin: { x: 0, y: 0 } }, actions: {} }; var Ie = {}; function De(t) { return De = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t; } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }, De(t); } function Ae(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function ze(t, e) { return ze = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, ze(t, e); } function Ce(t, e) { if (e && ("object" === De(e) || "function" == typeof e))
        return e; if (void 0 !== e)
        throw new TypeError("Derived constructors may only return object or undefined"); return Re(t); } function Re(t) { if (void 0 === t)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; } function Fe(t) { return Fe = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, Fe(t); } function Xe(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } Object.defineProperty(Ie, "__esModule", { value: !0 }), Ie.InteractEvent = void 0; var Be = function (t) { !function (t, e) { if ("function" != typeof e && null !== e)
        throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && ze(t, e); }(a, t); var e, n, r, o, i = (r = a, o = function () { if ("undefined" == typeof Reflect || !Reflect.construct)
        return !1; if (Reflect.construct.sham)
        return !1; if ("function" == typeof Proxy)
        return !0; try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0;
    }
    catch (t) {
        return !1;
    } }(), function () { var t, e = Fe(r); if (o) {
        var n = Fe(this).constructor;
        t = Reflect.construct(e, arguments, n);
    }
    else
        t = e.apply(this, arguments); return Ce(this, t); }); function a(t, e, n, r, o, s, l) { var u; !function (t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); }(this, a), Xe(Re(u = i.call(this, t)), "relatedTarget", null), Xe(Re(u), "screenX", void 0), Xe(Re(u), "screenY", void 0), Xe(Re(u), "button", void 0), Xe(Re(u), "buttons", void 0), Xe(Re(u), "ctrlKey", void 0), Xe(Re(u), "shiftKey", void 0), Xe(Re(u), "altKey", void 0), Xe(Re(u), "metaKey", void 0), Xe(Re(u), "page", void 0), Xe(Re(u), "client", void 0), Xe(Re(u), "delta", void 0), Xe(Re(u), "rect", void 0), Xe(Re(u), "x0", void 0), Xe(Re(u), "y0", void 0), Xe(Re(u), "t0", void 0), Xe(Re(u), "dt", void 0), Xe(Re(u), "duration", void 0), Xe(Re(u), "clientX0", void 0), Xe(Re(u), "clientY0", void 0), Xe(Re(u), "velocity", void 0), Xe(Re(u), "speed", void 0), Xe(Re(u), "swipe", void 0), Xe(Re(u), "axes", void 0), Xe(Re(u), "preEnd", void 0), o = o || t.element; var c = t.interactable, f = (c && c.options || ke.defaults).deltaSource, d = (0, A.default)(c, o, n), p = "start" === r, v = "end" === r, h = p ? Re(u) : t.prevEvent, g = p ? t.coords.start : v ? { page: h.page, client: h.client, timeStamp: t.coords.cur.timeStamp } : t.coords.cur; return u.page = (0, M.default)({}, g.page), u.client = (0, M.default)({}, g.client), u.rect = (0, M.default)({}, t.rect), u.timeStamp = g.timeStamp, v || (u.page.x -= d.x, u.page.y -= d.y, u.client.x -= d.x, u.client.y -= d.y), u.ctrlKey = e.ctrlKey, u.altKey = e.altKey, u.shiftKey = e.shiftKey, u.metaKey = e.metaKey, u.button = e.button, u.buttons = e.buttons, u.target = o, u.currentTarget = o, u.preEnd = s, u.type = l || n + (r || ""), u.interactable = c, u.t0 = p ? t.pointers[t.pointers.length - 1].downTime : h.t0, u.x0 = t.coords.start.page.x - d.x, u.y0 = t.coords.start.page.y - d.y, u.clientX0 = t.coords.start.client.x - d.x, u.clientY0 = t.coords.start.client.y - d.y, u.delta = p || v ? { x: 0, y: 0 } : { x: u[f].x - h[f].x, y: u[f].y - h[f].y }, u.dt = t.coords.delta.timeStamp, u.duration = u.timeStamp - u.t0, u.velocity = (0, M.default)({}, t.coords.velocity[f]), u.speed = (0, R.default)(u.velocity.x, u.velocity.y), u.swipe = v || "inertiastart" === r ? u.getSwipe() : null, u; } return e = a, (n = [{ key: "getSwipe", value: function () { var t = this._interaction; if (t.prevEvent.speed < 600 || this.timeStamp - t.prevEvent.timeStamp > 150)
                return null; var e = 180 * Math.atan2(t.prevEvent.velocityY, t.prevEvent.velocityX) / Math.PI; e < 0 && (e += 360); var n = 112.5 <= e && e < 247.5, r = 202.5 <= e && e < 337.5; return { up: r, down: !r && 22.5 <= e && e < 157.5, left: n, right: !n && (292.5 <= e || e < 67.5), angle: e, speed: t.prevEvent.speed, velocity: { x: t.prevEvent.velocityX, y: t.prevEvent.velocityY } }; } }, { key: "preventDefault", value: function () { } }, { key: "stopImmediatePropagation", value: function () { this.immediatePropagationStopped = this.propagationStopped = !0; } }, { key: "stopPropagation", value: function () { this.propagationStopped = !0; } }]) && Ae(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), a; }(N.BaseEvent); Ie.InteractEvent = Be, Object.defineProperties(Be.prototype, { pageX: { get: function () { return this.page.x; }, set: function (t) { this.page.x = t; } }, pageY: { get: function () { return this.page.y; }, set: function (t) { this.page.y = t; } }, clientX: { get: function () { return this.client.x; }, set: function (t) { this.client.x = t; } }, clientY: { get: function () { return this.client.y; }, set: function (t) { this.client.y = t; } }, dx: { get: function () { return this.delta.x; }, set: function (t) { this.delta.x = t; } }, dy: { get: function () { return this.delta.y; }, set: function (t) { this.delta.y = t; } }, velocityX: { get: function () { return this.velocity.x; }, set: function (t) { this.velocity.x = t; } }, velocityY: { get: function () { return this.velocity.y; }, set: function (t) { this.velocity.y = t; } } }); var Ye = {}; function We(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function Le(t, e, n) { return e && We(t.prototype, e), n && We(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t; } function Ue(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } Object.defineProperty(Ye, "__esModule", { value: !0 }), Ye.PointerInfo = void 0; var Ve = Le((function t(e, n, r, o, i) { !function (t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); }(this, t), Ue(this, "id", void 0), Ue(this, "pointer", void 0), Ue(this, "event", void 0), Ue(this, "downTime", void 0), Ue(this, "downTarget", void 0), this.id = e, this.pointer = n, this.event = r, this.downTime = o, this.downTarget = i; })); Ye.PointerInfo = Ve; var Ne, qe, Ge = {}; function $e(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function He(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } Object.defineProperty(Ge, "__esModule", { value: !0 }), Ge.Interaction = void 0, Object.defineProperty(Ge, "PointerInfo", { enumerable: !0, get: function () { return Ye.PointerInfo; } }), Ge.default = Ge._ProxyValues = Ge._ProxyMethods = void 0, Ge._ProxyValues = Ne, function (t) { t.interactable = "", t.element = "", t.prepared = "", t.pointerIsDown = "", t.pointerWasMoved = "", t._proxy = ""; }(Ne || (Ge._ProxyValues = Ne = {})), Ge._ProxyMethods = qe, function (t) { t.start = "", t.move = "", t.end = "", t.stop = "", t.interacting = ""; }(qe || (Ge._ProxyMethods = qe = {})); var Ke = 0, Ze = function () { function t(e) { var n = this, r = e.pointerType, o = e.scopeFire; !function (t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); }(this, t), He(this, "interactable", null), He(this, "element", null), He(this, "rect", null), He(this, "_rects", void 0), He(this, "edges", null), He(this, "_scopeFire", void 0), He(this, "prepared", { name: null, axis: null, edges: null }), He(this, "pointerType", void 0), He(this, "pointers", []), He(this, "downEvent", null), He(this, "downPointer", {}), He(this, "_latestPointer", { pointer: null, event: null, eventTarget: null }), He(this, "prevEvent", null), He(this, "pointerIsDown", !1), He(this, "pointerWasMoved", !1), He(this, "_interacting", !1), He(this, "_ending", !1), He(this, "_stopped", !0), He(this, "_proxy", null), He(this, "simulation", null), He(this, "doMove", (0, Xt.warnOnce)((function (t) { this.move(t); }), "The interaction.doMove() method has been renamed to interaction.move()")), He(this, "coords", { start: X.newCoords(), prev: X.newCoords(), cur: X.newCoords(), delta: X.newCoords(), velocity: X.newCoords() }), He(this, "_id", Ke++), this._scopeFire = o, this.pointerType = r; var i = this; this._proxy = {}; var a = function (t) { Object.defineProperty(n._proxy, t, { get: function () { return i[t]; } }); }; for (var s in Ne)
        a(s); var l = function (t) { Object.defineProperty(n._proxy, t, { value: function () { return i[t].apply(i, arguments); } }); }; for (var u in qe)
        l(u); this._scopeFire("interactions:new", { interaction: this }); } var e, n; return e = t, n = [{ key: "pointerMoveTolerance", get: function () { return 1; } }, { key: "pointerDown", value: function (t, e, n) { var r = this.updatePointer(t, e, n, !0), o = this.pointers[r]; this._scopeFire("interactions:down", { pointer: t, event: e, eventTarget: n, pointerIndex: r, pointerInfo: o, type: "down", interaction: this }); } }, { key: "start", value: function (t, e, n) { return !(this.interacting() || !this.pointerIsDown || this.pointers.length < ("gesture" === t.name ? 2 : 1) || !e.options[t.name].enabled) && ((0, Xt.copyAction)(this.prepared, t), this.interactable = e, this.element = n, this.rect = e.getRect(n), this.edges = this.prepared.edges ? (0, M.default)({}, this.prepared.edges) : { left: !0, right: !0, top: !0, bottom: !0 }, this._stopped = !1, this._interacting = this._doPhase({ interaction: this, event: this.downEvent, phase: "start" }) && !this._stopped, this._interacting); } }, { key: "pointerMove", value: function (t, e, n) { this.simulation || this.modification && this.modification.endResult || this.updatePointer(t, e, n, !1); var r, o, i = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y; this.pointerIsDown && !this.pointerWasMoved && (r = this.coords.cur.client.x - this.coords.start.client.x, o = this.coords.cur.client.y - this.coords.start.client.y, this.pointerWasMoved = (0, R.default)(r, o) > this.pointerMoveTolerance); var a = this.getPointerIndex(t), s = { pointer: t, pointerIndex: a, pointerInfo: this.pointers[a], event: e, type: "move", eventTarget: n, dx: r, dy: o, duplicate: i, interaction: this }; i || X.setCoordVelocity(this.coords.velocity, this.coords.delta), this._scopeFire("interactions:move", s), i || this.simulation || (this.interacting() && (s.type = null, this.move(s)), this.pointerWasMoved && X.copyCoords(this.coords.prev, this.coords.cur)); } }, { key: "move", value: function (t) { t && t.event || X.setZeroCoords(this.coords.delta), (t = (0, M.default)({ pointer: this._latestPointer.pointer, event: this._latestPointer.event, eventTarget: this._latestPointer.eventTarget, interaction: this }, t || {})).phase = "move", this._doPhase(t); } }, { key: "pointerUp", value: function (t, e, n, r) { var o = this.getPointerIndex(t); -1 === o && (o = this.updatePointer(t, e, n, !1)); var i = /cancel$/i.test(e.type) ? "cancel" : "up"; this._scopeFire("interactions:".concat(i), { pointer: t, pointerIndex: o, pointerInfo: this.pointers[o], event: e, eventTarget: n, type: i, curEventTarget: r, interaction: this }), this.simulation || this.end(e), this.removePointer(t, e); } }, { key: "documentBlur", value: function (t) { this.end(t), this._scopeFire("interactions:blur", { event: t, type: "blur", interaction: this }); } }, { key: "end", value: function (t) { var e; this._ending = !0, t = t || this._latestPointer.event, this.interacting() && (e = this._doPhase({ event: t, interaction: this, phase: "end" })), this._ending = !1, !0 === e && this.stop(); } }, { key: "currentAction", value: function () { return this._interacting ? this.prepared.name : null; } }, { key: "interacting", value: function () { return this._interacting; } }, { key: "stop", value: function () { this._scopeFire("interactions:stop", { interaction: this }), this.interactable = this.element = null, this._interacting = !1, this._stopped = !0, this.prepared.name = this.prevEvent = null; } }, { key: "getPointerIndex", value: function (t) { var e = X.getPointerId(t); return "mouse" === this.pointerType || "pen" === this.pointerType ? this.pointers.length - 1 : H.findIndex(this.pointers, (function (t) { return t.id === e; })); } }, { key: "getPointerInfo", value: function (t) { return this.pointers[this.getPointerIndex(t)]; } }, { key: "updatePointer", value: function (t, e, n, r) { var o = X.getPointerId(t), i = this.getPointerIndex(t), a = this.pointers[i]; return r = !1 !== r && (r || /(down|start)$/i.test(e.type)), a ? a.pointer = t : (a = new Ye.PointerInfo(o, t, e, null, null), i = this.pointers.length, this.pointers.push(a)), X.setCoords(this.coords.cur, this.pointers.map((function (t) { return t.pointer; })), this._now()), X.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur), r && (this.pointerIsDown = !0, a.downTime = this.coords.cur.timeStamp, a.downTarget = n, X.pointerExtend(this.downPointer, t), this.interacting() || (X.copyCoords(this.coords.start, this.coords.cur), X.copyCoords(this.coords.prev, this.coords.cur), this.downEvent = e, this.pointerWasMoved = !1)), this._updateLatestPointer(t, e, n), this._scopeFire("interactions:update-pointer", { pointer: t, event: e, eventTarget: n, down: r, pointerInfo: a, pointerIndex: i, interaction: this }), i; } }, { key: "removePointer", value: function (t, e) { var n = this.getPointerIndex(t); if (-1 !== n) {
                var r = this.pointers[n];
                this._scopeFire("interactions:remove-pointer", { pointer: t, event: e, eventTarget: null, pointerIndex: n, pointerInfo: r, interaction: this }), this.pointers.splice(n, 1), this.pointerIsDown = !1;
            } } }, { key: "_updateLatestPointer", value: function (t, e, n) { this._latestPointer.pointer = t, this._latestPointer.event = e, this._latestPointer.eventTarget = n; } }, { key: "destroy", value: function () { this._latestPointer.pointer = null, this._latestPointer.event = null, this._latestPointer.eventTarget = null; } }, { key: "_createPreparedEvent", value: function (t, e, n, r) { return new Ie.InteractEvent(this, t, this.prepared.name, e, this.element, n, r); } }, { key: "_fireEvent", value: function (t) { var e; null == (e = this.interactable) || e.fire(t), (!this.prevEvent || t.timeStamp >= this.prevEvent.timeStamp) && (this.prevEvent = t); } }, { key: "_doPhase", value: function (t) { var e = t.event, n = t.phase, r = t.preEnd, o = t.type, i = this.rect; if (i && "move" === n && (k.addEdges(this.edges, i, this.coords.delta[this.interactable.options.deltaSource]), i.width = i.right - i.left, i.height = i.bottom - i.top), !1 === this._scopeFire("interactions:before-action-".concat(n), t))
                return !1; var a = t.iEvent = this._createPreparedEvent(e, n, r, o); return this._scopeFire("interactions:action-".concat(n), t), "start" === n && (this.prevEvent = a), this._fireEvent(a), this._scopeFire("interactions:after-action-".concat(n), t), !0; } }, { key: "_now", value: function () { return Date.now(); } }], n && $e(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t; }(); Ge.Interaction = Ze; var Je = Ze; Ge.default = Je; var Qe = {}; function tn(t) { t.pointerIsDown && (on(t.coords.cur, t.offset.total), t.offset.pending.x = 0, t.offset.pending.y = 0); } function en(t) { nn(t.interaction); } function nn(t) { if (!function (t) { return !(!t.offset.pending.x && !t.offset.pending.y); }(t))
        return !1; var e = t.offset.pending; return on(t.coords.cur, e), on(t.coords.delta, e), k.addEdges(t.edges, t.rect, e), e.x = 0, e.y = 0, !0; } function rn(t) { var e = t.x, n = t.y; this.offset.pending.x += e, this.offset.pending.y += n, this.offset.total.x += e, this.offset.total.y += n; } function on(t, e) { var n = t.page, r = t.client, o = e.x, i = e.y; n.x += o, n.y += i, r.x += o, r.y += i; } Object.defineProperty(Qe, "__esModule", { value: !0 }), Qe.addTotal = tn, Qe.applyPending = nn, Qe.default = void 0, Ge._ProxyMethods.offsetBy = ""; var an = { id: "offset", before: ["modifiers", "pointer-events", "actions", "inertia"], install: function (t) { t.Interaction.prototype.offsetBy = rn; }, listeners: { "interactions:new": function (t) { t.interaction.offset = { total: { x: 0, y: 0 }, pending: { x: 0, y: 0 } }; }, "interactions:update-pointer": function (t) { return tn(t.interaction); }, "interactions:before-action-start": en, "interactions:before-action-move": en, "interactions:before-action-end": function (t) { var e = t.interaction; if (nn(e))
                return e.move({ offset: !0 }), e.end(), !1; }, "interactions:stop": function (t) { var e = t.interaction; e.offset.total.x = 0, e.offset.total.y = 0, e.offset.pending.x = 0, e.offset.pending.y = 0; } } }, sn = an; Qe.default = sn; var ln = {}; function un(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function cn(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } Object.defineProperty(ln, "__esModule", { value: !0 }), ln.default = ln.InertiaState = void 0; var fn = function () { function t(e) { !function (t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); }(this, t), cn(this, "active", !1), cn(this, "isModified", !1), cn(this, "smoothEnd", !1), cn(this, "allowResume", !1), cn(this, "modification", void 0), cn(this, "modifierCount", 0), cn(this, "modifierArg", void 0), cn(this, "startCoords", void 0), cn(this, "t0", 0), cn(this, "v0", 0), cn(this, "te", 0), cn(this, "targetOffset", void 0), cn(this, "modifiedOffset", void 0), cn(this, "currentOffset", void 0), cn(this, "lambda_v0", 0), cn(this, "one_ve_v0", 0), cn(this, "timeout", void 0), cn(this, "interaction", void 0), this.interaction = e; } var e, n; return e = t, (n = [{ key: "start", value: function (t) { var e = this.interaction, n = dn(e); if (!n || !n.enabled)
                return !1; var r = e.coords.velocity.client, o = (0, R.default)(r.x, r.y), i = this.modification || (this.modification = new me.default(e)); if (i.copyFrom(e.modification), this.t0 = e._now(), this.allowResume = n.allowResume, this.v0 = o, this.currentOffset = { x: 0, y: 0 }, this.startCoords = e.coords.cur.page, this.modifierArg = i.fillArg({ pageCoords: this.startCoords, preEnd: !0, phase: "inertiastart" }), this.t0 - e.coords.cur.timeStamp < 50 && o > n.minSpeed && o > n.endSpeed)
                this.startInertia();
            else {
                if (i.result = i.setAll(this.modifierArg), !i.result.changed)
                    return !1;
                this.startSmoothEnd();
            } return e.modification.result.rect = null, e.offsetBy(this.targetOffset), e._doPhase({ interaction: e, event: t, phase: "inertiastart" }), e.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y }), e.modification.result.rect = null, this.active = !0, e.simulation = this, !0; } }, { key: "startInertia", value: function () { var t = this, e = this.interaction.coords.velocity.client, n = dn(this.interaction), r = n.resistance, o = -Math.log(n.endSpeed / this.v0) / r; this.targetOffset = { x: (e.x - o) / r, y: (e.y - o) / r }, this.te = o, this.lambda_v0 = r / this.v0, this.one_ve_v0 = 1 - n.endSpeed / this.v0; var i = this.modification, a = this.modifierArg; a.pageCoords = { x: this.startCoords.x + this.targetOffset.x, y: this.startCoords.y + this.targetOffset.y }, i.result = i.setAll(a), i.result.changed && (this.isModified = !0, this.modifiedOffset = { x: this.targetOffset.x + i.result.delta.x, y: this.targetOffset.y + i.result.delta.y }), this.onNextFrame((function () { return t.inertiaTick(); })); } }, { key: "startSmoothEnd", value: function () { var t = this; this.smoothEnd = !0, this.isModified = !0, this.targetOffset = { x: this.modification.result.delta.x, y: this.modification.result.delta.y }, this.onNextFrame((function () { return t.smoothEndTick(); })); } }, { key: "onNextFrame", value: function (t) { var e = this; this.timeout = Tt.default.request((function () { e.active && t(); })); } }, { key: "inertiaTick", value: function () { var t, e, n, r, o, i = this, a = this.interaction, s = dn(a).resistance, l = (a._now() - this.t0) / 1e3; if (l < this.te) {
                var u, c = 1 - (Math.exp(-s * l) - this.lambda_v0) / this.one_ve_v0;
                this.isModified ? (t = this.targetOffset.x, e = this.targetOffset.y, n = this.modifiedOffset.x, r = this.modifiedOffset.y, u = { x: vn(o = c, 0, t, n), y: vn(o, 0, e, r) }) : u = { x: this.targetOffset.x * c, y: this.targetOffset.y * c };
                var f = { x: u.x - this.currentOffset.x, y: u.y - this.currentOffset.y };
                this.currentOffset.x += f.x, this.currentOffset.y += f.y, a.offsetBy(f), a.move(), this.onNextFrame((function () { return i.inertiaTick(); }));
            }
            else
                a.offsetBy({ x: this.modifiedOffset.x - this.currentOffset.x, y: this.modifiedOffset.y - this.currentOffset.y }), this.end(); } }, { key: "smoothEndTick", value: function () { var t = this, e = this.interaction, n = e._now() - this.t0, r = dn(e).smoothEndDuration; if (n < r) {
                var o = { x: hn(n, 0, this.targetOffset.x, r), y: hn(n, 0, this.targetOffset.y, r) }, i = { x: o.x - this.currentOffset.x, y: o.y - this.currentOffset.y };
                this.currentOffset.x += i.x, this.currentOffset.y += i.y, e.offsetBy(i), e.move({ skipModifiers: this.modifierCount }), this.onNextFrame((function () { return t.smoothEndTick(); }));
            }
            else
                e.offsetBy({ x: this.targetOffset.x - this.currentOffset.x, y: this.targetOffset.y - this.currentOffset.y }), this.end(); } }, { key: "resume", value: function (t) { var e = t.pointer, n = t.event, r = t.eventTarget, o = this.interaction; o.offsetBy({ x: -this.currentOffset.x, y: -this.currentOffset.y }), o.updatePointer(e, n, r, !0), o._doPhase({ interaction: o, event: n, phase: "resume" }), (0, X.copyCoords)(o.coords.prev, o.coords.cur), this.stop(); } }, { key: "end", value: function () { this.interaction.move(), this.interaction.end(), this.stop(); } }, { key: "stop", value: function () { this.active = this.smoothEnd = !1, this.interaction.simulation = null, Tt.default.cancel(this.timeout); } }]) && un(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t; }(); function dn(t) { var e = t.interactable, n = t.prepared; return e && e.options && n.name && e.options[n.name].inertia; } ln.InertiaState = fn; var pn = { id: "inertia", before: ["modifiers", "actions"], install: function (t) { var e = t.defaults; t.usePlugin(Qe.default), t.usePlugin(Se.default), t.actions.phases.inertiastart = !0, t.actions.phases.resume = !0, e.perAction.inertia = { enabled: !1, resistance: 10, minSpeed: 100, endSpeed: 10, allowResume: !0, smoothEndDuration: 300 }; }, listeners: { "interactions:new": function (t) { var e = t.interaction; e.inertia = new fn(e); }, "interactions:before-action-end": function (t) { var e = t.interaction, n = t.event; return (!e._interacting || e.simulation || !e.inertia.start(n)) && null; }, "interactions:down": function (t) { var e = t.interaction, n = t.eventTarget, r = e.inertia; if (r.active)
                for (var o = n; i.default.element(o);) {
                    if (o === e.element) {
                        r.resume(t);
                        break;
                    }
                    o = _.parentNode(o);
                } }, "interactions:stop": function (t) { var e = t.interaction.inertia; e.active && e.stop(); }, "interactions:before-action-resume": function (t) { var e = t.interaction.modification; e.stop(t), e.start(t, t.interaction.coords.cur.page), e.applyToInteraction(t); }, "interactions:before-action-inertiastart": function (t) { return t.interaction.modification.setAndApply(t); }, "interactions:action-resume": Se.addEventModifiers, "interactions:action-inertiastart": Se.addEventModifiers, "interactions:after-action-inertiastart": function (t) { return t.interaction.modification.restoreInteractionCoords(t); }, "interactions:after-action-resume": function (t) { return t.interaction.modification.restoreInteractionCoords(t); } } }; function vn(t, e, n, r) { var o = 1 - t; return o * o * e + 2 * o * t * n + t * t * r; } function hn(t, e, n, r) { return -n * (t /= r) * (t - 2) + e; } var gn = pn; ln.default = gn; var yn = {}; function mn(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function bn(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } function xn(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        if (t.immediatePropagationStopped)
            break;
        r(t);
    } } Object.defineProperty(yn, "__esModule", { value: !0 }), yn.Eventable = void 0; var wn = function () { function t(e) { !function (t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); }(this, t), bn(this, "options", void 0), bn(this, "types", {}), bn(this, "propagationStopped", !1), bn(this, "immediatePropagationStopped", !1), bn(this, "global", void 0), this.options = (0, M.default)({}, e || {}); } var e, n; return e = t, (n = [{ key: "fire", value: function (t) { var e, n = this.global; (e = this.types[t.type]) && xn(t, e), !t.propagationStopped && n && (e = n[t.type]) && xn(t, e); } }, { key: "on", value: function (t, e) { var n = (0, z.default)(t, e); for (t in n)
                this.types[t] = H.merge(this.types[t] || [], n[t]); } }, { key: "off", value: function (t, e) { var n = (0, z.default)(t, e); for (t in n) {
                var r = this.types[t];
                if (r && r.length)
                    for (var o = 0; o < n[t].length; o++) {
                        var i = n[t][o], a = r.indexOf(i);
                        -1 !== a && r.splice(a, 1);
                    }
            } } }, { key: "getRect", value: function (t) { return null; } }]) && mn(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t; }(); yn.Eventable = wn; var _n = {}; Object.defineProperty(_n, "__esModule", { value: !0 }), _n.default = function (t, e) { if (e.phaselessTypes[t])
        return !0; for (var n in e.map)
        if (0 === t.indexOf(n) && t.substr(n.length) in e.phases)
            return !0; return !1; }; var Pn = {}; Object.defineProperty(Pn, "__esModule", { value: !0 }), Pn.createInteractStatic = function (t) { var e = function e(n, r) { var o = t.interactables.get(n, r); return o || ((o = t.interactables.new(n, r)).events.global = e.globalEvents), o; }; return e.getPointerAverage = X.pointerAverage, e.getTouchBBox = X.touchBBox, e.getTouchDistance = X.touchDistance, e.getTouchAngle = X.touchAngle, e.getElementRect = _.getElementRect, e.getElementClientRect = _.getElementClientRect, e.matchesSelector = _.matchesSelector, e.closest = _.closest, e.globalEvents = {}, e.version = "1.10.17", e.scope = t, e.use = function (t, e) { return this.scope.usePlugin(t, e), this; }, e.isSet = function (t, e) { return !!this.scope.interactables.get(t, e && e.context); }, e.on = (0, Xt.warnOnce)((function (t, e, n) { if (i.default.string(t) && -1 !== t.search(" ") && (t = t.trim().split(/ +/)), i.default.array(t)) {
        for (var r = 0; r < t.length; r++) {
            var o = t[r];
            this.on(o, e, n);
        }
        return this;
    } if (i.default.object(t)) {
        for (var a in t)
            this.on(a, t[a], e);
        return this;
    } return (0, _n.default)(t, this.scope.actions) ? this.globalEvents[t] ? this.globalEvents[t].push(e) : this.globalEvents[t] = [e] : this.scope.events.add(this.scope.document, t, e, { options: n }), this; }), "The interact.on() method is being deprecated"), e.off = (0, Xt.warnOnce)((function (t, e, n) { if (i.default.string(t) && -1 !== t.search(" ") && (t = t.trim().split(/ +/)), i.default.array(t)) {
        for (var r = 0; r < t.length; r++) {
            var o = t[r];
            this.off(o, e, n);
        }
        return this;
    } if (i.default.object(t)) {
        for (var a in t)
            this.off(a, t[a], e);
        return this;
    } var s; return (0, _n.default)(t, this.scope.actions) ? t in this.globalEvents && -1 !== (s = this.globalEvents[t].indexOf(e)) && this.globalEvents[t].splice(s, 1) : this.scope.events.remove(this.scope.document, t, e, n), this; }), "The interact.off() method is being deprecated"), e.debug = function () { return this.scope; }, e.supportsTouch = function () { return b.default.supportsTouch; }, e.supportsPointerEvent = function () { return b.default.supportsPointerEvent; }, e.stop = function () { for (var t = 0; t < this.scope.interactions.list.length; t++)
        this.scope.interactions.list[t].stop(); return this; }, e.pointerMoveTolerance = function (t) { return i.default.number(t) ? (this.scope.interactions.pointerMoveTolerance = t, this) : this.scope.interactions.pointerMoveTolerance; }, e.addDocument = function (t, e) { this.scope.addDocument(t, e); }, e.removeDocument = function (t) { this.scope.removeDocument(t); }, e; }; var On = {}; function En(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function Sn(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } Object.defineProperty(On, "__esModule", { value: !0 }), On.Interactable = void 0; var Tn = function () { function t(n, r, o, i) { !function (t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); }(this, t), Sn(this, "options", void 0), Sn(this, "_actions", void 0), Sn(this, "target", void 0), Sn(this, "events", new yn.Eventable), Sn(this, "_context", void 0), Sn(this, "_win", void 0), Sn(this, "_doc", void 0), Sn(this, "_scopeEvents", void 0), Sn(this, "_rectChecker", void 0), this._actions = r.actions, this.target = n, this._context = r.context || o, this._win = (0, e.getWindow)((0, _.trySelector)(n) ? this._context : n), this._doc = this._win.document, this._scopeEvents = i, this.set(r); } var n, r; return n = t, (r = [{ key: "_defaults", get: function () { return { base: {}, perAction: {}, actions: {} }; } }, { key: "setOnEvents", value: function (t, e) { return i.default.func(e.onstart) && this.on("".concat(t, "start"), e.onstart), i.default.func(e.onmove) && this.on("".concat(t, "move"), e.onmove), i.default.func(e.onend) && this.on("".concat(t, "end"), e.onend), i.default.func(e.oninertiastart) && this.on("".concat(t, "inertiastart"), e.oninertiastart), this; } }, { key: "updatePerActionListeners", value: function (t, e, n) { (i.default.array(e) || i.default.object(e)) && this.off(t, e), (i.default.array(n) || i.default.object(n)) && this.on(t, n); } }, { key: "setPerAction", value: function (t, e) { var n = this._defaults; for (var r in e) {
                var o = r, a = this.options[t], s = e[o];
                "listeners" === o && this.updatePerActionListeners(t, a.listeners, s), i.default.array(s) ? a[o] = H.from(s) : i.default.plainObject(s) ? (a[o] = (0, M.default)(a[o] || {}, (0, ye.default)(s)), i.default.object(n.perAction[o]) && "enabled" in n.perAction[o] && (a[o].enabled = !1 !== s.enabled)) : i.default.bool(s) && i.default.object(n.perAction[o]) ? a[o].enabled = s : a[o] = s;
            } } }, { key: "getRect", value: function (t) { return t = t || (i.default.element(this.target) ? this.target : null), i.default.string(this.target) && (t = t || this._context.querySelector(this.target)), (0, _.getElementRect)(t); } }, { key: "rectChecker", value: function (t) { var e = this; return i.default.func(t) ? (this._rectChecker = t, this.getRect = function (t) { var n = (0, M.default)({}, e._rectChecker(t)); return "width" in n || (n.width = n.right - n.left, n.height = n.bottom - n.top), n; }, this) : null === t ? (delete this.getRect, delete this._rectChecker, this) : this.getRect; } }, { key: "_backCompatOption", value: function (t, e) { if ((0, _.trySelector)(e) || i.default.object(e)) {
                for (var n in this.options[t] = e, this._actions.map)
                    this.options[n][t] = e;
                return this;
            } return this.options[t]; } }, { key: "origin", value: function (t) { return this._backCompatOption("origin", t); } }, { key: "deltaSource", value: function (t) { return "page" === t || "client" === t ? (this.options.deltaSource = t, this) : this.options.deltaSource; } }, { key: "context", value: function () { return this._context; } }, { key: "inContext", value: function (t) { return this._context === t.ownerDocument || (0, _.nodeContains)(this._context, t); } }, { key: "testIgnoreAllow", value: function (t, e, n) { return !this.testIgnore(t.ignoreFrom, e, n) && this.testAllow(t.allowFrom, e, n); } }, { key: "testAllow", value: function (t, e, n) { return !t || !!i.default.element(n) && (i.default.string(t) ? (0, _.matchesUpTo)(n, t, e) : !!i.default.element(t) && (0, _.nodeContains)(t, n)); } }, { key: "testIgnore", value: function (t, e, n) { return !(!t || !i.default.element(n)) && (i.default.string(t) ? (0, _.matchesUpTo)(n, t, e) : !!i.default.element(t) && (0, _.nodeContains)(t, n)); } }, { key: "fire", value: function (t) { return this.events.fire(t), this; } }, { key: "_onOff", value: function (t, e, n, r) { i.default.object(e) && !i.default.array(e) && (r = n, n = null); var o = "on" === t ? "add" : "remove", a = (0, z.default)(e, n); for (var s in a) {
                "wheel" === s && (s = b.default.wheelEvent);
                for (var l = 0; l < a[s].length; l++) {
                    var u = a[s][l];
                    (0, _n.default)(s, this._actions) ? this.events[t](s, u) : i.default.string(this.target) ? this._scopeEvents["".concat(o, "Delegate")](this.target, this._context, s, u, r) : this._scopeEvents[o](this.target, s, u, r);
                }
            } return this; } }, { key: "on", value: function (t, e, n) { return this._onOff("on", t, e, n); } }, { key: "off", value: function (t, e, n) { return this._onOff("off", t, e, n); } }, { key: "set", value: function (t) { var e = this._defaults; for (var n in i.default.object(t) || (t = {}), this.options = (0, ye.default)(e.base), this._actions.methodDict) {
                var r = n, o = this._actions.methodDict[r];
                this.options[r] = {}, this.setPerAction(r, (0, M.default)((0, M.default)({}, e.perAction), e.actions[r])), this[o](t[r]);
            } for (var a in t)
                i.default.func(this[a]) && this[a](t[a]); return this; } }, { key: "unset", value: function () { if (i.default.string(this.target))
                for (var t in this._scopeEvents.delegatedEvents)
                    for (var e = this._scopeEvents.delegatedEvents[t], n = e.length - 1; n >= 0; n--) {
                        var r = e[n], o = r.selector, a = r.context, s = r.listeners;
                        o === this.target && a === this._context && e.splice(n, 1);
                        for (var l = s.length - 1; l >= 0; l--)
                            this._scopeEvents.removeDelegate(this.target, this._context, t, s[l][0], s[l][1]);
                    }
            else
                this._scopeEvents.remove(this.target, "all"); } }]) && En(n.prototype, r), Object.defineProperty(n, "prototype", { writable: !1 }), t; }(); On.Interactable = Tn; var jn = {}; function Mn(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function kn(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } Object.defineProperty(jn, "__esModule", { value: !0 }), jn.InteractableSet = void 0; var In = function () { function t(e) { var n = this; !function (t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); }(this, t), kn(this, "list", []), kn(this, "selectorMap", {}), kn(this, "scope", void 0), this.scope = e, e.addListeners({ "interactable:unset": function (t) { var e = t.interactable, r = e.target, o = e._context, a = i.default.string(r) ? n.selectorMap[r] : r[n.scope.id], s = H.findIndex(a, (function (t) { return t.context === o; })); a[s] && (a[s].context = null, a[s].interactable = null), a.splice(s, 1); } }); } var e, n; return e = t, (n = [{ key: "new", value: function (t, e) { e = (0, M.default)(e || {}, { actions: this.scope.actions }); var n = new this.scope.Interactable(t, e, this.scope.document, this.scope.events), r = { context: n._context, interactable: n }; return this.scope.addDocument(n._doc), this.list.push(n), i.default.string(t) ? (this.selectorMap[t] || (this.selectorMap[t] = []), this.selectorMap[t].push(r)) : (n.target[this.scope.id] || Object.defineProperty(t, this.scope.id, { value: [], configurable: !0 }), t[this.scope.id].push(r)), this.scope.fire("interactable:new", { target: t, options: e, interactable: n, win: this.scope._win }), n; } }, { key: "get", value: function (t, e) { var n = e && e.context || this.scope.document, r = i.default.string(t), o = r ? this.selectorMap[t] : t[this.scope.id]; if (!o)
                return null; var a = H.find(o, (function (e) { return e.context === n && (r || e.interactable.inContext(t)); })); return a && a.interactable; } }, { key: "forEachMatch", value: function (t, e) { for (var n = 0; n < this.list.length; n++) {
                var r = this.list[n], o = void 0;
                if ((i.default.string(r.target) ? i.default.element(t) && _.matchesSelector(t, r.target) : t === r.target) && r.inContext(t) && (o = e(r)), void 0 !== o)
                    return o;
            } } }]) && Mn(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t; }(); jn.InteractableSet = In; var Dn = {}; function An(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function zn(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } function Cn(t, e) { return function (t) { if (Array.isArray(t))
        return t; }(t) || function (t, e) { var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (null != n) {
        var r, o, i = [], a = !0, s = !1;
        try {
            for (n = n.call(t); !(a = (r = n.next()).done) && (i.push(r.value), !e || i.length !== e); a = !0)
                ;
        }
        catch (t) {
            s = !0, o = t;
        }
        finally {
            try {
                a || null == n.return || n.return();
            }
            finally {
                if (s)
                    throw o;
            }
        }
        return i;
    } }(t, e) || function (t, e) { if (t) {
        if ("string" == typeof t)
            return Rn(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Rn(t, e) : void 0;
    } }(t, e) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }(); } function Rn(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)
        r[n] = t[n]; return r; } Object.defineProperty(Dn, "__esModule", { value: !0 }), Dn.default = void 0; var Fn = function () { function t(e) { !function (t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); }(this, t), zn(this, "currentTarget", void 0), zn(this, "originalEvent", void 0), zn(this, "type", void 0), this.originalEvent = e, (0, F.default)(this, e); } var e, n; return e = t, (n = [{ key: "preventOriginalDefault", value: function () { this.originalEvent.preventDefault(); } }, { key: "stopPropagation", value: function () { this.originalEvent.stopPropagation(); } }, { key: "stopImmediatePropagation", value: function () { this.originalEvent.stopImmediatePropagation(); } }]) && An(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t; }(); function Xn(t) { if (!i.default.object(t))
        return { capture: !!t, passive: !1 }; var e = (0, M.default)({}, t); return e.capture = !!t.capture, e.passive = !!t.passive, e; } var Bn = { id: "events", install: function (t) { var e, n = [], r = {}, o = [], a = { add: s, remove: l, addDelegate: function (t, e, n, i, a) { var l = Xn(a); if (!r[n]) {
                r[n] = [];
                for (var f = 0; f < o.length; f++) {
                    var d = o[f];
                    s(d, n, u), s(d, n, c, !0);
                }
            } var p = r[n], v = H.find(p, (function (n) { return n.selector === t && n.context === e; })); v || (v = { selector: t, context: e, listeners: [] }, p.push(v)), v.listeners.push([i, l]); }, removeDelegate: function (t, e, n, o, i) { var a, s = Xn(i), f = r[n], d = !1; if (f)
                for (a = f.length - 1; a >= 0; a--) {
                    var p = f[a];
                    if (p.selector === t && p.context === e) {
                        for (var v = p.listeners, h = v.length - 1; h >= 0; h--) {
                            var g = Cn(v[h], 2), y = g[0], m = g[1], b = m.capture, x = m.passive;
                            if (y === o && b === s.capture && x === s.passive) {
                                v.splice(h, 1), v.length || (f.splice(a, 1), l(e, n, u), l(e, n, c, !0)), d = !0;
                                break;
                            }
                        }
                        if (d)
                            break;
                    }
                } }, delegateListener: u, delegateUseCapture: c, delegatedEvents: r, documents: o, targets: n, supportsOptions: !1, supportsPassive: !1 }; function s(t, e, r, o) { var i = Xn(o), s = H.find(n, (function (e) { return e.eventTarget === t; })); s || (s = { eventTarget: t, events: {} }, n.push(s)), s.events[e] || (s.events[e] = []), t.addEventListener && !H.contains(s.events[e], r) && (t.addEventListener(e, r, a.supportsOptions ? i : i.capture), s.events[e].push(r)); } function l(t, e, r, o) { var i = Xn(o), s = H.findIndex(n, (function (e) { return e.eventTarget === t; })), u = n[s]; if (u && u.events)
            if ("all" !== e) {
                var c = !1, f = u.events[e];
                if (f) {
                    if ("all" === r) {
                        for (var d = f.length - 1; d >= 0; d--)
                            l(t, e, f[d], i);
                        return;
                    }
                    for (var p = 0; p < f.length; p++)
                        if (f[p] === r) {
                            t.removeEventListener(e, r, a.supportsOptions ? i : i.capture), f.splice(p, 1), 0 === f.length && (delete u.events[e], c = !0);
                            break;
                        }
                }
                c && !Object.keys(u.events).length && n.splice(s, 1);
            }
            else
                for (e in u.events)
                    u.events.hasOwnProperty(e) && l(t, e, "all"); } function u(t, e) { for (var n = Xn(e), o = new Fn(t), a = r[t.type], s = Cn(X.getEventTargets(t), 1)[0], l = s; i.default.element(l);) {
            for (var u = 0; u < a.length; u++) {
                var c = a[u], f = c.selector, d = c.context;
                if (_.matchesSelector(l, f) && _.nodeContains(d, s) && _.nodeContains(d, l)) {
                    var p = c.listeners;
                    o.currentTarget = l;
                    for (var v = 0; v < p.length; v++) {
                        var h = Cn(p[v], 2), g = h[0], y = h[1], m = y.capture, b = y.passive;
                        m === n.capture && b === n.passive && g(o);
                    }
                }
            }
            l = _.parentNode(l);
        } } function c(t) { return u(t, !0); } return null == (e = t.document) || e.createElement("div").addEventListener("test", null, { get capture() { return a.supportsOptions = !0; }, get passive() { return a.supportsPassive = !0; } }), t.events = a, a; } }; Dn.default = Bn; var Yn = {}; Object.defineProperty(Yn, "__esModule", { value: !0 }), Yn.default = void 0; var Wn = { methodOrder: ["simulationResume", "mouseOrPen", "hasPointer", "idle"], search: function (t) { for (var e = 0; e < Wn.methodOrder.length; e++) {
            var n;
            n = Wn.methodOrder[e];
            var r = Wn[n](t);
            if (r)
                return r;
        } return null; }, simulationResume: function (t) { var e = t.pointerType, n = t.eventType, r = t.eventTarget, o = t.scope; if (!/down|start/i.test(n))
            return null; for (var i = 0; i < o.interactions.list.length; i++) {
            var a = o.interactions.list[i], s = r;
            if (a.simulation && a.simulation.allowResume && a.pointerType === e)
                for (; s;) {
                    if (s === a.element)
                        return a;
                    s = _.parentNode(s);
                }
        } return null; }, mouseOrPen: function (t) { var e, n = t.pointerId, r = t.pointerType, o = t.eventType, i = t.scope; if ("mouse" !== r && "pen" !== r)
            return null; for (var a = 0; a < i.interactions.list.length; a++) {
            var s = i.interactions.list[a];
            if (s.pointerType === r) {
                if (s.simulation && !Ln(s, n))
                    continue;
                if (s.interacting())
                    return s;
                e || (e = s);
            }
        } if (e)
            return e; for (var l = 0; l < i.interactions.list.length; l++) {
            var u = i.interactions.list[l];
            if (!(u.pointerType !== r || /down/i.test(o) && u.simulation))
                return u;
        } return null; }, hasPointer: function (t) { for (var e = t.pointerId, n = t.scope, r = 0; r < n.interactions.list.length; r++) {
            var o = n.interactions.list[r];
            if (Ln(o, e))
                return o;
        } return null; }, idle: function (t) { for (var e = t.pointerType, n = t.scope, r = 0; r < n.interactions.list.length; r++) {
            var o = n.interactions.list[r];
            if (1 === o.pointers.length) {
                var i = o.interactable;
                if (i && (!i.options.gesture || !i.options.gesture.enabled))
                    continue;
            }
            else if (o.pointers.length >= 2)
                continue;
            if (!o.interacting() && e === o.pointerType)
                return o;
        } return null; } }; function Ln(t, e) { return t.pointers.some((function (t) { return t.id === e; })); } var Un = Wn; Yn.default = Un; var Vn = {}; function Nn(t) { return Nn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t; } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }, Nn(t); } function qn(t, e) { return function (t) { if (Array.isArray(t))
        return t; }(t) || function (t, e) { var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (null != n) {
        var r, o, i = [], a = !0, s = !1;
        try {
            for (n = n.call(t); !(a = (r = n.next()).done) && (i.push(r.value), !e || i.length !== e); a = !0)
                ;
        }
        catch (t) {
            s = !0, o = t;
        }
        finally {
            try {
                a || null == n.return || n.return();
            }
            finally {
                if (s)
                    throw o;
            }
        }
        return i;
    } }(t, e) || function (t, e) { if (t) {
        if ("string" == typeof t)
            return Gn(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Gn(t, e) : void 0;
    } }(t, e) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }(); } function Gn(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)
        r[n] = t[n]; return r; } function $n(t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); } function Hn(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function Kn(t, e) { return Kn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, Kn(t, e); } function Zn(t, e) { if (e && ("object" === Nn(e) || "function" == typeof e))
        return e; if (void 0 !== e)
        throw new TypeError("Derived constructors may only return object or undefined"); return function (t) { if (void 0 === t)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; }(t); } function Jn(t) { return Jn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, Jn(t); } Object.defineProperty(Vn, "__esModule", { value: !0 }), Vn.default = void 0; var Qn = ["pointerDown", "pointerMove", "pointerUp", "updatePointer", "removePointer", "windowBlur"]; function tr(t, e) { return function (n) { var r = e.interactions.list, o = X.getPointerType(n), i = qn(X.getEventTargets(n), 2), a = i[0], s = i[1], l = []; if (/^touch/.test(n.type)) {
        e.prevTouchTime = e.now();
        for (var u = 0; u < n.changedTouches.length; u++) {
            var c = n.changedTouches[u], f = { pointer: c, pointerId: X.getPointerId(c), pointerType: o, eventType: n.type, eventTarget: a, curEventTarget: s, scope: e }, d = er(f);
            l.push([f.pointer, f.eventTarget, f.curEventTarget, d]);
        }
    }
    else {
        var p = !1;
        if (!b.default.supportsPointerEvent && /mouse/.test(n.type)) {
            for (var v = 0; v < r.length && !p; v++)
                p = "mouse" !== r[v].pointerType && r[v].pointerIsDown;
            p = p || e.now() - e.prevTouchTime < 500 || 0 === n.timeStamp;
        }
        if (!p) {
            var h = { pointer: n, pointerId: X.getPointerId(n), pointerType: o, eventType: n.type, curEventTarget: s, eventTarget: a, scope: e }, g = er(h);
            l.push([h.pointer, h.eventTarget, h.curEventTarget, g]);
        }
    } for (var y = 0; y < l.length; y++) {
        var m = qn(l[y], 4), x = m[0], w = m[1], _ = m[2];
        m[3][t](x, n, w, _);
    } }; } function er(t) { var e = t.pointerType, n = t.scope, r = { interaction: Yn.default.search(t), searchDetails: t }; return n.fire("interactions:find", r), r.interaction || n.interactions.new({ pointerType: e }); } function nr(t, e) { var n = t.doc, r = t.scope, o = t.options, i = r.interactions.docEvents, a = r.events, s = a[e]; for (var l in r.browser.isIOS && !o.events && (o.events = { passive: !1 }), a.delegatedEvents)
        s(n, l, a.delegateListener), s(n, l, a.delegateUseCapture, !0); for (var u = o && o.events, c = 0; c < i.length; c++) {
        var f = i[c];
        s(n, f.type, f.listener, u);
    } } var rr = { id: "core/interactions", install: function (t) { for (var e = {}, n = 0; n < Qn.length; n++) {
            var r = Qn[n];
            e[r] = tr(r, t);
        } var o, i = b.default.pEventTypes; function a() { for (var e = 0; e < t.interactions.list.length; e++) {
            var n = t.interactions.list[e];
            if (n.pointerIsDown && "touch" === n.pointerType && !n._interacting)
                for (var r = function () { var e = n.pointers[o]; t.documents.some((function (t) { var n = t.doc; return (0, _.nodeContains)(n, e.downTarget); })) || n.removePointer(e.pointer, e.event); }, o = 0; o < n.pointers.length; o++)
                    r();
        } } (o = h.default.PointerEvent ? [{ type: i.down, listener: a }, { type: i.down, listener: e.pointerDown }, { type: i.move, listener: e.pointerMove }, { type: i.up, listener: e.pointerUp }, { type: i.cancel, listener: e.pointerUp }] : [{ type: "mousedown", listener: e.pointerDown }, { type: "mousemove", listener: e.pointerMove }, { type: "mouseup", listener: e.pointerUp }, { type: "touchstart", listener: a }, { type: "touchstart", listener: e.pointerDown }, { type: "touchmove", listener: e.pointerMove }, { type: "touchend", listener: e.pointerUp }, { type: "touchcancel", listener: e.pointerUp }]).push({ type: "blur", listener: function (e) { for (var n = 0; n < t.interactions.list.length; n++)
                t.interactions.list[n].documentBlur(e); } }), t.prevTouchTime = 0, t.Interaction = function (e) { !function (t, e) { if ("function" != typeof e && null !== e)
            throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && Kn(t, e); }(s, e); var n, r, o, i, a = (o = s, i = function () { if ("undefined" == typeof Reflect || !Reflect.construct)
            return !1; if (Reflect.construct.sham)
            return !1; if ("function" == typeof Proxy)
            return !0; try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0;
        }
        catch (t) {
            return !1;
        } }(), function () { var t, e = Jn(o); if (i) {
            var n = Jn(this).constructor;
            t = Reflect.construct(e, arguments, n);
        }
        else
            t = e.apply(this, arguments); return Zn(this, t); }); function s() { return $n(this, s), a.apply(this, arguments); } return n = s, (r = [{ key: "pointerMoveTolerance", get: function () { return t.interactions.pointerMoveTolerance; }, set: function (e) { t.interactions.pointerMoveTolerance = e; } }, { key: "_now", value: function () { return t.now(); } }]) && Hn(n.prototype, r), Object.defineProperty(n, "prototype", { writable: !1 }), s; }(Ge.default), t.interactions = { list: [], new: function (e) { e.scopeFire = function (e, n) { return t.fire(e, n); }; var n = new t.Interaction(e); return t.interactions.list.push(n), n; }, listeners: e, docEvents: o, pointerMoveTolerance: 1 }, t.usePlugin(le.default); }, listeners: { "scope:add-document": function (t) { return nr(t, "add"); }, "scope:remove-document": function (t) { return nr(t, "remove"); }, "interactable:unset": function (t, e) { for (var n = t.interactable, r = e.interactions.list.length - 1; r >= 0; r--) {
                var o = e.interactions.list[r];
                o.interactable === n && (o.stop(), e.fire("interactions:destroy", { interaction: o }), o.destroy(), e.interactions.list.length > 2 && e.interactions.list.splice(r, 1));
            } } }, onDocSignal: nr, doOnInteractions: tr, methodNames: Qn }, or = rr; Vn.default = or; var ir = {}; function ar(t) { return ar = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t; } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }, ar(t); } function sr() { return sr = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (t, e, n) { var r = lr(t, e); if (r) {
        var o = Object.getOwnPropertyDescriptor(r, e);
        return o.get ? o.get.call(arguments.length < 3 ? t : n) : o.value;
    } }, sr.apply(this, arguments); } function lr(t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = fr(t));)
        ; return t; } function ur(t, e) { return ur = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, ur(t, e); } function cr(t, e) { if (e && ("object" === ar(e) || "function" == typeof e))
        return e; if (void 0 !== e)
        throw new TypeError("Derived constructors may only return object or undefined"); return function (t) { if (void 0 === t)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; }(t); } function fr(t) { return fr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, fr(t); } function dr(t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); } function pr(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function vr(t, e, n) { return e && pr(t.prototype, e), n && pr(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t; } function hr(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } Object.defineProperty(ir, "__esModule", { value: !0 }), ir.Scope = void 0, ir.initScope = yr; var gr = function () { function t() { var e = this; dr(this, t), hr(this, "id", "__interact_scope_".concat(Math.floor(100 * Math.random()))), hr(this, "isInitialized", !1), hr(this, "listenerMaps", []), hr(this, "browser", b.default), hr(this, "defaults", (0, ye.default)(ke.defaults)), hr(this, "Eventable", yn.Eventable), hr(this, "actions", { map: {}, phases: { start: !0, move: !0, end: !0 }, methodDict: {}, phaselessTypes: {} }), hr(this, "interactStatic", (0, Pn.createInteractStatic)(this)), hr(this, "InteractEvent", Ie.InteractEvent), hr(this, "Interactable", void 0), hr(this, "interactables", new jn.InteractableSet(this)), hr(this, "_win", void 0), hr(this, "document", void 0), hr(this, "window", void 0), hr(this, "documents", []), hr(this, "_plugins", { list: [], map: {} }), hr(this, "onWindowUnload", (function (t) { return e.removeDocument(t.target); })); var n = this; this.Interactable = function (t) { !function (t, e) { if ("function" != typeof e && null !== e)
        throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && ur(t, e); }(i, t); var e, r, o = (e = i, r = function () { if ("undefined" == typeof Reflect || !Reflect.construct)
        return !1; if (Reflect.construct.sham)
        return !1; if ("function" == typeof Proxy)
        return !0; try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0;
    }
    catch (t) {
        return !1;
    } }(), function () { var t, n = fr(e); if (r) {
        var o = fr(this).constructor;
        t = Reflect.construct(n, arguments, o);
    }
    else
        t = n.apply(this, arguments); return cr(this, t); }); function i() { return dr(this, i), o.apply(this, arguments); } return vr(i, [{ key: "_defaults", get: function () { return n.defaults; } }, { key: "set", value: function (t) { return sr(fr(i.prototype), "set", this).call(this, t), n.fire("interactable:set", { options: t, interactable: this }), this; } }, { key: "unset", value: function () { sr(fr(i.prototype), "unset", this).call(this); var t = n.interactables.list.indexOf(this); t < 0 || (sr(fr(i.prototype), "unset", this).call(this), n.interactables.list.splice(t, 1), n.fire("interactable:unset", { interactable: this })); } }]), i; }(On.Interactable); } return vr(t, [{ key: "addListeners", value: function (t, e) { this.listenerMaps.push({ id: e, map: t }); } }, { key: "fire", value: function (t, e) { for (var n = 0; n < this.listenerMaps.length; n++) {
                var r = this.listenerMaps[n].map[t];
                if (r && !1 === r(e, this, t))
                    return !1;
            } } }, { key: "init", value: function (t) { return this.isInitialized ? this : yr(this, t); } }, { key: "pluginIsInstalled", value: function (t) { return this._plugins.map[t.id] || -1 !== this._plugins.list.indexOf(t); } }, { key: "usePlugin", value: function (t, e) { if (!this.isInitialized)
                return this; if (this.pluginIsInstalled(t))
                return this; if (t.id && (this._plugins.map[t.id] = t), this._plugins.list.push(t), t.install && t.install(this, e), t.listeners && t.before) {
                for (var n = 0, r = this.listenerMaps.length, o = t.before.reduce((function (t, e) { return t[e] = !0, t[mr(e)] = !0, t; }), {}); n < r; n++) {
                    var i = this.listenerMaps[n].id;
                    if (o[i] || o[mr(i)])
                        break;
                }
                this.listenerMaps.splice(n, 0, { id: t.id, map: t.listeners });
            }
            else
                t.listeners && this.listenerMaps.push({ id: t.id, map: t.listeners }); return this; } }, { key: "addDocument", value: function (t, n) { if (-1 !== this.getDocIndex(t))
                return !1; var r = e.getWindow(t); n = n ? (0, M.default)({}, n) : {}, this.documents.push({ doc: t, options: n }), this.events.documents.push(t), t !== this.document && this.events.add(r, "unload", this.onWindowUnload), this.fire("scope:add-document", { doc: t, window: r, scope: this, options: n }); } }, { key: "removeDocument", value: function (t) { var n = this.getDocIndex(t), r = e.getWindow(t), o = this.documents[n].options; this.events.remove(r, "unload", this.onWindowUnload), this.documents.splice(n, 1), this.events.documents.splice(n, 1), this.fire("scope:remove-document", { doc: t, window: r, scope: this, options: o }); } }, { key: "getDocIndex", value: function (t) { for (var e = 0; e < this.documents.length; e++)
                if (this.documents[e].doc === t)
                    return e; return -1; } }, { key: "getDocOptions", value: function (t) { var e = this.getDocIndex(t); return -1 === e ? null : this.documents[e].options; } }, { key: "now", value: function () { return (this.window.Date || Date).now(); } }]), t; }(); function yr(t, n) { return t.isInitialized = !0, i.default.window(n) && e.init(n), h.default.init(n), b.default.init(n), Tt.default.init(n), t.window = n, t.document = n.document, t.usePlugin(Vn.default), t.usePlugin(Dn.default), t; } function mr(t) { return t && t.replace(/\/.*$/, ""); } ir.Scope = gr; var br = {}; Object.defineProperty(br, "__esModule", { value: !0 }), br.default = void 0; var xr = new ir.Scope, wr = xr.interactStatic; br.default = wr; var _r = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0; xr.init(_r); var Pr = {}; Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.default = void 0, Pr.default = function () { }; var Or = {}; Object.defineProperty(Or, "__esModule", { value: !0 }), Or.default = void 0, Or.default = function () { }; var Er = {}; function Sr(t, e) { return function (t) { if (Array.isArray(t))
        return t; }(t) || function (t, e) { var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (null != n) {
        var r, o, i = [], a = !0, s = !1;
        try {
            for (n = n.call(t); !(a = (r = n.next()).done) && (i.push(r.value), !e || i.length !== e); a = !0)
                ;
        }
        catch (t) {
            s = !0, o = t;
        }
        finally {
            try {
                a || null == n.return || n.return();
            }
            finally {
                if (s)
                    throw o;
            }
        }
        return i;
    } }(t, e) || function (t, e) { if (t) {
        if ("string" == typeof t)
            return Tr(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Tr(t, e) : void 0;
    } }(t, e) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }(); } function Tr(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)
        r[n] = t[n]; return r; } Object.defineProperty(Er, "__esModule", { value: !0 }), Er.default = void 0, Er.default = function (t) { var e = [["x", "y"], ["left", "top"], ["right", "bottom"], ["width", "height"]].filter((function (e) { var n = Sr(e, 2), r = n[0], o = n[1]; return r in t || o in t; })), n = function (n, r) { for (var o = t.range, i = t.limits, a = void 0 === i ? { left: -1 / 0, right: 1 / 0, top: -1 / 0, bottom: 1 / 0 } : i, s = t.offset, l = void 0 === s ? { x: 0, y: 0 } : s, u = { range: o, grid: t, x: null, y: null }, c = 0; c < e.length; c++) {
        var f = Sr(e[c], 2), d = f[0], p = f[1], v = Math.round((n - l.x) / t[d]), h = Math.round((r - l.y) / t[p]);
        u[d] = Math.max(a.left, Math.min(a.right, v * t[d] + l.x)), u[p] = Math.max(a.top, Math.min(a.bottom, h * t[p] + l.y));
    } return u; }; return n.grid = t, n.coordFields = e, n; }; var jr = {}; Object.defineProperty(jr, "__esModule", { value: !0 }), Object.defineProperty(jr, "edgeTarget", { enumerable: !0, get: function () { return Pr.default; } }), Object.defineProperty(jr, "elements", { enumerable: !0, get: function () { return Or.default; } }), Object.defineProperty(jr, "grid", { enumerable: !0, get: function () { return Er.default; } }); var Mr = {}; Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.default = void 0; var kr = { id: "snappers", install: function (t) { var e = t.interactStatic; e.snappers = (0, M.default)(e.snappers || {}, jr), e.createSnapGrid = e.snappers.grid; } }, Ir = kr; Mr.default = Ir; var Dr = {}; function Ar(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(t);
        e && (r = r.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable; }))), n.push.apply(n, r);
    } return n; } function zr(t) { for (var e = 1; e < arguments.length; e++) {
        var n = null != arguments[e] ? arguments[e] : {};
        e % 2 ? Ar(Object(n), !0).forEach((function (e) { Cr(t, e, n[e]); })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Ar(Object(n)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e)); }));
    } return t; } function Cr(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t; } Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.default = Dr.aspectRatio = void 0; var Rr = { start: function (t) { var e = t.state, n = t.rect, r = t.edges, o = t.pageCoords, i = e.options.ratio, a = e.options, s = a.equalDelta, l = a.modifiers; "preserve" === i && (i = n.width / n.height), e.startCoords = (0, M.default)({}, o), e.startRect = (0, M.default)({}, n), e.ratio = i, e.equalDelta = s; var u = e.linkedEdges = { top: r.top || r.left && !r.bottom, left: r.left || r.top && !r.right, bottom: r.bottom || r.right && !r.top, right: r.right || r.bottom && !r.left }; if (e.xIsPrimaryAxis = !(!r.left && !r.right), e.equalDelta) {
            var c = (u.left ? 1 : -1) * (u.top ? 1 : -1);
            e.edgeSign = { x: c, y: c };
        }
        else
            e.edgeSign = { x: u.left ? -1 : 1, y: u.top ? -1 : 1 }; if ((0, M.default)(t.edges, u), l && l.length) {
            var f = new me.default(t.interaction);
            f.copyFrom(t.interaction.modification), f.prepareStates(l), e.subModification = f, f.startAll(zr({}, t));
        } }, set: function (t) { var e = t.state, n = t.rect, r = t.coords, o = (0, M.default)({}, r), i = e.equalDelta ? Fr : Xr; if (i(e, e.xIsPrimaryAxis, r, n), !e.subModification)
            return null; var a = (0, M.default)({}, n); (0, k.addEdges)(e.linkedEdges, a, { x: r.x - o.x, y: r.y - o.y }); var s = e.subModification.setAll(zr(zr({}, t), {}, { rect: a, edges: e.linkedEdges, pageCoords: r, prevCoords: r, prevRect: a })), l = s.delta; return s.changed && (i(e, Math.abs(l.x) > Math.abs(l.y), s.coords, s.rect), (0, M.default)(r, s.coords)), s.eventProps; }, defaults: { ratio: "preserve", equalDelta: !1, modifiers: [], enabled: !1 } }; function Fr(t, e, n) { var r = t.startCoords, o = t.edgeSign; e ? n.y = r.y + (n.x - r.x) * o.y : n.x = r.x + (n.y - r.y) * o.x; } function Xr(t, e, n, r) { var o = t.startRect, i = t.startCoords, a = t.ratio, s = t.edgeSign; if (e) {
        var l = r.width / a;
        n.y = i.y + (l - o.height) * s.y;
    }
    else {
        var u = r.height * a;
        n.x = i.x + (u - o.width) * s.x;
    } } Dr.aspectRatio = Rr; var Br = (0, Se.makeModifier)(Rr, "aspectRatio"); Dr.default = Br; var Yr = {}; Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.default = void 0; var Wr = function () { }; Wr._defaults = {}; var Lr = Wr; Yr.default = Lr; var Ur = {}; Object.defineProperty(Ur, "__esModule", { value: !0 }), Object.defineProperty(Ur, "default", { enumerable: !0, get: function () { return Yr.default; } }); var Vr = {}; function Nr(t, e, n) { return i.default.func(t) ? k.resolveRectLike(t, e.interactable, e.element, [n.x, n.y, e]) : k.resolveRectLike(t, e.interactable, e.element); } Object.defineProperty(Vr, "__esModule", { value: !0 }), Vr.default = void 0, Vr.getRestrictionRect = Nr, Vr.restrict = void 0; var qr = { start: function (t) { var e = t.rect, n = t.startOffset, r = t.state, o = t.interaction, i = t.pageCoords, a = r.options, s = a.elementRect, l = (0, M.default)({ left: 0, top: 0, right: 0, bottom: 0 }, a.offset || {}); if (e && s) {
            var u = Nr(a.restriction, o, i);
            if (u) {
                var c = u.right - u.left - e.width, f = u.bottom - u.top - e.height;
                c < 0 && (l.left += c, l.right += c), f < 0 && (l.top += f, l.bottom += f);
            }
            l.left += n.left - e.width * s.left, l.top += n.top - e.height * s.top, l.right += n.right - e.width * (1 - s.right), l.bottom += n.bottom - e.height * (1 - s.bottom);
        } r.offset = l; }, set: function (t) { var e = t.coords, n = t.interaction, r = t.state, o = r.options, i = r.offset, a = Nr(o.restriction, n, e); if (a) {
            var s = k.xywhToTlbr(a);
            e.x = Math.max(Math.min(s.right - i.right, e.x), s.left + i.left), e.y = Math.max(Math.min(s.bottom - i.bottom, e.y), s.top + i.top);
        } }, defaults: { restriction: null, elementRect: null, offset: null, endOnly: !1, enabled: !1 } }; Vr.restrict = qr; var Gr = (0, Se.makeModifier)(qr, "restrict"); Vr.default = Gr; var $r = {}; Object.defineProperty($r, "__esModule", { value: !0 }), $r.restrictEdges = $r.default = void 0; var Hr = { top: 1 / 0, left: 1 / 0, bottom: -1 / 0, right: -1 / 0 }, Kr = { top: -1 / 0, left: -1 / 0, bottom: 1 / 0, right: 1 / 0 }; function Zr(t, e) { for (var n = ["top", "left", "bottom", "right"], r = 0; r < n.length; r++) {
        var o = n[r];
        o in t || (t[o] = e[o]);
    } return t; } var Jr = { noInner: Hr, noOuter: Kr, start: function (t) { var e, n = t.interaction, r = t.startOffset, o = t.state, i = o.options; if (i) {
            var a = (0, Vr.getRestrictionRect)(i.offset, n, n.coords.start.page);
            e = k.rectToXY(a);
        } e = e || { x: 0, y: 0 }, o.offset = { top: e.y + r.top, left: e.x + r.left, bottom: e.y - r.bottom, right: e.x - r.right }; }, set: function (t) { var e = t.coords, n = t.edges, r = t.interaction, o = t.state, i = o.offset, a = o.options; if (n) {
            var s = (0, M.default)({}, e), l = (0, Vr.getRestrictionRect)(a.inner, r, s) || {}, u = (0, Vr.getRestrictionRect)(a.outer, r, s) || {};
            Zr(l, Hr), Zr(u, Kr), n.top ? e.y = Math.min(Math.max(u.top + i.top, s.y), l.top + i.top) : n.bottom && (e.y = Math.max(Math.min(u.bottom + i.bottom, s.y), l.bottom + i.bottom)), n.left ? e.x = Math.min(Math.max(u.left + i.left, s.x), l.left + i.left) : n.right && (e.x = Math.max(Math.min(u.right + i.right, s.x), l.right + i.right));
        } }, defaults: { inner: null, outer: null, offset: null, endOnly: !1, enabled: !1 } }; $r.restrictEdges = Jr; var Qr = (0, Se.makeModifier)(Jr, "restrictEdges"); $r.default = Qr; var to = {}; Object.defineProperty(to, "__esModule", { value: !0 }), to.restrictRect = to.default = void 0; var eo = (0, M.default)({ get elementRect() { return { top: 0, left: 0, bottom: 1, right: 1 }; }, set elementRect(t) { } }, Vr.restrict.defaults), no = { start: Vr.restrict.start, set: Vr.restrict.set, defaults: eo }; to.restrictRect = no; var ro = (0, Se.makeModifier)(no, "restrictRect"); to.default = ro; var oo = {}; Object.defineProperty(oo, "__esModule", { value: !0 }), oo.restrictSize = oo.default = void 0; var io = { width: -1 / 0, height: -1 / 0 }, ao = { width: 1 / 0, height: 1 / 0 }, so = { start: function (t) { return $r.restrictEdges.start(t); }, set: function (t) { var e = t.interaction, n = t.state, r = t.rect, o = t.edges, i = n.options; if (o) {
            var a = k.tlbrToXywh((0, Vr.getRestrictionRect)(i.min, e, t.coords)) || io, s = k.tlbrToXywh((0, Vr.getRestrictionRect)(i.max, e, t.coords)) || ao;
            n.options = { endOnly: i.endOnly, inner: (0, M.default)({}, $r.restrictEdges.noInner), outer: (0, M.default)({}, $r.restrictEdges.noOuter) }, o.top ? (n.options.inner.top = r.bottom - a.height, n.options.outer.top = r.bottom - s.height) : o.bottom && (n.options.inner.bottom = r.top + a.height, n.options.outer.bottom = r.top + s.height), o.left ? (n.options.inner.left = r.right - a.width, n.options.outer.left = r.right - s.width) : o.right && (n.options.inner.right = r.left + a.width, n.options.outer.right = r.left + s.width), $r.restrictEdges.set(t), n.options = i;
        } }, defaults: { min: null, max: null, endOnly: !1, enabled: !1 } }; oo.restrictSize = so; var lo = (0, Se.makeModifier)(so, "restrictSize"); oo.default = lo; var uo = {}; Object.defineProperty(uo, "__esModule", { value: !0 }), Object.defineProperty(uo, "default", { enumerable: !0, get: function () { return Yr.default; } }); var co = {}; Object.defineProperty(co, "__esModule", { value: !0 }), co.snap = co.default = void 0; var fo = { start: function (t) { var e, n = t.interaction, r = t.interactable, o = t.element, i = t.rect, a = t.state, s = t.startOffset, l = a.options, u = l.offsetWithOrigin ? function (t) { var e = t.interaction.element; return (0, k.rectToXY)((0, k.resolveRectLike)(t.state.options.origin, null, null, [e])) || (0, A.default)(t.interactable, e, t.interaction.prepared.name); }(t) : { x: 0, y: 0 }; if ("startCoords" === l.offset)
            e = { x: n.coords.start.page.x, y: n.coords.start.page.y };
        else {
            var c = (0, k.resolveRectLike)(l.offset, r, o, [n]);
            (e = (0, k.rectToXY)(c) || { x: 0, y: 0 }).x += u.x, e.y += u.y;
        } var f = l.relativePoints; a.offsets = i && f && f.length ? f.map((function (t, n) { return { index: n, relativePoint: t, x: s.left - i.width * t.x + e.x, y: s.top - i.height * t.y + e.y }; })) : [{ index: 0, relativePoint: null, x: e.x, y: e.y }]; }, set: function (t) { var e = t.interaction, n = t.coords, r = t.state, o = r.options, a = r.offsets, s = (0, A.default)(e.interactable, e.element, e.prepared.name), l = (0, M.default)({}, n), u = []; o.offsetWithOrigin || (l.x -= s.x, l.y -= s.y); for (var c = 0; c < a.length; c++)
            for (var f = a[c], d = l.x - f.x, p = l.y - f.y, v = 0, h = o.targets.length; v < h; v++) {
                var g, y = o.targets[v];
                (g = i.default.func(y) ? y(d, p, e._proxy, f, v) : y) && u.push({ x: (i.default.number(g.x) ? g.x : d) + f.x, y: (i.default.number(g.y) ? g.y : p) + f.y, range: i.default.number(g.range) ? g.range : o.range, source: y, index: v, offset: f });
            } for (var m = { target: null, inRange: !1, distance: 0, range: 0, delta: { x: 0, y: 0 } }, b = 0; b < u.length; b++) {
            var x = u[b], w = x.range, _ = x.x - l.x, P = x.y - l.y, O = (0, R.default)(_, P), E = O <= w;
            w === 1 / 0 && m.inRange && m.range !== 1 / 0 && (E = !1), m.target && !(E ? m.inRange && w !== 1 / 0 ? O / w < m.distance / m.range : w === 1 / 0 && m.range !== 1 / 0 || O < m.distance : !m.inRange && O < m.distance) || (m.target = x, m.distance = O, m.range = w, m.inRange = E, m.delta.x = _, m.delta.y = P);
        } return m.inRange && (n.x = m.target.x, n.y = m.target.y), r.closest = m, m; }, defaults: { range: 1 / 0, targets: null, offset: null, offsetWithOrigin: !0, origin: null, relativePoints: null, endOnly: !1, enabled: !1 } }; co.snap = fo; var po = (0, Se.makeModifier)(fo, "snap"); co.default = po; var vo = {}; function ho(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)
        r[n] = t[n]; return r; } Object.defineProperty(vo, "__esModule", { value: !0 }), vo.snapSize = vo.default = void 0; var go = { start: function (t) { var e = t.state, n = t.edges, r = e.options; if (!n)
            return null; t.state = { options: { targets: null, relativePoints: [{ x: n.left ? 0 : 1, y: n.top ? 0 : 1 }], offset: r.offset || "self", origin: { x: 0, y: 0 }, range: r.range } }, e.targetFields = e.targetFields || [["width", "height"], ["x", "y"]], co.snap.start(t), e.offsets = t.state.offsets, t.state = e; }, set: function (t) { var e, n, r = t.interaction, o = t.state, a = t.coords, s = o.options, l = o.offsets, u = { x: a.x - l[0].x, y: a.y - l[0].y }; o.options = (0, M.default)({}, s), o.options.targets = []; for (var c = 0; c < (s.targets || []).length; c++) {
            var f = (s.targets || [])[c], d = void 0;
            if (d = i.default.func(f) ? f(u.x, u.y, r) : f) {
                for (var p = 0; p < o.targetFields.length; p++) {
                    var v = (e = o.targetFields[p], n = 2, function (t) { if (Array.isArray(t))
                        return t; }(e) || function (t, e) { var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (null != n) {
                        var r, o, i = [], a = !0, s = !1;
                        try {
                            for (n = n.call(t); !(a = (r = n.next()).done) && (i.push(r.value), !e || i.length !== e); a = !0)
                                ;
                        }
                        catch (t) {
                            s = !0, o = t;
                        }
                        finally {
                            try {
                                a || null == n.return || n.return();
                            }
                            finally {
                                if (s)
                                    throw o;
                            }
                        }
                        return i;
                    } }(e, n) || function (t, e) { if (t) {
                        if ("string" == typeof t)
                            return ho(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ho(t, e) : void 0;
                    } }(e, n) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }()), h = v[0], g = v[1];
                    if (h in d || g in d) {
                        d.x = d[h], d.y = d[g];
                        break;
                    }
                }
                o.options.targets.push(d);
            }
        } var y = co.snap.set(t); return o.options = s, y; }, defaults: { range: 1 / 0, targets: null, offset: null, endOnly: !1, enabled: !1 } }; vo.snapSize = go; var yo = (0, Se.makeModifier)(go, "snapSize"); vo.default = yo; var mo = {}; Object.defineProperty(mo, "__esModule", { value: !0 }), mo.snapEdges = mo.default = void 0; var bo = { start: function (t) { var e = t.edges; return e ? (t.state.targetFields = t.state.targetFields || [[e.left ? "left" : "right", e.top ? "top" : "bottom"]], vo.snapSize.start(t)) : null; }, set: vo.snapSize.set, defaults: (0, M.default)((0, ye.default)(vo.snapSize.defaults), { targets: null, range: null, offset: { x: 0, y: 0 } }) }; mo.snapEdges = bo; var xo = (0, Se.makeModifier)(bo, "snapEdges"); mo.default = xo; var wo = {}; Object.defineProperty(wo, "__esModule", { value: !0 }), Object.defineProperty(wo, "default", { enumerable: !0, get: function () { return Yr.default; } }); var _o = {}; Object.defineProperty(_o, "__esModule", { value: !0 }), Object.defineProperty(_o, "default", { enumerable: !0, get: function () { return Yr.default; } }); var Po = {}; Object.defineProperty(Po, "__esModule", { value: !0 }), Po.default = void 0; var Oo = { aspectRatio: Dr.default, restrictEdges: $r.default, restrict: Vr.default, restrictRect: to.default, restrictSize: oo.default, snapEdges: mo.default, snap: co.default, snapSize: vo.default, spring: wo.default, avoid: Ur.default, transform: _o.default, rubberband: uo.default }; Po.default = Oo; var Eo = {}; Object.defineProperty(Eo, "__esModule", { value: !0 }), Eo.default = void 0; var So = { id: "modifiers", install: function (t) { var e = t.interactStatic; for (var n in t.usePlugin(Se.default), t.usePlugin(Mr.default), e.modifiers = Po.default, Po.default) {
            var r = Po.default[n], o = r._defaults, i = r._methods;
            o._methods = i, t.defaults.perAction[n] = o;
        } } }, To = So; Eo.default = To; var jo = {}; function Mo(t) { return Mo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t; } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }, Mo(t); } function ko(t, e) { for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    } } function Io(t, e) { return Io = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, Io(t, e); } function Do(t, e) { if (e && ("object" === Mo(e) || "function" == typeof e))
        return e; if (void 0 !== e)
        throw new TypeError("Derived constructors may only return object or undefined"); return Ao(t); } function Ao(t) { if (void 0 === t)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; } function zo(t) { return zo = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, zo(t); } Object.defineProperty(jo, "__esModule", { value: !0 }), jo.default = jo.PointerEvent = void 0; var Co = function (t) { !function (t, e) { if ("function" != typeof e && null !== e)
        throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && Io(t, e); }(a, t); var e, n, r, o, i = (r = a, o = function () { if ("undefined" == typeof Reflect || !Reflect.construct)
        return !1; if (Reflect.construct.sham)
        return !1; if ("function" == typeof Proxy)
        return !0; try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0;
    }
    catch (t) {
        return !1;
    } }(), function () { var t, e = zo(r); if (o) {
        var n = zo(this).constructor;
        t = Reflect.construct(e, arguments, n);
    }
    else
        t = e.apply(this, arguments); return Do(this, t); }); function a(t, e, n, r, o, s) { var l; if (function (t, e) { if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function"); }(this, a), l = i.call(this, o), X.pointerExtend(Ao(l), n), n !== e && X.pointerExtend(Ao(l), e), l.timeStamp = s, l.originalEvent = n, l.type = t, l.pointerId = X.getPointerId(e), l.pointerType = X.getPointerType(e), l.target = r, l.currentTarget = null, "tap" === t) {
        var u = o.getPointerIndex(e);
        l.dt = l.timeStamp - o.pointers[u].downTime;
        var c = l.timeStamp - o.tapTime;
        l.double = !!o.prevTap && "doubletap" !== o.prevTap.type && o.prevTap.target === l.target && c < 500;
    }
    else
        "doubletap" === t && (l.dt = e.timeStamp - o.tapTime, l.double = !0); return l; } return e = a, (n = [{ key: "_subtractOrigin", value: function (t) { var e = t.x, n = t.y; return this.pageX -= e, this.pageY -= n, this.clientX -= e, this.clientY -= n, this; } }, { key: "_addOrigin", value: function (t) { var e = t.x, n = t.y; return this.pageX += e, this.pageY += n, this.clientX += e, this.clientY += n, this; } }, { key: "preventDefault", value: function () { this.originalEvent.preventDefault(); } }]) && ko(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), a; }(N.BaseEvent); jo.PointerEvent = jo.default = Co; var Ro = {}; Object.defineProperty(Ro, "__esModule", { value: !0 }), Ro.default = void 0; var Fo = { id: "pointer-events/base", before: ["inertia", "modifiers", "auto-start", "actions"], install: function (t) { t.pointerEvents = Fo, t.defaults.actions.pointerEvents = Fo.defaults, (0, M.default)(t.actions.phaselessTypes, Fo.types); }, listeners: { "interactions:new": function (t) { var e = t.interaction; e.prevTap = null, e.tapTime = 0; }, "interactions:update-pointer": function (t) { var e = t.down, n = t.pointerInfo; !e && n.hold || (n.hold = { duration: 1 / 0, timeout: null }); }, "interactions:move": function (t, e) { var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget; t.duplicate || n.pointerIsDown && !n.pointerWasMoved || (n.pointerIsDown && Yo(t), Xo({ interaction: n, pointer: r, event: o, eventTarget: i, type: "move" }, e)); }, "interactions:down": function (t, e) { !function (t, e) { for (var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget, a = t.pointerIndex, s = n.pointers[a].hold, l = _.getPath(i), u = { interaction: n, pointer: r, event: o, eventTarget: i, type: "hold", targets: [], path: l, node: null }, c = 0; c < l.length; c++) {
                var f = l[c];
                u.node = f, e.fire("pointerEvents:collect-targets", u);
            } if (u.targets.length) {
                for (var d = 1 / 0, p = 0; p < u.targets.length; p++) {
                    var v = u.targets[p].eventable.options.holdDuration;
                    v < d && (d = v);
                }
                s.duration = d, s.timeout = setTimeout((function () { Xo({ interaction: n, eventTarget: i, pointer: r, event: o, type: "hold" }, e); }), d);
            } }(t, e), Xo(t, e); }, "interactions:up": function (t, e) { Yo(t), Xo(t, e), function (t, e) { var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget; n.pointerWasMoved || Xo({ interaction: n, eventTarget: i, pointer: r, event: o, type: "tap" }, e); }(t, e); }, "interactions:cancel": function (t, e) { Yo(t), Xo(t, e); } }, PointerEvent: jo.PointerEvent, fire: Xo, collectEventTargets: Bo, defaults: { holdDuration: 600, ignoreFrom: null, allowFrom: null, origin: { x: 0, y: 0 } }, types: { down: !0, move: !0, up: !0, cancel: !0, tap: !0, doubletap: !0, hold: !0 } }; function Xo(t, e) { var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget, a = t.type, s = t.targets, l = void 0 === s ? Bo(t, e) : s, u = new jo.PointerEvent(a, r, o, i, n, e.now()); e.fire("pointerEvents:new", { pointerEvent: u }); for (var c = { interaction: n, pointer: r, event: o, eventTarget: i, targets: l, type: a, pointerEvent: u }, f = 0; f < l.length; f++) {
        var d = l[f];
        for (var p in d.props || {})
            u[p] = d.props[p];
        var v = (0, A.default)(d.eventable, d.node);
        if (u._subtractOrigin(v), u.eventable = d.eventable, u.currentTarget = d.node, d.eventable.fire(u), u._addOrigin(v), u.immediatePropagationStopped || u.propagationStopped && f + 1 < l.length && l[f + 1].node !== u.currentTarget)
            break;
    } if (e.fire("pointerEvents:fired", c), "tap" === a) {
        var h = u.double ? Xo({ interaction: n, pointer: r, event: o, eventTarget: i, type: "doubletap" }, e) : u;
        n.prevTap = h, n.tapTime = h.timeStamp;
    } return u; } function Bo(t, e) { var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget, a = t.type, s = n.getPointerIndex(r), l = n.pointers[s]; if ("tap" === a && (n.pointerWasMoved || !l || l.downTarget !== i))
        return []; for (var u = _.getPath(i), c = { interaction: n, pointer: r, event: o, eventTarget: i, type: a, path: u, targets: [], node: null }, f = 0; f < u.length; f++) {
        var d = u[f];
        c.node = d, e.fire("pointerEvents:collect-targets", c);
    } return "hold" === a && (c.targets = c.targets.filter((function (t) { var e; return t.eventable.options.holdDuration === (null == (e = n.pointers[s]) ? void 0 : e.hold.duration); }))), c.targets; } function Yo(t) { var e = t.interaction, n = t.pointerIndex, r = e.pointers[n].hold; r && r.timeout && (clearTimeout(r.timeout), r.timeout = null); } var Wo = Fo; Ro.default = Wo; var Lo = {}; function Uo(t) { var e = t.interaction; e.holdIntervalHandle && (clearInterval(e.holdIntervalHandle), e.holdIntervalHandle = null); } Object.defineProperty(Lo, "__esModule", { value: !0 }), Lo.default = void 0; var Vo = { id: "pointer-events/holdRepeat", install: function (t) { t.usePlugin(Ro.default); var e = t.pointerEvents; e.defaults.holdRepeatInterval = 0, e.types.holdrepeat = t.actions.phaselessTypes.holdrepeat = !0; }, listeners: ["move", "up", "cancel", "endall"].reduce((function (t, e) { return t["pointerEvents:".concat(e)] = Uo, t; }), { "pointerEvents:new": function (t) { var e = t.pointerEvent; "hold" === e.type && (e.count = (e.count || 0) + 1); }, "pointerEvents:fired": function (t, e) { var n = t.interaction, r = t.pointerEvent, o = t.eventTarget, i = t.targets; if ("hold" === r.type && i.length) {
                var a = i[0].eventable.options.holdRepeatInterval;
                a <= 0 || (n.holdIntervalHandle = setTimeout((function () { e.pointerEvents.fire({ interaction: n, eventTarget: o, type: "hold", pointer: r, event: r }, e); }), a));
            } } }) }, No = Vo; Lo.default = No; var qo = {}; function Go(t) { return (0, M.default)(this.events.options, t), this; } Object.defineProperty(qo, "__esModule", { value: !0 }), qo.default = void 0; var $o = { id: "pointer-events/interactableTargets", install: function (t) { var e = t.Interactable; e.prototype.pointerEvents = Go; var n = e.prototype._backCompatOption; e.prototype._backCompatOption = function (t, e) { var r = n.call(this, t, e); return r === this && (this.events.options[t] = e), r; }; }, listeners: { "pointerEvents:collect-targets": function (t, e) { var n = t.targets, r = t.node, o = t.type, i = t.eventTarget; e.interactables.forEachMatch(r, (function (t) { var e = t.events, a = e.options; e.types[o] && e.types[o].length && t.testIgnoreAllow(a, r, i) && n.push({ node: r, eventable: e, props: { interactable: t } }); })); }, "interactable:new": function (t) { var e = t.interactable; e.events.getRect = function (t) { return e.getRect(t); }; }, "interactable:set": function (t, e) { var n = t.interactable, r = t.options; (0, M.default)(n.events.options, e.pointerEvents.defaults), (0, M.default)(n.events.options, r.pointerEvents || {}); } } }, Ho = $o; qo.default = Ho; var Ko = {}; Object.defineProperty(Ko, "__esModule", { value: !0 }), Ko.default = void 0; var Zo = { id: "pointer-events", install: function (t) { t.usePlugin(Ro), t.usePlugin(Lo.default), t.usePlugin(qo.default); } }, Jo = Zo; Ko.default = Jo; var Qo = {}; function ti(t) { var e = t.Interactable; t.actions.phases.reflow = !0, e.prototype.reflow = function (e) { return function (t, e, n) { for (var r = i.default.string(t.target) ? H.from(t._context.querySelectorAll(t.target)) : [t.target], o = n.window.Promise, a = o ? [] : null, s = function () { var i = r[l], s = t.getRect(i); if (!s)
        return "break"; var u = H.find(n.interactions.list, (function (n) { return n.interacting() && n.interactable === t && n.element === i && n.prepared.name === e.name; })), c = void 0; if (u)
        u.move(), a && (c = u._reflowPromise || new o((function (t) { u._reflowResolve = t; })));
    else {
        var f = (0, k.tlbrToXywh)(s), d = { page: { x: f.x, y: f.y }, client: { x: f.x, y: f.y }, timeStamp: n.now() }, p = X.coordsToEvent(d);
        c = function (t, e, n, r, o) { var i = t.interactions.new({ pointerType: "reflow" }), a = { interaction: i, event: o, pointer: o, eventTarget: n, phase: "reflow" }; i.interactable = e, i.element = n, i.prevEvent = o, i.updatePointer(o, o, n, !0), X.setZeroCoords(i.coords.delta), (0, Xt.copyAction)(i.prepared, r), i._doPhase(a); var s = t.window.Promise, l = s ? new s((function (t) { i._reflowResolve = t; })) : void 0; return i._reflowPromise = l, i.start(r, e, n), i._interacting ? (i.move(a), i.end(o)) : (i.stop(), i._reflowResolve()), i.removePointer(o, o), l; }(n, t, i, e, p);
    } a && a.push(c); }, l = 0; l < r.length && "break" !== s(); l++)
        ; return a && o.all(a).then((function () { return t; })); }(this, e, t); }; } Object.defineProperty(Qo, "__esModule", { value: !0 }), Qo.default = void 0, Qo.install = ti; var ei = { id: "reflow", install: ti, listeners: { "interactions:stop": function (t, e) { var n = t.interaction; "reflow" === n.pointerType && (n._reflowResolve && n._reflowResolve(), H.remove(e.interactions.list, n)); } } }, ni = ei; Qo.default = ni; var ri = { exports: {} }; function oi(t) { return oi = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t; } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }, oi(t); } Object.defineProperty(ri.exports, "__esModule", { value: !0 }), ri.exports.default = void 0, br.default.use(le.default), br.default.use(Qe.default), br.default.use(Ko.default), br.default.use(ln.default), br.default.use(Eo.default), br.default.use(ae.default), br.default.use(Et.default), br.default.use(Dt.default), br.default.use(Qo.default); var ii = br.default; if (ri.exports.default = ii, "object" === oi(ri) && ri)
        try {
            ri.exports = br.default;
        }
        catch (t) { } br.default.default = br.default, Et.default, Dt.default, ae.default, le.default, he.default, ln.default, br.default, Eo.default, Qe.default, Ko.default, Qo.default, ri = ri.exports; var ai = { exports: {} }; function si(t) { return si = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t; } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }, si(t); } Object.defineProperty(ai.exports, "__esModule", { value: !0 }), ai.exports.default = void 0; var li = ri.default; if (ai.exports.default = li, "object" === si(ai) && ai)
        try {
            ai.exports = ri.default;
        }
        catch (t) { } return ri.default.default = ri.default, ai.exports; }));
}(interact_min));
var interact = getDefaultExportFromCjs(interact_min.exports);
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
var Symbol$1 = root.Symbol;
var objectProto$s = Object.prototype;
var hasOwnProperty$o = objectProto$s.hasOwnProperty;
var nativeObjectToString$3 = objectProto$s.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
function getRawTag(value) {
    var isOwn = hasOwnProperty$o.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
    }
    catch (e) { }
    var result = nativeObjectToString$3.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag$1] = tag;
        }
        else {
            delete value[symToStringTag$1];
        }
    }
    return result;
}
var objectProto$r = Object.prototype;
var nativeObjectToString$2 = objectProto$r.toString;
function objectToString(value) {
    return nativeObjectToString$2.call(value);
}
var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
}
function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
var symbolTag$3 = '[object Symbol]';
function isSymbol(value) {
    return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag$3);
}
var NAN$2 = 0 / 0;
function baseToNumber(value) {
    if (typeof value == 'number') {
        return value;
    }
    if (isSymbol(value)) {
        return NAN$2;
    }
    return +value;
}
function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
        result[index] = iteratee(array[index], index, array);
    }
    return result;
}
var isArray = Array.isArray;
var INFINITY$5 = 1 / 0;
var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : undefined, symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;
function baseToString(value) {
    if (typeof value == 'string') {
        return value;
    }
    if (isArray(value)) {
        return arrayMap(value, baseToString) + '';
    }
    if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$5) ? '-0' : result;
}
function createMathOperation(operator, defaultValue) {
    return function (value, other) {
        var result;
        if (value === undefined && other === undefined) {
            return defaultValue;
        }
        if (value !== undefined) {
            result = value;
        }
        if (other !== undefined) {
            if (result === undefined) {
                return other;
            }
            if (typeof value == 'string' || typeof other == 'string') {
                value = baseToString(value);
                other = baseToString(other);
            }
            else {
                value = baseToNumber(value);
                other = baseToNumber(other);
            }
            result = operator(value, other);
        }
        return result;
    };
}
var add = createMathOperation(function (augend, addend) {
    return augend + addend;
}, 0);
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) { }
    return index;
}
var reTrimStart$2 = /^\s+/;
function baseTrim(string) {
    return string
        ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart$2, '')
        : string;
}
function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
}
var NAN$1 = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
    if (typeof value == 'number') {
        return value;
    }
    if (isSymbol(value)) {
        return NAN$1;
    }
    if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
        return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN$1 : +value);
}
var INFINITY$4 = 1 / 0, MAX_INTEGER = 1.7976931348623157e+308;
function toFinite(value) {
    if (!value) {
        return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY$4 || value === -INFINITY$4) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
}
function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? (remainder ? result - remainder : result) : 0;
}
var FUNC_ERROR_TEXT$b = 'Expected a function';
function after(n, func) {
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$b);
    }
    n = toInteger(n);
    return function () {
        if (--n < 1) {
            return func.apply(this, arguments);
        }
    };
}
function identity(value) {
    return value;
}
var asyncTag = '[object AsyncFunction]', funcTag$2 = '[object Function]', genTag$1 = '[object GeneratorFunction]', proxyTag = '[object Proxy]';
function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root['__core-js_shared__'];
var maskSrcKey = (function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
}());
function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
    if (func != null) {
        try {
            return funcToString$2.call(func);
        }
        catch (e) { }
        try {
            return (func + '');
        }
        catch (e) { }
    }
    return '';
}
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$q = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$n = objectProto$q.hasOwnProperty;
var reIsNative = RegExp('^' +
    funcToString$1.call(hasOwnProperty$n).replace(reRegExpChar$1, '\\$&')
        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
function getValue(object, key) {
    return object == null ? undefined : object[key];
}
function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
var WeakMap = getNative(root, 'WeakMap');
var metaMap = WeakMap && new WeakMap;
var baseSetData = !metaMap ? identity : function (func, data) {
    metaMap.set(func, data);
    return func;
};
var objectCreate = Object.create;
var baseCreate = (function () {
    function object() { }
    return function (proto) {
        if (!isObject(proto)) {
            return {};
        }
        if (objectCreate) {
            return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
    };
}());
function createCtor(Ctor) {
    return function () {
        var args = arguments;
        switch (args.length) {
            case 0: return new Ctor;
            case 1: return new Ctor(args[0]);
            case 2: return new Ctor(args[0], args[1]);
            case 3: return new Ctor(args[0], args[1], args[2]);
            case 4: return new Ctor(args[0], args[1], args[2], args[3]);
            case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
        return isObject(result) ? result : thisBinding;
    };
}
var WRAP_BIND_FLAG$8 = 1;
function createBind(func, bitmask, thisArg) {
    var isBind = bitmask & WRAP_BIND_FLAG$8, Ctor = createCtor(func);
    function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
    }
    return wrapper;
}
function apply(func, thisArg, args) {
    switch (args.length) {
        case 0: return func.call(thisArg);
        case 1: return func.call(thisArg, args[0]);
        case 2: return func.call(thisArg, args[0], args[1]);
        case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
var nativeMax$g = Math.max;
function composeArgs(args, partials, holders, isCurried) {
    var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax$g(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
    while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
    }
    while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
            result[holders[argsIndex]] = args[argsIndex];
        }
    }
    while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
    }
    return result;
}
var nativeMax$f = Math.max;
function composeArgsRight(args, partials, holders, isCurried) {
    var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax$f(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
    while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
    }
    var offset = argsIndex;
    while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
    }
    while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
    }
    return result;
}
function countHolders(array, placeholder) {
    var length = array.length, result = 0;
    while (length--) {
        if (array[length] === placeholder) {
            ++result;
        }
    }
    return result;
}
function baseLodash() {
}
var MAX_ARRAY_LENGTH$6 = 4294967295;
function LazyWrapper(value) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__dir__ = 1;
    this.__filtered__ = false;
    this.__iteratees__ = [];
    this.__takeCount__ = MAX_ARRAY_LENGTH$6;
    this.__views__ = [];
}
LazyWrapper.prototype = baseCreate(baseLodash.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
function noop() {
}
var getData = !metaMap ? noop : function (func) {
    return metaMap.get(func);
};
var realNames = {};
var objectProto$p = Object.prototype;
var hasOwnProperty$m = objectProto$p.hasOwnProperty;
function getFuncName(func) {
    var result = (func.name + ''), array = realNames[result], length = hasOwnProperty$m.call(realNames, result) ? array.length : 0;
    while (length--) {
        var data = array[length], otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
            return data.name;
        }
    }
    return result;
}
function LodashWrapper(value, chainAll) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__chain__ = !!chainAll;
    this.__index__ = 0;
    this.__values__ = undefined;
}
LodashWrapper.prototype = baseCreate(baseLodash.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
        array[index] = source[index];
    }
    return array;
}
function wrapperClone(wrapper) {
    if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
    }
    var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
    result.__actions__ = copyArray(wrapper.__actions__);
    result.__index__ = wrapper.__index__;
    result.__values__ = wrapper.__values__;
    return result;
}
var objectProto$o = Object.prototype;
var hasOwnProperty$l = objectProto$o.hasOwnProperty;
function lodash(value) {
    if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
            return value;
        }
        if (hasOwnProperty$l.call(value, '__wrapped__')) {
            return wrapperClone(value);
        }
    }
    return new LodashWrapper(value);
}
lodash.prototype = baseLodash.prototype;
lodash.prototype.constructor = lodash;
function isLaziable(func) {
    var funcName = getFuncName(func), other = lodash[funcName];
    if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
    }
    if (func === other) {
        return true;
    }
    var data = getData(other);
    return !!data && func === data[0];
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function () {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
            if (++count >= HOT_COUNT) {
                return arguments[0];
            }
        }
        else {
            count = 0;
        }
        return func.apply(undefined, arguments);
    };
}
var setData = shortOut(baseSetData);
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
function getWrapDetails(source) {
    var match = source.match(reWrapDetails);
    return match ? match[1].split(reSplitDetails) : [];
}
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails(source, details) {
    var length = details.length;
    if (!length) {
        return source;
    }
    var lastIndex = length - 1;
    details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
    details = details.join(length > 2 ? ', ' : ' ');
    return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
}
function constant(value) {
    return function () {
        return value;
    };
}
var defineProperty = (function () {
    try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
    }
    catch (e) { }
}());
var baseSetToString = !defineProperty ? identity : function (func, string) {
    return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
    });
};
var setToString = shortOut(baseSetToString);
function arrayEach(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
            break;
        }
    }
    return array;
}
function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
            return index;
        }
    }
    return -1;
}
function baseIsNaN(value) {
    return value !== value;
}
function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
        if (array[index] === value) {
            return index;
        }
    }
    return -1;
}
function baseIndexOf(array, value, fromIndex) {
    return value === value
        ? strictIndexOf(array, value, fromIndex)
        : baseFindIndex(array, baseIsNaN, fromIndex);
}
function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
}
var WRAP_BIND_FLAG$7 = 1, WRAP_BIND_KEY_FLAG$6 = 2, WRAP_CURRY_FLAG$6 = 8, WRAP_CURRY_RIGHT_FLAG$3 = 16, WRAP_PARTIAL_FLAG$6 = 32, WRAP_PARTIAL_RIGHT_FLAG$3 = 64, WRAP_ARY_FLAG$4 = 128, WRAP_REARG_FLAG$3 = 256, WRAP_FLIP_FLAG$2 = 512;
var wrapFlags = [
    ['ary', WRAP_ARY_FLAG$4],
    ['bind', WRAP_BIND_FLAG$7],
    ['bindKey', WRAP_BIND_KEY_FLAG$6],
    ['curry', WRAP_CURRY_FLAG$6],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG$3],
    ['flip', WRAP_FLIP_FLAG$2],
    ['partial', WRAP_PARTIAL_FLAG$6],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG$3],
    ['rearg', WRAP_REARG_FLAG$3]
];
function updateWrapDetails(details, bitmask) {
    arrayEach(wrapFlags, function (pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
            details.push(value);
        }
    });
    return details.sort();
}
function setWrapToString(wrapper, reference, bitmask) {
    var source = (reference + '');
    return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
}
var WRAP_BIND_FLAG$6 = 1, WRAP_BIND_KEY_FLAG$5 = 2, WRAP_CURRY_BOUND_FLAG$1 = 4, WRAP_CURRY_FLAG$5 = 8, WRAP_PARTIAL_FLAG$5 = 32, WRAP_PARTIAL_RIGHT_FLAG$2 = 64;
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
    var isCurry = bitmask & WRAP_CURRY_FLAG$5, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
    bitmask |= (isCurry ? WRAP_PARTIAL_FLAG$5 : WRAP_PARTIAL_RIGHT_FLAG$2);
    bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$2 : WRAP_PARTIAL_FLAG$5);
    if (!(bitmask & WRAP_CURRY_BOUND_FLAG$1)) {
        bitmask &= ~(WRAP_BIND_FLAG$6 | WRAP_BIND_KEY_FLAG$5);
    }
    var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
    ];
    var result = wrapFunc.apply(undefined, newData);
    if (isLaziable(func)) {
        setData(result, newData);
    }
    result.placeholder = placeholder;
    return setWrapToString(result, func, bitmask);
}
function getHolder(func) {
    var object = func;
    return object.placeholder;
}
var MAX_SAFE_INTEGER$5 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$5 : length;
    return !!length &&
        (type == 'number' ||
            (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}
var nativeMin$e = Math.min;
function reorder(array, indexes) {
    var arrLength = array.length, length = nativeMin$e(indexes.length, arrLength), oldArray = copyArray(array);
    while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
    }
    return array;
}
var PLACEHOLDER$1 = '__lodash_placeholder__';
function replaceHolders(array, placeholder) {
    var index = -1, length = array.length, resIndex = 0, result = [];
    while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER$1) {
            array[index] = PLACEHOLDER$1;
            result[resIndex++] = index;
        }
    }
    return result;
}
var WRAP_BIND_FLAG$5 = 1, WRAP_BIND_KEY_FLAG$4 = 2, WRAP_CURRY_FLAG$4 = 8, WRAP_CURRY_RIGHT_FLAG$2 = 16, WRAP_ARY_FLAG$3 = 128, WRAP_FLIP_FLAG$1 = 512;
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
    var isAry = bitmask & WRAP_ARY_FLAG$3, isBind = bitmask & WRAP_BIND_FLAG$5, isBindKey = bitmask & WRAP_BIND_KEY_FLAG$4, isCurried = bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2), isFlip = bitmask & WRAP_FLIP_FLAG$1, Ctor = isBindKey ? undefined : createCtor(func);
    function wrapper() {
        var length = arguments.length, args = Array(length), index = length;
        while (index--) {
            args[index] = arguments[index];
        }
        if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
        }
        var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
        length = args.length;
        if (argPos) {
            args = reorder(args, argPos);
        }
        else if (isFlip && length > 1) {
            args.reverse();
        }
        if (isAry && ary < length) {
            args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
    }
    return wrapper;
}
function createCurry(func, bitmask, arity) {
    var Ctor = createCtor(func);
    function wrapper() {
        var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
        while (index--) {
            args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
            ? []
            : replaceHolders(args, placeholder);
        length -= holders.length;
        if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
    }
    return wrapper;
}
var WRAP_BIND_FLAG$4 = 1;
function createPartial(func, bitmask, thisArg, partials) {
    var isBind = bitmask & WRAP_BIND_FLAG$4, Ctor = createCtor(func);
    function wrapper() {
        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
    }
    return wrapper;
}
var PLACEHOLDER = '__lodash_placeholder__';
var WRAP_BIND_FLAG$3 = 1, WRAP_BIND_KEY_FLAG$3 = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG$3 = 8, WRAP_ARY_FLAG$2 = 128, WRAP_REARG_FLAG$2 = 256;
var nativeMin$d = Math.min;
function mergeData(data, source) {
    var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG$3 | WRAP_BIND_KEY_FLAG$3 | WRAP_ARY_FLAG$2);
    var isCombo = ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_CURRY_FLAG$3)) ||
        ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_REARG_FLAG$2) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$2)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG$3));
    if (!(isCommon || isCombo)) {
        return data;
    }
    if (srcBitmask & WRAP_BIND_FLAG$3) {
        data[2] = source[2];
        newBitmask |= bitmask & WRAP_BIND_FLAG$3 ? 0 : WRAP_CURRY_BOUND_FLAG;
    }
    var value = source[3];
    if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
    }
    value = source[5];
    if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
    }
    value = source[7];
    if (value) {
        data[7] = value;
    }
    if (srcBitmask & WRAP_ARY_FLAG$2) {
        data[8] = data[8] == null ? source[8] : nativeMin$d(data[8], source[8]);
    }
    if (data[9] == null) {
        data[9] = source[9];
    }
    data[0] = source[0];
    data[1] = newBitmask;
    return data;
}
var FUNC_ERROR_TEXT$a = 'Expected a function';
var WRAP_BIND_FLAG$2 = 1, WRAP_BIND_KEY_FLAG$2 = 2, WRAP_CURRY_FLAG$2 = 8, WRAP_CURRY_RIGHT_FLAG$1 = 16, WRAP_PARTIAL_FLAG$4 = 32, WRAP_PARTIAL_RIGHT_FLAG$1 = 64;
var nativeMax$e = Math.max;
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
    var isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2;
    if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$a);
    }
    var length = partials ? partials.length : 0;
    if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG$4 | WRAP_PARTIAL_RIGHT_FLAG$1);
        partials = holders = undefined;
    }
    ary = ary === undefined ? ary : nativeMax$e(toInteger(ary), 0);
    arity = arity === undefined ? arity : toInteger(arity);
    length -= holders ? holders.length : 0;
    if (bitmask & WRAP_PARTIAL_RIGHT_FLAG$1) {
        var partialsRight = partials, holdersRight = holders;
        partials = holders = undefined;
    }
    var data = isBindKey ? undefined : getData(func);
    var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
    ];
    if (data) {
        mergeData(newData, data);
    }
    func = newData[0];
    bitmask = newData[1];
    thisArg = newData[2];
    partials = newData[3];
    holders = newData[4];
    arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax$e(newData[9] - length, 0);
    if (!arity && bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1)) {
        bitmask &= ~(WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1);
    }
    if (!bitmask || bitmask == WRAP_BIND_FLAG$2) {
        var result = createBind(func, bitmask, thisArg);
    }
    else if (bitmask == WRAP_CURRY_FLAG$2 || bitmask == WRAP_CURRY_RIGHT_FLAG$1) {
        result = createCurry(func, bitmask, arity);
    }
    else if ((bitmask == WRAP_PARTIAL_FLAG$4 || bitmask == (WRAP_BIND_FLAG$2 | WRAP_PARTIAL_FLAG$4)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
    }
    else {
        result = createHybrid.apply(undefined, newData);
    }
    var setter = data ? baseSetData : setData;
    return setWrapToString(setter(result, newData), func, bitmask);
}
var WRAP_ARY_FLAG$1 = 128;
function ary(func, n, guard) {
    n = guard ? undefined : n;
    n = (func && n == null) ? func.length : n;
    return createWrap(func, WRAP_ARY_FLAG$1, undefined, undefined, undefined, undefined, n);
}
function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
            'configurable': true,
            'enumerable': true,
            'value': value,
            'writable': true
        });
    }
    else {
        object[key] = value;
    }
}
function eq(value, other) {
    return value === other || (value !== value && other !== other);
}
var objectProto$n = Object.prototype;
var hasOwnProperty$k = objectProto$n.hasOwnProperty;
function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$k.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
    }
}
function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
        var key = props[index];
        var newValue = customizer
            ? customizer(object[key], source[key], key, object, source)
            : undefined;
        if (newValue === undefined) {
            newValue = source[key];
        }
        if (isNew) {
            baseAssignValue(object, key, newValue);
        }
        else {
            assignValue(object, key, newValue);
        }
    }
    return object;
}
var nativeMax$d = Math.max;
function overRest(func, start, transform) {
    start = nativeMax$d(start === undefined ? (func.length - 1) : start, 0);
    return function () {
        var args = arguments, index = -1, length = nativeMax$d(args.length - start, 0), array = Array(length);
        while (++index < length) {
            array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
            otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
    };
}
function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + '');
}
var MAX_SAFE_INTEGER$4 = 9007199254740991;
function isLength(value) {
    return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$4;
}
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
        return false;
    }
    var type = typeof index;
    if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)) {
        return eq(object[index], value);
    }
    return false;
}
function createAssigner(assigner) {
    return baseRest(function (object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
        customizer = (assigner.length > 3 && typeof customizer == 'function')
            ? (length--, customizer)
            : undefined;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined : customizer;
            length = 1;
        }
        object = Object(object);
        while (++index < length) {
            var source = sources[index];
            if (source) {
                assigner(object, source, index, customizer);
            }
        }
        return object;
    });
}
var objectProto$m = Object.prototype;
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$m;
    return value === proto;
}
function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
        result[index] = iteratee(index);
    }
    return result;
}
var argsTag$3 = '[object Arguments]';
function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}
var objectProto$l = Object.prototype;
var hasOwnProperty$j = objectProto$l.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$l.propertyIsEnumerable;
var isArguments = baseIsArguments(function () { return arguments; }()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty$j.call(value, 'callee') &&
        !propertyIsEnumerable$1.call(value, 'callee');
};
function stubFalse() {
    return false;
}
var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root.Buffer : undefined;
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : undefined;
var isBuffer = nativeIsBuffer || stubFalse;
var argsTag$2 = '[object Arguments]', arrayTag$2 = '[object Array]', boolTag$4 = '[object Boolean]', dateTag$4 = '[object Date]', errorTag$3 = '[object Error]', funcTag$1 = '[object Function]', mapTag$9 = '[object Map]', numberTag$4 = '[object Number]', objectTag$4 = '[object Object]', regexpTag$4 = '[object RegExp]', setTag$9 = '[object Set]', stringTag$4 = '[object String]', weakMapTag$3 = '[object WeakMap]';
var arrayBufferTag$4 = '[object ArrayBuffer]', dataViewTag$4 = '[object DataView]', float32Tag$2 = '[object Float32Array]', float64Tag$2 = '[object Float64Array]', int8Tag$2 = '[object Int8Array]', int16Tag$2 = '[object Int16Array]', int32Tag$2 = '[object Int32Array]', uint8Tag$2 = '[object Uint8Array]', uint8ClampedTag$2 = '[object Uint8ClampedArray]', uint16Tag$2 = '[object Uint16Array]', uint32Tag$2 = '[object Uint32Array]';
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
    typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
        typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
            typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
                typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
    typedArrayTags[arrayBufferTag$4] = typedArrayTags[boolTag$4] =
        typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$4] =
            typedArrayTags[errorTag$3] = typedArrayTags[funcTag$1] =
                typedArrayTags[mapTag$9] = typedArrayTags[numberTag$4] =
                    typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$4] =
                        typedArrayTags[setTag$9] = typedArrayTags[stringTag$4] =
                            typedArrayTags[weakMapTag$3] = false;
function baseIsTypedArray(value) {
    return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
    return function (value) {
        return func(value);
    };
}
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal.process;
var nodeUtil = (function () {
    try {
        var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;
        if (types) {
            return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
    }
    catch (e) { }
}());
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var objectProto$k = Object.prototype;
var hasOwnProperty$i = objectProto$k.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
        if ((inherited || hasOwnProperty$i.call(value, key)) &&
            !(skipIndexes && (key == 'length' ||
                (isBuff && (key == 'offset' || key == 'parent')) ||
                (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
function overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
var nativeKeys = overArg(Object.keys, Object);
var objectProto$j = Object.prototype;
var hasOwnProperty$h = objectProto$j.hasOwnProperty;
function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
        if (hasOwnProperty$h.call(object, key) && key != 'constructor') {
            result.push(key);
        }
    }
    return result;
}
function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var objectProto$i = Object.prototype;
var hasOwnProperty$g = objectProto$i.hasOwnProperty;
var assign = createAssigner(function (object, source) {
    if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
    }
    for (var key in source) {
        if (hasOwnProperty$g.call(source, key)) {
            assignValue(object, key, source[key]);
        }
    }
});
function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
        for (var key in Object(object)) {
            result.push(key);
        }
    }
    return result;
}
var objectProto$h = Object.prototype;
var hasOwnProperty$f = objectProto$h.hasOwnProperty;
function baseKeysIn(object) {
    if (!isObject(object)) {
        return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty$f.call(object, key)))) {
            result.push(key);
        }
    }
    return result;
}
function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var assignIn = createAssigner(function (object, source) {
    copyObject(source, keysIn(source), object);
});
var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object, customizer);
});
var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
    copyObject(source, keys(source), object, customizer);
});
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
    if (isArray(value)) {
        return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
}
var nativeCreate = getNative(Object, 'create');
function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
}
function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
var objectProto$g = Object.prototype;
var hasOwnProperty$e = objectProto$g.hasOwnProperty;
function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? undefined : result;
    }
    return hasOwnProperty$e.call(data, key) ? data[key] : undefined;
}
var objectProto$f = Object.prototype;
var hasOwnProperty$d = objectProto$f.hasOwnProperty;
function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$d.call(data, key);
}
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
    return this;
}
function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
}
function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
var arrayProto$5 = Array.prototype;
var splice$2 = arrayProto$5.splice;
function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    }
    else {
        splice$2.call(data, index, 1);
    }
    --this.size;
    return true;
}
function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        ++this.size;
        data.push([key, value]);
    }
    else {
        data[index][1] = value;
    }
    return this;
}
function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, 'Map');
function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map$1 || ListCache),
        'string': new Hash
    };
}
function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
}
function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
}
function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
}
function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$9 = 'Expected a function';
function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT$9);
    }
    var memoized = function () {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
    var result = memoize(func, function (key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
        }
        return key;
    });
    var cache = result.cache;
    return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function (string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
        result.push('');
    }
    string.replace(rePropName, function (match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
});
function toString(value) {
    return value == null ? '' : baseToString(value);
}
function castPath(value, object) {
    if (isArray(value)) {
        return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
}
var INFINITY$3 = 1 / 0;
function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
        return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$3) ? '-0' : result;
}
function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0, length = path.length;
    while (object != null && index < length) {
        object = object[toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
}
function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
}
function baseAt(object, paths) {
    var index = -1, length = paths.length, result = Array(length), skip = object == null;
    while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
    }
    return result;
}
function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
        array[offset + index] = values[index];
    }
    return array;
}
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;
function isFlattenable(value) {
    return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result);
            }
            else {
                arrayPush(result, value);
            }
        }
        else if (!isStrict) {
            result[result.length] = value;
        }
    }
    return result;
}
function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
}
function flatRest(func) {
    return setToString(overRest(func, undefined, flatten), func + '');
}
var at = flatRest(baseAt);
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectTag$3 = '[object Object]';
var funcProto = Function.prototype, objectProto$e = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$c = objectProto$e.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
        return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = hasOwnProperty$c.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
}
var domExcTag = '[object DOMException]', errorTag$2 = '[object Error]';
function isError(value) {
    if (!isObjectLike(value)) {
        return false;
    }
    var tag = baseGetTag(value);
    return tag == errorTag$2 || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
}
var attempt = baseRest(function (func, args) {
    try {
        return apply(func, undefined, args);
    }
    catch (e) {
        return isError(e) ? e : new Error(e);
    }
});
var FUNC_ERROR_TEXT$8 = 'Expected a function';
function before(n, func) {
    var result;
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$8);
    }
    n = toInteger(n);
    return function () {
        if (--n > 0) {
            result = func.apply(this, arguments);
        }
        if (n <= 1) {
            func = undefined;
        }
        return result;
    };
}
var WRAP_BIND_FLAG$1 = 1, WRAP_PARTIAL_FLAG$3 = 32;
var bind = baseRest(function (func, thisArg, partials) {
    var bitmask = WRAP_BIND_FLAG$1;
    if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG$3;
    }
    return createWrap(func, bitmask, thisArg, partials, holders);
});
bind.placeholder = {};
var bindAll = flatRest(function (object, methodNames) {
    arrayEach(methodNames, function (key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
    });
    return object;
});
var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG$1 = 2, WRAP_PARTIAL_FLAG$2 = 32;
var bindKey = baseRest(function (object, key, partials) {
    var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG$1;
    if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG$2;
    }
    return createWrap(key, bitmask, object, partials, holders);
});
bindKey.placeholder = {};
function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) {
        start = -start > length ? 0 : (length + start);
    }
    end = end > length ? length : end;
    if (end < 0) {
        end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
        result[index] = array[index + start];
    }
    return result;
}
function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return (!start && end >= length) ? array : baseSlice(array, start, end);
}
var rsAstralRange$3 = '\\ud800-\\udfff', rsComboMarksRange$4 = '\\u0300-\\u036f', reComboHalfMarksRange$4 = '\\ufe20-\\ufe2f', rsComboSymbolsRange$4 = '\\u20d0-\\u20ff', rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4, rsVarRange$3 = '\\ufe0e\\ufe0f';
var rsZWJ$3 = '\\u200d';
var reHasUnicode = RegExp('[' + rsZWJ$3 + rsAstralRange$3 + rsComboRange$4 + rsVarRange$3 + ']');
function hasUnicode(string) {
    return reHasUnicode.test(string);
}
function asciiToArray(string) {
    return string.split('');
}
var rsAstralRange$2 = '\\ud800-\\udfff', rsComboMarksRange$3 = '\\u0300-\\u036f', reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f', rsComboSymbolsRange$3 = '\\u20d0-\\u20ff', rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = '\\ufe0e\\ufe0f';
var rsAstral$1 = '[' + rsAstralRange$2 + ']', rsCombo$3 = '[' + rsComboRange$3 + ']', rsFitz$2 = '\\ud83c[\\udffb-\\udfff]', rsModifier$2 = '(?:' + rsCombo$3 + '|' + rsFitz$2 + ')', rsNonAstral$2 = '[^' + rsAstralRange$2 + ']', rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsZWJ$2 = '\\u200d';
var reOptMod$2 = rsModifier$2 + '?', rsOptVar$2 = '[' + rsVarRange$2 + ']?', rsOptJoin$2 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*', rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2, rsSymbol$1 = '(?:' + [rsNonAstral$2 + rsCombo$3 + '?', rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join('|') + ')';
var reUnicode$1 = RegExp(rsFitz$2 + '(?=' + rsFitz$2 + ')|' + rsSymbol$1 + rsSeq$2, 'g');
function unicodeToArray(string) {
    return string.match(reUnicode$1) || [];
}
function stringToArray(string) {
    return hasUnicode(string)
        ? unicodeToArray(string)
        : asciiToArray(string);
}
function createCaseFirst(methodName) {
    return function (string) {
        string = toString(string);
        var strSymbols = hasUnicode(string)
            ? stringToArray(string)
            : undefined;
        var chr = strSymbols
            ? strSymbols[0]
            : string.charAt(0);
        var trailing = strSymbols
            ? castSlice(strSymbols, 1).join('')
            : string.slice(1);
        return chr[methodName]() + trailing;
    };
}
var upperFirst = createCaseFirst('toUpperCase');
function capitalize(string) {
    return upperFirst(toString(string).toLowerCase());
}
function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array == null ? 0 : array.length;
    if (initAccum && length) {
        accumulator = array[++index];
    }
    while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
}
function basePropertyOf(object) {
    return function (key) {
        return object == null ? undefined : object[key];
    };
}
var deburredLetters = {
    '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C', '\xe7': 'c',
    '\xd0': 'D', '\xf0': 'd',
    '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N', '\xf1': 'n',
    '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    '\u0100': 'A', '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a', '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C', '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c', '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D', '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E', '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e', '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G', '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g', '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H', '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I', '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i', '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J', '\u0135': 'j',
    '\u0136': 'K', '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L', '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l', '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N', '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n', '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O', '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o', '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R', '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r', '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S', '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's', '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T', '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't', '\u0165': 't', '\u0167': 't',
    '\u0168': 'U', '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u', '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W', '\u0175': 'w',
    '\u0176': 'Y', '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z', '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z', '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
};
var deburrLetter = basePropertyOf(deburredLetters);
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$2 = '\\u0300-\\u036f', reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f', rsComboSymbolsRange$2 = '\\u20d0-\\u20ff', rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
var rsCombo$2 = '[' + rsComboRange$2 + ']';
var reComboMark = RegExp(rsCombo$2, 'g');
function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string) {
    return string.match(reAsciiWord) || [];
}
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
}
var rsAstralRange$1 = '\\ud800-\\udfff', rsComboMarksRange$1 = '\\u0300-\\u036f', reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f', rsComboSymbolsRange$1 = '\\u20d0-\\u20ff', rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsDingbatRange = '\\u2700-\\u27bf', rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff', rsMathOpRange = '\\xac\\xb1\\xd7\\xf7', rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf', rsPunctuationRange = '\\u2000-\\u206f', rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000', rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde', rsVarRange$1 = '\\ufe0e\\ufe0f', rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['\u2019]", rsBreak = '[' + rsBreakRange + ']', rsCombo$1 = '[' + rsComboRange$1 + ']', rsDigits = '\\d+', rsDingbat = '[' + rsDingbatRange + ']', rsLower = '[' + rsLowerRange + ']', rsMisc = '[^' + rsAstralRange$1 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']', rsFitz$1 = '\\ud83c[\\udffb-\\udfff]', rsModifier$1 = '(?:' + rsCombo$1 + '|' + rsFitz$1 + ')', rsNonAstral$1 = '[^' + rsAstralRange$1 + ']', rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsUpper = '[' + rsUpperRange + ']', rsZWJ$1 = '\\u200d';
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')', rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')', rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?', rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?', reOptMod$1 = rsModifier$1 + '?', rsOptVar$1 = '[' + rsVarRange$1 + ']?', rsOptJoin$1 = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*', rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])', rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])', rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsEmoji = '(?:' + [rsDingbat, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsSeq$1;
var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
].join('|'), 'g');
function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
}
function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? undefined : pattern;
    if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
}
var rsApos = "['\u2019]";
var reApos = RegExp(rsApos, 'g');
function createCompounder(callback) {
    return function (string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
    };
}
var camelCase = createCompounder(function (result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
});
function castArray() {
    if (!arguments.length) {
        return [];
    }
    var value = arguments[0];
    return isArray(value) ? value : [value];
}
var nativeIsFinite$1 = root.isFinite, nativeMin$c = Math.min;
function createRound(methodName) {
    var func = Math[methodName];
    return function (number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin$c(toInteger(precision), 292);
        if (precision && nativeIsFinite$1(number)) {
            var pair = (toString(number) + 'e').split('e'), value = func(pair[0] + 'e' + (+pair[1] + precision));
            pair = (toString(value) + 'e').split('e');
            return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
    };
}
var ceil = createRound('ceil');
function chain(value) {
    var result = lodash(value);
    result.__chain__ = true;
    return result;
}
var nativeCeil$3 = Math.ceil, nativeMax$c = Math.max;
function chunk(array, size, guard) {
    if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
    }
    else {
        size = nativeMax$c(toInteger(size), 0);
    }
    var length = array == null ? 0 : array.length;
    if (!length || size < 1) {
        return [];
    }
    var index = 0, resIndex = 0, result = Array(nativeCeil$3(length / size));
    while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
    }
    return result;
}
function baseClamp(number, lower, upper) {
    if (number === number) {
        if (upper !== undefined) {
            number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
            number = number >= lower ? number : lower;
        }
    }
    return number;
}
function clamp(number, lower, upper) {
    if (upper === undefined) {
        upper = lower;
        lower = undefined;
    }
    if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
    }
    if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
    }
    return baseClamp(toNumber(number), lower, upper);
}
function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
}
function stackDelete(key) {
    var data = this.__data__, result = data['delete'](key);
    this.size = data.size;
    return result;
}
function stackGet(key) {
    return this.__data__.get(key);
}
function stackHas(key) {
    return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE$2 = 200;
function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE$2 - 1)) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
        }
        data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
}
function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
}
function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
}
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer$1 = moduleExports ? root.Buffer : undefined, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;
function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
        return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
}
function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
            result[resIndex++] = value;
        }
    }
    return result;
}
function stubArray() {
    return [];
}
var objectProto$d = Object.prototype;
var propertyIsEnumerable = objectProto$d.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function (object) {
    if (object == null) {
        return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols$1(object), function (symbol) {
        return propertyIsEnumerable.call(object, symbol);
    });
};
function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
    var result = [];
    while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
    }
    return result;
};
function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
}
var DataView = getNative(root, 'DataView');
var Promise$1 = getNative(root, 'Promise');
var Set$1 = getNative(root, 'Set');
var mapTag$8 = '[object Map]', objectTag$2 = '[object Object]', promiseTag = '[object Promise]', setTag$8 = '[object Set]', weakMapTag$2 = '[object WeakMap]';
var dataViewTag$3 = '[object DataView]';
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap);
var getTag = baseGetTag;
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3) ||
    (Map$1 && getTag(new Map$1) != mapTag$8) ||
    (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
    (Set$1 && getTag(new Set$1) != setTag$8) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag$2)) {
    getTag = function (value) {
        var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : '';
        if (ctorString) {
            switch (ctorString) {
                case dataViewCtorString: return dataViewTag$3;
                case mapCtorString: return mapTag$8;
                case promiseCtorString: return promiseTag;
                case setCtorString: return setTag$8;
                case weakMapCtorString: return weakMapTag$2;
            }
        }
        return result;
    };
}
var getTag$1 = getTag;
var objectProto$c = Object.prototype;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
function initCloneArray(array) {
    var length = array.length, result = new array.constructor(length);
    if (length && typeof array[0] == 'string' && hasOwnProperty$b.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
    }
    return result;
}
var Uint8Array = root.Uint8Array;
function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
}
function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags$1 = /\w*$/;
function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags$1.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
}
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;
function cloneSymbol(symbol) {
    return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$3 = '[object Boolean]', dateTag$3 = '[object Date]', mapTag$7 = '[object Map]', numberTag$3 = '[object Number]', regexpTag$3 = '[object RegExp]', setTag$7 = '[object Set]', stringTag$3 = '[object String]', symbolTag$2 = '[object Symbol]';
var arrayBufferTag$3 = '[object ArrayBuffer]', dataViewTag$2 = '[object DataView]', float32Tag$1 = '[object Float32Array]', float64Tag$1 = '[object Float64Array]', int8Tag$1 = '[object Int8Array]', int16Tag$1 = '[object Int16Array]', int32Tag$1 = '[object Int32Array]', uint8Tag$1 = '[object Uint8Array]', uint8ClampedTag$1 = '[object Uint8ClampedArray]', uint16Tag$1 = '[object Uint16Array]', uint32Tag$1 = '[object Uint32Array]';
function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
        case arrayBufferTag$3:
            return cloneArrayBuffer(object);
        case boolTag$3:
        case dateTag$3:
            return new Ctor(+object);
        case dataViewTag$2:
            return cloneDataView(object, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
            return cloneTypedArray(object, isDeep);
        case mapTag$7:
            return new Ctor;
        case numberTag$3:
        case stringTag$3:
            return new Ctor(object);
        case regexpTag$3:
            return cloneRegExp(object);
        case setTag$7:
            return new Ctor;
        case symbolTag$2:
            return cloneSymbol(object);
    }
}
function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
}
var mapTag$6 = '[object Map]';
function baseIsMap(value) {
    return isObjectLike(value) && getTag$1(value) == mapTag$6;
}
var nodeIsMap = nodeUtil && nodeUtil.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var setTag$6 = '[object Set]';
function baseIsSet(value) {
    return isObjectLike(value) && getTag$1(value) == setTag$6;
}
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var CLONE_DEEP_FLAG$7 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$5 = 4;
var argsTag$1 = '[object Arguments]', arrayTag$1 = '[object Array]', boolTag$2 = '[object Boolean]', dateTag$2 = '[object Date]', errorTag$1 = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag$5 = '[object Map]', numberTag$2 = '[object Number]', objectTag$1 = '[object Object]', regexpTag$2 = '[object RegExp]', setTag$5 = '[object Set]', stringTag$2 = '[object String]', symbolTag$1 = '[object Symbol]', weakMapTag$1 = '[object WeakMap]';
var arrayBufferTag$2 = '[object ArrayBuffer]', dataViewTag$1 = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] =
    cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$1] =
        cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
            cloneableTags[float32Tag] = cloneableTags[float64Tag] =
                cloneableTags[int8Tag] = cloneableTags[int16Tag] =
                    cloneableTags[int32Tag] = cloneableTags[mapTag$5] =
                        cloneableTags[numberTag$2] = cloneableTags[objectTag$1] =
                            cloneableTags[regexpTag$2] = cloneableTags[setTag$5] =
                                cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] =
                                    cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                                        cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] =
    cloneableTags[weakMapTag$1] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG$7, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$5;
    if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
        return result;
    }
    if (!isObject(value)) {
        return value;
    }
    var isArr = isArray(value);
    if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
            return copyArray(value, result);
        }
    }
    else {
        var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag$1 || tag == argsTag$1 || (isFunc && !object)) {
            result = (isFlat || isFunc) ? {} : initCloneObject(value);
            if (!isDeep) {
                return isFlat
                    ? copySymbolsIn(value, baseAssignIn(result, value))
                    : copySymbols(value, baseAssign(result, value));
            }
        }
        else {
            if (!cloneableTags[tag]) {
                return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
        }
    }
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) {
        return stacked;
    }
    stack.set(value, result);
    if (isSet(value)) {
        value.forEach(function (subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
    }
    else if (isMap(value)) {
        value.forEach(function (subValue, key) {
            result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
    }
    var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);
    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function (subValue, key) {
        if (props) {
            key = subValue;
            subValue = value[key];
        }
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
}
var CLONE_SYMBOLS_FLAG$4 = 4;
function clone(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG$4);
}
var CLONE_DEEP_FLAG$6 = 1, CLONE_SYMBOLS_FLAG$3 = 4;
function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG$6 | CLONE_SYMBOLS_FLAG$3);
}
var CLONE_DEEP_FLAG$5 = 1, CLONE_SYMBOLS_FLAG$2 = 4;
function cloneDeepWith(value, customizer) {
    customizer = typeof customizer == 'function' ? customizer : undefined;
    return baseClone(value, CLONE_DEEP_FLAG$5 | CLONE_SYMBOLS_FLAG$2, customizer);
}
var CLONE_SYMBOLS_FLAG$1 = 4;
function cloneWith(value, customizer) {
    customizer = typeof customizer == 'function' ? customizer : undefined;
    return baseClone(value, CLONE_SYMBOLS_FLAG$1, customizer);
}
function wrapperCommit() {
    return new LodashWrapper(this.value(), this.__chain__);
}
function compact(array) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
        var value = array[index];
        if (value) {
            result[resIndex++] = value;
        }
    }
    return result;
}
function concat() {
    var length = arguments.length;
    if (!length) {
        return [];
    }
    var args = Array(length - 1), array = arguments[0], index = length;
    while (index--) {
        args[index - 1] = arguments[index];
    }
    return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
}
var HASH_UNDEFINED = '__lodash_hash_undefined__';
function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
function setCacheHas(value) {
    return this.__data__.has(value);
}
function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while (++index < length) {
        this.add(values[index]);
    }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
        if (predicate(array[index], index, array)) {
            return true;
        }
    }
    return false;
}
function cacheHas(cache, key) {
    return cache.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
    }
    var index = -1, result = true, seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
            var compared = isPartial
                ? customizer(othValue, arrValue, index, other, array, stack)
                : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
            if (compared) {
                continue;
            }
            result = false;
            break;
        }
        if (seen) {
            if (!arraySome(other, function (othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                }
            })) {
                result = false;
                break;
            }
        }
        else if (!(arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
        }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
}
function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function (value, key) {
        result[++index] = [key, value];
    });
    return result;
}
function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
        result[++index] = value;
    });
    return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$1 = '[object Boolean]', dateTag$1 = '[object Date]', errorTag = '[object Error]', mapTag$4 = '[object Map]', numberTag$1 = '[object Number]', regexpTag$1 = '[object RegExp]', setTag$4 = '[object Set]', stringTag$1 = '[object String]', symbolTag = '[object Symbol]';
var arrayBufferTag$1 = '[object ArrayBuffer]', dataViewTag = '[object DataView]';
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
        case dataViewTag:
            if ((object.byteLength != other.byteLength) ||
                (object.byteOffset != other.byteOffset)) {
                return false;
            }
            object = object.buffer;
            other = other.buffer;
        case arrayBufferTag$1:
            if ((object.byteLength != other.byteLength) ||
                !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
            }
            return true;
        case boolTag$1:
        case dateTag$1:
        case numberTag$1:
            return eq(+object, +other);
        case errorTag:
            return object.name == other.name && object.message == other.message;
        case regexpTag$1:
        case stringTag$1:
            return object == (other + '');
        case mapTag$4:
            var convert = mapToArray;
        case setTag$4:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
                return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
                return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$2;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack['delete'](object);
            return result;
        case symbolTag:
            if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
    }
    return false;
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
        return false;
    }
    var index = objLength;
    while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
            return false;
        }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
            var compared = isPartial
                ? customizer(othValue, objValue, key, other, object, stack)
                : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                typeof othCtor == 'function' && othCtor instanceof othCtor)) {
            result = false;
        }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = '[object Arguments]', arrayTag = '[object Array]', objectTag = '[object Object]';
var objectProto$a = Object.prototype;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
            return false;
        }
        objIsArr = true;
        objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
            ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
            : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty$9.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty$9.call(other, '__wrapped__');
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
    }
    if (!isSameTag) {
        return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
        return true;
    }
    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
        return !length;
    }
    object = Object(object);
    while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
            ? data[1] !== object[data[0]]
            : !(data[0] in object)) {
            return false;
        }
    }
    while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) {
                return false;
            }
        }
        else {
            var stack = new Stack;
            if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
                : result)) {
                return false;
            }
        }
    }
    return true;
}
function isStrictComparable(value) {
    return value === value && !isObject(value);
}
function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
}
function matchesStrictComparable(key, srcValue) {
    return function (object) {
        if (object == null) {
            return false;
        }
        return object[key] === srcValue &&
            (srcValue !== undefined || (key in Object(object)));
    };
}
function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function (object) {
        return object === source || baseIsMatch(object, source, matchData);
    };
}
function baseHasIn(object, key) {
    return object != null && key in Object(object);
}
function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1, length = path.length, result = false;
    while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
            break;
        }
        object = object[key];
    }
    if (result || ++index != length) {
        return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
}
function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
    }
    return function (object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
            ? hasIn(object, path)
            : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
}
function baseProperty(key) {
    return function (object) {
        return object == null ? undefined : object[key];
    };
}
function basePropertyDeep(path) {
    return function (object) {
        return baseGet(object, path);
    };
}
function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
    if (typeof value == 'function') {
        return value;
    }
    if (value == null) {
        return identity;
    }
    if (typeof value == 'object') {
        return isArray(value)
            ? baseMatchesProperty(value[0], value[1])
            : baseMatches(value);
    }
    return property(value);
}
var FUNC_ERROR_TEXT$7 = 'Expected a function';
function cond(pairs) {
    var length = pairs == null ? 0 : pairs.length, toIteratee = baseIteratee;
    pairs = !length ? [] : arrayMap(pairs, function (pair) {
        if (typeof pair[1] != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT$7);
        }
        return [toIteratee(pair[0]), pair[1]];
    });
    return baseRest(function (args) {
        var index = -1;
        while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
            }
        }
    });
}
function baseConformsTo(object, source, props) {
    var length = props.length;
    if (object == null) {
        return !length;
    }
    object = Object(object);
    while (length--) {
        var key = props[length], predicate = source[key], value = object[key];
        if ((value === undefined && !(key in object)) || !predicate(value)) {
            return false;
        }
    }
    return true;
}
function baseConforms(source) {
    var props = keys(source);
    return function (object) {
        return baseConformsTo(object, source, props);
    };
}
var CLONE_DEEP_FLAG$4 = 1;
function conforms(source) {
    return baseConforms(baseClone(source, CLONE_DEEP_FLAG$4));
}
function conformsTo(object, source) {
    return source == null || baseConformsTo(object, source, keys(source));
}
function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
}
function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
                break;
            }
        }
        return object;
    };
}
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
}
function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
        if (collection == null) {
            return collection;
        }
        if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while ((fromRight ? index-- : ++index < length)) {
            if (iteratee(iterable[index], index, iterable) === false) {
                break;
            }
        }
        return collection;
    };
}
var baseEach = createBaseEach(baseForOwn);
function baseAggregator(collection, setter, iteratee, accumulator) {
    baseEach(collection, function (value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
    });
    return accumulator;
}
function createAggregator(setter, initializer) {
    return function (collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee), accumulator);
    };
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
var countBy = createAggregator(function (result, value, key) {
    if (hasOwnProperty$8.call(result, key)) {
        ++result[key];
    }
    else {
        baseAssignValue(result, key, 1);
    }
});
function create(prototype, properties) {
    var result = baseCreate(prototype);
    return properties == null ? result : baseAssign(result, properties);
}
var WRAP_CURRY_FLAG$1 = 8;
function curry(func, arity, guard) {
    arity = guard ? undefined : arity;
    var result = createWrap(func, WRAP_CURRY_FLAG$1, undefined, undefined, undefined, undefined, undefined, arity);
    result.placeholder = curry.placeholder;
    return result;
}
curry.placeholder = {};
var WRAP_CURRY_RIGHT_FLAG = 16;
function curryRight(func, arity, guard) {
    arity = guard ? undefined : arity;
    var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
    result.placeholder = curryRight.placeholder;
    return result;
}
curryRight.placeholder = {};
var now = function () {
    return root.Date.now();
};
var FUNC_ERROR_TEXT$6 = 'Expected a function';
var nativeMax$b = Math.max, nativeMin$b = Math.min;
function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$6);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax$b(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing
            ? nativeMin$b(timeWaiting, maxWait - timeSinceLastInvoke)
            : timeWaiting;
    }
    function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
            (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }
    function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
            return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        if (trailing && lastArgs) {
            return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
    }
    function cancel() {
        if (timerId !== undefined) {
            clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
        return timerId === undefined ? result : trailingEdge(now());
    }
    function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) {
                return leadingEdge(lastCallTime);
            }
            if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
        }
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
}
function defaultTo(value, defaultValue) {
    return (value == null || value !== value) ? defaultValue : value;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var defaults = baseRest(function (object, sources) {
    object = Object(object);
    var index = -1;
    var length = sources.length;
    var guard = length > 2 ? sources[2] : undefined;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
    }
    while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined ||
                (eq(value, objectProto$8[key]) && !hasOwnProperty$7.call(object, key))) {
                object[key] = source[key];
            }
        }
    }
    return object;
});
function assignMergeValue(object, key, value) {
    if ((value !== undefined && !eq(object[key], value)) ||
        (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
    }
}
function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
function safeGet(object, key) {
    if (key === 'constructor' && typeof object[key] === 'function') {
        return;
    }
    if (key == '__proto__') {
        return;
    }
    return object[key];
}
function toPlainObject(value) {
    return copyObject(value, keysIn(value));
}
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
    if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
    }
    var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;
    var isCommon = newValue === undefined;
    if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
                newValue = objValue;
            }
            else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
            }
            else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
            }
            else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
            }
            else {
                newValue = [];
            }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
            }
            else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
            }
        }
        else {
            isCommon = false;
        }
    }
    if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
    }
    assignMergeValue(object, key, newValue);
}
function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
        return;
    }
    baseFor(source, function (srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
            var newValue = customizer
                ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
                : undefined;
            if (newValue === undefined) {
                newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
        }
    }, keysIn);
}
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
    if (isObject(objValue) && isObject(srcValue)) {
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
    }
    return objValue;
}
var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
    baseMerge(object, source, srcIndex, customizer);
});
var defaultsDeep = baseRest(function (args) {
    args.push(undefined, customDefaultsMerge);
    return apply(mergeWith, undefined, args);
});
var FUNC_ERROR_TEXT$5 = 'Expected a function';
function baseDelay(func, wait, args) {
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$5);
    }
    return setTimeout(function () { func.apply(undefined, args); }, wait);
}
var defer = baseRest(function (func, args) {
    return baseDelay(func, 1, args);
});
var delay = baseRest(function (func, wait, args) {
    return baseDelay(func, toNumber(wait) || 0, args);
});
function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
        if (comparator(value, array[index])) {
            return true;
        }
    }
    return false;
}
var LARGE_ARRAY_SIZE$1 = 200;
function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) {
        return result;
    }
    if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
    }
    if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
    }
    else if (values.length >= LARGE_ARRAY_SIZE$1) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
    }
    outer: while (++index < length) {
        var value = array[index], computed = iteratee == null ? value : iteratee(value);
        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
                if (values[valuesIndex] === computed) {
                    continue outer;
                }
            }
            result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
            result.push(value);
        }
    }
    return result;
}
var difference = baseRest(function (array, values) {
    return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
});
function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
}
var differenceBy = baseRest(function (array, values) {
    var iteratee = last(values);
    if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
    }
    return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee))
        : [];
});
var differenceWith = baseRest(function (array, values) {
    var comparator = last(values);
    if (isArrayLikeObject(comparator)) {
        comparator = undefined;
    }
    return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
});
var divide = createMathOperation(function (dividend, divisor) {
    return dividend / divisor;
}, 1);
function drop(array, n, guard) {
    var length = array == null ? 0 : array.length;
    if (!length) {
        return [];
    }
    n = (guard || n === undefined) ? 1 : toInteger(n);
    return baseSlice(array, n < 0 ? 0 : n, length);
}
function dropRight(array, n, guard) {
    var length = array == null ? 0 : array.length;
    if (!length) {
        return [];
    }
    n = (guard || n === undefined) ? 1 : toInteger(n);
    n = length - n;
    return baseSlice(array, 0, n < 0 ? 0 : n);
}
function baseWhile(array, predicate, isDrop, fromRight) {
    var length = array.length, index = fromRight ? length : -1;
    while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) { }
    return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
}
function dropRightWhile(array, predicate) {
    return (array && array.length)
        ? baseWhile(array, baseIteratee(predicate), true, true)
        : [];
}
function dropWhile(array, predicate) {
    return (array && array.length)
        ? baseWhile(array, baseIteratee(predicate), true)
        : [];
}
function castFunction(value) {
    return typeof value == 'function' ? value : identity;
}
function forEach(collection, iteratee) {
    var func = isArray(collection) ? arrayEach : baseEach;
    return func(collection, castFunction(iteratee));
}
function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;
    while (length--) {
        if (iteratee(array[length], length, array) === false) {
            break;
        }
    }
    return array;
}
var baseForRight = createBaseFor(true);
function baseForOwnRight(object, iteratee) {
    return object && baseForRight(object, iteratee, keys);
}
var baseEachRight = createBaseEach(baseForOwnRight, true);
function forEachRight(collection, iteratee) {
    var func = isArray(collection) ? arrayEachRight : baseEachRight;
    return func(collection, castFunction(iteratee));
}
function endsWith(string, target, position) {
    string = toString(string);
    target = baseToString(target);
    var length = string.length;
    position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);
    var end = position;
    position -= target.length;
    return position >= 0 && string.slice(position, end) == target;
}
function baseToPairs(object, props) {
    return arrayMap(props, function (key) {
        return [key, object[key]];
    });
}
function setToPairs(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
        result[++index] = [value, value];
    });
    return result;
}
var mapTag$3 = '[object Map]', setTag$3 = '[object Set]';
function createToPairs(keysFunc) {
    return function (object) {
        var tag = getTag$1(object);
        if (tag == mapTag$3) {
            return mapToArray(object);
        }
        if (tag == setTag$3) {
            return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
    };
}
var toPairs = createToPairs(keys);
var toPairsIn = createToPairs(keysIn);
var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
};
var escapeHtmlChar = basePropertyOf(htmlEscapes);
var reUnescapedHtml = /[&<>"']/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape(string) {
    string = toString(string);
    return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
function escapeRegExp(string) {
    string = toString(string);
    return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
}
function arrayEvery(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
        if (!predicate(array[index], index, array)) {
            return false;
        }
    }
    return true;
}
function baseEvery(collection, predicate) {
    var result = true;
    baseEach(collection, function (value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
    });
    return result;
}
function every(collection, predicate, guard) {
    var func = isArray(collection) ? arrayEvery : baseEvery;
    if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
    }
    return func(collection, baseIteratee(predicate));
}
var MAX_ARRAY_LENGTH$5 = 4294967295;
function toLength(value) {
    return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH$5) : 0;
}
function baseFill(array, value, start, end) {
    var length = array.length;
    start = toInteger(start);
    if (start < 0) {
        start = -start > length ? 0 : (length + start);
    }
    end = (end === undefined || end > length) ? length : toInteger(end);
    if (end < 0) {
        end += length;
    }
    end = start > end ? 0 : toLength(end);
    while (start < end) {
        array[start++] = value;
    }
    return array;
}
function fill(array, value, start, end) {
    var length = array == null ? 0 : array.length;
    if (!length) {
        return [];
    }
    if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
    }
    return baseFill(array, value, start, end);
}
function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function (value, index, collection) {
        if (predicate(value, index, collection)) {
            result.push(value);
        }
    });
    return result;
}
function filter(collection, predicate) {
    var func = isArray(collection) ? arrayFilter : baseFilter;
    return func(collection, baseIteratee(predicate));
}
function createFind(findIndexFunc) {
    return function (collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
            var iteratee = baseIteratee(predicate);
            collection = keys(collection);
            predicate = function (key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
    };
}
var nativeMax$a = Math.max;
function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
        return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
        index = nativeMax$a(length + index, 0);
    }
    return baseFindIndex(array, baseIteratee(predicate), index);
}
var find = createFind(findIndex);
function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function (value, key, collection) {
        if (predicate(value, key, collection)) {
            result = key;
            return false;
        }
    });
    return result;
}
function findKey(object, predicate) {
    return baseFindKey(object, baseIteratee(predicate), baseForOwn);
}
var nativeMax$9 = Math.max, nativeMin$a = Math.min;
function findLastIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
        return -1;
    }
    var index = length - 1;
    if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
            ? nativeMax$9(length + index, 0)
            : nativeMin$a(index, length - 1);
    }
    return baseFindIndex(array, baseIteratee(predicate), index, true);
}
var findLast = createFind(findLastIndex);
function findLastKey(object, predicate) {
    return baseFindKey(object, baseIteratee(predicate), baseForOwnRight);
}
function head(array) {
    return (array && array.length) ? array[0] : undefined;
}
function baseMap(collection, iteratee) {
    var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function (value, key, collection) {
        result[++index] = iteratee(value, key, collection);
    });
    return result;
}
function map(collection, iteratee) {
    var func = isArray(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee));
}
function flatMap(collection, iteratee) {
    return baseFlatten(map(collection, iteratee), 1);
}
var INFINITY$2 = 1 / 0;
function flatMapDeep(collection, iteratee) {
    return baseFlatten(map(collection, iteratee), INFINITY$2);
}
function flatMapDepth(collection, iteratee, depth) {
    depth = depth === undefined ? 1 : toInteger(depth);
    return baseFlatten(map(collection, iteratee), depth);
}
var INFINITY$1 = 1 / 0;
function flattenDeep(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, INFINITY$1) : [];
}
function flattenDepth(array, depth) {
    var length = array == null ? 0 : array.length;
    if (!length) {
        return [];
    }
    depth = depth === undefined ? 1 : toInteger(depth);
    return baseFlatten(array, depth);
}
var WRAP_FLIP_FLAG = 512;
function flip(func) {
    return createWrap(func, WRAP_FLIP_FLAG);
}
var floor = createRound('floor');
var FUNC_ERROR_TEXT$4 = 'Expected a function';
var WRAP_CURRY_FLAG = 8, WRAP_PARTIAL_FLAG$1 = 32, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG$1 = 256;
function createFlow(fromRight) {
    return flatRest(function (funcs) {
        var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
        if (fromRight) {
            funcs.reverse();
        }
        while (index--) {
            var func = funcs[index];
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT$4);
            }
            if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                var wrapper = new LodashWrapper([], true);
            }
        }
        index = wrapper ? index : length;
        while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == 'wrapper' ? getData(func) : undefined;
            if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG$1 | WRAP_REARG_FLAG$1) &&
                !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            }
            else {
                wrapper = (func.length == 1 && isLaziable(func))
                    ? wrapper[funcName]()
                    : wrapper.thru(func);
            }
        }
        return function () {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
            }
            var index = 0, result = length ? funcs[index].apply(this, args) : value;
            while (++index < length) {
                result = funcs[index].call(this, result);
            }
            return result;
        };
    });
}
var flow = createFlow();
var flowRight = createFlow(true);
function forIn(object, iteratee) {
    return object == null
        ? object
        : baseFor(object, castFunction(iteratee), keysIn);
}
function forInRight(object, iteratee) {
    return object == null
        ? object
        : baseForRight(object, castFunction(iteratee), keysIn);
}
function forOwn(object, iteratee) {
    return object && baseForOwn(object, castFunction(iteratee));
}
function forOwnRight(object, iteratee) {
    return object && baseForOwnRight(object, castFunction(iteratee));
}
function fromPairs(pairs) {
    var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
    while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
    }
    return result;
}
function baseFunctions(object, props) {
    return arrayFilter(props, function (key) {
        return isFunction(object[key]);
    });
}
function functions(object) {
    return object == null ? [] : baseFunctions(object, keys(object));
}
function functionsIn(object) {
    return object == null ? [] : baseFunctions(object, keysIn(object));
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var groupBy = createAggregator(function (result, value, key) {
    if (hasOwnProperty$6.call(result, key)) {
        result[key].push(value);
    }
    else {
        baseAssignValue(result, key, [value]);
    }
});
function baseGt(value, other) {
    return value > other;
}
function createRelationalOperation(operator) {
    return function (value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
            value = toNumber(value);
            other = toNumber(other);
        }
        return operator(value, other);
    };
}
var gt = createRelationalOperation(baseGt);
var gte = createRelationalOperation(function (value, other) {
    return value >= other;
});
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function baseHas(object, key) {
    return object != null && hasOwnProperty$5.call(object, key);
}
function has(object, path) {
    return object != null && hasPath(object, path, baseHas);
}
var nativeMax$8 = Math.max, nativeMin$9 = Math.min;
function baseInRange(number, start, end) {
    return number >= nativeMin$9(start, end) && number < nativeMax$8(start, end);
}
function inRange(number, start, end) {
    start = toFinite(start);
    if (end === undefined) {
        end = start;
        start = 0;
    }
    else {
        end = toFinite(end);
    }
    number = toNumber(number);
    return baseInRange(number, start, end);
}
var stringTag = '[object String]';
function isString(value) {
    return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}
function baseValues(object, props) {
    return arrayMap(props, function (key) {
        return object[key];
    });
}
function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
}
var nativeMax$7 = Math.max;
function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
        fromIndex = nativeMax$7(length + fromIndex, 0);
    }
    return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}
var nativeMax$6 = Math.max;
function indexOf(array, value, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
        return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
        index = nativeMax$6(length + index, 0);
    }
    return baseIndexOf(array, value, index);
}
function initial(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseSlice(array, 0, -1) : [];
}
var nativeMin$8 = Math.min;
function baseIntersection(arrays, iteratee, comparator) {
    var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
    while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
            array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin$8(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
            ? new SetCache(othIndex && array)
            : undefined;
    }
    array = arrays[0];
    var index = -1, seen = caches[0];
    outer: while (++index < length && result.length < maxLength) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
            ? cacheHas(seen, computed)
            : includes(result, computed, comparator))) {
            othIndex = othLength;
            while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache
                    ? cacheHas(cache, computed)
                    : includes(arrays[othIndex], computed, comparator))) {
                    continue outer;
                }
            }
            if (seen) {
                seen.push(computed);
            }
            result.push(value);
        }
    }
    return result;
}
function castArrayLikeObject(value) {
    return isArrayLikeObject(value) ? value : [];
}
var intersection = baseRest(function (arrays) {
    var mapped = arrayMap(arrays, castArrayLikeObject);
    return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
});
var intersectionBy = baseRest(function (arrays) {
    var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
    if (iteratee === last(mapped)) {
        iteratee = undefined;
    }
    else {
        mapped.pop();
    }
    return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, baseIteratee(iteratee))
        : [];
});
var intersectionWith = baseRest(function (arrays) {
    var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
    comparator = typeof comparator == 'function' ? comparator : undefined;
    if (comparator) {
        mapped.pop();
    }
    return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
});
function baseInverter(object, setter, iteratee, accumulator) {
    baseForOwn(object, function (value, key, object) {
        setter(accumulator, iteratee(value), key, object);
    });
    return accumulator;
}
function createInverter(setter, toIteratee) {
    return function (object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
    };
}
var objectProto$5 = Object.prototype;
var nativeObjectToString$1 = objectProto$5.toString;
var invert = createInverter(function (result, value, key) {
    if (value != null &&
        typeof value.toString != 'function') {
        value = nativeObjectToString$1.call(value);
    }
    result[value] = key;
}, constant(identity));
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
var nativeObjectToString = objectProto$4.toString;
var invertBy = createInverter(function (result, value, key) {
    if (value != null &&
        typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
    }
    if (hasOwnProperty$4.call(result, value)) {
        result[value].push(key);
    }
    else {
        result[value] = [key];
    }
}, baseIteratee);
function parent$1(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}
function baseInvoke(object, path, args) {
    path = castPath(path, object);
    object = parent$1(object, path);
    var func = object == null ? object : object[toKey(last(path))];
    return func == null ? undefined : apply(func, object, args);
}
var invoke = baseRest(baseInvoke);
var invokeMap = baseRest(function (collection, path, args) {
    var index = -1, isFunc = typeof path == 'function', result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function (value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
    });
    return result;
});
var arrayBufferTag = '[object ArrayBuffer]';
function baseIsArrayBuffer(value) {
    return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
}
var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer;
var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
var boolTag = '[object Boolean]';
function isBoolean(value) {
    return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
}
var dateTag = '[object Date]';
function baseIsDate(value) {
    return isObjectLike(value) && baseGetTag(value) == dateTag;
}
var nodeIsDate = nodeUtil && nodeUtil.isDate;
var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
function isElement(value) {
    return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
}
var mapTag$2 = '[object Map]', setTag$2 = '[object Set]';
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function isEmpty(value) {
    if (value == null) {
        return true;
    }
    if (isArrayLike(value) &&
        (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
    }
    var tag = getTag$1(value);
    if (tag == mapTag$2 || tag == setTag$2) {
        return !value.size;
    }
    if (isPrototype(value)) {
        return !baseKeys(value).length;
    }
    for (var key in value) {
        if (hasOwnProperty$3.call(value, key)) {
            return false;
        }
    }
    return true;
}
function isEqual(value, other) {
    return baseIsEqual(value, other);
}
function isEqualWith(value, other, customizer) {
    customizer = typeof customizer == 'function' ? customizer : undefined;
    var result = customizer ? customizer(value, other) : undefined;
    return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
}
var nativeIsFinite = root.isFinite;
function isFinite$1(value) {
    return typeof value == 'number' && nativeIsFinite(value);
}
function isInteger(value) {
    return typeof value == 'number' && value == toInteger(value);
}
function isMatch(object, source) {
    return object === source || baseIsMatch(object, source, getMatchData(source));
}
function isMatchWith(object, source, customizer) {
    customizer = typeof customizer == 'function' ? customizer : undefined;
    return baseIsMatch(object, source, getMatchData(source), customizer);
}
var numberTag = '[object Number]';
function isNumber(value) {
    return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
}
function isNaN$1(value) {
    return isNumber(value) && value != +value;
}
var isMaskable = coreJsData ? isFunction : stubFalse;
var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.';
function isNative(value) {
    if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
    }
    return baseIsNative(value);
}
function isNil(value) {
    return value == null;
}
function isNull(value) {
    return value === null;
}
var regexpTag = '[object RegExp]';
function baseIsRegExp(value) {
    return isObjectLike(value) && baseGetTag(value) == regexpTag;
}
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
var MAX_SAFE_INTEGER$3 = 9007199254740991;
function isSafeInteger(value) {
    return isInteger(value) && value >= -MAX_SAFE_INTEGER$3 && value <= MAX_SAFE_INTEGER$3;
}
function isUndefined(value) {
    return value === undefined;
}
var weakMapTag = '[object WeakMap]';
function isWeakMap(value) {
    return isObjectLike(value) && getTag$1(value) == weakMapTag;
}
var weakSetTag = '[object WeakSet]';
function isWeakSet(value) {
    return isObjectLike(value) && baseGetTag(value) == weakSetTag;
}
var CLONE_DEEP_FLAG$3 = 1;
function iteratee(func) {
    return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG$3));
}
var arrayProto$4 = Array.prototype;
var nativeJoin = arrayProto$4.join;
function join(array, separator) {
    return array == null ? '' : nativeJoin.call(array, separator);
}
var kebabCase = createCompounder(function (result, word, index) {
    return result + (index ? '-' : '') + word.toLowerCase();
});
var keyBy = createAggregator(function (result, value, key) {
    baseAssignValue(result, key, value);
});
function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
        if (array[index] === value) {
            return index;
        }
    }
    return index;
}
var nativeMax$5 = Math.max, nativeMin$7 = Math.min;
function lastIndexOf(array, value, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
        return -1;
    }
    var index = length;
    if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax$5(length + index, 0) : nativeMin$7(index, length - 1);
    }
    return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
}
var lowerCase = createCompounder(function (result, word, index) {
    return result + (index ? ' ' : '') + word.toLowerCase();
});
var lowerFirst = createCaseFirst('toLowerCase');
function baseLt(value, other) {
    return value < other;
}
var lt = createRelationalOperation(baseLt);
var lte = createRelationalOperation(function (value, other) {
    return value <= other;
});
function mapKeys(object, iteratee) {
    var result = {};
    iteratee = baseIteratee(iteratee);
    baseForOwn(object, function (value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
    });
    return result;
}
function mapValues(object, iteratee) {
    var result = {};
    iteratee = baseIteratee(iteratee);
    baseForOwn(object, function (value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
    });
    return result;
}
var CLONE_DEEP_FLAG$2 = 1;
function matches(source) {
    return baseMatches(baseClone(source, CLONE_DEEP_FLAG$2));
}
var CLONE_DEEP_FLAG$1 = 1;
function matchesProperty(path, srcValue) {
    return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG$1));
}
function baseExtremum(array, iteratee, comparator) {
    var index = -1, length = array.length;
    while (++index < length) {
        var value = array[index], current = iteratee(value);
        if (current != null && (computed === undefined
            ? (current === current && !isSymbol(current))
            : comparator(current, computed))) {
            var computed = current, result = value;
        }
    }
    return result;
}
function max(array) {
    return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
}
function maxBy(array, iteratee) {
    return (array && array.length)
        ? baseExtremum(array, baseIteratee(iteratee), baseGt)
        : undefined;
}
function baseSum(array, iteratee) {
    var result, index = -1, length = array.length;
    while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined) {
            result = result === undefined ? current : (result + current);
        }
    }
    return result;
}
var NAN = 0 / 0;
function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
}
function mean(array) {
    return baseMean(array, identity);
}
function meanBy(array, iteratee) {
    return baseMean(array, baseIteratee(iteratee));
}
var merge = createAssigner(function (object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
});
var method = baseRest(function (path, args) {
    return function (object) {
        return baseInvoke(object, path, args);
    };
});
var methodOf = baseRest(function (object, args) {
    return function (path) {
        return baseInvoke(object, path, args);
    };
});
function min(array) {
    return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
}
function minBy(array, iteratee) {
    return (array && array.length)
        ? baseExtremum(array, baseIteratee(iteratee), baseLt)
        : undefined;
}
function mixin$1(object, source, options) {
    var props = keys(source), methodNames = baseFunctions(source, props);
    var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object);
    arrayEach(methodNames, function (methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
            object.prototype[methodName] = function () {
                var chainAll = this.__chain__;
                if (chain || chainAll) {
                    var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                    actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                    result.__chain__ = chainAll;
                    return result;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
            };
        }
    });
    return object;
}
var multiply = createMathOperation(function (multiplier, multiplicand) {
    return multiplier * multiplicand;
}, 1);
var FUNC_ERROR_TEXT$3 = 'Expected a function';
function negate(predicate) {
    if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$3);
    }
    return function () {
        var args = arguments;
        switch (args.length) {
            case 0: return !predicate.call(this);
            case 1: return !predicate.call(this, args[0]);
            case 2: return !predicate.call(this, args[0], args[1]);
            case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
    };
}
function iteratorToArray(iterator) {
    var data, result = [];
    while (!(data = iterator.next()).done) {
        result.push(data.value);
    }
    return result;
}
var mapTag$1 = '[object Map]', setTag$1 = '[object Set]';
var symIterator$1 = Symbol$1 ? Symbol$1.iterator : undefined;
function toArray(value) {
    if (!value) {
        return [];
    }
    if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
    }
    if (symIterator$1 && value[symIterator$1]) {
        return iteratorToArray(value[symIterator$1]());
    }
    var tag = getTag$1(value), func = tag == mapTag$1 ? mapToArray : (tag == setTag$1 ? setToArray : values);
    return func(value);
}
function wrapperNext() {
    if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
    }
    var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
    return { 'done': done, 'value': value };
}
function baseNth(array, n) {
    var length = array.length;
    if (!length) {
        return;
    }
    n += n < 0 ? length : 0;
    return isIndex(n, length) ? array[n] : undefined;
}
function nth(array, n) {
    return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
}
function nthArg(n) {
    n = toInteger(n);
    return baseRest(function (args) {
        return baseNth(args, n);
    });
}
function baseUnset(object, path) {
    path = castPath(path, object);
    object = parent$1(object, path);
    return object == null || delete object[toKey(last(path))];
}
function customOmitClone(value) {
    return isPlainObject(value) ? undefined : value;
}
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function (object, paths) {
    var result = {};
    if (object == null) {
        return result;
    }
    var isDeep = false;
    paths = arrayMap(paths, function (path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
    });
    copyObject(object, getAllKeysIn(object), result);
    if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
    }
    var length = paths.length;
    while (length--) {
        baseUnset(result, paths[length]);
    }
    return result;
});
function baseSet(object, path, value, customizer) {
    if (!isObject(object)) {
        return object;
    }
    path = castPath(path, object);
    var index = -1, length = path.length, lastIndex = length - 1, nested = object;
    while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
            return object;
        }
        if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined;
            if (newValue === undefined) {
                newValue = isObject(objValue)
                    ? objValue
                    : (isIndex(path[index + 1]) ? [] : {});
            }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
    }
    return object;
}
function basePickBy(object, paths, predicate) {
    var index = -1, length = paths.length, result = {};
    while (++index < length) {
        var path = paths[index], value = baseGet(object, path);
        if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
        }
    }
    return result;
}
function pickBy(object, predicate) {
    if (object == null) {
        return {};
    }
    var props = arrayMap(getAllKeysIn(object), function (prop) {
        return [prop];
    });
    predicate = baseIteratee(predicate);
    return basePickBy(object, props, function (value, path) {
        return predicate(value, path[0]);
    });
}
function omitBy(object, predicate) {
    return pickBy(object, negate(baseIteratee(predicate)));
}
function once(func) {
    return before(2, func);
}
function baseSortBy(array, comparer) {
    var length = array.length;
    array.sort(comparer);
    while (length--) {
        array[length] = array[length].value;
    }
    return array;
}
function compareAscending(value, other) {
    if (value !== other) {
        var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
            return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
            return -1;
        }
    }
    return 0;
}
function compareMultiple(object, other, orders) {
    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
    while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
            if (index >= ordersLength) {
                return result;
            }
            var order = orders[index];
            return result * (order == 'desc' ? -1 : 1);
        }
    }
    return object.index - other.index;
}
function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
        iteratees = arrayMap(iteratees, function (iteratee) {
            if (isArray(iteratee)) {
                return function (value) {
                    return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                };
            }
            return iteratee;
        });
    }
    else {
        iteratees = [identity];
    }
    var index = -1;
    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
    var result = baseMap(collection, function (value, key, collection) {
        var criteria = arrayMap(iteratees, function (iteratee) {
            return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
    });
    return baseSortBy(result, function (object, other) {
        return compareMultiple(object, other, orders);
    });
}
function orderBy(collection, iteratees, orders, guard) {
    if (collection == null) {
        return [];
    }
    if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
    }
    orders = guard ? undefined : orders;
    if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
    }
    return baseOrderBy(collection, iteratees, orders);
}
function createOver(arrayFunc) {
    return flatRest(function (iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
        return baseRest(function (args) {
            var thisArg = this;
            return arrayFunc(iteratees, function (iteratee) {
                return apply(iteratee, thisArg, args);
            });
        });
    });
}
var over = createOver(arrayMap);
var castRest = baseRest;
var nativeMin$6 = Math.min;
var overArgs = castRest(function (func, transforms) {
    transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(baseIteratee))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(baseIteratee));
    var funcsLength = transforms.length;
    return baseRest(function (args) {
        var index = -1, length = nativeMin$6(args.length, funcsLength);
        while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
    });
});
var overEvery = createOver(arrayEvery);
var overSome = createOver(arraySome);
var MAX_SAFE_INTEGER$2 = 9007199254740991;
var nativeFloor$3 = Math.floor;
function baseRepeat(string, n) {
    var result = '';
    if (!string || n < 1 || n > MAX_SAFE_INTEGER$2) {
        return result;
    }
    do {
        if (n % 2) {
            result += string;
        }
        n = nativeFloor$3(n / 2);
        if (n) {
            string += string;
        }
    } while (n);
    return result;
}
var asciiSize = baseProperty('length');
var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f', reComboHalfMarksRange = '\\ufe20-\\ufe2f', rsComboSymbolsRange = '\\u20d0-\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = '\\ufe0e\\ufe0f';
var rsAstral = '[' + rsAstralRange + ']', rsCombo = '[' + rsComboRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsZWJ = '\\u200d';
var reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
        ++result;
    }
    return result;
}
function stringSize(string) {
    return hasUnicode(string)
        ? unicodeSize(string)
        : asciiSize(string);
}
var nativeCeil$2 = Math.ceil;
function createPadding(length, chars) {
    chars = chars === undefined ? ' ' : baseToString(chars);
    var charsLength = chars.length;
    if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
    }
    var result = baseRepeat(chars, nativeCeil$2(length / stringSize(chars)));
    return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
}
var nativeCeil$1 = Math.ceil, nativeFloor$2 = Math.floor;
function pad(string, length, chars) {
    string = toString(string);
    length = toInteger(length);
    var strLength = length ? stringSize(string) : 0;
    if (!length || strLength >= length) {
        return string;
    }
    var mid = (length - strLength) / 2;
    return (createPadding(nativeFloor$2(mid), chars) +
        string +
        createPadding(nativeCeil$1(mid), chars));
}
function padEnd(string, length, chars) {
    string = toString(string);
    length = toInteger(length);
    var strLength = length ? stringSize(string) : 0;
    return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
}
function padStart(string, length, chars) {
    string = toString(string);
    length = toInteger(length);
    var strLength = length ? stringSize(string) : 0;
    return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
}
var reTrimStart$1 = /^\s+/;
var nativeParseInt = root.parseInt;
function parseInt$1(string, radix, guard) {
    if (guard || radix == null) {
        radix = 0;
    }
    else if (radix) {
        radix = +radix;
    }
    return nativeParseInt(toString(string).replace(reTrimStart$1, ''), radix || 0);
}
var WRAP_PARTIAL_FLAG = 32;
var partial = baseRest(function (func, partials) {
    var holders = replaceHolders(partials, getHolder(partial));
    return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
});
partial.placeholder = {};
var WRAP_PARTIAL_RIGHT_FLAG = 64;
var partialRight = baseRest(function (func, partials) {
    var holders = replaceHolders(partials, getHolder(partialRight));
    return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
});
partialRight.placeholder = {};
var partition = createAggregator(function (result, value, key) {
    result[key ? 0 : 1].push(value);
}, function () { return [[], []]; });
function basePick(object, paths) {
    return basePickBy(object, paths, function (value, path) {
        return hasIn(object, path);
    });
}
var pick = flatRest(function (object, paths) {
    return object == null ? {} : basePick(object, paths);
});
function wrapperPlant(value) {
    var result, parent = this;
    while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
            previous.__wrapped__ = clone;
        }
        else {
            result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
    }
    previous.__wrapped__ = value;
    return result;
}
function propertyOf(object) {
    return function (path) {
        return object == null ? undefined : baseGet(object, path);
    };
}
function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
        if (comparator(array[index], value)) {
            return index;
        }
    }
    return -1;
}
var arrayProto$3 = Array.prototype;
var splice$1 = arrayProto$3.splice;
function basePullAll(array, values, iteratee, comparator) {
    var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
    if (array === values) {
        values = copyArray(values);
    }
    if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
    }
    while (++index < length) {
        var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
                splice$1.call(seen, fromIndex, 1);
            }
            splice$1.call(array, fromIndex, 1);
        }
    }
    return array;
}
function pullAll(array, values) {
    return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
}
var pull = baseRest(pullAll);
function pullAllBy(array, values, iteratee) {
    return (array && array.length && values && values.length)
        ? basePullAll(array, values, baseIteratee(iteratee))
        : array;
}
function pullAllWith(array, values, comparator) {
    return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
}
var arrayProto$2 = Array.prototype;
var splice = arrayProto$2.splice;
function basePullAt(array, indexes) {
    var length = array ? indexes.length : 0, lastIndex = length - 1;
    while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
                splice.call(array, index, 1);
            }
            else {
                baseUnset(array, index);
            }
        }
    }
    return array;
}
var pullAt = flatRest(function (array, indexes) {
    var length = array == null ? 0 : array.length, result = baseAt(array, indexes);
    basePullAt(array, arrayMap(indexes, function (index) {
        return isIndex(index, length) ? +index : index;
    }).sort(compareAscending));
    return result;
});
var nativeFloor$1 = Math.floor, nativeRandom$1 = Math.random;
function baseRandom(lower, upper) {
    return lower + nativeFloor$1(nativeRandom$1() * (upper - lower + 1));
}
var freeParseFloat = parseFloat;
var nativeMin$5 = Math.min, nativeRandom = Math.random;
function random(lower, upper, floating) {
    if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
    }
    if (floating === undefined) {
        if (typeof upper == 'boolean') {
            floating = upper;
            upper = undefined;
        }
        else if (typeof lower == 'boolean') {
            floating = lower;
            lower = undefined;
        }
    }
    if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
    }
    else {
        lower = toFinite(lower);
        if (upper === undefined) {
            upper = lower;
            lower = 0;
        }
        else {
            upper = toFinite(upper);
        }
    }
    if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
    }
    if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin$5(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
    }
    return baseRandom(lower, upper);
}
var nativeCeil = Math.ceil, nativeMax$4 = Math.max;
function baseRange(start, end, step, fromRight) {
    var index = -1, length = nativeMax$4(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
    while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
    }
    return result;
}
function createRange(fromRight) {
    return function (start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
            end = step = undefined;
        }
        start = toFinite(start);
        if (end === undefined) {
            end = start;
            start = 0;
        }
        else {
            end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
    };
}
var range = createRange();
var rangeRight = createRange(true);
var WRAP_REARG_FLAG = 256;
var rearg = flatRest(function (func, indexes) {
    return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
});
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function (value, index, collection) {
        accumulator = initAccum
            ? (initAccum = false, value)
            : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
}
function reduce(collection, iteratee, accumulator) {
    var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
    return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEach);
}
function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
        accumulator = array[--length];
    }
    while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
}
function reduceRight(collection, iteratee, accumulator) {
    var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
    return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEachRight);
}
function reject(collection, predicate) {
    var func = isArray(collection) ? arrayFilter : baseFilter;
    return func(collection, negate(baseIteratee(predicate)));
}
function remove(array, predicate) {
    var result = [];
    if (!(array && array.length)) {
        return result;
    }
    var index = -1, indexes = [], length = array.length;
    predicate = baseIteratee(predicate);
    while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
            result.push(value);
            indexes.push(index);
        }
    }
    basePullAt(array, indexes);
    return result;
}
function repeat(string, n, guard) {
    if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
    }
    else {
        n = toInteger(n);
    }
    return baseRepeat(toString(string), n);
}
function replace() {
    var args = arguments, string = toString(args[0]);
    return args.length < 3 ? string : string.replace(args[1], args[2]);
}
var FUNC_ERROR_TEXT$2 = 'Expected a function';
function rest(func, start) {
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$2);
    }
    start = start === undefined ? start : toInteger(start);
    return baseRest(func, start);
}
function result(object, path, defaultValue) {
    path = castPath(path, object);
    var index = -1, length = path.length;
    if (!length) {
        length = 1;
        object = undefined;
    }
    while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
            index = length;
            value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
    }
    return object;
}
var arrayProto$1 = Array.prototype;
var nativeReverse = arrayProto$1.reverse;
function reverse(array) {
    return array == null ? array : nativeReverse.call(array);
}
var round = createRound('round');
function arraySample(array) {
    var length = array.length;
    return length ? array[baseRandom(0, length - 1)] : undefined;
}
function baseSample(collection) {
    return arraySample(values(collection));
}
function sample(collection) {
    var func = isArray(collection) ? arraySample : baseSample;
    return func(collection);
}
function shuffleSelf(array, size) {
    var index = -1, length = array.length, lastIndex = length - 1;
    size = size === undefined ? length : size;
    while (++index < size) {
        var rand = baseRandom(index, lastIndex), value = array[rand];
        array[rand] = array[index];
        array[index] = value;
    }
    array.length = size;
    return array;
}
function arraySampleSize(array, n) {
    return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
}
function baseSampleSize(collection, n) {
    var array = values(collection);
    return shuffleSelf(array, baseClamp(n, 0, array.length));
}
function sampleSize(collection, n, guard) {
    if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
    }
    else {
        n = toInteger(n);
    }
    var func = isArray(collection) ? arraySampleSize : baseSampleSize;
    return func(collection, n);
}
function set(object, path, value) {
    return object == null ? object : baseSet(object, path, value);
}
function setWith(object, path, value, customizer) {
    customizer = typeof customizer == 'function' ? customizer : undefined;
    return object == null ? object : baseSet(object, path, value, customizer);
}
function arrayShuffle(array) {
    return shuffleSelf(copyArray(array));
}
function baseShuffle(collection) {
    return shuffleSelf(values(collection));
}
function shuffle(collection) {
    var func = isArray(collection) ? arrayShuffle : baseShuffle;
    return func(collection);
}
var mapTag = '[object Map]', setTag = '[object Set]';
function size(collection) {
    if (collection == null) {
        return 0;
    }
    if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
    }
    var tag = getTag$1(collection);
    if (tag == mapTag || tag == setTag) {
        return collection.size;
    }
    return baseKeys(collection).length;
}
function slice(array, start, end) {
    var length = array == null ? 0 : array.length;
    if (!length) {
        return [];
    }
    if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
    }
    else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
    }
    return baseSlice(array, start, end);
}
var snakeCase = createCompounder(function (result, word, index) {
    return result + (index ? '_' : '') + word.toLowerCase();
});
function baseSome(collection, predicate) {
    var result;
    baseEach(collection, function (value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
    });
    return !!result;
}
function some(collection, predicate, guard) {
    var func = isArray(collection) ? arraySome : baseSome;
    if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
    }
    return func(collection, baseIteratee(predicate));
}
var sortBy = baseRest(function (collection, iteratees) {
    if (collection == null) {
        return [];
    }
    var length = iteratees.length;
    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
    }
    else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});
var MAX_ARRAY_LENGTH$4 = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$4 - 1;
var nativeFloor = Math.floor, nativeMin$4 = Math.min;
function baseSortedIndexBy(array, value, iteratee, retHighest) {
    var low = 0, high = array == null ? 0 : array.length;
    if (high === 0) {
        return 0;
    }
    value = iteratee(value);
    var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined;
    while (low < high) {
        var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
        if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
        }
        else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
        }
        else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        }
        else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        }
        else if (othIsNull || othIsSymbol) {
            setLow = false;
        }
        else {
            setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
            low = mid + 1;
        }
        else {
            high = mid;
        }
    }
    return nativeMin$4(high, MAX_ARRAY_INDEX);
}
var MAX_ARRAY_LENGTH$3 = 4294967295, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH$3 >>> 1;
function baseSortedIndex(array, value, retHighest) {
    var low = 0, high = array == null ? low : array.length;
    if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
            var mid = (low + high) >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) &&
                (retHighest ? (computed <= value) : (computed < value))) {
                low = mid + 1;
            }
            else {
                high = mid;
            }
        }
        return high;
    }
    return baseSortedIndexBy(array, value, identity, retHighest);
}
function sortedIndex(array, value) {
    return baseSortedIndex(array, value);
}
function sortedIndexBy(array, value, iteratee) {
    return baseSortedIndexBy(array, value, baseIteratee(iteratee));
}
function sortedIndexOf(array, value) {
    var length = array == null ? 0 : array.length;
    if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
            return index;
        }
    }
    return -1;
}
function sortedLastIndex(array, value) {
    return baseSortedIndex(array, value, true);
}
function sortedLastIndexBy(array, value, iteratee) {
    return baseSortedIndexBy(array, value, baseIteratee(iteratee), true);
}
function sortedLastIndexOf(array, value) {
    var length = array == null ? 0 : array.length;
    if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
            return index;
        }
    }
    return -1;
}
function baseSortedUniq(array, iteratee) {
    var index = -1, length = array.length, resIndex = 0, result = [];
    while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        if (!index || !eq(computed, seen)) {
            var seen = computed;
            result[resIndex++] = value === 0 ? 0 : value;
        }
    }
    return result;
}
function sortedUniq(array) {
    return (array && array.length)
        ? baseSortedUniq(array)
        : [];
}
function sortedUniqBy(array, iteratee) {
    return (array && array.length)
        ? baseSortedUniq(array, baseIteratee(iteratee))
        : [];
}
var MAX_ARRAY_LENGTH$2 = 4294967295;
function split(string, separator, limit) {
    if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
    }
    limit = limit === undefined ? MAX_ARRAY_LENGTH$2 : limit >>> 0;
    if (!limit) {
        return [];
    }
    string = toString(string);
    if (string && (typeof separator == 'string' ||
        (separator != null && !isRegExp(separator)))) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
        }
    }
    return string.split(separator, limit);
}
var FUNC_ERROR_TEXT$1 = 'Expected a function';
var nativeMax$3 = Math.max;
function spread(func, start) {
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    start = start == null ? 0 : nativeMax$3(toInteger(start), 0);
    return baseRest(function (args) {
        var array = args[start], otherArgs = castSlice(args, 0, start);
        if (array) {
            arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
    });
}
var startCase = createCompounder(function (result, word, index) {
    return result + (index ? ' ' : '') + upperFirst(word);
});
function startsWith(string, target, position) {
    string = toString(string);
    position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);
    target = baseToString(target);
    return string.slice(position, position + target.length) == target;
}
function stubObject() {
    return {};
}
function stubString() {
    return '';
}
function stubTrue() {
    return true;
}
var subtract = createMathOperation(function (minuend, subtrahend) {
    return minuend - subtrahend;
}, 0);
function sum(array) {
    return (array && array.length)
        ? baseSum(array, identity)
        : 0;
}
function sumBy(array, iteratee) {
    return (array && array.length)
        ? baseSum(array, baseIteratee(iteratee))
        : 0;
}
function tail(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseSlice(array, 1, length) : [];
}
function take(array, n, guard) {
    if (!(array && array.length)) {
        return [];
    }
    n = (guard || n === undefined) ? 1 : toInteger(n);
    return baseSlice(array, 0, n < 0 ? 0 : n);
}
function takeRight(array, n, guard) {
    var length = array == null ? 0 : array.length;
    if (!length) {
        return [];
    }
    n = (guard || n === undefined) ? 1 : toInteger(n);
    n = length - n;
    return baseSlice(array, n < 0 ? 0 : n, length);
}
function takeRightWhile(array, predicate) {
    return (array && array.length)
        ? baseWhile(array, baseIteratee(predicate), false, true)
        : [];
}
function takeWhile(array, predicate) {
    return (array && array.length)
        ? baseWhile(array, baseIteratee(predicate))
        : [];
}
function tap(value, interceptor) {
    interceptor(value);
    return value;
}
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key, object) {
    if (objValue === undefined ||
        (eq(objValue, objectProto$2[key]) && !hasOwnProperty$2.call(object, key))) {
        return srcValue;
    }
    return objValue;
}
var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
};
function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
}
var reInterpolate = /<%=([\s\S]+?)%>/g;
var reEscape = /<%-([\s\S]+?)%>/g;
var reEvaluate = /<%([\s\S]+?)%>/g;
var templateSettings = {
    'escape': reEscape,
    'evaluate': reEvaluate,
    'interpolate': reInterpolate,
    'variable': '',
    'imports': {
        '_': { 'escape': escape }
    }
};
var INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';
var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function template(string, options, guard) {
    var settings = templateSettings.imports._.templateSettings || templateSettings;
    if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
    }
    string = toString(string);
    options = assignInWith({}, options, settings, customDefaultsAssignIn);
    var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
    var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
    var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$', 'g');
    var sourceURL = hasOwnProperty$1.call(options, 'sourceURL')
        ? ('//# sourceURL=' +
            (options.sourceURL + '').replace(/\s/g, ' ') +
            '\n')
        : '';
    string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
        if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;
        return match;
    });
    source += "';\n";
    var variable = hasOwnProperty$1.call(options, 'variable') && options.variable;
    if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
    }
    else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
    }
    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');
    source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
            ? ''
            : 'obj || (obj = {});\n') +
        "var __t, __p = ''" +
        (isEscaping
            ? ', __e = _.escape'
            : '') +
        (isEvaluating
            ? ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n"
            : ';\n') +
        source +
        'return __p\n}';
    var result = attempt(function () {
        return Function(importsKeys, sourceURL + 'return ' + source)
            .apply(undefined, importsValues);
    });
    result.source = source;
    if (isError(result)) {
        throw result;
    }
    return result;
}
var FUNC_ERROR_TEXT = 'Expected a function';
function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
    });
}
function thru(value, interceptor) {
    return interceptor(value);
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var MAX_ARRAY_LENGTH$1 = 4294967295;
var nativeMin$3 = Math.min;
function times(n, iteratee) {
    n = toInteger(n);
    if (n < 1 || n > MAX_SAFE_INTEGER$1) {
        return [];
    }
    var index = MAX_ARRAY_LENGTH$1, length = nativeMin$3(n, MAX_ARRAY_LENGTH$1);
    iteratee = castFunction(iteratee);
    n -= MAX_ARRAY_LENGTH$1;
    var result = baseTimes(length, iteratee);
    while (++index < n) {
        iteratee(index);
    }
    return result;
}
function wrapperToIterator() {
    return this;
}
function baseWrapperValue(value, actions) {
    var result = value;
    if (result instanceof LazyWrapper) {
        result = result.value();
    }
    return arrayReduce(actions, function (result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
    }, result);
}
function wrapperValue() {
    return baseWrapperValue(this.__wrapped__, this.__actions__);
}
function toLower(value) {
    return toString(value).toLowerCase();
}
function toPath(value) {
    if (isArray(value)) {
        return arrayMap(value, toKey);
    }
    return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
}
var MAX_SAFE_INTEGER = 9007199254740991;
function toSafeInteger(value) {
    return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
}
function toUpper(value) {
    return toString(value).toUpperCase();
}
function transform(object, iteratee, accumulator) {
    var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
    iteratee = baseIteratee(iteratee);
    if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
            accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
            accumulator = {};
        }
    }
    (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
        return iteratee(accumulator, value, index, object);
    });
    return accumulator;
}
function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;
    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) { }
    return index;
}
function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1, length = strSymbols.length;
    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) { }
    return index;
}
function trim(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === undefined)) {
        return baseTrim(string);
    }
    if (!string || !(chars = baseToString(chars))) {
        return string;
    }
    var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
    return castSlice(strSymbols, start, end).join('');
}
function trimEnd(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
    }
    if (!string || !(chars = baseToString(chars))) {
        return string;
    }
    var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
    return castSlice(strSymbols, 0, end).join('');
}
var reTrimStart = /^\s+/;
function trimStart(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
    }
    if (!string || !(chars = baseToString(chars))) {
        return string;
    }
    var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
    return castSlice(strSymbols, start).join('');
}
var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';
var reFlags = /\w*$/;
function truncate(string, options) {
    var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
    if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
    }
    string = toString(string);
    var strLength = string.length;
    if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
    }
    if (length >= strLength) {
        return string;
    }
    var end = length - stringSize(omission);
    if (end < 1) {
        return omission;
    }
    var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);
    if (separator === undefined) {
        return result + omission;
    }
    if (strSymbols) {
        end += (result.length - end);
    }
    if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
            var match, substring = result;
            if (!separator.global) {
                separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
            }
            separator.lastIndex = 0;
            while ((match = separator.exec(substring))) {
                var newEnd = match.index;
            }
            result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
    }
    else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
            result = result.slice(0, index);
        }
    }
    return result + omission;
}
function unary(func) {
    return ary(func, 1);
}
var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
};
var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reHasEscapedHtml = RegExp(reEscapedHtml.source);
function unescape(string) {
    string = toString(string);
    return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
}
var INFINITY = 1 / 0;
var createSet = !(Set$1 && (1 / setToArray(new Set$1([, -0]))[1]) == INFINITY) ? noop : function (values) {
    return new Set$1(values);
};
var LARGE_ARRAY_SIZE = 200;
function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
    }
    else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
            return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
    }
    else {
        seen = iteratee ? [] : result;
    }
    outer: while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                    continue outer;
                }
            }
            if (iteratee) {
                seen.push(computed);
            }
            result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
                seen.push(computed);
            }
            result.push(value);
        }
    }
    return result;
}
var union = baseRest(function (arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});
var unionBy = baseRest(function (arrays) {
    var iteratee = last(arrays);
    if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
    }
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee));
});
var unionWith = baseRest(function (arrays) {
    var comparator = last(arrays);
    comparator = typeof comparator == 'function' ? comparator : undefined;
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
});
function uniq(array) {
    return (array && array.length) ? baseUniq(array) : [];
}
function uniqBy(array, iteratee) {
    return (array && array.length) ? baseUniq(array, baseIteratee(iteratee)) : [];
}
function uniqWith(array, comparator) {
    comparator = typeof comparator == 'function' ? comparator : undefined;
    return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
}
var idCounter = 0;
function uniqueId(prefix) {
    var id = ++idCounter;
    return toString(prefix) + id;
}
function unset(object, path) {
    return object == null ? true : baseUnset(object, path);
}
var nativeMax$2 = Math.max;
function unzip(array) {
    if (!(array && array.length)) {
        return [];
    }
    var length = 0;
    array = arrayFilter(array, function (group) {
        if (isArrayLikeObject(group)) {
            length = nativeMax$2(group.length, length);
            return true;
        }
    });
    return baseTimes(length, function (index) {
        return arrayMap(array, baseProperty(index));
    });
}
function unzipWith(array, iteratee) {
    if (!(array && array.length)) {
        return [];
    }
    var result = unzip(array);
    if (iteratee == null) {
        return result;
    }
    return arrayMap(result, function (group) {
        return apply(iteratee, undefined, group);
    });
}
function baseUpdate(object, path, updater, customizer) {
    return baseSet(object, path, updater(baseGet(object, path)), customizer);
}
function update(object, path, updater) {
    return object == null ? object : baseUpdate(object, path, castFunction(updater));
}
function updateWith(object, path, updater, customizer) {
    customizer = typeof customizer == 'function' ? customizer : undefined;
    return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
}
var upperCase = createCompounder(function (result, word, index) {
    return result + (index ? ' ' : '') + word.toUpperCase();
});
function valuesIn(object) {
    return object == null ? [] : baseValues(object, keysIn(object));
}
var without = baseRest(function (array, values) {
    return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
});
function wrap(value, wrapper) {
    return partial(castFunction(wrapper), value);
}
var wrapperAt = flatRest(function (paths) {
    var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function (object) { return baseAt(object, paths); };
    if (length > 1 || this.__actions__.length ||
        !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
    }
    value = value.slice(start, +start + (length ? 1 : 0));
    value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
    });
    return new LodashWrapper(value, this.__chain__).thru(function (array) {
        if (length && !array.length) {
            array.push(undefined);
        }
        return array;
    });
});
function wrapperChain() {
    return chain(this);
}
function wrapperReverse() {
    var value = this.__wrapped__;
    if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
            'func': thru,
            'args': [reverse],
            'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
    }
    return this.thru(reverse);
}
function baseXor(arrays, iteratee, comparator) {
    var length = arrays.length;
    if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
    }
    var index = -1, result = Array(length);
    while (++index < length) {
        var array = arrays[index], othIndex = -1;
        while (++othIndex < length) {
            if (othIndex != index) {
                result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
            }
        }
    }
    return baseUniq(baseFlatten(result, 1), iteratee, comparator);
}
var xor = baseRest(function (arrays) {
    return baseXor(arrayFilter(arrays, isArrayLikeObject));
});
var xorBy = baseRest(function (arrays) {
    var iteratee = last(arrays);
    if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
    }
    return baseXor(arrayFilter(arrays, isArrayLikeObject), baseIteratee(iteratee));
});
var xorWith = baseRest(function (arrays) {
    var comparator = last(arrays);
    comparator = typeof comparator == 'function' ? comparator : undefined;
    return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
});
var zip = baseRest(unzip);
function baseZipObject(props, values, assignFunc) {
    var index = -1, length = props.length, valsLength = values.length, result = {};
    while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
    }
    return result;
}
function zipObject(props, values) {
    return baseZipObject(props || [], values || [], assignValue);
}
function zipObjectDeep(props, values) {
    return baseZipObject(props || [], values || [], baseSet);
}
var zipWith = baseRest(function (arrays) {
    var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
    iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
    return unzipWith(arrays, iteratee);
});
var array = {
    chunk, compact, concat, difference, differenceBy,
    differenceWith, drop, dropRight, dropRightWhile, dropWhile,
    fill, findIndex, findLastIndex, first: head, flatten,
    flattenDeep, flattenDepth, fromPairs, head, indexOf,
    initial, intersection, intersectionBy, intersectionWith, join,
    last, lastIndexOf, nth, pull, pullAll,
    pullAllBy, pullAllWith, pullAt, remove, reverse,
    slice, sortedIndex, sortedIndexBy, sortedIndexOf, sortedLastIndex,
    sortedLastIndexBy, sortedLastIndexOf, sortedUniq, sortedUniqBy, tail,
    take, takeRight, takeRightWhile, takeWhile, union,
    unionBy, unionWith, uniq, uniqBy, uniqWith,
    unzip, unzipWith, without, xor, xorBy,
    xorWith, zip, zipObject, zipObjectDeep, zipWith
};
var collection = {
    countBy, each: forEach, eachRight: forEachRight, every, filter,
    find, findLast, flatMap, flatMapDeep, flatMapDepth,
    forEach, forEachRight, groupBy, includes, invokeMap,
    keyBy, map, orderBy, partition, reduce,
    reduceRight, reject, sample, sampleSize, shuffle,
    size, some, sortBy
};
var date = {
    now
};
var func = {
    after, ary, before, bind, bindKey,
    curry, curryRight, debounce, defer, delay,
    flip, memoize, negate, once, overArgs,
    partial, partialRight, rearg, rest, spread,
    throttle, unary, wrap
};
var lang = {
    castArray, clone, cloneDeep, cloneDeepWith, cloneWith,
    conformsTo, eq, gt, gte, isArguments,
    isArray, isArrayBuffer, isArrayLike, isArrayLikeObject, isBoolean,
    isBuffer, isDate, isElement, isEmpty, isEqual,
    isEqualWith, isError, isFinite: isFinite$1, isFunction, isInteger,
    isLength, isMap, isMatch, isMatchWith, isNaN: isNaN$1,
    isNative, isNil, isNull, isNumber, isObject,
    isObjectLike, isPlainObject, isRegExp, isSafeInteger, isSet,
    isString, isSymbol, isTypedArray, isUndefined, isWeakMap,
    isWeakSet, lt, lte, toArray, toFinite,
    toInteger, toLength, toNumber, toPlainObject, toSafeInteger,
    toString
};
var math = {
    add, ceil, divide, floor, max,
    maxBy, mean, meanBy, min, minBy,
    multiply, round, subtract, sum, sumBy
};
var number = {
    clamp, inRange, random
};
var object = {
    assign, assignIn, assignInWith, assignWith, at,
    create, defaults, defaultsDeep, entries: toPairs, entriesIn: toPairsIn,
    extend: assignIn, extendWith: assignInWith, findKey, findLastKey, forIn,
    forInRight, forOwn, forOwnRight, functions, functionsIn,
    get, has, hasIn, invert, invertBy,
    invoke, keys, keysIn, mapKeys, mapValues,
    merge, mergeWith, omit, omitBy, pick,
    pickBy, result, set, setWith, toPairs,
    toPairsIn, transform, unset, update, updateWith,
    values, valuesIn
};
var seq = {
    at: wrapperAt, chain, commit: wrapperCommit, lodash, next: wrapperNext,
    plant: wrapperPlant, reverse: wrapperReverse, tap, thru, toIterator: wrapperToIterator,
    toJSON: wrapperValue, value: wrapperValue, valueOf: wrapperValue, wrapperChain
};
var string = {
    camelCase, capitalize, deburr, endsWith, escape,
    escapeRegExp, kebabCase, lowerCase, lowerFirst, pad,
    padEnd, padStart, parseInt: parseInt$1, repeat, replace,
    snakeCase, split, startCase, startsWith, template,
    templateSettings, toLower, toUpper, trim, trimEnd,
    trimStart, truncate, unescape, upperCase, upperFirst,
    words
};
var util$1 = {
    attempt, bindAll, cond, conforms, constant,
    defaultTo, flow, flowRight, identity, iteratee,
    matches, matchesProperty, method, methodOf, mixin: mixin$1,
    noop, nthArg, over, overEvery, overSome,
    property, propertyOf, range, rangeRight, stubArray,
    stubFalse, stubObject, stubString, stubTrue, times,
    toPath, uniqueId
};
function lazyClone() {
    var result = new LazyWrapper(this.__wrapped__);
    result.__actions__ = copyArray(this.__actions__);
    result.__dir__ = this.__dir__;
    result.__filtered__ = this.__filtered__;
    result.__iteratees__ = copyArray(this.__iteratees__);
    result.__takeCount__ = this.__takeCount__;
    result.__views__ = copyArray(this.__views__);
    return result;
}
function lazyReverse() {
    if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
    }
    else {
        result = this.clone();
        result.__dir__ *= -1;
    }
    return result;
}
var nativeMax$1 = Math.max, nativeMin$2 = Math.min;
function getView(start, end, transforms) {
    var index = -1, length = transforms.length;
    while (++index < length) {
        var data = transforms[index], size = data.size;
        switch (data.type) {
            case 'drop':
                start += size;
                break;
            case 'dropRight':
                end -= size;
                break;
            case 'take':
                end = nativeMin$2(end, start + size);
                break;
            case 'takeRight':
                start = nativeMax$1(start, end - size);
                break;
        }
    }
    return { 'start': start, 'end': end };
}
var LAZY_FILTER_FLAG$1 = 1, LAZY_MAP_FLAG = 2;
var nativeMin$1 = Math.min;
function lazyValue() {
    var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : (start - 1), iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin$1(length, this.__takeCount__);
    if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
    }
    var result = [];
    outer: while (length-- && resIndex < takeCount) {
        index += dir;
        var iterIndex = -1, value = array[index];
        while (++iterIndex < iterLength) {
            var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
            if (type == LAZY_MAP_FLAG) {
                value = computed;
            }
            else if (!computed) {
                if (type == LAZY_FILTER_FLAG$1) {
                    continue outer;
                }
                else {
                    break outer;
                }
            }
        }
        result[resIndex++] = value;
    }
    return result;
}
var VERSION = '4.17.21';
var WRAP_BIND_KEY_FLAG = 2;
var LAZY_FILTER_FLAG = 1, LAZY_WHILE_FLAG = 3;
var MAX_ARRAY_LENGTH = 4294967295;
var arrayProto = Array.prototype, objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var symIterator = Symbol$1 ? Symbol$1.iterator : undefined;
var nativeMax = Math.max, nativeMin = Math.min;
var mixin = (function (func) {
    return function (object, source, options) {
        if (options == null) {
            var isObj = isObject(source), props = isObj && keys(source), methodNames = props && props.length && baseFunctions(source, props);
            if (!(methodNames ? methodNames.length : isObj)) {
                options = source;
                source = object;
                object = this;
            }
        }
        return func(object, source, options);
    };
}(mixin$1));
lodash.after = func.after;
lodash.ary = func.ary;
lodash.assign = object.assign;
lodash.assignIn = object.assignIn;
lodash.assignInWith = object.assignInWith;
lodash.assignWith = object.assignWith;
lodash.at = object.at;
lodash.before = func.before;
lodash.bind = func.bind;
lodash.bindAll = util$1.bindAll;
lodash.bindKey = func.bindKey;
lodash.castArray = lang.castArray;
lodash.chain = seq.chain;
lodash.chunk = array.chunk;
lodash.compact = array.compact;
lodash.concat = array.concat;
lodash.cond = util$1.cond;
lodash.conforms = util$1.conforms;
lodash.constant = util$1.constant;
lodash.countBy = collection.countBy;
lodash.create = object.create;
lodash.curry = func.curry;
lodash.curryRight = func.curryRight;
lodash.debounce = func.debounce;
lodash.defaults = object.defaults;
lodash.defaultsDeep = object.defaultsDeep;
lodash.defer = func.defer;
lodash.delay = func.delay;
lodash.difference = array.difference;
lodash.differenceBy = array.differenceBy;
lodash.differenceWith = array.differenceWith;
lodash.drop = array.drop;
lodash.dropRight = array.dropRight;
lodash.dropRightWhile = array.dropRightWhile;
lodash.dropWhile = array.dropWhile;
lodash.fill = array.fill;
lodash.filter = collection.filter;
lodash.flatMap = collection.flatMap;
lodash.flatMapDeep = collection.flatMapDeep;
lodash.flatMapDepth = collection.flatMapDepth;
lodash.flatten = array.flatten;
lodash.flattenDeep = array.flattenDeep;
lodash.flattenDepth = array.flattenDepth;
lodash.flip = func.flip;
lodash.flow = util$1.flow;
lodash.flowRight = util$1.flowRight;
lodash.fromPairs = array.fromPairs;
lodash.functions = object.functions;
lodash.functionsIn = object.functionsIn;
lodash.groupBy = collection.groupBy;
lodash.initial = array.initial;
lodash.intersection = array.intersection;
lodash.intersectionBy = array.intersectionBy;
lodash.intersectionWith = array.intersectionWith;
lodash.invert = object.invert;
lodash.invertBy = object.invertBy;
lodash.invokeMap = collection.invokeMap;
lodash.iteratee = util$1.iteratee;
lodash.keyBy = collection.keyBy;
lodash.keys = keys;
lodash.keysIn = object.keysIn;
lodash.map = collection.map;
lodash.mapKeys = object.mapKeys;
lodash.mapValues = object.mapValues;
lodash.matches = util$1.matches;
lodash.matchesProperty = util$1.matchesProperty;
lodash.memoize = func.memoize;
lodash.merge = object.merge;
lodash.mergeWith = object.mergeWith;
lodash.method = util$1.method;
lodash.methodOf = util$1.methodOf;
lodash.mixin = mixin;
lodash.negate = negate;
lodash.nthArg = util$1.nthArg;
lodash.omit = object.omit;
lodash.omitBy = object.omitBy;
lodash.once = func.once;
lodash.orderBy = collection.orderBy;
lodash.over = util$1.over;
lodash.overArgs = func.overArgs;
lodash.overEvery = util$1.overEvery;
lodash.overSome = util$1.overSome;
lodash.partial = func.partial;
lodash.partialRight = func.partialRight;
lodash.partition = collection.partition;
lodash.pick = object.pick;
lodash.pickBy = object.pickBy;
lodash.property = util$1.property;
lodash.propertyOf = util$1.propertyOf;
lodash.pull = array.pull;
lodash.pullAll = array.pullAll;
lodash.pullAllBy = array.pullAllBy;
lodash.pullAllWith = array.pullAllWith;
lodash.pullAt = array.pullAt;
lodash.range = util$1.range;
lodash.rangeRight = util$1.rangeRight;
lodash.rearg = func.rearg;
lodash.reject = collection.reject;
lodash.remove = array.remove;
lodash.rest = func.rest;
lodash.reverse = array.reverse;
lodash.sampleSize = collection.sampleSize;
lodash.set = object.set;
lodash.setWith = object.setWith;
lodash.shuffle = collection.shuffle;
lodash.slice = array.slice;
lodash.sortBy = collection.sortBy;
lodash.sortedUniq = array.sortedUniq;
lodash.sortedUniqBy = array.sortedUniqBy;
lodash.split = string.split;
lodash.spread = func.spread;
lodash.tail = array.tail;
lodash.take = array.take;
lodash.takeRight = array.takeRight;
lodash.takeRightWhile = array.takeRightWhile;
lodash.takeWhile = array.takeWhile;
lodash.tap = seq.tap;
lodash.throttle = func.throttle;
lodash.thru = thru;
lodash.toArray = lang.toArray;
lodash.toPairs = object.toPairs;
lodash.toPairsIn = object.toPairsIn;
lodash.toPath = util$1.toPath;
lodash.toPlainObject = lang.toPlainObject;
lodash.transform = object.transform;
lodash.unary = func.unary;
lodash.union = array.union;
lodash.unionBy = array.unionBy;
lodash.unionWith = array.unionWith;
lodash.uniq = array.uniq;
lodash.uniqBy = array.uniqBy;
lodash.uniqWith = array.uniqWith;
lodash.unset = object.unset;
lodash.unzip = array.unzip;
lodash.unzipWith = array.unzipWith;
lodash.update = object.update;
lodash.updateWith = object.updateWith;
lodash.values = object.values;
lodash.valuesIn = object.valuesIn;
lodash.without = array.without;
lodash.words = string.words;
lodash.wrap = func.wrap;
lodash.xor = array.xor;
lodash.xorBy = array.xorBy;
lodash.xorWith = array.xorWith;
lodash.zip = array.zip;
lodash.zipObject = array.zipObject;
lodash.zipObjectDeep = array.zipObjectDeep;
lodash.zipWith = array.zipWith;
lodash.entries = object.toPairs;
lodash.entriesIn = object.toPairsIn;
lodash.extend = object.assignIn;
lodash.extendWith = object.assignInWith;
mixin(lodash, lodash);
lodash.add = math.add;
lodash.attempt = util$1.attempt;
lodash.camelCase = string.camelCase;
lodash.capitalize = string.capitalize;
lodash.ceil = math.ceil;
lodash.clamp = number.clamp;
lodash.clone = lang.clone;
lodash.cloneDeep = lang.cloneDeep;
lodash.cloneDeepWith = lang.cloneDeepWith;
lodash.cloneWith = lang.cloneWith;
lodash.conformsTo = lang.conformsTo;
lodash.deburr = string.deburr;
lodash.defaultTo = util$1.defaultTo;
lodash.divide = math.divide;
lodash.endsWith = string.endsWith;
lodash.eq = lang.eq;
lodash.escape = string.escape;
lodash.escapeRegExp = string.escapeRegExp;
lodash.every = collection.every;
lodash.find = collection.find;
lodash.findIndex = array.findIndex;
lodash.findKey = object.findKey;
lodash.findLast = collection.findLast;
lodash.findLastIndex = array.findLastIndex;
lodash.findLastKey = object.findLastKey;
lodash.floor = math.floor;
lodash.forEach = collection.forEach;
lodash.forEachRight = collection.forEachRight;
lodash.forIn = object.forIn;
lodash.forInRight = object.forInRight;
lodash.forOwn = object.forOwn;
lodash.forOwnRight = object.forOwnRight;
lodash.get = object.get;
lodash.gt = lang.gt;
lodash.gte = lang.gte;
lodash.has = object.has;
lodash.hasIn = object.hasIn;
lodash.head = array.head;
lodash.identity = identity;
lodash.includes = collection.includes;
lodash.indexOf = array.indexOf;
lodash.inRange = number.inRange;
lodash.invoke = object.invoke;
lodash.isArguments = lang.isArguments;
lodash.isArray = isArray;
lodash.isArrayBuffer = lang.isArrayBuffer;
lodash.isArrayLike = lang.isArrayLike;
lodash.isArrayLikeObject = lang.isArrayLikeObject;
lodash.isBoolean = lang.isBoolean;
lodash.isBuffer = lang.isBuffer;
lodash.isDate = lang.isDate;
lodash.isElement = lang.isElement;
lodash.isEmpty = lang.isEmpty;
lodash.isEqual = lang.isEqual;
lodash.isEqualWith = lang.isEqualWith;
lodash.isError = lang.isError;
lodash.isFinite = lang.isFinite;
lodash.isFunction = lang.isFunction;
lodash.isInteger = lang.isInteger;
lodash.isLength = lang.isLength;
lodash.isMap = lang.isMap;
lodash.isMatch = lang.isMatch;
lodash.isMatchWith = lang.isMatchWith;
lodash.isNaN = lang.isNaN;
lodash.isNative = lang.isNative;
lodash.isNil = lang.isNil;
lodash.isNull = lang.isNull;
lodash.isNumber = lang.isNumber;
lodash.isObject = isObject;
lodash.isObjectLike = lang.isObjectLike;
lodash.isPlainObject = lang.isPlainObject;
lodash.isRegExp = lang.isRegExp;
lodash.isSafeInteger = lang.isSafeInteger;
lodash.isSet = lang.isSet;
lodash.isString = lang.isString;
lodash.isSymbol = lang.isSymbol;
lodash.isTypedArray = lang.isTypedArray;
lodash.isUndefined = lang.isUndefined;
lodash.isWeakMap = lang.isWeakMap;
lodash.isWeakSet = lang.isWeakSet;
lodash.join = array.join;
lodash.kebabCase = string.kebabCase;
lodash.last = last;
lodash.lastIndexOf = array.lastIndexOf;
lodash.lowerCase = string.lowerCase;
lodash.lowerFirst = string.lowerFirst;
lodash.lt = lang.lt;
lodash.lte = lang.lte;
lodash.max = math.max;
lodash.maxBy = math.maxBy;
lodash.mean = math.mean;
lodash.meanBy = math.meanBy;
lodash.min = math.min;
lodash.minBy = math.minBy;
lodash.stubArray = util$1.stubArray;
lodash.stubFalse = util$1.stubFalse;
lodash.stubObject = util$1.stubObject;
lodash.stubString = util$1.stubString;
lodash.stubTrue = util$1.stubTrue;
lodash.multiply = math.multiply;
lodash.nth = array.nth;
lodash.noop = util$1.noop;
lodash.now = date.now;
lodash.pad = string.pad;
lodash.padEnd = string.padEnd;
lodash.padStart = string.padStart;
lodash.parseInt = string.parseInt;
lodash.random = number.random;
lodash.reduce = collection.reduce;
lodash.reduceRight = collection.reduceRight;
lodash.repeat = string.repeat;
lodash.replace = string.replace;
lodash.result = object.result;
lodash.round = math.round;
lodash.sample = collection.sample;
lodash.size = collection.size;
lodash.snakeCase = string.snakeCase;
lodash.some = collection.some;
lodash.sortedIndex = array.sortedIndex;
lodash.sortedIndexBy = array.sortedIndexBy;
lodash.sortedIndexOf = array.sortedIndexOf;
lodash.sortedLastIndex = array.sortedLastIndex;
lodash.sortedLastIndexBy = array.sortedLastIndexBy;
lodash.sortedLastIndexOf = array.sortedLastIndexOf;
lodash.startCase = string.startCase;
lodash.startsWith = string.startsWith;
lodash.subtract = math.subtract;
lodash.sum = math.sum;
lodash.sumBy = math.sumBy;
lodash.template = string.template;
lodash.times = util$1.times;
lodash.toFinite = lang.toFinite;
lodash.toInteger = toInteger;
lodash.toLength = lang.toLength;
lodash.toLower = string.toLower;
lodash.toNumber = lang.toNumber;
lodash.toSafeInteger = lang.toSafeInteger;
lodash.toString = lang.toString;
lodash.toUpper = string.toUpper;
lodash.trim = string.trim;
lodash.trimEnd = string.trimEnd;
lodash.trimStart = string.trimStart;
lodash.truncate = string.truncate;
lodash.unescape = string.unescape;
lodash.uniqueId = util$1.uniqueId;
lodash.upperCase = string.upperCase;
lodash.upperFirst = string.upperFirst;
lodash.each = collection.forEach;
lodash.eachRight = collection.forEachRight;
lodash.first = array.head;
mixin(lodash, (function () {
    var source = {};
    baseForOwn(lodash, function (func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
        }
    });
    return source;
}()), { 'chain': false });
lodash.VERSION = VERSION;
(lodash.templateSettings = string.templateSettings).imports._ = lodash;
arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
    lodash[methodName].placeholder = lodash;
});
arrayEach(['drop', 'take'], function (methodName, index) {
    LazyWrapper.prototype[methodName] = function (n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
        var result = (this.__filtered__ && !index)
            ? new LazyWrapper(this)
            : this.clone();
        if (result.__filtered__) {
            result.__takeCount__ = nativeMin(n, result.__takeCount__);
        }
        else {
            result.__views__.push({
                'size': nativeMin(n, MAX_ARRAY_LENGTH),
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
            });
        }
        return result;
    };
    LazyWrapper.prototype[methodName + 'Right'] = function (n) {
        return this.reverse()[methodName](n).reverse();
    };
});
arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
    var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
    LazyWrapper.prototype[methodName] = function (iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
            'iteratee': baseIteratee(iteratee),
            'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
    };
});
arrayEach(['head', 'last'], function (methodName, index) {
    var takeName = 'take' + (index ? 'Right' : '');
    LazyWrapper.prototype[methodName] = function () {
        return this[takeName](1).value()[0];
    };
});
arrayEach(['initial', 'tail'], function (methodName, index) {
    var dropName = 'drop' + (index ? '' : 'Right');
    LazyWrapper.prototype[methodName] = function () {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
    };
});
LazyWrapper.prototype.compact = function () {
    return this.filter(identity);
};
LazyWrapper.prototype.find = function (predicate) {
    return this.filter(predicate).head();
};
LazyWrapper.prototype.findLast = function (predicate) {
    return this.reverse().find(predicate);
};
LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
    if (typeof path == 'function') {
        return new LazyWrapper(this);
    }
    return this.map(function (value) {
        return baseInvoke(value, path, args);
    });
});
LazyWrapper.prototype.reject = function (predicate) {
    return this.filter(negate(baseIteratee(predicate)));
};
LazyWrapper.prototype.slice = function (start, end) {
    start = toInteger(start);
    var result = this;
    if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
    }
    if (start < 0) {
        result = result.takeRight(-start);
    }
    else if (start) {
        result = result.drop(start);
    }
    if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
    }
    return result;
};
LazyWrapper.prototype.takeRightWhile = function (predicate) {
    return this.reverse().takeWhile(predicate).reverse();
};
LazyWrapper.prototype.toArray = function () {
    return this.take(MAX_ARRAY_LENGTH);
};
baseForOwn(LazyWrapper.prototype, function (func, methodName) {
    var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
    if (!lodashFunc) {
        return;
    }
    lodash.prototype[methodName] = function () {
        var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
        var interceptor = function (value) {
            var result = lodashFunc.apply(lodash, arrayPush([value], args));
            return (isTaker && chainAll) ? result[0] : result;
        };
        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
            isLazy = useLazy = false;
        }
        var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
        if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result = func.apply(value, args);
            result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
            return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
    };
});
arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
    var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName);
    lodash.prototype[methodName] = function () {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function (value) {
            return func.apply(isArray(value) ? value : [], args);
        });
    };
});
baseForOwn(LazyWrapper.prototype, function (func, methodName) {
    var lodashFunc = lodash[methodName];
    if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
    }
});
realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
        'name': 'wrapper',
        'func': undefined
    }];
LazyWrapper.prototype.clone = lazyClone;
LazyWrapper.prototype.reverse = lazyReverse;
LazyWrapper.prototype.value = lazyValue;
lodash.prototype.at = seq.at;
lodash.prototype.chain = seq.wrapperChain;
lodash.prototype.commit = seq.commit;
lodash.prototype.next = seq.next;
lodash.prototype.plant = seq.plant;
lodash.prototype.reverse = seq.reverse;
lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = seq.value;
lodash.prototype.first = lodash.prototype.head;
if (symIterator) {
    lodash.prototype[symIterator] = seq.toIterator;
}
const CONFIG$1 = {
    TEST: {
        USER: "Luigi Test",
        EMAIL: "luigi.test05@gmail.com",
        CANVAS: false,
        ATTRIBUTE: false,
        PALETTE: false,
        ACTIVITY: false,
    },
    LAYER: {
        META: "META",
        MODEL: "MODEL",
    },
    WIDGET: {
        NAME: {
            MAIN: "Canvas",
            PALETTE: "Palette",
            ATTRIBUTE: "Property Browser",
            ACTIVITY: "User Activity",
            GUIDANCE: "Guidance",
            HEATMAP: "Heatmap",
            METADATA: "METADATA",
            OPENAPI: "Metadata Widget",
            DEBUG: "Debug",
            IMSLD_EXPORT: "IMSLD Export",
            JSON_EXPORT: "JSON Export",
            VIEWCONTROL: "View Control",
        },
    },
    ENTITY: {
        NODE: "node",
        EDGE: "edge",
        ATTR: "attr",
        VAL: "val",
    },
    IWC: {
        FLAG: {
            PUBLISH_GLOBAL: "PUBLISH_GLOBAL",
            PUBLISH_LOCAL: "PUBLISH_LOCAL",
        },
        ACTION: {
            SYNC: "ACTION_SYNC",
            DATA: "ACTION_DATA",
            DATA_ARRAY: "ACTION_DATA_ARRAY",
        },
        POSITION: {
            NODE: {
                ADD: 0,
                DEL: 0,
                POS: 1,
                Z: 2,
                DIM: 3,
            },
            EDGE: {
                ADD: 0,
                DEL: 0,
                MOV: 1,
            },
            ATTR: {
                ADD: 0,
                DEL: 0,
            },
        },
    },
    OPERATION: {
        TYPE: {
            INSERT: "insert",
            UPDATE: "update",
            DELETE: "delete",
        },
    },
    ACTIVITY: {
        TYPE: {
            NODEADD: 0,
            EDGEADD: 1,
            NODEDEL: 2,
            EDGEDEL: 3,
            NODEATTRCHANGE: 4,
        },
    },
    DATA: {
        RELATION: {
            GLOBAL: {
                MAIN: {
                    MAIN: {
                        OPERATION: "MAIN2MAIN4OPERATION",
                    },
                },
            },
            LOCAL: {
                PALETTE: {
                    MAIN: {
                        TOOLSELECTION: "PALETTE2MAIN4TOOLSELECTION",
                    },
                },
                MAIN: {
                    ATTRIBUTE: {
                        NODESELECTION: "MAIN2ATTRIBUTE4NODESELECTION",
                        NODEADDITION: "MAIN2ATTRIBUTE4NODEADDITION",
                        ATTRIBUTECHANGE: "MAIN2ATTRIBUTE4ATTRIBUTECHANGE",
                    },
                    ACTIVITY: {
                        NEWACTIVITY: "MAIN2ACTIVITY4NEWACTIVITY",
                    },
                    PALETTE: {
                        TOOLSELECTION: "MAIN2PALETTE4TOOLSELECTION",
                    },
                },
                ATTRIBUTE: {
                    MAIN: {
                        ATTRIBUTECHANGE: "ATTRIBUTE2MAIN4ATTRIBUTECHANGE",
                    },
                },
            },
        },
    },
    NS: {
        PERSON: {
            TITLE: "http://purl.org/dc/terms/title",
            JABBERID: "http://xmlns.com/foaf/0.1/jabberID",
            MBOX: "http://xmlns.com/foaf/0.1/mbox",
        },
        MY: {
            MODEL: "my:ns:model",
            METAMODEL: "my:ns:metamodel",
            INSTANCE: "my:ns:instance",
            VIEWPOINT: "my:ns:viewpoint",
            VIEW: "my:ns:view",
            COPY: "my:ns:copy",
            GUIDANCEMODEL: "my:ns:guidancemodel",
            METAMODELPREVIEW: "my:ns:metamodelpreview",
            GUIDANCEMETAMODEL: "my:ns:guidancemetamodel",
            LOGICALGUIDANCEREPRESENTATION: "my:ns:logicalguidancerepresentation",
        },
    },
};
function getWidgetTagName(name) {
    if (!name)
        return;
    if (!Object.values(CONFIG$1.WIDGET.NAME).some((n) => n.toLocaleLowerCase() === name.toLocaleLowerCase())) {
        console.warn(`Widget name ${name} is not defined in config.js. Add it to the CONFIG.WIDGET.NAME object.`);
    }
    let widgetName = name;
    widgetName = widgetName.replace(/\s+/g, "-");
    return `${widgetName}-widget`.toLowerCase();
}
function getQuerySelectorFromNode(node) {
    if (node instanceof jQuery) {
        node = node.get(0);
    }
    if (node.id) {
        return `[id="${node.id}"]`;
    }
    if (node.className) {
        return `.${node.className}`;
    }
    return null;
}
class Operation {
    constructor() { }
}
class OTOperation extends Operation {
    constructor(name, value, type, position) {
        super();
        var _sender = null;
        var _operation = {
            name: name,
            value: value,
            type: type,
            position: position
        };
        this.setSender = function (sender) {
            _sender = sender;
        };
        this.getSender = function () {
            return _sender;
        };
        this.getName = function () {
            return _operation.name;
        };
        this.getValue = function () {
            return _operation.value;
        };
        this.getType = function () {
            return _operation.type;
        };
        this.getPosition = function () {
            return _operation.position;
        };
        this.getOperationObject = function () {
            return _operation;
        };
    }
}
NonOTOperation.prototype = new Operation();
NonOTOperation.prototype.constructor = NonOTOperation;
function NonOTOperation(type, data) {
    var _sender = null;
    var _operation = {
        type: type,
        data: data
    };
    this.setSender = function (sender) {
        _sender = sender;
    };
    this.getSender = function () {
        return _sender;
    };
    this.getType = function () {
        return _operation.type;
    };
    this.getData = function () {
        return _operation.data;
    };
    this.getOperationObject = function () {
        return _operation;
    };
}
class EntityOperation {
    constructor(operationType, entityId, entityType) {
        this.triggeredBy = window.y.clientID;
        var _operationType = operationType;
        var _otOperation = null;
        var _entityId = entityId;
        var _entityType = entityType;
        this.getOperationType = function () {
            return _operationType;
        };
        this.setOTOperation = function (otOperation) {
            _otOperation = otOperation;
        };
        this._getOTOperation = function () {
            return _otOperation;
        };
        this.getEntityId = function () {
            return _entityId;
        };
        this.getEntityType = function () {
            return _entityType;
        };
        this.adjust = function (EntityManager, operation) {
            return operation;
        };
        this.inverse = function () {
            return this;
        };
    }
    static { this.TYPES = {
        AttributeAddOperation: "AttributeAddOperation",
        AttributeDeleteOperation: "AttributeDeleteOperation",
        EdgeAddOperation: "EdgeAddOperation",
        EdgeDeleteOperation: "EdgeDeleteOperation",
        NodeAddOperation: "NodeAddOperation",
        NodeDeleteOperation: "NodeDeleteOperation",
        NodeMoveOperation: "NodeMoveOperation",
        NodeMoveZOperation: "NodeMoveZOperation",
        NodeResizeOperation: "NodeResizeOperation",
        ValueChangeOperation: "ValueChangeOperation",
    }; }
    getOTOperation() {
        return this._getOTOperation();
    }
}
class NodeDeleteOperation extends EntityOperation {
    constructor(entityId, type, left, top, width, height, zIndex, containment, json) {
        super(EntityOperation.TYPES.NodeDeleteOperation, entityId, CONFIG$1.ENTITY.NODE);
        this.toJSON = function () {
            return {
                id: this.getEntityId(),
                type: this.getType(),
                left: this.getLeft(),
                top: this.getTop(),
                width: this.getWidth(),
                height: this.getHeight(),
                zIndex: this.getZIndex(),
                containment: this.getContainment(),
                json: this.getJSON(),
            };
        };
        var that = this;
        var _type = type;
        var _left = left;
        var _top = top;
        var _width = width;
        var _height = height;
        var _zIndex = zIndex;
        var _containment = containment;
        var _json = json;
        var createOTOperation = function () {
            return new OTOperation(CONFIG$1.ENTITY.NODE + ":" + that.getEntityId(), JSON.stringify({
                type: _type,
                left: _left,
                top: _top,
                width: _width,
                height: _height,
                zIndex: _zIndex,
                containment: _containment,
                json: _json,
            }), CONFIG$1.OPERATION.TYPE.UPDATE, CONFIG$1.IWC.POSITION.NODE.DEL);
        };
        this.getType = function () {
            return _type;
        };
        this.getLeft = function () {
            return _left;
        };
        this.getTop = function () {
            return _top;
        };
        this.getWidth = function () {
            return _width;
        };
        this.getHeight = function () {
            return _height;
        };
        this.getZIndex = function () {
            return _zIndex;
        };
        this.getContainment = function () {
            return _containment;
        };
        this.getJSON = function () {
            return _json;
        };
        this.getOTOperation = function () {
            var otOperation = EntityOperation.prototype.getOTOperation.call(this);
            if (otOperation === null) {
                otOperation = createOTOperation();
                this.setOTOperation(otOperation);
            }
            return otOperation;
        };
        this.adjust = function (EntityManager, operation) {
            var edge;
            switch (operation.getOperationType()) {
                case EntityOperation.TYPES.AttributeAddOperation:
                case EntityOperation.TYPES.AttributeDeleteOperation:
                    edge = EntityManager.findEdge(operation.getRootSubjectEntityId());
                    if (edge &&
                        (edge.getSource().getEntityId() === this.getEntityId() ||
                            edge.getTarget().getEntityId() === this.getEntityId())) {
                        return null;
                    }
                    if (this.getEntityId() === operation.getRootSubjectEntityId()) {
                        return null;
                    }
                    break;
                case EntityOperation.TYPES.EdgeAddOperation:
                case EntityOperation.TYPES.EdgeDeleteOperation:
                    edge = EntityManager.findEdge(operation.getEntityId());
                    if (edge &&
                        (edge.getSource().getEntityId() === this.getEntityId() ||
                            edge.getTarget().getEntityId() === this.getEntityId())) {
                        return null;
                    }
                    break;
                case EntityOperation.TYPES.NodeAddOperation:
                case EntityOperation.TYPES.NodeDeleteOperation:
                case EntityOperation.TYPES.NodeMoveOperation:
                case EntityOperation.TYPES.NodeResizeOperation:
                    if (this.getEntityId() === operation.getEntityId()) {
                        return null;
                    }
                    break;
                case EntityOperation.TYPES.ValueChangeOperation:
                    edge = EntityManager.findEdge(operation.getRootSubjectEntityId());
                    if (edge &&
                        (edge.getSource().getEntityId() === this.getEntityId() ||
                            edge.getTarget().getEntityId() === this.getEntityId())) {
                        return null;
                    }
                    if (operation.getRootSubjectEntityId() === this.getEntityId()) {
                        return null;
                    }
                    break;
            }
            return operation;
        };
        this.inverse = function () {
            return new NodeAddOperation(this.getEntityId(), this.getType(), this.getLeft(), this.getTop(), this.getWidth(), this.getHeight(), this.getZIndex(), this.getContainment(), this.getContainment(), json);
        };
    }
    static { this.TYPE = "NodeDeleteOperation"; }
    static getOperationDescription(nodeType, nodeLabel, viewId) {
        if (!nodeLabel && !viewId) {
            return "..deleted " + nodeType;
        }
        else if (!viewId) {
            return "..deleted " + nodeType + " " + nodeLabel;
        }
        else
            return "..deleted " + nodeType + " " + nodeLabel + " in View " + viewId;
    }
}
class NodeAddOperation extends EntityOperation {
    constructor(entityId, type, left, top, width, height, zIndex, containment, json = null, viewId = null, oType = null, jabberId = null, defaultLabel = null, defaultAttributeValues = null) {
        super(EntityOperation.TYPES.NodeAddOperation, entityId, CONFIG$1.ENTITY.NODE);
        var that = this;
        var _viewId = viewId;
        var _jabberId = jabberId;
        var _oType = oType;
        var _type = type;
        var _left = left;
        var _top = top;
        var _width = width;
        var _height = height;
        var _zIndex = zIndex;
        var _containment = containment;
        var _json = json;
        var _defaultLabel = defaultLabel;
        var _defaultAttributeValues = defaultAttributeValues;
        var createOTOperation = function () {
            return new OTOperation(CONFIG$1.ENTITY.NODE + ":" + that.getEntityId(), JSON.stringify({
                type: _type,
                left: _left,
                top: _top,
                width: _width,
                height: _height,
                zIndex: _zIndex,
                containment: _containment,
                json: _json,
                viewId: _viewId,
                oType: _oType,
                jabberId: _jabberId,
            }), CONFIG$1.OPERATION.TYPE.INSERT, CONFIG$1.IWC.POSITION.NODE.ADD);
        };
        this.getType = function () {
            return _type;
        };
        this.getOriginType = function () {
            return _oType;
        };
        this.getLeft = function () {
            return _left;
        };
        this.getTop = function () {
            return _top;
        };
        this.getWidth = function () {
            return _width;
        };
        this.getHeight = function () {
            return _height;
        };
        this.getZIndex = function () {
            return _zIndex;
        };
        this.getContainment = function () {
            return _containment;
        };
        this.getJSON = function () {
            return _json;
        };
        this.getViewId = function () {
            return _viewId;
        };
        this.getJabberId = function () {
            return _jabberId;
        };
        this.getDefaultLabel = function () {
            return _defaultLabel;
        };
        this.getDefaultAttributeValues = function () {
            return _defaultAttributeValues;
        };
        this.getOTOperation = function () {
            var otOperation = EntityOperation.prototype.getOTOperation.call(this);
            if (otOperation === null) {
                otOperation = createOTOperation();
                this.setOTOperation(otOperation);
            }
            return otOperation;
        };
        this.adjust = function (EntityManager, operation) {
            return operation;
        };
        this.inverse = function () {
            return new NodeDeleteOperation(this.getEntityId(), this.getType(), this.getLeft(), this.getTop(), this.getWidth(), this.getHeight(), this.getZIndex(), this.getContainment(), json);
        };
        this.toJSON = function () {
            return {
                id: this.getEntityId(),
                type: this.getType(),
                left: this.getLeft(),
                top: this.getTop(),
                width: this.getWidth(),
                height: this.getHeight(),
                zIndex: this.getZIndex(),
                containment: this.getContainment(),
                json: this.getJSON(),
                viewId: this.getViewId(),
                oType: this.getOriginType(),
                jabberId: this.getJabberId(),
                defaultLabel: this.getDefaultLabel(),
                defaultAttributeValues: this.getDefaultAttributeValues(),
                triggeredBy: this.triggeredBy,
            };
        };
    }
    static { this.TYPE = "NodeAddOperation"; }
    static getOperationDescription(nodeType, nodeLabel, viewId) {
        if (!nodeLabel && !viewId) {
            return "..created a new " + nodeType;
        }
        else if (!viewId) {
            return "..created " + nodeType + " " + nodeLabel;
        }
        else
            return ".. created " + nodeType + " " + nodeLabel + " in View " + viewId;
    }
}
class EdgeDeleteOperation extends EntityOperation {
    constructor(entityId, type, source, target, json = null) {
        super(EntityOperation.TYPES.EdgeDeleteOperation, entityId, CONFIG$1.ENTITY.EDGE);
        this.toJSON = function () {
            return {
                id: this.getEntityId(),
                type: this.getType(),
                source: this.getSource(),
                target: this.getTarget(),
                json: this.getJSON(),
            };
        };
        var that = this;
        var _type = type;
        var _source = source;
        var _target = target;
        var _json = json;
        var createOTOperation = function () {
            return new OTOperation(CONFIG$1.ENTITY.EDGE + ":" + that.getEntityId(), JSON.stringify({
                type: _type,
                source: _source,
                target: _target,
                json: _json,
            }), CONFIG$1.OPERATION.TYPE.UPDATE, CONFIG$1.IWC.POSITION.EDGE.DEL);
        };
        this.getType = function () {
            return _type;
        };
        this.getSource = function () {
            return _source;
        };
        this.getTarget = function () {
            return _target;
        };
        this.getJSON = function () {
            return _json;
        };
        this.getOTOperation = function () {
            var otOperation = EntityOperation.prototype.getOTOperation.call(this);
            if (otOperation === null) {
                otOperation = createOTOperation();
                this.setOTOperation(otOperation);
            }
            return otOperation;
        };
        this.adjust = function (EntityManager, operation) {
            switch (operation.getOperationType()) {
                case EntityOperation.TYPES.AttributeAddOperation:
                case EntityOperation.TYPES.AttributeDeleteOperation:
                    if (this.getEntityId() === operation.getRootSubjectEntityId()) {
                        return null;
                    }
                    break;
                case EntityOperation.TYPES.EdgeAddOperation:
                case EntityOperation.TYPES.EdgeDeleteOperation:
                    if (this.getEntityId() === operation.getEntityId()) {
                        return null;
                    }
                    break;
                case EntityOperation.TYPES.ValueChangeOperation:
                    if (this.getEntityId() === operation.getRootSubjectEntityId()) {
                        return null;
                    }
                    break;
            }
            return operation;
        };
        this.inverse = function () {
            return new EdgeAddOperation(this.getEntityId(), this.getType(), this.getSource(), this.getTarget());
        };
    }
    static { this.TYPE = "EdgeDeleteOperation"; }
    static getOperationDescription(edgeType, edgeLabel, viewId) {
        if (!edgeLabel && !viewId) {
            return "..deleted " + edgeType;
        }
        else if (!viewId) {
            return "..deleted " + edgeType + " " + edgeLabel;
        }
        else {
            return "..deleted " + edgeType + " " + edgeLabel + "in View " + viewId;
        }
    }
}
class EdgeAddOperation extends EntityOperation {
    constructor(entityId, type, source, target, json = null, viewId = null, oType = null, jabberId = null) {
        super(EntityOperation.TYPES.EdgeAddOperation, entityId, CONFIG$1.ENTITY.EDGE);
        this.toJSON = function () {
            return {
                id: this.getEntityId(),
                type: this.getType(),
                source: this.getSource(),
                target: this.getTarget(),
                json: this.getJSON(),
                viewId: this.getViewId(),
                oType: this.getOriginType(),
                jabberId: this.getJabberId(),
            };
        };
        var that = this;
        var _oType = oType;
        var _jabberId = jabberId;
        this.getOriginType = function () {
            return _oType;
        };
        var _viewId = viewId;
        var _type = type;
        var _source = source;
        var _target = target;
        var _json = json;
        var createOTOperation = function () {
            return new OTOperation(CONFIG$1.ENTITY.EDGE + ":" + that.getEntityId(), JSON.stringify({
                type: _type,
                source: _source,
                target: _target,
                json: _json,
                viewId: _viewId,
                oType: _oType,
                jabberId: _jabberId,
            }), CONFIG$1.OPERATION.TYPE.INSERT, CONFIG$1.IWC.POSITION.EDGE.ADD);
        };
        this.getType = function () {
            return _type;
        };
        this.getSource = function () {
            return _source;
        };
        this.getTarget = function () {
            return _target;
        };
        this.getViewId = function () {
            return _viewId;
        };
        this.getJabberId = function () {
            return _jabberId;
        };
        this.getJSON = function () {
            return _json;
        };
        this.getOTOperation = function () {
            var otOperation = EntityOperation.prototype.getOTOperation.call(this);
            if (otOperation === null) {
                otOperation = createOTOperation();
                this.setOTOperation(otOperation);
            }
            return otOperation;
        };
        this.adjust = function (EntityManager, operation) {
            return operation;
        };
        this.inverse = function () {
            return new EdgeDeleteOperation(this.getEntityId(), this.getType(), this.getSource(), this.getTarget());
        };
    }
    static { this.TYPE = "EdgeAddOperation"; }
    static getOperationDescription(edgeType, edgeLabel, sourceNodeType, sourceNodeLabel, targetNodeType, targetNodeLabel, viewId) {
        if (!edgeLabel && !viewId) {
            return ("..created a new " +
                edgeType +
                " between " +
                sourceNodeType +
                " " +
                sourceNodeLabel +
                " and " +
                targetNodeType +
                " " +
                targetNodeLabel);
        }
        else if (!viewId) {
            return ("..created " +
                edgeType +
                " " +
                edgeLabel +
                " between " +
                sourceNodeType +
                " " +
                sourceNodeLabel +
                " and " +
                targetNodeType +
                " " +
                targetNodeLabel);
        }
        else {
            return ("..created " +
                edgeType +
                " " +
                edgeLabel +
                " between " +
                sourceNodeType +
                " " +
                sourceNodeLabel +
                " and " +
                targetNodeType +
                " " +
                targetNodeLabel +
                " in View " +
                viewId);
        }
    }
}
class AttributeAddOperation extends EntityOperation {
    constructor(entityId, subjectEntityId, rootSubjectEntityId, type, data = null) {
        super(EntityOperation.TYPES.AttributeAddOperation, entityId, CONFIG$1.ENTITY.ATTR);
        var that = this;
        var _subjectEntityId = subjectEntityId;
        var _rootSubjectEntityId = rootSubjectEntityId;
        var _type = type;
        var _data = data;
        var createOTOperation = function () {
            return new OTOperation(CONFIG$1.ENTITY.ATTR + ":" + that.getEntityId(), JSON.stringify({
                type: _type,
                subjectEntityId: _subjectEntityId,
                rootSubjectEntityId: _rootSubjectEntityId,
                data: _data,
            }), CONFIG$1.OPERATION.TYPE.INSERT, CONFIG$1.IWC.POSITION.ATTR.ADD);
        };
        this.getSubjectEntityId = function () {
            return _subjectEntityId;
        };
        this.getRootSubjectEntityId = function () {
            return _rootSubjectEntityId;
        };
        this.getType = function () {
            return _type;
        };
        this.getOTOperation = function () {
            var otOperation = EntityOperation.prototype.getOTOperation.call(this);
            if (otOperation === null) {
                otOperation = createOTOperation();
                that.setOTOperation(otOperation);
            }
            return otOperation;
        };
        this.getData = function () {
            return _data;
        };
        this.adjust = function (EntityManager, operation) {
            return operation;
        };
        this.inverse = function () {
            return new AttributeDeleteOperation(that.getEntityId(), that.getSubjectEntityId(), that.getRootSubjectEntityId(), that.getType());
        };
        this.toJSON = function () {
            return {
                entityId: this.getEntityId(),
                type: this.getType(),
                subjectEntityId: this.getSubjectEntityId(),
                rootSubjectEntityId: this.getRootSubjectEntityId(),
                data: this.getData(),
            };
        };
    }
    static { this.TYPE = "AttributeAddOperation"; }
}
class AttributeDeleteOperation extends EntityOperation {
    constructor(entityId, subjectEntityId, rootSubjectEntityId, type) {
        super(EntityOperation.TYPES.AttributeDeleteOperation, entityId, CONFIG$1.ENTITY.ATTR);
        var that = this;
        var _subjectEntityId = subjectEntityId;
        var _rootSubjectEntityId = rootSubjectEntityId;
        var _type = type;
        var createOTOperation = function () {
            return new OTOperation(CONFIG$1.ENTITY.ATTR + ":" + that.getEntityId(), JSON.stringify({
                type: _type,
                subjectEntityId: _subjectEntityId,
                rootSubjectEntityId: _rootSubjectEntityId,
            }), CONFIG$1.OPERATION.TYPE.UPDATE, CONFIG$1.IWC.POSITION.ATTR.DEL);
        };
        this.getSubjectEntityId = function () {
            return _subjectEntityId;
        };
        this.getRootSubjectEntityId = function () {
            return _rootSubjectEntityId;
        };
        this.getType = function () {
            return _type;
        };
        this.getOTOperation = function () {
            var otOperation = EntityOperation.prototype.getOTOperation.call(this);
            if (otOperation === null) {
                otOperation = createOTOperation();
                that.setOTOperation(otOperation);
            }
            return otOperation;
        };
        this.adjust = function (EntityManager, operation) {
            switch (operation.getOperationType()) {
                case EntityOperation.TYPES.AttributeAddOperation:
                case EntityOperation.TYPES.AttributeDeleteOperation:
                    if (that.getRootSubjectEntityId() === operation.getRootSubjectEntityId()) {
                        return null;
                    }
                    break;
                case EntityOperation.TYPES.ValueChangeOperation:
                    if (operation.getEntityIdChain().indexOf(this.getEntityId()) !== -1) {
                        return null;
                    }
                    break;
            }
            return operation;
        };
        this.inverse = function () {
            return new AttributeAddOperation(this.getEntityId(), this.getSubjectEntityId(), this.getRootSubjectEntityId(), this.getType());
        };
        this.toJSON = function () {
            return {
                entityId: this.getEntityId(),
                type: this.getType(),
                subjectEntityId: this.getSubjectEntityId(),
                rootSubjectEntityId: this.getRootSubjectEntityId(),
            };
        };
    }
    static { this.TYPE = "AttributeDeleteOperation"; }
}
class NodeMoveOperation extends EntityOperation {
    constructor(entityId, offsetX, offsetY, jabberId) {
        super(EntityOperation.TYPES.NodeMoveOperation, entityId, CONFIG$1.ENTITY.NODE);
        this.toJSON = function () {
            return {
                id: this.getEntityId(),
                offsetX: this.getOffsetX(),
                offsetY: this.getOffsetY(),
                jabberId: this.getJabberId(),
            };
        };
        var that = this;
        var _offsetX = offsetX;
        var _offsetY = offsetY;
        var _jabberId = jabberId;
        var createOTOperation = function () {
            return new OTOperation(CONFIG$1.ENTITY.NODE + ":" + that.getEntityId(), JSON.stringify({
                offsetX: _offsetX,
                offsetY: _offsetY,
                jabberId: _jabberId,
            }), CONFIG$1.OPERATION.TYPE.UPDATE, CONFIG$1.IWC.POSITION.NODE.POS);
        };
        this.getOffsetX = function () {
            return _offsetX;
        };
        this.getOffsetY = function () {
            return _offsetY;
        };
        this.getJabberId = function () {
            return _jabberId;
        };
        this.setJabberId = function (jabberId) {
            _jabberId = jabberId;
        };
        this.getOTOperation = function () {
            var otOperation = EntityOperation.prototype.getOTOperation.call(this);
            if (otOperation === null) {
                otOperation = createOTOperation();
                this.setOTOperation(otOperation);
            }
            return otOperation;
        };
        this.adjust = function (EntityManager, operation) {
            return operation;
        };
        this.inverse = function () {
            return new NodeMoveOperation(this.getEntityId(), -this.getOffsetX(), -this.getOffsetY(), this.getJabberId());
        };
    }
    static { this.TYPE = "NodeMoveOperation"; }
    static getOperationDescription(nodeType, nodeLabel, viewId) {
        if (!nodeLabel && !viewId) {
            return "..moved " + nodeType;
        }
        else if (!viewId) {
            return "..moved " + nodeType + " " + nodeLabel;
        }
        else {
            return "..moved " + nodeType + " " + nodeLabel + " in View " + viewId;
        }
    }
}
class NodeMoveZOperation extends EntityOperation {
    constructor(entityId, offsetZ, jabberId) {
        super(EntityOperation.TYPES.NodeMoveZOperation, entityId, CONFIG$1.ENTITY.NODE);
        this.toJSON = function () {
            return {
                id: this.getEntityId(),
                offsetZ: this.getOffsetZ(),
                jabberId: this.getJabberId(),
            };
        };
        var that = this;
        var _offsetZ = offsetZ;
        var _jabberId = jabberId;
        var createOTOperation = function () {
            return new OTOperation(CONFIG$1.ENTITY.NODE + ":" + that.getEntityId(), JSON.stringify({
                offsetZ: _offsetZ,
                jabberId: _jabberId,
            }), CONFIG$1.OPERATION.TYPE.UPDATE, CONFIG$1.IWC.POSITION.NODE.Z);
        };
        this.getOffsetZ = function () {
            return _offsetZ;
        };
        this.getJabberId = function () {
            return _jabberId;
        };
        this.setJabberId = function (jabberId) {
            _jabberId = jabberId;
        };
        this.getOTOperation = function () {
            var otOperation = EntityOperation.prototype.getOTOperation.call(this);
            if (otOperation === null) {
                otOperation = createOTOperation();
                this.setOTOperation(otOperation);
            }
            return otOperation;
        };
        this.adjust = function (EntityManager, operation) {
            return operation;
        };
        this.inverse = function () {
            return new NodeMoveZOperation(this.getEntityId(), -this.getOffsetZ(), this.getJabberId());
        };
    }
    static { this.TYPE = "NodeMoveZOperation"; }
    static getOperationDescription(nodeType, nodeLabel, viewId) {
        if (!nodeLabel && !viewId) {
            return "..moved " + nodeType + " on on Z-Axis";
        }
        else if (!viewId) {
            return "..moved " + nodeType + " " + nodeLabel + " on Z-Axis";
        }
        else {
            return ("..moved " +
                nodeType +
                " " +
                nodeLabel +
                " in View " +
                viewId +
                " on Z-Axis");
        }
    }
}
class NodeResizeOperation extends EntityOperation {
    constructor(entityId, offsetX, offsetY, jabberId) {
        super(EntityOperation.TYPES.NodeResizeOperation, entityId, CONFIG$1.ENTITY.NODE);
        this.toJSON = function () {
            return {
                id: this.getEntityId(),
                offsetX: this.getOffsetX(),
                offsetY: this.getOffsetY(),
                jabberId: this.getJabberId(),
            };
        };
        var that = this;
        var _jabberId = jabberId;
        var _offsetX = offsetX;
        var _offsetY = offsetY;
        var createOTOperation = function () {
            return new OTOperation(CONFIG$1.ENTITY.NODE + ":" + that.getEntityId(), JSON.stringify({
                offsetX: _offsetX,
                offsetY: _offsetY,
                jabberId: _jabberId,
            }), CONFIG$1.OPERATION.TYPE.UPDATE, CONFIG$1.IWC.POSITION.NODE.DIM);
        };
        this.getOffsetX = function () {
            return _offsetX;
        };
        this.getOffsetY = function () {
            return _offsetY;
        };
        this.getJabberId = function () {
            return _jabberId;
        };
        this.setJabberId = function (jabberId) {
            _jabberId = jabberId;
        };
        this.getOTOperation = function () {
            var otOperation = EntityOperation.prototype.getOTOperation.call(this);
            if (otOperation === null) {
                otOperation = createOTOperation();
                this.setOTOperation(otOperation);
            }
            return otOperation;
        };
        this.adjust = function (EntityManager, operation) {
            return operation;
        };
        this.inverse = function () {
            return new NodeResizeOperation(this.getEntityId(), -this.getOffsetX(), -this.getOffsetY(), this.getJabberId());
        };
    }
    static { this.TYPE = "NodeResizeOperation"; }
    static getOperationDescription(nodeType, nodeLabel, viewId) {
        if (!nodeLabel && !viewId) {
            return "..resized " + nodeType;
        }
        else if (!viewId) {
            return "..resized " + nodeType + " " + nodeLabel;
        }
        else {
            return "..resized " + nodeType + " " + nodeLabel + " in View " + viewId;
        }
    }
}
class ValueChangeOperation extends EntityOperation {
    constructor(entityId, value, type, position, jabberId = null, fromView = null) {
        super(EntityOperation.TYPES.ValueChangeOperation, entityId, CONFIG$1.ENTITY.VAL);
        var that = this;
        var _fromView = fromView;
        var _jabberId = jabberId;
        var _value = value;
        var _type = type;
        var _position = position;
        var _remote = true;
        var _entityIdChain = [];
        var createOTOperation = function () {
            return new OTOperation(CONFIG$1.ENTITY.VAL + ":" + that.getEntityId(), _value, _type, _position, _jabberId, _fromView);
        };
        this.getJabberId = function () {
            return _jabberId;
        };
        this.setJabberId = function (jabberId) {
            _jabberId = jabberId;
        };
        this.getFromView = function () {
            return _fromView;
        };
        this.setFromView = function (fromView) {
            _fromView = fromView;
        };
        this.getValue = function () {
            return _value;
        };
        this.getType = function () {
            return _type;
        };
        this.setPosition = function (position) {
            _position = position;
        };
        this.getPosition = function () {
            return _position;
        };
        this.setRemote = function (remote) {
            _remote = remote;
        };
        this.getRemote = function () {
            return _remote;
        };
        this.setEntityIdChain = function (entityIdChain) {
            _entityIdChain = entityIdChain;
        };
        this.getEntityIdChain = function () {
            return _entityIdChain;
        };
        this.getRootSubjectEntityId = function () {
            return _entityIdChain[0];
        };
        this.getOTOperation = function () {
            var otOperation = EntityOperation.prototype.getOTOperation.call(this);
            if (otOperation === null) {
                otOperation = createOTOperation();
                this.setOTOperation(otOperation);
            }
            return otOperation;
        };
        this.adjust = function (EntityManager, operation) {
            switch (operation.getOperationType()) {
                case EntityOperation.TYPES.ValueChangeOperation:
                    if (this.getEntityId() === operation.getEntityId()) {
                        if ((this.getPosition() === operation.getPosition &&
                            this.getValue() === operation.getValue &&
                            this.getType() === CONFIG$1.OPERATION.TYPE.INSERT &&
                            operation.getType() === CONFIG$1.OPERATION.TYPE.DELETE) ||
                            (this.getType() === CONFIG$1.OPERATION.TYPE.DELETE &&
                                operation.getType() === CONFIG$1.OPERATION.TYPE.INSERT)) {
                            return null;
                        }
                        if (this.getPosition() <= operation.getPosition()) {
                            switch (this.getType()) {
                                case CONFIG$1.OPERATION.TYPE.INSERT:
                                    operation.setPosition(operation.getPosition() + 1);
                                    break;
                                case CONFIG$1.OPERATION.TYPE.DELETE:
                                    operation.setPosition(operation.getPosition() - 1);
                                    break;
                            }
                        }
                    }
                    break;
            }
            return operation;
        };
        this.inverse = function () {
            var newType, ValueChangeOperation = ValueChangeOperation;
            switch (this.getType()) {
                case CONFIG$1.OPERATION.TYPE.INSERT:
                    newType = CONFIG$1.OPERATION.TYPE.DELETE;
                    break;
                case CONFIG$1.OPERATION.TYPE.DELETE:
                    newType = CONFIG$1.OPERATION.TYPE.INSERT;
                    break;
                case CONFIG$1.OPERATION.TYPE.UPDATE:
                    newType = CONFIG$1.OPERATION.TYPE.UPDATE;
                    break;
            }
            return new ValueChangeOperation(this.getEntityId(), this.getValue(), newType, this.getPosition());
        };
        this.toJSON = function () {
            return {
                entityId: this.getEntityId(),
                value: this.getValue(),
                position: this.getPosition(),
                type: this.getType(),
                jabberId: this.getJabberId(),
            };
        };
    }
    static { this.TYPE = "ValueChangeOperation"; }
    static getOperationDescription(valueKey, entityType, entityName, viewId) {
        if (!viewId)
            return (".. changed " +
                valueKey +
                " of " +
                entityType +
                (entityName ? " " : "") +
                entityName);
        else
            return (".. changed " +
                valueKey +
                " of " +
                entityType +
                (entityName ? " " : "") +
                entityName +
                " in View " +
                viewId);
    }
}
EntitySelectOperation.TYPE = "EntitySelectOperation";
function EntitySelectOperation(selectedEntityId, selectedEntityType, jabberId) {
    var _selectedEntityId = selectedEntityId;
    var _jabberId = jabberId;
    var _selectedEntityType = selectedEntityType;
    var _nonOTOperation = null;
    this.getSelectedEntityId = function () {
        return _selectedEntityId;
    };
    this.getSelectedEntityType = function () {
        return _selectedEntityType;
    };
    this.getJabberId = function () {
        return _jabberId;
    };
    this.setNonOTOperation = function (nonOTOperation) {
        _nonOTOperation = nonOTOperation;
    };
    this.getNonOTOperation = function () {
        return _nonOTOperation;
    };
    this.toNonOTOperation = function () {
        if (_nonOTOperation === null) {
            _nonOTOperation = new NonOTOperation(EntitySelectOperation.TYPE, JSON.stringify({
                selectedEntityId: _selectedEntityId,
                selectedEntityType: _selectedEntityType,
            }));
        }
        return _nonOTOperation;
    };
}
EntitySelectOperation.prototype.toJSON = function () {
    return {
        selectedEntityId: this.getSelectedEntityId(),
        selectedEntityType: this.getSelectedEntityType(),
        jabberId: this.getJabberId(),
    };
};
class ToolSelectOperation {
    constructor(toolName, label, defaultAttributeValues = {}) {
        var selectedToolName = toolName;
        var nonOTOperation = null;
        var defaultLabel = label;
        var defaultAttributeValues = defaultAttributeValues;
        this.getSelectedToolName = function () {
            return selectedToolName;
        };
        this.getDefaultLabel = function () {
            return defaultLabel;
        };
        this.getDefaultAttributeValues = function () {
            return defaultAttributeValues;
        };
        this.toNonOTOperation = function () {
            if (nonOTOperation === null) {
                nonOTOperation = new NonOTOperation(ToolSelectOperation.TYPE, JSON.stringify({ selectedToolName: selectedToolName }));
            }
            return nonOTOperation;
        };
    }
    static { this.TYPE = "ToolSelectOperation"; }
}
class ActivityOperation {
    constructor(type, entityId, sender, text, data) {
        var _type = type;
        var _entityId = entityId;
        var _sender = sender;
        var _text = text;
        var _data = data;
        var _nonOTOperation = null;
        this.getType = function () {
            return _type;
        };
        this.getEntityId = function () {
            return _entityId;
        };
        this.getSender = function () {
            return _sender;
        };
        this.getText = function () {
            return _text;
        };
        this.getData = function () {
            return _data;
        };
        this.toNonOTOperation = function () {
            if (_nonOTOperation === null) {
                _nonOTOperation = new NonOTOperation(ActivityOperation.TYPE, JSON.stringify({
                    type: _type,
                    entityId: _entityId,
                    sender: _sender,
                    text: _text,
                    data: _data,
                }));
            }
            return _nonOTOperation;
        };
    }
    static { this.TYPE = "ActivityOperation"; }
    toJSON() {
        return {
            type: this.getType(),
            entityId: this.getEntityId(),
            sender: this.getSender(),
            text: this.getText(),
            data: this.getData(),
        };
    }
}
ExportMetaModelOperation.TYPE = "ExportMetaModelOperation";
function ExportMetaModelOperation(requestingComponent, data) {
    var _requestingComponent = requestingComponent;
    var _data = data;
    var _nonOTOperation = null;
    this.getRequestingComponent = function () {
        return _requestingComponent;
    };
    this.getData = function () {
        return _data;
    };
    this.setData = function (data) {
        _data = data;
    };
    this.toNonOTOperation = function () {
        if (_nonOTOperation === null) {
            _nonOTOperation = new NonOTOperation(ExportMetaModelOperation.TYPE, JSON.stringify({
                requestingComponent: _requestingComponent,
                data: _data,
            }));
        }
        return _nonOTOperation;
    };
}
ExportLogicalGuidanceRepresentationOperation.TYPE =
    "ExportLogicalGuidanceRepresentationOperation";
function ExportLogicalGuidanceRepresentationOperation(requestingComponent, data) {
    var _requestingComponent = requestingComponent;
    var _data = data;
    var _nonOTOperation = null;
    this.getRequestingComponent = function () {
        return _requestingComponent;
    };
    this.getData = function () {
        return _data;
    };
    this.setData = function (data) {
        _data = data;
    };
    this.toNonOTOperation = function () {
        if (_nonOTOperation === null) {
            _nonOTOperation = new NonOTOperation(ExportLogicalGuidanceRepresentationOperation.TYPE, JSON.stringify({
                requestingComponent: _requestingComponent,
                data: _data,
            }));
        }
        return _nonOTOperation;
    };
}
ExportImageOperation.TYPE = "ExportImageOperation";
function ExportImageOperation(requestingComponent, data) {
    var _requestingComponent = requestingComponent;
    var _data = data;
    var _nonOTOperation = null;
    this.getRequestingComponent = function () {
        return _requestingComponent;
    };
    this.getData = function () {
        return _data;
    };
    this.setData = function (data) {
        _data = data;
    };
    this.toNonOTOperation = function () {
        if (_nonOTOperation === null) {
            _nonOTOperation = new NonOTOperation(ExportImageOperation.TYPE, JSON.stringify({
                requestingComponent: _requestingComponent,
                data: _data,
            }));
        }
        return _nonOTOperation;
    };
}
class SetViewTypesOperation {
    constructor(flag) {
        this.getFlag = function () {
            return this._flag;
        };
        this.toNonOTOperation = function () {
            if (this.nonOTOperation === null) {
                this.nonOTOperation = new NonOTOperation(SetViewTypesOperation.TYPE, JSON.stringify({ flag: this._flag }));
            }
            return this.nonOTOperation;
        };
        this._flag = flag;
        this.nonOTOperation = null;
    }
    static { this.TYPE = "SetViewTypesOperation"; }
}
class InitModelTypesOperation {
    constructor(vls, startViewGeneration) {
        this.nonOTOperation = null;
        this.getVLS = function () {
            return this._vls;
        };
        this.getViewGenerationFlag = function () {
            return this._startViewGeneration;
        };
        this.toNonOTOperation = function () {
            if (this.nonOTOperation === null) {
                this.nonOTOperation = new NonOTOperation(InitModelTypesOperation.TYPE, JSON.stringify({
                    vls: this._vls,
                    startViewGeneration: this._startViewGeneration,
                }));
            }
            return this.nonOTOperation;
        };
        this._vls = vls;
        this._startViewGeneration = startViewGeneration;
    }
    static { this.TYPE = "InitModelTypesOperation"; }
}
ViewInitOperation.TYPE = "ViewInitOperation";
function ViewInitOperation(data, viewpoint) {
    var _data = data;
    var _viewpoint = viewpoint;
    var nonOTOperation = null;
    this.getData = function () {
        return _data;
    };
    this.getViewpoint = function () {
        return _viewpoint;
    };
    this.toNonOTOperation = function () {
        if (nonOTOperation === null) {
            nonOTOperation = new NonOTOperation(ViewInitOperation.TYPE, JSON.stringify({ data: _data, viewpoint: _viewpoint }));
        }
        return nonOTOperation;
    };
}
class DeleteViewOperation {
    constructor(viewId) {
        var _viewId = viewId;
        var nonOTOperation = null;
        this.getViewId = function () {
            return _viewId;
        };
        this.toNonOTOperation = function () {
            if (nonOTOperation === null) {
                nonOTOperation = new NonOTOperation(DeleteViewOperation.TYPE, JSON.stringify({ viewId: _viewId }));
            }
            return nonOTOperation;
        };
    }
    static { this.TYPE = "DeleteViewOperation"; }
}
SetModelAttributeNodeOperation.TYPE = "SetModelAttributeNodeOperation";
function SetModelAttributeNodeOperation() {
    var nonOTOperation = null;
    this.toNonOTOperation = function () {
        if (nonOTOperation === null) {
            nonOTOperation = new NonOTOperation(SetModelAttributeNodeOperation.TYPE, JSON.stringify({ empty: "empty" }));
        }
        return nonOTOperation;
    };
}
UpdateViewListOperation.TYPE = "UpdateViewListOperation";
function UpdateViewListOperation() {
    var nonOTOperation = null;
    this.toNonOTOperation = function () {
        if (nonOTOperation === null) {
            nonOTOperation = new NonOTOperation(UpdateViewListOperation.TYPE, JSON.stringify({}));
        }
        return nonOTOperation;
    };
}
ShowGuidanceBoxOperation.TYPE = "ShowGuidanceBoxOperation";
function ShowGuidanceBoxOperation(label, guidance, entityId) {
    var nonOTOperation = null;
    var _label = label;
    var _guidance = guidance;
    var _entityId = entityId;
    this.getLabel = function () {
        return _label;
    };
    this.getGuidance = function () {
        return _guidance;
    };
    this.getEntityId = function () {
        return _entityId;
    };
    this.toNonOTOperation = function () {
        if (nonOTOperation === null) {
            nonOTOperation = new NonOTOperation(ShowGuidanceBoxOperation.TYPE, JSON.stringify({
                label: _label,
                guidance: _guidance,
                entityId: _entityId,
            }));
        }
        return nonOTOperation;
    };
}
CanvasViewChangeOperation.TYPE = "CanvasViewChangeOperation";
function CanvasViewChangeOperation(left, top, width, height, zoom) {
    var _nonOTOperation = null;
    this.getLeft = function () {
        return left;
    };
    this.getTop = function () {
        return top;
    };
    this.getWidth = function () {
        return width;
    };
    this.getHeight = function () {
        return height;
    };
    this.getZoom = function () {
        return zoom;
    };
    this.setNonOTOperation = function (nonOTOperation) {
        _nonOTOperation = nonOTOperation;
    };
    this.getNonOTOperation = function () {
        return _nonOTOperation;
    };
    this.toNonOTOperation = function () {
        if (_nonOTOperation === null) {
            _nonOTOperation = new NonOTOperation(CanvasViewChangeOperation.TYPE, JSON.stringify({
                left: left,
                top: top,
                width: width,
                height: height,
                zoom: zoom,
            }));
        }
        return _nonOTOperation;
    };
}
RevokeSharedActivityOperation.TYPE = "RevokeSharedActivityOperation";
function RevokeSharedActivityOperation(id) {
    var _nonOTOperation = null;
    this.getId = function () {
        return id;
    };
    this.setNonOTOperation = function (nonOTOperation) {
        _nonOTOperation = nonOTOperation;
    };
    this.getNonOTOperation = function () {
        return _nonOTOperation;
    };
    this.toNonOTOperation = function () {
        if (_nonOTOperation === null) {
            _nonOTOperation = new NonOTOperation(RevokeSharedActivityOperation.TYPE, JSON.stringify({
                id: id,
            }));
        }
        return _nonOTOperation;
    };
}
RevokeSharedActivityOperation.prototype.toJSON = function () {
    return { id: this.getId() };
};
CollaborateInActivityOperation.TYPE = "CollaborateInActivityOperation";
function CollaborateInActivityOperation(id) {
    var _nonOTOperation = null;
    this.getId = function () {
        return id;
    };
    this.setNonOTOperation = function (nonOTOperation) {
        _nonOTOperation = nonOTOperation;
    };
    this.getNonOTOperation = function () {
        return _nonOTOperation;
    };
    this.toNonOTOperation = function () {
        if (_nonOTOperation === null) {
            _nonOTOperation = new NonOTOperation(CollaborateInActivityOperation.TYPE, JSON.stringify({
                id: id,
            }));
        }
        return _nonOTOperation;
    };
}
MoveCanvasOperation.TYPE = "MoveCanvasOperation";
function MoveCanvasOperation(objectId, transition) {
    var _nonOTOperation = null;
    this.getObjectId = function () {
        return objectId;
    };
    this.getTransition = function () {
        return transition;
    };
    this.setNonOTOperation = function (nonOTOperation) {
        _nonOTOperation = nonOTOperation;
    };
    this.getNonOTOperation = function () {
        return _nonOTOperation;
    };
    this.toNonOTOperation = function () {
        if (_nonOTOperation === null) {
            _nonOTOperation = new NonOTOperation(MoveCanvasOperation.TYPE, JSON.stringify({
                objectId: objectId,
                transition: transition,
            }));
        }
        return _nonOTOperation;
    };
}
class GuidanceStrategyOperation {
    constructor(data) {
        var _nonOTOperation = null;
        this.getData = function () {
            return data;
        };
        this.setNonOTOperation = function (nonOTOperation) {
            _nonOTOperation = nonOTOperation;
        };
        this.getNonOTOperation = function () {
            return _nonOTOperation;
        };
        this.toNonOTOperation = function () {
            if (_nonOTOperation === null) {
                _nonOTOperation = new NonOTOperation(GuidanceStrategyOperation.TYPE, JSON.stringify({
                    data: data,
                }));
            }
            return _nonOTOperation;
        };
    }
    static { this.TYPE = "GuidanceStrategyOperation"; }
    toJSON() {
        return { data: this.getData() };
    }
}
UpdateMetamodelOperation.TYPE = "UpdateMetamodelOperation";
function UpdateMetamodelOperation(metaModelingRoomName, modelingRoomName) {
    var _metaModelingRoomName = metaModelingRoomName;
    var _modelingRoomName = modelingRoomName;
    var _nonOTOperation = null;
    this.getMetaModelingRoomName = function () {
        return _metaModelingRoomName;
    };
    this.getModelingRoomName = function () {
        return _modelingRoomName;
    };
    this.toNonOTOperation = function () {
        if (_nonOTOperation === null) {
            _nonOTOperation = new NonOTOperation(UpdateMetamodelOperation.TYPE, JSON.stringify({ empty: "empty" }));
        }
        return _nonOTOperation;
    };
}
UpdateMetamodelOperation.prototype.toJSON = function () {
    return {};
};
function OperationFactory() {
    return {
        createOperationFromNonOTOperation: function (operation) {
            var type = operation.getType(), data, resOperation;
            try {
                data = JSON.parse(operation.getData());
            }
            catch (e) {
                console.error("Not able to parse data to JSON. Check the corresponding operation");
                return null;
            }
            switch (type) {
                case EntitySelectOperation.TYPE:
                    resOperation = new EntitySelectOperation(data.selectedEntityId, data.selectedEntityType, data.jabberId);
                    resOperation.setNonOTOperation(operation);
                    break;
                case ToolSelectOperation.TYPE:
                    resOperation = new ToolSelectOperation(data.selectedToolName, data.name, data.defaultAttributeValues);
                    break;
                case ActivityOperation.TYPE:
                    resOperation = new ActivityOperation(data.type, data.entityId, data.sender, data.text, data.data);
                    break;
                case ExportMetaModelOperation.TYPE:
                    resOperation = new ExportMetaModelOperation(data.requestingComponent, data.data);
                    break;
                case ExportLogicalGuidanceRepresentationOperation.TYPE:
                    resOperation = new ExportLogicalGuidanceRepresentationOperation(data.requestingComponent, data.data);
                    break;
                case ExportImageOperation.TYPE:
                    resOperation = new ExportImageOperation(data.requestingComponent, data.data);
                    break;
                case SetViewTypesOperation.TYPE:
                    resOperation = new SetViewTypesOperation(data.flag);
                    break;
                case InitModelTypesOperation.TYPE:
                    resOperation = new InitModelTypesOperation(data.vls, data.startViewGeneration);
                    break;
                case ViewInitOperation.TYPE:
                    resOperation = new ViewInitOperation(data.data, data.viewpoint);
                    break;
                case DeleteViewOperation.TYPE:
                    resOperation = new DeleteViewOperation(data.viewId);
                    break;
                case ShowGuidanceBoxOperation.TYPE:
                    resOperation = new ShowGuidanceBoxOperation(data.label, data.guidance, data.entityId);
                    break;
                case SetModelAttributeNodeOperation.TYPE:
                    resOperation = new SetModelAttributeNodeOperation();
                    break;
                case UpdateViewListOperation.TYPE:
                    resOperation = new UpdateViewListOperation();
                    break;
                case CanvasViewChangeOperation.TYPE:
                    resOperation = new CanvasViewChangeOperation(data.left, data.top, data.width, data.height, data.zoom);
                    resOperation.setNonOTOperation(operation);
                    break;
                case RevokeSharedActivityOperation.TYPE:
                    resOperation = new RevokeSharedActivityOperation(data.id);
                    break;
                case CollaborateInActivityOperation.TYPE:
                    resOperation = new CollaborateInActivityOperation(data.id);
                    break;
                case MoveCanvasOperation.TYPE:
                    resOperation = new MoveCanvasOperation(data.objectId, data.transition);
                    break;
                case GuidanceStrategyOperation.TYPE:
                    resOperation = new GuidanceStrategyOperation(data.data);
                    resOperation.setNonOTOperation(operation);
                    break;
                case UpdateMetamodelOperation.TYPE:
                    resOperation = new UpdateMetamodelOperation(data.metamodelingRoomName, data.modelingRoomName);
                    break;
                default:
                    resOperation = new NonOTOperation(type, data);
                    break;
            }
            return resOperation;
        },
        createOperationFromOTOperation: function (operation) {
            var value;
            var entityType;
            var entityId;
            var components = operation.getName().split(":");
            var resOperation;
            if (components.length === 2) {
                entityType = components[0];
                entityId = components[1];
                switch (entityType) {
                    case CONFIG$1.ENTITY.NODE:
                        try {
                            value = JSON.parse(operation.getValue());
                        }
                        catch (e) {
                            return null;
                        }
                        switch (operation.getPosition()) {
                            case CONFIG$1.IWC.POSITION.NODE.ADD:
                                switch (operation.getType()) {
                                    case CONFIG$1.OPERATION.TYPE.INSERT:
                                        resOperation = new NodeAddOperation(entityId, value.type, value.left, value.top, value.width, value.height, value.zIndex, value.containment, value.json, value.viewId, value.oType, value.jabberId);
                                        break;
                                    case CONFIG$1.OPERATION.TYPE.UPDATE:
                                        resOperation = new NodeDeleteOperation(entityId, value.type, value.left, value.top, value.width, value.height, value.zIndex, value.containment, value.json);
                                        break;
                                }
                                break;
                            case CONFIG$1.IWC.POSITION.NODE.POS:
                                resOperation = new NodeMoveOperation(entityId, value.offsetX, value.offsetY, value.jabberId);
                                break;
                            case CONFIG$1.IWC.POSITION.NODE.Z:
                                resOperation = new NodeMoveZOperation(entityId, value.offsetZ, value.jabberId);
                                break;
                            case CONFIG$1.IWC.POSITION.NODE.DIM:
                                resOperation = new NodeResizeOperation(entityId, value.offsetX, value.offsetY, value.jabberId);
                                break;
                        }
                        break;
                    case CONFIG$1.ENTITY.EDGE:
                        try {
                            value = JSON.parse(operation.getValue());
                        }
                        catch (e) {
                            return null;
                        }
                        switch (operation.getType()) {
                            case CONFIG$1.OPERATION.TYPE.INSERT:
                                resOperation = new EdgeAddOperation(entityId, value.type, value.source, value.target, value.json, value.viewId, value.oType, value.jabberId);
                                break;
                            case CONFIG$1.OPERATION.TYPE.UPDATE:
                                resOperation = new EdgeDeleteOperation(entityId, value.type, value.source, value.target, value.json);
                                break;
                        }
                        break;
                    case CONFIG$1.ENTITY.ATTR:
                        try {
                            value = JSON.parse(operation.getValue());
                        }
                        catch (e) {
                            return null;
                        }
                        switch (operation.getType()) {
                            case CONFIG$1.OPERATION.TYPE.INSERT:
                                resOperation = new AttributeAddOperation(entityId, value.subjectEntityId, value.rootSubjectEntityId, value.type, value.data);
                                break;
                            case CONFIG$1.OPERATION.TYPE.UPDATE:
                                resOperation = new AttributeDeleteOperation(entityId, value.subjectEntityId, value.rootSubjectEntityId, value.type);
                                break;
                        }
                        break;
                    case CONFIG$1.ENTITY.VAL:
                        resOperation = new ValueChangeOperation(entityId, operation.getValue(), operation.getType(), operation.getPosition(), null);
                        break;
                }
            }
            if (resOperation !== null) {
                resOperation.setOTOperation(operation);
            }
            return resOperation;
        },
    };
}
var OperationFactory$1 = OperationFactory();
class OpenAppProvider {
    constructor() {
        var openapp = {};
        this.openapp = openapp;
        openapp["event"] = {};
        var gadgets = "undefined" !== typeof this.gadgets ? this.gadgets : {};
        this.gadgets = gadgets;
        gadgets.openapp = gadgets.openapp || {};
        var usePostMessage = "undefined" !== typeof window &&
            "undefined" !== typeof window.parent &&
            "undefined" !== typeof window.postMessage &&
            "undefined" !== typeof JSON &&
            "undefined" !== typeof JSON.parse &&
            "undefined" !== typeof JSON.stringify, usePubSub = !usePostMessage &&
            "undefined" !== typeof gadgets &&
            "undefined" !== typeof gadgets.pubsub &&
            "undefined" !== typeof gadgets.pubsub.subscribe &&
            "undefined" !== typeof gadgets.pubsub.unsubscribe &&
            "undefined" !== typeof gadgets.pubsub.publish, init = { postParentOnly: true }, ownData, doCallback, onMessage;
        usePostMessage
            ? ((onMessage = function (a) {
                if ("string" === typeof a.data &&
                    '{"OpenApplicationEvent":{' === a.data.slice(0, 25)) {
                    var b = JSON.parse(a.data).OpenApplicationEvent;
                    if ("openapp" === b.event &&
                        !0 === b.welcome &&
                        a.source === window.parent) {
                        for (var d in b.message) {
                            b.message.hasOwnProperty(d) && (init[d] = b.message[d]);
                        }
                    }
                    else {
                        (b.source = a.source),
                            (b.origin = a.origin),
                            (b.toJSON = function () {
                                var a = {}, b;
                                for (b in this) {
                                    this.hasOwnProperty(b) &&
                                        "function" !== typeof this[b] &&
                                        "source" !== b &&
                                        "origin" !== b &&
                                        (a[b] = this[b]);
                                }
                                return a;
                            }),
                            "function" === typeof doCallback &&
                                !0 === doCallback(b, b.message) &&
                                window.parent.postMessage(JSON.stringify({
                                    OpenApplicationEvent: { event: "openapp", receipt: !0 },
                                }), "*");
                    }
                }
            }),
                "undefined" !== typeof window.attachEvent
                    ?
                        window.attachEvent("onmessage", onMessage)
                    : window.addEventListener("message", onMessage, !1),
                "undefined" !== typeof window.parent &&
                    window.parent.postMessage(JSON.stringify({
                        OpenApplicationEvent: { event: "openapp", hello: !0 },
                    }), "*"))
            : usePubSub &&
                (onMessage = function (a, b) {
                    b.source = void 0;
                    b.origin = void 0;
                    b.sender = a;
                    "function" === typeof doCallback &&
                        !0 === doCallback(b, b.message) &&
                        gadgets.pubsub.publish("openapp-recieve", !0);
                });
        gadgets.openapp.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
        gadgets.openapp.connect = function (a) {
            doCallback = a;
            usePubSub && gadgets.pubsub.subscribe("openapp", onMessage);
        };
        gadgets.openapp.disconnect = function () {
            usePubSub && gadgets.pubsub.unsubscribe("openapp");
            doCallback = null;
        };
        gadgets.openapp.publish = function (a, b) {
            a.event = a.event || "select";
            a.type = a.type || "namespaced-properties";
            a.sharing = a.sharing || "public";
            a.date = a.date || new Date();
            a.message = b || a.message;
            if (usePostMessage) {
                if (!1 === init.postParentOnly && null === ownData) {
                    ownData = { sender: "unknown", viewer: "unknown" };
                    if ("undefined" !== typeof window.location &&
                        "string" === typeof window.location.search &&
                        "function" === typeof window.unescape) {
                        var d = window.location.search.substring(1).split("&"), c, e = {};
                        if (!(1 == d.length && "" === d[0])) {
                            for (var f = 0; f < d.length; f++) {
                                (c = d[f].split("=")),
                                    2 == c.length && (e[c[0]] = window.unescape(c[1]));
                            }
                        }
                        "string" === typeof e.url && (ownData.sender = e.url);
                    }
                    if ("undefined" !== typeof opensocial &&
                        "function" === typeof opensocial.newDataRequest) {
                        d = opensocial.newDataRequest();
                        d.add(d.newFetchPersonRequest(opensocial.IdSpec.PersonId.VIEWER), "viewer");
                        var g = this;
                        d.send(function (c) {
                            c = c.get("viewer").getData();
                            "object" === typeof c &&
                                null !== c &&
                                "function" === typeof c.getId &&
                                ((c = c.getId()),
                                    "string" === typeof c && (ownData.viewer = c));
                            g.publish(a, b);
                        });
                        return;
                    }
                }
                null !== ownData &&
                    ("string" === typeof ownData.sender && (a.sender = ownData.sender),
                        "string" === typeof ownData.viewer && (a.viewer = ownData.viewer));
                d = JSON.stringify({ OpenApplicationEvent: a });
                if ("undefined" !== window.parent) {
                    if ((window.parent.postMessage(d, "*"), !init.postParentOnly)) {
                        c = window.parent.frames;
                        for (e = 0; e < c.length; e++) {
                            c[e].postMessage(d, "*");
                        }
                    }
                }
                else {
                    window.postMessage(d, "*");
                }
            }
            else {
                usePubSub && gadgets.pubsub.publish("openapp", a);
            }
        };
        openapp["io"] = {};
        openapp["io"].createXMLHttpRequest = function () {
            if ("undefined" !== typeof XMLHttpRequest) {
                return new XMLHttpRequest();
            }
            if ("undefined" !== typeof ActiveXObject) {
                return new ActiveXObject("Microsoft.XMLHTTP");
            }
            throw {
                name: "XMLHttpRequestError",
                message: "XMLHttpRequest not supported",
            };
        };
        openapp["io"].makeRequest = function (a, b, d) {
            gadgets.io.makeRequest(a, function (c) {
                var e, f, g, h, j, k, l, p;
                if (null === document.getElementById("oauthPersonalize")) {
                    e = document.createElement("div");
                    f = document.createElement("input");
                    g = document.createElement("input");
                    h = document.createElement("div");
                    j = document.createElement("input");
                    k = document.createElement("div");
                    l = document.createElement("span");
                    p = document.createElement("input");
                    e.id = "oauthPersonalize";
                    f.id = "oauthPersonalizeButton";
                    g.id = "oauthPersonalizeDenyButton";
                    h.id = "oauthPersonalizeDone";
                    j.id = "oauthPersonalizeDoneButton";
                    k.id = "oauthPersonalizeComplete";
                    l.id = "oauthPersonalizeMessage";
                    p.id = "oauthPersonalizeHideButton";
                    f.id = "oauthPersonalizeButton";
                    e.style.display = "none";
                    h.style.display = "none";
                    k.style.display = "none";
                    f.type = "button";
                    g.type = "button";
                    j.type = "button";
                    p.type = "button";
                    f.value = "Continue";
                    g.value = "Ignore";
                    j.value = "Done";
                    p.value = "Hide";
                    e.appendChild(document.createTextNode("In order to provide the full functionality of this tool, access to your personal data is being requested."));
                    h.appendChild(document.createTextNode("If you have provided authorization and are still reading this, click the Done button."));
                    var m = document.getElementById("openappDialog");
                    null == m &&
                        ((m = document.createElement("div")),
                            null != document.body.firstChild
                                ? document.body.insertBefore(m, document.body.firstChild)
                                : document.body.appendChild(m));
                    m.appendChild(e);
                    m.appendChild(h);
                    m.appendChild(k);
                    e.appendChild(f);
                    e.appendChild(g);
                    h.appendChild(j);
                    k.appendChild(l);
                    k.appendChild(p);
                    g.onclick = function () {
                        e.style.display = "none";
                    };
                    p.onclick = function () {
                        k.style.display = "none";
                    };
                }
                if (c.oauthApprovalUrl) {
                    var r = function () {
                        q && (window.clearInterval(q), (q = null));
                        n && (n.close(), (n = null));
                        document.getElementById("oauthPersonalizeDone").style.display =
                            "none";
                        document.getElementById("oauthPersonalizeComplete").style.display = "block";
                        openapp["io"].makeRequest(a, b, d);
                        return !1;
                    }, s = function () {
                        if (!n || n.closed) {
                            (n = null), r();
                        }
                    }, t = c.oauthApprovalUrl, n = null, q = null;
                    c = {
                        createOpenerOnClick: function () {
                            return function () {
                                if ((n = window.open(t, "_blank", "width=450,height=500"))) {
                                    (q = window.setInterval(s, 100)),
                                        (document.getElementById("oauthPersonalize").style.display = "none"),
                                        (document.getElementById("oauthPersonalizeDone").style.display = "block");
                                }
                                return !1;
                            };
                        },
                        createApprovedOnClick: function () {
                            return r;
                        },
                    };
                    document.getElementById("oauthPersonalizeButton").onclick =
                        c.createOpenerOnClick();
                    document.getElementById("oauthPersonalizeDoneButton").onclick =
                        c.createApprovedOnClick();
                    f = "Please wait.";
                    document.all
                        ?
                            (document.getElementById("oauthPersonalizeMessage").innerText =
                                f)
                        :
                            (document.getElementById("oauthPersonalizeMessage").textContent = f);
                    document.getElementById("oauthPersonalize").style.display = "block";
                }
                else {
                    c.oauthError
                        ? ((f =
                            "The authorization was not completed successfully. (" +
                                c.oauthError +
                                ")"),
                            document.all
                                ?
                                    (document.getElementById("oauthPersonalizeMessage").innerText = f)
                                :
                                    (document.getElementById("oauthPersonalizeMessage").textContent = f),
                            (document.getElementById("oauthPersonalizeComplete").style.display = "block"))
                        : ((f =
                            "You have now granted authorization. To revoke authorization, go to your Privacy settings."),
                            document.all
                                ?
                                    (document.getElementById("oauthPersonalizeMessage").innerText = f)
                                :
                                    (document.getElementById("oauthPersonalizeMessage").textContent = f),
                            b(c));
                }
            }, d);
        };
        openapp["ns"] = {};
        openapp["ns"].rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
        openapp["ns"].rdfs = "http://www.w3.org/2000/01/rdf-schema#";
        openapp["ns"].dcterms = "http://purl.org/dc/terms/";
        openapp["ns"].foaf = "http://xmlns.com/foaf/0.1/";
        openapp["ns"].rest = "http://purl.org/openapp/";
        openapp["ns"].conserve = "http://purl.org/openapp/";
        openapp["ns"].openapp = "http://purl.org/openapp/";
        openapp["ns"].role = "http://purl.org/role/terms/";
        openapp["ns"].widget = "http://purl.org/role/widget/";
        openapp["resource"] = {};
        var linkexp = /<[^>]*>\s*(\s*;\s*[^\(\)<>@,;:"\/\[\]\?={} \t]+=(([^\(\)<>@,;:"\/\[\]\?={} \t]+)|("[^"]*")))*(,|\$)/g, paramexp = /[^\(\)<>@,;:"\/\[\]\?={} \t]+=(([^\(\)<>@,;:"\/\[\]\?={} \t]+)|("[^"]*"))/g;
        function unquote(a) {
            return '"' === a.charAt(0) && '"' === a.charAt(a.length - 1)
                ? a.substring(1, a.length - 1)
                : a;
        }
        function parseLinkHeader(a) {
            var b = (a + ",").match(linkexp);
            a = {};
            var d = {}, c = {}, e, f, g, h, j, k;
            for (e = 0; e < b.length; e++) {
                f = b[e].split(">");
                g = f[0].substring(1);
                h = f[1];
                f = {};
                f.href = g;
                g = h.match(paramexp);
                for (h = 0; h < g.length; h++) {
                    (j = g[h]), (j = j.split("=")), (k = j[0]), (f[k] = unquote(j[1]));
                }
                void 0 !== f.rel && "undefined" === typeof f.anchor && (a[f.rel] = f);
                void 0 !== f.title &&
                    "undefined" === typeof f.anchor &&
                    (d[f.title] = f);
                g = c[f.anchor || ""] || {};
                h = g[f.rel || "http://purl.org/dc/terms/relation"] || [];
                h.push({ type: "uri", value: f.href });
                g[f.rel || "http://purl.org/dc/terms/relation"] = h;
                c[f.anchor || ""] = g;
            }
            b = {};
            b.rels = a;
            b.titles = d;
            b.rdf = c;
            return b;
        }
        var isStringValue = function (a) {
            return "" !== a && "string" === typeof a;
        };
        openapp["resource"].makeRequest = function (a, b, d, c, e, f) {
            var g = openapp["io"].createXMLHttpRequest(), h, j = 0;
            if ("undefined" !== typeof c) {
                for (h in c) {
                    c.hasOwnProperty(h) && j++;
                }
                if (0 < j) {
                    j = "";
                    -1 !== b?.indexOf("?") &&
                        ((j = b?.substring(b.indexOf("?"))),
                            (b = b?.substring(0, b.length - j.length)));
                    switch (b?.substring(b.length - 1)) {
                        case "/":
                            b += ":";
                            break;
                        case ":":
                            break;
                        default:
                            b += "/:";
                    }
                    for (h in c) {
                        c.hasOwnProperty(h) &&
                            (b =
                                h === openapp["ns"].rdf + "predicate"
                                    ? b + (";predicate=" + encodeURIComponent(c[h]))
                                    : b +
                                        (";" +
                                            encodeURIComponent(h) +
                                            "=" +
                                            encodeURIComponent(c[h])));
                    }
                    b += j;
                }
            }
            g.open(a, b, !0);
            g.setRequestHeader("Accept", "application/json");
            e = e || "";
            if (0 < e.length || "POST" === a || "PUT" === a) {
                g.setRequestHeader("Content-Type", "undefined" !== typeof f ? f : "application/json");
            }
            d = d || function () { };
            g.onreadystatechange = function () {
                if (4 === g.readyState) {
                    var a = {
                        data: g.responseText,
                        link: isStringValue(g.getResponseHeader("link"))
                            ? parseLinkHeader(g.getResponseHeader("link"))
                            : {},
                    };
                    isStringValue(g.getResponseHeader("location"))
                        ? (a["uri"] = g.getResponseHeader("location"))
                        : isStringValue(g.getResponseHeader("content-base"))
                            ? (a["uri"] = g.getResponseHeader("content-base"))
                            : a["link"].hasOwnProperty("http://purl.org/dc/terms/subject") &&
                                (a["uri"] = a["link"]["http://purl.org/dc/terms/subject"].href);
                    isStringValue(g.getResponseHeader("content-location")) &&
                        (a["contentUri"] = g.getResponseHeader("content-location"));
                    isStringValue(g.getResponseHeader("content-type")) &&
                        "application/json" ===
                            g.getResponseHeader("content-type").split(";")[0] &&
                        (a.data = JSON.parse(a.data));
                    a["subject"] =
                        "undefined" !== typeof g.responseText
                            ? a.data.hasOwnProperty("")
                                ? a.data[""]
                                : a.data[a["uri"]] || {}
                            : {};
                    d(a);
                }
            };
            g.send(e);
        };
        "undefined" === typeof openapp_forceXhr &&
            "undefined" !== typeof gadgets &&
            "undefined" !== typeof gadgets.io &&
            "undefined" !== typeof gadgets.io.makeRequest &&
            (openapp["resource"].makeRequest = function (a, b, d, c, e, f) {
                var g = {}, h, j = 0;
                if ("undefined" !== typeof c) {
                    for (h in c) {
                        c.hasOwnProperty(h) && j++;
                    }
                    if (0 < j) {
                        j = "";
                        -1 !== b.indexOf("?") &&
                            ((j = b.substring(b.indexOf("?"))),
                                (b = b.substring(0, b.length - j.length)));
                        switch (b.substring(b.length - 1)) {
                            case "/":
                                b += ":";
                                break;
                            case ":":
                                break;
                            default:
                                b += "/:";
                        }
                        for (h in c) {
                            c.hasOwnProperty(h) &&
                                (b =
                                    h === openapp["ns"].rdf + "predicate"
                                        ? b + (";predicate=" + encodeURIComponent(c[h]))
                                        : b +
                                            (";" +
                                                encodeURIComponent(h) +
                                                "=" +
                                                encodeURIComponent(c[h])));
                        }
                        b += j;
                    }
                }
                g[gadgets.io.RequestParameters.GET_FULL_HEADERS] = !0;
                g[gadgets.io.RequestParameters.CONTENT_TYPE] =
                    gadgets.io.ContentType.TEXT;
                g[gadgets.io.RequestParameters.AUTHORIZATION] =
                    gadgets.io.AuthorizationType.OAUTH;
                g[gadgets.io.RequestParameters.OAUTH_SERVICE_NAME] = "openapp";
                g[gadgets.io.RequestParameters.OAUTH_USE_TOKEN] = "always";
                g[gadgets.io.RequestParameters.METHOD] = a;
                g[gadgets.io.RequestParameters.HEADERS] =
                    g[gadgets.io.RequestParameters.HEADERS] || {};
                "undefined" !== typeof e &&
                    null !== e &&
                    ((g[gadgets.io.RequestParameters.HEADERS]["Content-Type"] =
                        "undefined" !== typeof f ? f : "application/json"),
                        (g[gadgets.io.RequestParameters.POST_DATA] = e));
                g[gadgets.io.RequestParameters.HEADERS].Accept = "application/json";
                d = d || function () { };
                openapp["io"].makeRequest(b, function (a) {
                    var b = {
                        data: a.data,
                        link: "undefined" !== typeof a.headers.link
                            ? parseLinkHeader(a.headers.link[0])
                            : {},
                    };
                    a.headers.hasOwnProperty("location")
                        ? (b["uri"] = a.headers.location[0])
                        : a.headers.hasOwnProperty("content-base")
                            ? (b["uri"] = a.headers["content-base"][0])
                            :
                                b["link"].hasOwnProperty("http://purl.org/dc/terms/subject") &&
                                    (b["uri"] = b["link"]["http://purl.org/dc/terms/subject"].href);
                    a.headers.hasOwnProperty("content-location") &&
                        (b["contentUri"] = a.headers["content-location"][0]);
                    a.headers.hasOwnProperty("content-type") &&
                        "application/json" ===
                            a.headers["content-type"][0].split(";")[0] &&
                        (b.data = gadgets.json.parse(b.data));
                    b["subject"] =
                        "undefined" !== typeof a.data
                            ? b.data.hasOwnProperty("")
                                ? b.data[""]
                                : b.data[b["uri"]] || {}
                            : {};
                    d(b);
                }, g);
            });
        openapp["resource"].get = function (a, b, d) {
            return openapp["resource"].makeRequest("GET", a, b, d || {
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate": openapp["ns"].conserve + "info",
            });
        };
        openapp["resource"].post = function (a, b, d, c, e) {
            return openapp["resource"].makeRequest("POST", a, b, d, c, e);
        };
        openapp["resource"].put = function (a, b, d, c, e) {
            return openapp["resource"].makeRequest("PUT", a, b, d, c, e);
        };
        openapp["resource"].del = function (a, b, d) {
            return openapp["resource"].makeRequest("DELETE", a, b, d);
        };
        openapp["resource"].context = function (a) {
            return {
                sub: function (b) {
                    var d = {};
                    return {
                        control: function (a, b) {
                            d[a] = b;
                            return this;
                        },
                        type: function (a) {
                            return this.control(openapp["ns"].rdf + "type", a);
                        },
                        seeAlso: function (a) {
                            return this.control(openapp["ns"].rdfs + "seeAlso", a);
                        },
                        list: function () {
                            var c = [], e = a["subject"][b], f, g, h, j, k, l;
                            if ("undefined" === typeof e) {
                                return c;
                            }
                            h = 0;
                            a: for (; h < e.length; h++) {
                                f = e[h];
                                g = a.data[f.value];
                                for (j in d) {
                                    if (d.hasOwnProperty(j)) {
                                        if (!g.hasOwnProperty(j)) {
                                            continue a;
                                        }
                                        l = !1;
                                        for (k = 0; k < g[j].length; k++) {
                                            if (g[j][k].value === d[j]) {
                                                l = !0;
                                                break;
                                            }
                                        }
                                        if (!l) {
                                            continue a;
                                        }
                                    }
                                }
                                c.push({ data: a.data, link: {}, uri: f.value, subject: g });
                            }
                            return c;
                        },
                        create: function (c) {
                            if (!a["link"].rdf.hasOwnProperty(b)) {
                                throw ("The context does not support the requested relation: " + b);
                            }
                            var e = a["uri"];
                            d[openapp["ns"].rdf + "predicate"] = b;
                            openapp["resource"].post(e, function (a) {
                                c(a);
                            }, d);
                        },
                    };
                },
                metadata: function () {
                    return openapp["resource"]
                        .context(a)
                        .content(openapp["ns"].rest + "metadata");
                },
                representation: function () {
                    return openapp["resource"]
                        .context(a)
                        .content(openapp["ns"].rest + "representation");
                },
                content: function (b) {
                    return {
                        get: function (d) {
                            openapp["resource"].get(a["uri"], function (a) {
                                d(a);
                            }, { "http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate": b });
                        },
                        mediaType: function (d) {
                            var c = null;
                            return {
                                string: function (a) {
                                    c = a;
                                    return this;
                                },
                                json: function (a) {
                                    c = JSON.stringify(a);
                                    return this;
                                },
                                put: function (e) {
                                    openapp["resource"].put(a["uri"], function (a) {
                                        "function" === typeof e && e(a);
                                    }, {
                                        "http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate": b,
                                    }, c, d);
                                },
                            };
                        },
                        string: function (a) {
                            return this.mediaType("text/plain").string(a);
                        },
                        json: function (a) {
                            return this.mediaType("application/json").json(a);
                        },
                        graph: function () {
                            var d = {}, c = "";
                            return {
                                subject: function (a) {
                                    c = a;
                                    return this;
                                },
                                resource: function (a, b) {
                                    d[c] = d[c] || {};
                                    d[c][a] = d[c][a] || [];
                                    d[c][a].push({ value: b, type: "uri" });
                                    return this;
                                },
                                literal: function (a, b, g, h) {
                                    d[c] = d[c] || {};
                                    d[c][a] = d[c][a] || [];
                                    d[c][a].push({
                                        value: b,
                                        type: "literal",
                                        lang: g,
                                        datatype: h,
                                    });
                                    return this;
                                },
                                put: function (c) {
                                    openapp["resource"].put(a["uri"], function (a) {
                                        "function" === typeof c && c(a);
                                    }, {
                                        "http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate": b,
                                    }, JSON.stringify(d));
                                },
                            };
                        },
                    };
                },
                properties: function () {
                    var b = {}, d;
                    for (d in a["subject"]) {
                        a["subject"].hasOwnProperty(d) && (b[d] = a["subject"][d][0].value);
                    }
                    return b;
                },
                string: function () {
                    return "string" === typeof a.data
                        ? a.data
                        : gadgets.json.stringify(a.data);
                },
                json: function () {
                    return "string" === typeof a.data ? null : a.data;
                },
                followSeeAlso: function () {
                    var b = a["subject"][openapp["ns"].rdfs + "seeAlso"], d = 0, c, e;
                    if ("undefined" !== typeof b) {
                        b = b[0].value;
                        for (e = 0; e < b.length &&
                            e < a["uri"].length &&
                            b.charAt(e) === a["uri"].charAt(e); e++) {
                            "/" === b.charAt(e) && d++;
                        }
                        for (c = d; e < b.length; e++) {
                            "/" === b.charAt(e) && c++;
                        }
                        return 3 > d || 4 < c
                            ? this
                            : openapp["resource"].context({
                                data: a.data,
                                link: {},
                                uri: b,
                                subject: a.data[b],
                            });
                    }
                    return this;
                },
            };
        };
        openapp["resource"].content = function (a) {
            return {
                properties: function () {
                    return openapp["resource"].context(a).properties();
                },
                string: function () {
                    return openapp["resource"].context(a).string();
                },
                json: function () {
                    return openapp["resource"].context(a).json();
                },
            };
        };
        openapp["oo"] = {};
        openapp["oo"].Resource = function (a, b, d) {
            this.uri = a;
            this.context = b;
            this.info = d;
        };
        var OARP = openapp["oo"].Resource.prototype;
        OARP.getURI = function () {
            return this.uri;
        };
        OARP._call = function (a) {
            var b = this;
            null == this.context
                ? null == this._deferred
                    ? ((this._deferred = [a]),
                        openapp["resource"].get(this.uri, function (a) {
                            b.context = a;
                            a = b._deferred;
                            delete b._deferred;
                            for (var c = 0; c < a.length; c++) {
                                a[c].call(b);
                            }
                        }))
                    : this._deferred.push(a)
                : a.call(b);
        };
        OARP.refresh = function (a) {
            delete this.context;
            delete this.info;
            a &&
                this._call(function () {
                    a();
                });
        };
        OARP.getSubResources = function (a) {
            this._call(function () {
                for (var b = null != a.type
                    ? openapp["resource"]
                        .context(this.context)
                        .sub(a.relation)
                        .type(a.type)
                        .list()
                    : openapp["resource"]
                        .context(this.context)
                        .sub(a.relation)
                        .list(), d = [], c = 0; c < b.length; c++) {
                    var e = b[c].uri;
                    if (a.followReference) {
                        var f = this.context.data[e]["http://www.w3.org/2002/07/owl#sameAs"];
                        null != f && 0 < f.length && (e = f[0].value);
                    }
                    f = new openapp["oo"].Resource(e, null, b[c]);
                    null == a.followReference &&
                        ((f._referenceLoaded = !0),
                            (e = this.context.data[e]["http://www.w3.org/2002/07/owl#sameAs"]),
                            null != e && 0 < e.length && (f._reference = e[0].value));
                    if (a.onEach) {
                        a.onEach(f);
                    }
                    a.onAll && d.push(f);
                }
                if (a.onAll) {
                    a.onAll(d);
                }
            });
        };
        OARP.followReference = function (a) {
            this._referenceLoaded
                ? a(null != this._reference
                    ? new openapp["oo"].Resource(this._reference)
                    : this)
                : this._call(function () {
                    var b = this.context.data[this.uri]["http://www.w3.org/2002/07/owl#sameAs"];
                    null != b && 0 < b.length
                        ? a(new openapp["oo"].Resource(b[0].value))
                        : a(this);
                });
        };
        OARP.getReference = function (a) {
            this._referenceLoaded
                ? a(this._reference)
                : this._call(function () {
                    var b = this.context.subject[openapp["ns"].rdfs + "seeAlso"];
                    null != b && 0 < b.length
                        ? a(this.context.subject[openapp["ns"].rdfs + "seeAlso"][0].value)
                        : a();
                });
        };
        OARP.getMetadata = function (a, b) {
            this._call(function () {
                openapp["resource"]
                    .context(this.context)
                    .metadata()
                    .get(function (d) {
                    switch (a || "properties") {
                        case "properties":
                            b(openapp["resource"].context(d).properties());
                            break;
                        case "graph":
                            b(openapp["resource"].content(d).graph());
                            break;
                        case "rdfjson":
                            b(openapp["resource"].content(d).json());
                    }
                });
            });
        };
        OARP.getInfo = function (a) {
            if (a) {
                this.context || this.info
                    ? a(openapp["resource"]
                        .context(this.context || this.info)
                        .properties())
                    : this._call(function () {
                        a(openapp["resource"]
                            .context(this.context || this.info)
                            .properties());
                    });
            }
            else {
                if (this.context || this.info) {
                    return openapp["resource"]
                        .context(this.context || this.info)
                        .properties();
                }
            }
        };
        OARP.getRepresentation = function (a, b) {
            this._call(function () {
                openapp["resource"]
                    .context(this.context)
                    .representation()
                    .get(function (d) {
                    switch (a || "text/html") {
                        case "properties":
                            b(openapp["resource"].context(d).properties());
                            break;
                        case "graph":
                            b(openapp["resource"].content(d).graph());
                            break;
                        case "rdfjson":
                            b(openapp["resource"].content(d).json());
                            break;
                        case "text/html":
                            b(openapp["resource"].content(d).string());
                    }
                });
            });
        };
        OARP.setMetadata = function (a, b, d) {
            var c = {};
            switch (b || "properties") {
                case "properties":
                    b = {};
                    for (var e in a) {
                        b[e] = [{ type: "literal", value: a[e] }];
                    }
                    c[this.context.uri] = b;
                    break;
                case "rdfjson":
                    c = a;
                    break;
                case "graph":
                    graph.put(d);
                    return;
            }
            openapp["resource"].put(this.context.uri, d, {
                "http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate": openapp["ns"].rest + "metadata",
            }, JSON.stringify(c));
        };
        OARP.setRepresentation = function (a, b, d) {
            this._call(function () {
                var c = openapp["resource"]
                    .context(this.context)
                    .representation()
                    .mediaType(b);
                "string" === typeof a ? c.string(a).put(d) : c.json(a).put(d);
            });
        };
        OARP.create = function (a) {
            this._call(function () {
                var b = openapp["resource"]
                    .context(this.context)
                    .sub(a.relation || openapp["ns"].role + "data");
                null != a.referenceTo && (b = b.seeAlso(a.referenceTo));
                null != a.type && (b = b.type(a.type));
                b.create(function (b) {
                    var c = new openapp["oo"].Resource(b["uri"], b);
                    a.metadata
                        ? c.setMetadata(a.metadata, a.format, function () {
                            a.representation
                                ? c.setRepresentation(a.representation, a.medieType || "application/json", function () {
                                    a.callback(c);
                                })
                                : a.callback(c);
                        })
                        : a.representation
                            ? c.setRepresentation(a.representation, a.medieType || "application/json", function () {
                                a.callback(c);
                            })
                            : a.callback(c);
                });
            });
        };
        OARP.del = function (a) {
            openapp["resource"].del(this.uri, a);
        };
        openapp["param"] = {};
        var parseQueryParams = function (a) {
            var b, d, c = {};
            if (0 > a.indexOf("?")) {
                return {};
            }
            a = a.substr(a.indexOf("?") + 1).split("&");
            if (!(1 == a.length && "" === a[0])) {
                for (d = 0; d < a.length; d++) {
                    (b = a[d].split("=")),
                        2 == b.length && (c[b[0]] = window.unescape(b[1]));
                }
            }
            return c;
        }, parseOpenAppParams = function (a) {
            var b = {}, d = {}, c, e;
            for (c in a) {
                a.hasOwnProperty(c) &&
                    "openapp['ns']." === c.substring(0, 11) &&
                    (b[c.substr(11)] = a[c]);
            }
            for (c in a) {
                a.hasOwnProperty(c) &&
                    ((e = c.split(".")),
                        3 === e.length &&
                            "openapp" === e[0] &&
                            b.hasOwnProperty(e[1]) &&
                            (d[b[e[1]] + e[2]] = a[c]));
            }
            return d;
        }, _openAppParams = parseOpenAppParams(parseQueryParams(parseQueryParams(window.location.href)["url"] || ""));
        openapp["param"].get = function (a) {
            return _openAppParams[a];
        };
        openapp["param"].space = function () {
            return openapp["param"].get("http://purl.org/role/terms/space");
        };
        openapp["param"].user = function () {
            return openapp["param"].get("http://purl.org/role/terms/user");
        };
    }
}
const openapp$3 = new OpenAppProvider().openapp;
var Util = {
    generateRandomId: function (length) {
        var chars = "1234567890abcdef";
        var numOfChars = chars.length;
        var i, rand;
        var res = "";
        if (typeof length === "undefined")
            length = 24;
        for (i = 0; i < length; i++) {
            rand = Math.floor(Math.random() * numOfChars);
            res += chars[rand];
        }
        return res;
    },
    generateAnonymousUser: function () {
        const user = {};
        var id = this.generateRandomId();
        user[CONFIG$1.NS.PERSON.TITLE] = "Anonymous";
        user[CONFIG$1.NS.PERSON.JABBERID] = id;
        user[CONFIG$1.NS.PERSON.MBOX] = id + "@anonym.com";
        user.globalId = -1;
        user.self = true;
        return user;
    },
    delay: function (delay) {
        var deferred = jQuery.Deferred();
        setTimeout(function () {
            deferred.resolve();
        }, delay);
        return deferred.promise();
    },
    union: function (obj1, obj2) {
        var res = {}, i;
        for (i in obj1) {
            if (obj1.hasOwnProperty(i)) {
                res[i] = obj1[i];
            }
        }
        for (i in obj2) {
            if (obj2.hasOwnProperty(i) && !obj1.hasOwnProperty(i)) {
                res[i] = obj2[i];
            }
        }
        return res;
    },
    merge: function (obj1, obj2) {
        var i;
        for (i in obj2) {
            if (obj2.hasOwnProperty(i) && !obj1.hasOwnProperty(i)) {
                obj1[i] = obj2[i];
            }
        }
        return obj1;
    },
    toPromise: function (func) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            var deferred = jQuery.Deferred();
            args.push(function () {
                deferred.resolve.apply(this, arguments);
            });
            func.apply(this, args);
            return deferred.promise();
        };
    },
    COLORS: [
        "#8AFFC8",
        "#8A9FFF",
        "#FF8A8A",
        "#FFC08A",
        "#FF8AD2",
        "#8AEBFF",
        "#C68AFF",
        "#8EFF8A",
    ],
    getColor: function (id) {
        return this.COLORS[id % this.COLORS.length];
    },
    getGlobalId: function (user, y) {
        var mbox = user.user[CONFIG$1.NS.PERSON.MBOX];
        const userMap = y.getMap("users");
        var users = Array.from(userMap.values());
        var id = users.indexOf(mbox);
        if (id === -1) {
            id = users.length;
            userMap.set(y.clientID, mbox);
        }
        return id;
    },
    GetCurrentBaseModel: function () {
        var resourceSpace = new openapp$3.oo.Resource(openapp$3.param.space());
        var deferred = jQuery.Deferred();
        resourceSpace.getSubResources({
            relation: openapp$3.ns.role + "data",
            type: CONFIG$1.NS.MY.MODEL,
            onAll: function (data) {
                if (data === null || data.length === 0) {
                    deferred.resolve([]);
                }
                else {
                    data[0].getRepresentation("rdfjson", function (representation) {
                        if (!representation) {
                            deferred.resolve([]);
                        }
                        else {
                            deferred.resolve(representation);
                        }
                    });
                }
            },
        });
        return deferred.promise();
    },
    getSpaceTitle: function (url) {
        return url
            .substring(url.lastIndexOf("spaces/"))
            .replace(/spaces|#\S*|\?\S*|\//g, "");
    },
};
class Client {
    constructor(componentName, categories, origin, y) {
        this._componentName = "unknown";
        this._connected = false;
        this._y = y;
        this._componentName = componentName;
        this._categories = categories;
        this._origin = origin;
    }
    connect(callback) {
        this._callback = callback;
        var handler = this.receiveMessage.bind(this);
        const widgetTageName = getWidgetTagName(this._componentName);
        try {
            const _node = document.querySelector(widgetTageName);
            if (!_node) {
                throw new Error("html tag not found in document. Please make sure that you added the " +
                    widgetTageName +
                    " to the document. Hint: do not use the shadow dom.");
            }
            _node.addEventListener("syncmeta-message", handler);
        }
        catch (error) {
            console.error(error);
        }
        if (this._y) {
            const intents = this._y.getMap("intents");
            if (intents)
                intents.observe(handler);
        }
    }
    disconnect() {
        this._callback = null;
        if (!(this._y === null || this._y === undefined)) {
            this._y.getMap("intents").unobserve(this.receiveMessage);
        }
    }
    publish(intent) {
        if (util.validateIntent(intent)) {
            if (intent.flags[0] === util.FLAGS.PUBLISH_GLOBAL) {
                this.publishGlobal(intent, this._y);
            }
            else if (intent.flags[0] === util.FLAGS.PUBLISH_LOCAL) {
                this.publishLocal(intent, this._origin);
            }
        }
    }
    publishLocal(intent, origin) {
        const widgets = [];
        for (const el of document.querySelectorAll("*")) {
            if (el.tagName.match(/-widget$/i)) {
                widgets.push(el);
            }
        }
        widgets.forEach(function (widget) {
            const receiverTagName = getWidgetTagName(intent.receiver.toLowerCase());
            if (widget.tagName.toLowerCase() === receiverTagName.toLowerCase()) {
                const event = new CustomEvent("syncmeta-message", {
                    detail: {
                        intent,
                        origin,
                    },
                });
                widget.dispatchEvent(event);
            }
        });
    }
    publishGlobal(intent, y) {
        y.getMap("intents").set(intent.receiver, intent);
    }
    receiveMessage(event) {
        if (event.type === "syncmeta-message") {
            if (event instanceof CustomEvent) {
                this._callback(event.detail.intent);
            }
        }
        else if (event.type === "add" || event.type == "update") {
            var intent = event.object.get(event.name);
            event.object.delete(event.name);
            console.log(intent);
            this._callback(intent);
        }
    }
}
class util {
    static { this.FLAGS = {
        PUBLISH_LOCAL: "PUBLISH_LOCAL",
        PUBLISH_GLOBAL: "PUBLISH_GLOBAL",
    }; }
    static validateIntent(intent) {
        if (typeof intent.sender != "string") {
            throw new Error("Intent object must possess property 'component' of type 'String'");
        }
        if (typeof intent.data != "string") {
            throw new Error("Intent object must possess property 'data' of type 'String'");
        }
        if (typeof intent.dataType != "string") {
            throw new Error("Intent object must possess property 'dataType' of type 'String'");
        }
        return true;
    }
}
var PAYLOAD_DATA_TYPE = {
    OT_OPERATION: "OTOperation",
    NON_OT_OPERATION: "NonOTOperation",
};
class IWCWrapper {
    constructor(componentName, y) {
        this.BUFFER_ENABLED = false;
        this.INTERVAL_SEND = 25;
        this.Space = null;
        this._messageBuffer = [];
        this._onDataReceivedCallbacks = [];
        this._onDataReceivedCallers = [];
        this._times = {};
        this.componentName = componentName;
        this._iwc = new Client(componentName, "*", null, y);
        window._iwc_instance_ = this._iwc;
        if (this.BUFFER_ENABLED)
            setInterval(this.sendBufferedMessages, this.INTERVAL_SEND);
        this.connect = () => this._iwc.connect((intent) => this.onIntentReceivedCallback(this, intent));
        this.disconnect = () => this._iwc.disconnect;
        (this.sendLocalMessage = function (receiver, data) {
            var intent;
            if (!receiver || receiver === "")
                return;
            if (this.BUFFER_ENABLED) {
                if (this._messageBuffer.hasOwnProperty(receiver)) {
                    this._messageBuffer[receiver].push(data);
                }
                else {
                    this._messageBuffer[receiver] = [data];
                }
            }
            else {
                intent = this.encapsulateMessage(receiver, CONFIG$1.IWC.FLAG.PUBLISH_LOCAL, CONFIG$1.IWC.ACTION.DATA, data);
                if (util.validateIntent(intent)) {
                    this._iwc.publish(intent);
                }
            }
        }),
            (this.sendLocalOTOperation = function (receiver, operation) {
                this.sendLocalMessage(receiver, {
                    type: PAYLOAD_DATA_TYPE.OT_OPERATION,
                    data: operation.getOperationObject(),
                    sender: operation.getSender(),
                });
            }),
            (this.sendLocalNonOTOperation = function (receiver, operation) {
                this.sendLocalMessage(receiver, {
                    type: PAYLOAD_DATA_TYPE.NON_OT_OPERATION,
                    data: operation.getOperationObject(),
                    sender: operation.getSender(),
                });
            }),
            (this.getUserColor = function (jabberId) {
                return Util.getColor(this.Space.members[jabberId].globalId);
            }),
            (this.registerOnDataReceivedCallback = function (callback, caller) {
                if (typeof callback === "function") {
                    this.unregisterOnDataReceivedCallback(callback);
                    this._onDataReceivedCallbacks.push(callback);
                    this._onDataReceivedCallers.push(caller);
                }
            }),
            (this.unregisterOnDataReceivedCallback = function (callback) {
                var i, numOfCallbacks;
                if (typeof callback === "function") {
                    for (i = 0, numOfCallbacks = this._onDataReceivedCallbacks.length; i < numOfCallbacks; i++) {
                        if (callback === this._onDataReceivedCallbacks[i]) {
                            this._onDataReceivedCallbacks.splice(i, 1);
                            this._onDataReceivedCallers.splice(i, 1);
                        }
                    }
                }
            }),
            (this.getUser = function () {
                if (!this.Space) {
                    console.error("Space is null");
                    this.Space = { user: {} };
                }
                else if (!this.Space.user) {
                    console.error("User in space is null, generating new anonymous user");
                    this.Space.user = Util.generateAnonymousUser();
                }
                return this.Space.user;
            }),
            (this.getMembers = function () {
                return this.Space.members;
            }),
            (this.getSpaceTitle = function () {
                return this.Space.title;
            }),
            (this.setSpace = function (s) {
                this.Space = s;
            });
        return this;
    }
    encapsulateMessage(receiver, flags, action, payload) {
        var i, numOfFlags, flag;
        var validatedFlags = [];
        if (flags instanceof Array) {
            for (i = 0, numOfFlags = flags.length; i < numOfFlags; i++) {
                flag = flags[i];
                if (flag === CONFIG$1.IWC.FLAG.PUBLISH_LOCAL ||
                    flag === CONFIG$1.IWC.FLAG.PUBLISH_GLOBAL) {
                    validatedFlags.push(flag);
                }
            }
        }
        else if (typeof flags === "string") {
            if (flags === CONFIG$1.IWC.FLAG.PUBLISH_LOCAL ||
                flags === CONFIG$1.IWC.FLAG.PUBLISH_GLOBAL) {
                validatedFlags.push(flags);
            }
        }
        else {
            throw "Parameter flags has wrong type. Array or String expected.";
        }
        if (typeof action !== "string") {
            throw "Parameter action has wrong type. String expected.";
        }
        receiver = receiver || "";
        return {
            receiver: receiver,
            sender: this.componentName,
            data: "",
            dataType: "",
            action: action,
            flags: validatedFlags,
            extras: {
                payload: payload,
                time: new Date().getTime(),
            },
        };
    }
    sendBufferedMessages() {
        var intent;
        var data = null;
        for (var receiver in this._messageBuffer) {
            if (this._messageBuffer.hasOwnProperty(receiver)) {
                data = this._messageBuffer[receiver].splice(0, this._messageBuffer[receiver].length);
                if (data.length == 1) {
                    intent = this.encapsulateMessage(receiver, CONFIG$1.IWC.FLAG.PUBLISH_LOCAL, CONFIG$1.IWC.ACTION.DATA, data[0]);
                    if (util.validateIntent(intent)) {
                        this._iwc.publish(intent);
                    }
                }
                else if (data.length > 1) {
                    intent = this.encapsulateMessage(receiver, CONFIG$1.IWC.FLAG.PUBLISH_LOCAL, CONFIG$1.IWC.ACTION.DATA_ARRAY, data);
                    if (util.validateIntent(intent)) {
                        this._iwc.publish(intent);
                    }
                }
            }
        }
    }
    onIntentReceivedCallback(_self, intent) {
        if (typeof intent === "string") {
            try {
                intent = JSON.parse(intent);
                if (intent.hasOwnProperty("OpenApplicationEvent")) {
                    intent = intent["OpenApplicationEvent"];
                    if (intent.hasOwnProperty("message"))
                        intent = intent.message;
                }
            }
            catch (e) {
                return;
            }
        }
        if (!intent.hasOwnProperty("extras") ||
            !intent.extras.hasOwnProperty("payload")) {
            return;
        }
        var payload = intent.extras.payload, senderTime = intent.extras.time, senderTimes = _self._times[intent.sender];
        var i, numOfSenderTimes, numOfMessages;
        function handleMessage(payload) {
            var type, data, sender, operation, resOperation, i, numOfCallbacks;
            if (!payload ||
                !payload.hasOwnProperty("type") ||
                !payload.hasOwnProperty("data")) {
                return;
            }
            type = payload.type;
            data = payload.data;
            sender = payload.sender;
            switch (type) {
                case PAYLOAD_DATA_TYPE.OT_OPERATION:
                    operation = new OTOperation(data.name, data.value, data.type, data.position);
                    operation.setSender(sender);
                    resOperation =
                        OperationFactory$1.createOperationFromOTOperation(operation);
                    for (i = 0, numOfCallbacks = _self._onDataReceivedCallbacks.length; i < numOfCallbacks; i++) {
                        if (typeof _self._onDataReceivedCallbacks[i] === "function") {
                            var caller = _self._onDataReceivedCallers[i] || _self;
                            _self._onDataReceivedCallbacks[i].call(caller, resOperation);
                        }
                    }
                    break;
                case PAYLOAD_DATA_TYPE.NON_OT_OPERATION:
                    operation = new NonOTOperation(data.type, data.data);
                    operation.setSender(sender);
                    resOperation =
                        OperationFactory$1.createOperationFromNonOTOperation(operation);
                    for (i = 0, numOfCallbacks = _self._onDataReceivedCallbacks.length; i < numOfCallbacks; i++) {
                        if (typeof _self._onDataReceivedCallbacks[i] === "function") {
                            var caller = _self._onDataReceivedCallers[i] || _self;
                            _self._onDataReceivedCallbacks[i].call(caller, resOperation);
                        }
                    }
                    break;
            }
        }
        if (intent.flags.indexOf(CONFIG$1.IWC.FLAG.PUBLISH_GLOBAL) !== -1)
            return;
        if (typeof senderTimes === "undefined") {
            senderTimes = _self._times[intent.sender] = [];
        }
        else {
            for (i = 0, numOfSenderTimes = senderTimes.length; i < numOfSenderTimes; i++) {
                if (senderTime === senderTimes[i]) {
                    return;
                }
            }
        }
        senderTimes.push(senderTime);
        switch (intent.action) {
            case CONFIG$1.IWC.ACTION.DATA:
                handleMessage(payload);
                break;
            case CONFIG$1.IWC.ACTION.DATA_ARRAY:
                for (i = 0, numOfMessages = payload.length; i < numOfMessages; i++) {
                    handleMessage(payload[i]);
                }
                break;
        }
    }
}
class IWCW {
    constructor() { }
    static { this.instances = {}; }
    static hasInstance(componentName) {
        return componentName in IWCW.instances;
    }
    static getInstance(componentName, y) {
        if (!this.hasInstance(componentName)) {
            y = y || window.y;
            if (!y) {
                console.error("y is null, y is the shared y document that should be passed along when calling getInstance, proceed with caution");
            }
            IWCW.instances[componentName] = new IWCWrapper(componentName, y);
            IWCW.instances[componentName].connect();
        }
        return IWCW.instances[componentName];
    }
}
let AbstractEntity$1 = class AbstractEntity {
    constructor(id) {
        var _id = id;
        this.getEntityId = function () {
            return _id;
        };
    }
    static { this.MAX_Z_INDEX = 32000; }
    static { this.MIN_Z_INDEX = 1; }
    static { this.CONTEXT_MENU_Z_INDEX = 32000 + 1; }
    static { this.maxZIndex = 16000; }
    static { this.minZIndex = 16000; }
};
function Arrows(color) {
    return {
        unidirassociation: {
            type: "Arrow",
            options: {
                width: 20,
                length: 30,
                location: 1,
                foldback: 0.1,
                paintStyle: {
                    fill: "#ffffff",
                    outlineWidth: 2,
                    outlineStroke: color,
                },
            },
        },
        generalisation: {
            type: "Arrow",
            options: {
                width: 20,
                length: 30,
                location: 1,
                foldback: 1,
                paintStyle: {
                    fill: "#ffffff",
                    outlineWidth: 2,
                    outlineStroke: color,
                },
            },
        },
        diamond: {
            type: "Arrow",
            options: {
                width: 20,
                length: 20,
                location: 1,
                foldback: 2,
                paintStyle: {
                    fill: "#ffffff",
                    outlineWidth: 2,
                    outlineStroke: color,
                },
            },
        },
    };
}
const abstractAttributeHtml$1 = "<div class=\"attribute\"></div>";
let AbstractAttribute$1 = class AbstractAttribute extends AbstractEntity$1 {
    constructor(id, name, subjectEntity) {
        super(id);
        var _id = id;
        var _name = name;
        var _$node = $(lodash.template(abstractAttributeHtml$1)());
        var _subjectEntity = subjectEntity;
        this.setName = function (name) {
            _name = name;
        };
        this.getName = function () {
            return _name;
        };
        this.getSubjectEntity = function () {
            return _subjectEntity;
        };
        this.getRootSubjectEntity = function () {
            var rootSubjectEntity = this.getSubjectEntity();
            while (rootSubjectEntity instanceof AbstractAttribute$1) {
                rootSubjectEntity = rootSubjectEntity.getSubjectEntity();
            }
            return rootSubjectEntity;
        };
        this.getSubjectEntityId = function () {
            return _subjectEntity.getEntityId();
        };
        this._get$node = function () {
            return _$node;
        };
        this._toJSON = function () {
            return {
                id: _id,
                name: _name,
            };
        };
    }
    get$node() {
        return this._get$node();
    }
    toJSON() {
        return this._toJSON();
    }
    registerYTypeForValue(map, value) {
        var deferred = $.Deferred();
        map.get(value.getEntityId()).then(function (type) {
            value.registerYType(type);
            deferred.resolve();
        });
        return deferred.promise();
    }
};
let AbstractValue$1 = class AbstractValue {
    constructor(id, name, subjectEntity, rootSubjectEntity) {
        var that = this;
        var _id = id;
        var _name = name;
        var _subjectEntity = subjectEntity;
        var _rootSubjectEntity = rootSubjectEntity;
        this.getEntityId = function () {
            return _id;
        };
        this.getName = function () {
            return _name;
        };
        this.getSubjectEntity = function () {
            return _subjectEntity;
        };
        this.getRootSubjectEntity = function () {
            return _rootSubjectEntity;
        };
        this._toJSON = function () {
            return {
                id: that.getEntityId(),
                name: _name,
            };
        };
    }
    toJSON() {
        return this._toJSON();
    }
};
let booleanValueHtml$1 = "<div class=\"val\"><%= value %></div>";
const attributeBooleanValueHtml = "<input\n  class=\"form-check-input val\"\n  type=\"checkbox\"\n  name=\"<%= name %>\"\n  <% if (value) { %> checked=\"checked\" <% } %> />\n";
let BooleanValue$1 = class BooleanValue extends AbstractValue$1 {
    constructor(id, name, subjectEntity, rootSubjectEntity, useAttributeHtml) {
        if (useAttributeHtml)
            booleanValueHtml$1 = attributeBooleanValueHtml;
        super(id, name, subjectEntity, rootSubjectEntity);
        var that = this;
        var _value = false;
        var _$node = $(lodash.template(booleanValueHtml$1)({ value: _value }));
        y = y || window.y;
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var processValueChangeOperation = function (operation) {
            that.setValue(operation.getValue());
        };
        var init = function () {
            _$node.off();
        };
        this.setValue = function (value) {
            _value = value;
            if (useAttributeHtml)
                _$node.prop("checked", value);
            else
                _$node.text(value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractValue$1.prototype.toJSON.call(this);
            json.value = _value;
            return json;
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        this.registerYType = function () {
            that
                .getRootSubjectEntity()
                .getYMap()
                .observe(function (event) {
                const array = Array.from(event.changes.keys.entries());
                array.forEach(function ([key, value]) {
                    const map = event.currentTarget.get(key);
                    const json = map;
                    var operation = new ValueChangeOperation(json.entityId, json.value, json.type, json.position, json.jabberId);
                    _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
                    processValueChangeOperation(operation);
                    if (_iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID] ===
                        operation.getJabberId()) {
                        const activityMap = y.getMap("activity");
                        activityMap.set(ActivityOperation.TYPE, new ActivityOperation("ValueChangeActivity", that.getEntityId(), _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], ValueChangeOperation.getOperationDescription(that.getSubjectEntity().getName(), that.getRootSubjectEntity().getType(), that.getRootSubjectEntity().getLabel().getValue().getValue()), {
                            value: operation.getValue(),
                            subjectEntityName: that.getSubjectEntity().getName(),
                            rootSubjectEntityType: that
                                .getRootSubjectEntity()
                                .getType(),
                            rootSubjectEntityId: that
                                .getRootSubjectEntity()
                                .getEntityId(),
                        }).toJSON());
                    }
                    else {
                        _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
                    }
                });
            });
            that
                .getRootSubjectEntity()
                .getYMap()
                .observe(lodash.debounce(function (event) {
                event.keysChanged.forEach(function (key) {
                    if (key == "jabberId" &&
                        key === _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID])
                        EntityManager.storeDataYjs();
                });
            }, 500));
        };
        init();
    }
};
const booleanAttributeHtml$1 = "<div class=\"single_value_attribute\">\n    <div class=\"name\"></div>\n    <div class=\"value\"></div>\n</div>";
let BooleanAttribute$1 = class BooleanAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, useAttributeHtml) {
        useAttributeHtml =
            typeof useAttributeHtml !== "undefined" ? useAttributeHtml : false;
        super(id, name, subjectEntity);
        var _value = new BooleanValue$1(id, name, this, this.getRootSubjectEntity(), useAttributeHtml);
        var _$node = $(lodash.template(booleanAttributeHtml$1)());
        this.setValue = function (value) {
            _value = value;
            _$node.val(value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.value = _value.toJSON();
            return json;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".name").text(this.getName());
        _$node.find(".value").append(_value.get$node());
    }
};
const openapp$2 = new OpenAppProvider().openapp;
let fileValueHtml$1 = "<div class=\"val\"><%= value %></div>";
const attributeFileValueHtml = "<div class=\"file\">\n  <div class=\"select_file\">\n    <input class=\"form-control\" type=\"file\" id=\"file_object\" />\n    <input class=\"form-control\" type=\"button\" id=\"file_submit\" value=\"Submit\" />\n  </div>\n  <div class=\"manage_file\">\n    <span id=\"file_name\"></span>\n    <button id=\"file_preview\">Preview</button>\n    <button>\n      <a\n        id=\"file_download\"\n        href=\"#\"\n        target=\"_blank\"\n        style=\"color: #000; text-decoration: none\"\n        >Download</a\n      >\n    </button>\n    <button id=\"file_delete\">Delete</button>\n  </div>\n</div>\n";
FileValue$1.prototype = new AbstractValue$1();
FileValue$1.prototype.constructor = FileValue$1;
function FileValue$1(id, name, subjectEntity, rootSubjectEntity, useAttributeHtml) {
    var that = this;
    if (useAttributeHtml)
        fileValueHtml$1 = attributeFileValueHtml;
    AbstractValue$1.call(this, id, name, subjectEntity, rootSubjectEntity);
    var _value = "";
    var _$node;
    if (useAttributeHtml)
        _$node = $(lodash.template(fileValueHtml$1)({ name: name }));
    else
        _$node = $(lodash.template(fileValueHtml$1)({ value: _value }));
    var _$selectFile = _$node.find(".select_file");
    var _$manageFile = _$node.find(".manage_file");
    y = y || window.y;
    var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
    var getEntityIdChain = function () {
        var chain = [that.getEntityId()], entity = that;
        while (entity instanceof AbstractAttribute$1) {
            chain.unshift(entity.getSubjectEntity().getEntityId());
            entity = entity.getSubjectEntity();
        }
        return chain;
    };
    var uploadFile = function (name, type, data) {
        var resourceSpace = new openapp$2.oo.Resource(openapp$2.param.space());
        resourceSpace.create({
            relation: openapp$2.ns.role + "data",
            type: "my:ns:file",
            representation: {
                name: name,
                type: type,
                data: data,
            },
            callback: function (d) {
                if (d.uri) {
                    propagateValueChange(CONFIG$1.OPERATION.TYPE.UPDATE, d.uri, 0);
                }
            },
        });
    };
    var processValueChangeOperation = function (operation) {
        that.setValue(operation.getValue());
    };
    var propagateValueChange = function (type, value, position) {
        var operation = new ValueChangeOperation(that.getEntityId(), value, type, position);
        propagateValueChangeOperation(operation);
    };
    var propagateValueChangeOperation = function (operation) {
        operation.setEntityIdChain(getEntityIdChain());
        processValueChangeOperation(operation);
        if (_iwcw.sendRemoteOTOperation(operation)) {
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
            const activityMap = y.getMap("activity");
            activityMap.set(ActivityOperation.TYPE, new ActivityOperation("ValueChangeActivity", that.getEntityId(), _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], ValueChangeOperation.getOperationDescription(that.getSubjectEntity().getName(), that.getRootSubjectEntity().getType(), that.getRootSubjectEntity().getLabel().getValue().getValue()), {
                value: operation.getValue(),
                subjectEntityName: that.getSubjectEntity().getName(),
                rootSubjectEntityType: that.getRootSubjectEntity().getType(),
                rootSubjectEntityId: that.getRootSubjectEntity().getEntityId(),
            }).toJSON());
        }
    };
    var localValueChangeCallback = function (operation) {
        if (operation instanceof ValueChangeOperation &&
            operation.getEntityId() === that.getEntityId()) {
            propagateValueChangeOperation(operation);
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
        }
    };
    var init = function () {
        if (!useAttributeHtml)
            return;
        _$selectFile.find("#file_object").change(function () {
            var files = $(this)[0].files, file;
            if (!files || files.length === 0)
                return;
            file = files[0];
            if (file.size > 1048576) {
                alert("Chosen file is too large. Maximum size: 1MB");
            }
        });
        _$selectFile.find("#file_submit").click(function () {
            var fileReader, files = _$selectFile.find("#file_object")[0].files, file;
            if (!files || files.length === 0)
                return;
            file = files[0];
            fileReader = new FileReader();
            fileReader.onload = function (e) {
                uploadFile(file.name, file.type, e.target.result);
            };
            fileReader.readAsDataURL(file);
        });
        _$manageFile.find("#file_delete").click(function () {
            propagateValueChange(CONFIG$1.OPERATION.TYPE.UPDATE, "", 0);
        });
        _$selectFile.show();
        _$manageFile.hide();
    };
    this.setValue = function (value) {
        _value = value;
        if (_value === "") {
            _$node.text("");
        }
        else {
            $.get(_value + "/:representation").done(function (data) {
                _$node.text(data.name);
            });
        }
    };
    this.getValue = function () {
        return _value;
    };
    this.get$node = function () {
        return _$node;
    };
    this.toJSON = function () {
        var json = AbstractValue$1.prototype.toJSON.call(this);
        json.value = _value;
        return json;
    };
    this.setValueFromJSON = function (json) {
        this.setValue(json.value);
    };
    this.registerCallbacks = function () {
        _iwcw.registerOnDataReceivedCallback(localValueChangeCallback);
    };
    this.unregisterCallbacks = function () {
        _iwcw.unregisterOnDataReceivedCallback(localValueChangeCallback);
    };
    if (_iwcw) {
        that.registerCallbacks();
    }
    init();
}
const fileAttributeHtml$1 = "<div class=\"file_attribute\">\n    <div class=\"name\"></div>\n    <div class=\"value\"></div>\n</div>";
let FileAttribute$1 = class FileAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, useAttributeHtml) {
        useAttributeHtml =
            typeof useAttributeHtml !== "undefined" ? useAttributeHtml : false;
        super(id, name, subjectEntity);
        var _value = new FileValue$1(id, name, this, this.getRootSubjectEntity(), useAttributeHtml);
        var _$node = $(lodash.template(fileAttributeHtml$1)());
        this.setValue = function (value) {
            _value = value;
            _$node.val(value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.value = _value.toJSON();
            return json;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".name").text(this.getName());
        _$node.find(".value").append(_value.get$node());
    }
};
let integerValueHtml$1 = "<div class=\"val\"><%= value %></div>";
const attributeIntegerValueHtml = "<input\n  class=\"form-control h-100 val\"\n  type=\"number\"\n  name=\"<%= name %>\"\n  value=\"0\"\n/>\n";
let IntegerValue$1 = class IntegerValue extends AbstractValue$1 {
    constructor(id, name, subjectEntity, rootSubjectEntity, useAttributeHtml) {
        super(id, name, subjectEntity, rootSubjectEntity);
        var that = this;
        if (useAttributeHtml)
            integerValueHtml$1 = attributeIntegerValueHtml;
        var _value = 0;
        var _$node = $(lodash.template(integerValueHtml$1)({ value: _value }));
        y = y || window.y;
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var processValueChangeOperation = function (operation) {
            that.setValue(operation.getValue());
        };
        var init = function () {
            _$node.off();
        };
        this.setValue = function (value) {
            _value = value;
            if (useAttributeHtml)
                _$node.val(value);
            else
                _$node.text(value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractValue$1.prototype.toJSON.call(this);
            json.value = _value;
            return json;
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        this.registerYType = function () {
            that
                .getRootSubjectEntity()
                .getYMap()
                .observe(function (event) {
                const array = Array.from(event.changes.keys.entries());
                array.forEach(([key, change]) => {
                    var operation = new ValueChangeOperation(event.entityId, event.value, event.type, event.position, event.jabberId);
                    _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
                    processValueChangeOperation(operation);
                    if (_iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID] ===
                        operation.getJabberId()) {
                        const activityMap = y.getMap("activity");
                        activityMap.set(ActivityOperation.TYPE, new ActivityOperation("ValueChangeActivity", that.getEntityId(), _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], ValueChangeOperation.getOperationDescription(that.getSubjectEntity().getName(), that.getRootSubjectEntity().getType(), that.getRootSubjectEntity().getLabel().getValue().getValue()), {
                            value: operation.getValue(),
                            subjectEntityName: that.getSubjectEntity().getName(),
                            rootSubjectEntityType: that
                                .getRootSubjectEntity()
                                .getType(),
                            rootSubjectEntityId: that
                                .getRootSubjectEntity()
                                .getEntityId(),
                        }).toJSON());
                    }
                    else {
                        _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
                    }
                });
            });
            that
                .getRootSubjectEntity()
                .getYMap()
                .observe(lodash.debounce(function (event) {
                if (event &&
                    event.jabberId === _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID])
                    EntityManagerInstance$1.storeDataYjs();
            }, 500));
        };
        init();
    }
};
const integerAttributeHtml$1 = "<div class=\"single_value_attribute\">\n    <div class=\"name\"></div>\n    <div class=\"value\"></div>\n</div>";
let IntegerAttribute$1 = class IntegerAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, useAttributeHtml) {
        useAttributeHtml =
            typeof useAttributeHtml !== "undefined" ? useAttributeHtml : false;
        super(id, name, subjectEntity);
        var _value = new IntegerValue$1(id, name, this, this.getRootSubjectEntity(), useAttributeHtml);
        var _$node = $(lodash.template(integerAttributeHtml$1)());
        this.setValue = function (value) {
            _value = value;
            _$node.val(value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.value = _value.toJSON();
            return json;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".name").text(this.getName());
        _$node.find(".value").append(_value.get$node());
    }
};
$.fn.autoGrowInput = function (o) {
    o = $.extend({
        maxWidth: 1000,
        minWidth: 0,
        comfortZone: 70,
    }, o);
    this.filter("input:text").each(function () {
        var minWidth = o.minWidth || $(this).width(), val = "", input = $(this), testSubject = $("<tester/>").css({
            position: "absolute",
            top: -9999,
            left: -9999,
            width: "auto",
            fontSize: input.css("fontSize"),
            fontFamily: input.css("fontFamily"),
            fontWeight: input.css("fontWeight"),
            letterSpacing: input.css("letterSpacing"),
            whiteSpace: "nowrap",
        }), check = function () {
            val = input.val();
            var escaped = val
                .replace(/&/g, "&amp;")
                .replace(/\s/g, "&nbsp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
            testSubject.html(escaped);
            var testerWidth = testSubject.width(), newWidth = testerWidth + o.comfortZone >= minWidth
                ? testerWidth + o.comfortZone
                : minWidth, currentWidth = input.width(), isValidWidthChange = (newWidth < currentWidth && newWidth >= minWidth) ||
                (newWidth > minWidth && newWidth < o.maxWidth);
            if (isValidWidthChange) {
                input.width(newWidth);
            }
        };
        $("body").append(testSubject);
        $(this).bind("keyup keydown blur update", check);
    });
    return this;
};
const valueHtml = "<input\n  class=\"form-control val\"\n  type=\"text\"\n  name=\"<%= name %>\"\n  disabled=\"disabled\"\n/>\n";
let Value$1 = class Value extends AbstractValue$1 {
    constructor(id, name, subjectEntity, rootSubjectEntity, y) {
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var _ytext = null;
        y = y || window.y;
        if (y && id.indexOf("undefined") == -1) {
            const yMap = rootSubjectEntity.getYMap();
            if (!yMap) {
                throw new Error("yMap is undefined");
            }
            if (yMap?.has(id)) {
                _ytext = rootSubjectEntity.getYMap().get(id);
                if (!(_ytext instanceof Text$1)) {
                    _ytext = new Text$1();
                    rootSubjectEntity.getYMap().set(id, _ytext);
                }
            }
            else {
                _ytext = new Text$1();
                rootSubjectEntity.getYMap().set(id, _ytext);
            }
        }
        super(id, name, subjectEntity, rootSubjectEntity);
        this.value = "";
        var that = this;
        var _value = "";
        this.value = _value;
        var _$node = $(lodash.template(valueHtml)({ name: name }));
        this.setValue = function (value) {
            _value = value;
            _$node.val(value).trigger("blur");
            this.value = _ytext.toString();
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractValue$1.prototype.toJSON.call(this);
            json.value = _value;
            return json;
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        this.registerYType = function () {
            _$node.on("input", function () {
                if (_ytext) {
                    if (_$node.val() !== _ytext.toString()) {
                        if (_ytext.toString().length > 0)
                            _ytext.delete(0, _ytext.toString().length);
                        _ytext.insert(0, _$node.val());
                    }
                }
            });
            if (that.getValue() !== _ytext.toString()) {
                if (_ytext.toString().length > 0)
                    _ytext.delete(0, _ytext.toString().length - 1);
                _ytext.insert(0, that.getValue());
            }
            _ytext.observe(function (event) {
                _value = _ytext.toString().replace(/\n/g, "");
                that.setValue(_value);
            });
            _ytext.observe(lodash.debounce(function (event) {
                event.keysChanged.forEach((key) => {
                    if (key !== "delete") {
                        const userMap = y.getMap("users");
                        var jabberId = userMap.get(event.object._content[event.index].id[0]);
                        if (jabberId === _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]) {
                            EntityManagerInstance$1.storeDataYjs();
                            const activityMap = y.getMap("activity");
                            activityMap.set(ActivityOperation.TYPE, new ActivityOperation("ValueChangeActivity", that.getEntityId(), jabberId, ValueChangeOperation.getOperationDescription(that.getSubjectEntity().getName(), that.getRootSubjectEntity().getType(), that
                                .getRootSubjectEntity()
                                .getLabel()
                                .getValue()
                                .getValue()), {
                                value: _value,
                                subjectEntityName: that.getSubjectEntity().getName(),
                                rootSubjectEntityType: that
                                    .getRootSubjectEntity()
                                    .getType(),
                                rootSubjectEntityId: that
                                    .getRootSubjectEntity()
                                    .getEntityId(),
                            }).toJSON());
                        }
                        else {
                            EntityManagerInstance$1.storeDataYjs();
                        }
                    }
                });
            }, 500));
        };
        this.getYText = function () {
            return _ytext;
        };
        _$node
            .autoGrowInput({
            comfortZone: 10,
            minWidth: 40,
            maxWidth: 1000,
        })
            .trigger("blur");
    }
};
function ViewTypesUtil$1() { }
ViewTypesUtil$1.GetAllNodesOfBaseModelAsSelectionList = function (nodes) {
    var selectionList = {};
    for (var key in nodes) {
        if (nodes.hasOwnProperty(key)) {
            selectionList[key] = nodes[key].getLabel().getValue().getValue();
        }
    }
    return selectionList;
};
ViewTypesUtil$1.GetAllNodesOfBaseModelAsSelectionList2 = function (nodes, types) {
    var selectionList = {};
    selectionList["empty"] = "";
    for (var key in nodes) {
        if (nodes.hasOwnProperty(key)) {
            if (lodash.indexOf(types, nodes[key].type) != -1)
                selectionList[key] = nodes[key].label.value.value;
        }
    }
    return selectionList;
};
ViewTypesUtil$1.createReferenceToOrigin = function (viewtype) {
    const dataMap = y.getMap("data");
    var vls = dataMap.get("metamodelpreview");
    var originEntity;
    if (vls) {
        var targetAttr = viewtype.getAttribute(viewtype.getEntityId() + "[target]");
        var originId = targetAttr.getValue().getValue();
        if (viewtype.getType() === "ViewObject") {
            if (vls.nodes.hasOwnProperty(originId)) {
                originEntity = vls.nodes[originId];
                viewtype.getLabel().getValue().setValue(originEntity.label);
            }
        }
        else {
            if (vls.edges.hasOwnProperty(originId)) {
                originEntity = vls.edges[originId];
                viewtype.getLabel().getValue().setValue(originEntity.label);
            }
        }
        var originAttrs = originEntity.attributes;
        var renamingList = viewtype.getAttribute("[attributes]");
        var optionMap = {};
        for (var attrKey in originAttrs) {
            if (originAttrs.hasOwnProperty(attrKey)) {
                var attr = originAttrs[attrKey];
                var id = Util.generateRandomId();
                var operation = new AttributeAddOperation(id, renamingList.getEntityId(), viewtype.getEntityId, "RenamingAttribute");
                var renamingAttr = renamingList.propagateAttributeAddOperation(operation);
                renamingAttr.getKey().setValue(attr.key);
                renamingAttr.getRef().setValue(attr.key);
                optionMap[id] = attr.key;
            }
        }
        viewtype.getYMap().set("updateConditionOption", optionMap);
        renamingList.get$node().show();
        viewtype
            .getAttribute(viewtype.getEntityId() + "[conjunction]")
            .get$node()
            .show();
        viewtype.getAttribute("[condition]").get$node().show();
    }
};
const singleQuizAttributeHtml$1 = "<div class=\"single_quiz_attribute\">\n  <div class=\"name\"></div>\n  <div class=\"value\"></div>\n  <table id=\"table\" style=\"float: left; visibility: hidden\">\n    <tr>\n      <th>Assessment Name :</th>\n      <th><input class=\"form-control\" id=\"topic\" /></th>\n    </tr>\n    <tr>\n      <td>Nr</td>\n      <td>Question</td>\n      <td>Correct Intent</td>\n      <td>Optional Hint</td>\n    </tr>\n  </table>\n  <button\n    id=\"b\"\n    style=\"margin-left: 3px; float: left; width: 50%; visibility: hidden\"\n  >\n    +\n  </button>\n  <button\n    id=\"c\"\n    style=\"margin-left: 3px; float: left; width: 50%; visibility: hidden\"\n  >\n    -\n  </button>\n  <button\n    id=\"submit\"\n    style=\"margin-left: 3px; float: left; width: 50%; visibility: hidden\"\n  >\n    Submit\n  </button>\n  <button\n    id=\"display\"\n    style=\"margin-left: 3px; float: left; width: 50%; visibility: hidden\"\n  >\n    Display\n  </button>\n</div>\n";
let QuizAttribute$1 = class QuizAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity) {
        super(id, name, subjectEntity);
        var _value = new Value$1(id, name, this, this.getRootSubjectEntity());
        var _$node = $(lodash.template(singleQuizAttributeHtml$1)({ id: id }));
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.value = _value.toJSON();
            return json;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        this.registerYType = function () {
            _value.registerYType();
        };
        _$node.find(".name").text(this.getName());
        _$node.find(".value").append(_value.get$node());
        function addRow() {
            var table = _$node.find("#table")[0];
            var rows = table.rows.length;
            var row = table.insertRow(table.rows.length);
            var cell0 = row.insertCell(0);
            var cell1 = row.insertCell(1);
            var cell2 = row.insertCell(2);
            var cell3 = row.insertCell(3);
            var input0 = document.createElement("input");
            var input1 = document.createElement("input");
            var input2 = document.createElement("input");
            var input3 = document.createElement("input");
            input0.id = rows + "0";
            input1.id = rows + "1";
            input2.id = rows + "2";
            input3.id = rows + "3";
            input1.type = "text";
            input2.type = "text";
            input3.type = "text";
            cell0.appendChild(input0);
            cell1.appendChild(input1);
            cell2.appendChild(input2);
            cell3.appendChild(input3);
        }
        this.showTable = function () {
            _$node.find("#table")[0].style.visibility = "visible";
            _$node.find("#b")[0].style.visibility = "visible";
            _$node.find("#c")[0].style.visibility = "visible";
            _$node.find("#submit")[0].style.visibility = "visible";
            _$node.find("#display")[0].style.visibility = "visible";
        };
        this.hideTable = function () {
            _$node.find("#table")[0].style.visibility = "hidden";
            _$node.find("#b")[0].style.visibility = "hidden";
            _$node.find("#c")[0].style.visibility = "hidden";
            _$node.find("#submit")[0].style.visibility = "hidden";
            _$node.find("#display")[0].style.visibility = "hidden";
        };
        _$node.find("#b").click(function () {
            addRow();
        });
        _$node.find("#c").click(function () {
            var table = _$node.find("#table")[0];
            var rows = table.rows.length;
            table.deleteRow(rows - 1);
        });
        _$node.find("#submit").click(function () {
            var table = _$node.find("#table")[0];
            var Json = {};
            Json["topic"] = _$node.find("#topic")[0].value;
            var Sequence = [];
            var Questions = [];
            var Intents = [];
            var Hints = [];
            var row = table.rows.length;
            for (var i = 2; i < row; i++) {
                if (_$node.find("#" + i.toString() + "1")[0].value == "" ||
                    _$node.find("#" + i.toString() + "2")[0].value == "") {
                    continue;
                }
                Sequence.push(_$node.find("#" + i.toString() + "0")[0].value);
                Questions.push(_$node.find("#" + i.toString() + "1")[0].value);
                Intents.push(_$node.find("#" + i.toString() + "2")[0].value);
                if (_$node.find("#" + i.toString() + "3")[0].value == "") {
                    Hints.push("No Hint Available for this Question");
                }
                else
                    Hints.push(_$node.find("#" + i.toString() + "3")[0].value);
            }
            Json["Questions"] = Questions;
            Json["Sequence"] = Sequence;
            Json["Intents"] = Intents;
            Json["Hints"] = Hints;
            console.log(JSON.stringify(Json));
            _$node.find(".val")[0].value = JSON.stringify(Json);
            var field = _$node.find(".val")[0];
            field.dispatchEvent(new Event("input"));
        });
        _$node.find("#display").click(function () {
            var table = _$node.find("#table")[0];
            var Json = _$node.find(".val")[0].value;
            console.log(Json);
            var content = JSON.parse(Json);
            _$node.find("#topic")[0].value = content.topic;
            var rowNumb = content.Questions.length;
            console.log(rowNumb);
            var currRows = table.rows.length - 2;
            console.log(currRows);
            if (currRows < rowNumb) {
                for (currRows; currRows < rowNumb; currRows++) {
                    addRow();
                }
            }
            for (var i = 2; i < rowNumb + 2; i++) {
                if (_$node.find("#" + i.toString() + "0")[0].value == null) {
                    break;
                }
                _$node.find("#" + i.toString() + "0")[0].value =
                    content.Sequence[i - 2];
                _$node.find("#" + i.toString() + "1")[0].value =
                    content.Questions[i - 2];
                _$node.find("#" + i.toString() + "2")[0].value = content.Intents[i - 2];
                _$node.find("#" + i.toString() + "3")[0].value = content.Hints[i - 2];
            }
        });
    }
};
let selectionValueHtml$1 = "<div class=\"val\"><%= options[_.keys(options)[0]] %></div>";
const attributeSelectionValueHtml = "<select class=\"val form-select mb-3 h-100\">\n  <% _.each(options,function(option,key){ %>\n  <option value=\"<%= key %>\"><%= option %></option>\n  <% }); %>\n</select>\n";
let SelectionValue$1 = class SelectionValue extends AbstractValue$1 {
    constructor(id, name, subjectEntity, rootSubjectEntity, options, useAttributeHtml) {
        super(id, name, subjectEntity, rootSubjectEntity);
        var that = this;
        useAttributeHtml =
            typeof useAttributeHtml !== "undefinded" ? useAttributeHtml : false;
        var _value = lodash.keys(options)[0];
        if (useAttributeHtml) {
            selectionValueHtml$1 = attributeSelectionValueHtml;
        }
        var _$node = $(lodash.template(selectionValueHtml$1)({
            name: name,
            options: options,
        }));
        if (useAttributeHtml) {
            _$node.off();
        }
        y = y || window.y;
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var processValueChangeOperation = function (operation) {
            that.setValue(operation.getValue());
        };
        this.setValue = function (value) {
            _value = value;
            if (useAttributeHtml) {
                _$node.val(value);
                if (value == "Quiz") {
                    Object.values(rootSubjectEntity.getAttributes()).forEach((value) => {
                        if (value instanceof QuizAttribute$1) {
                            value.showTable();
                        }
                    });
                }
                else
                    Object.values(rootSubjectEntity.getAttributes()).forEach((value) => {
                        if (value instanceof QuizAttribute$1) {
                            value.hideTable();
                        }
                    });
            }
            else
                _$node.text(options[value]);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractValue$1.prototype.toJSON.call(this);
            json.value = _value;
            return json;
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        this.registerYType = function () {
            that
                .getRootSubjectEntity()
                .getYMap()
                .observe(function (event) {
                const array = Array.from(event.changes.keys.entries());
                array.forEach(([key, change]) => {
                    var operation = new ValueChangeOperation(event.entityId, event.value, event.type, event.position, event.jabberId);
                    _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
                    processValueChangeOperation(operation);
                    if (_iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID] ===
                        operation.getJabberId()) {
                        const activityMap = y.getMap("activity");
                        activityMap.set(ActivityOperation.TYPE, new ActivityOperation("ValueChangeActivity", that.getEntityId(), _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], ValueChangeOperation.getOperationDescription(that.getSubjectEntity().getName(), that.getRootSubjectEntity().getType(), that.getRootSubjectEntity().getLabel().getValue().getValue()), {
                            value: operation.getValue(),
                            subjectEntityName: that.getSubjectEntity().getName(),
                            rootSubjectEntityType: that
                                .getRootSubjectEntity()
                                .getType(),
                            rootSubjectEntityId: that
                                .getRootSubjectEntity()
                                .getEntityId(),
                        }).toJSON());
                        if (event.entityId.indexOf("[target]") != -1) {
                            ViewTypesUtil$1.createReferenceToOrigin(that.getRootSubjectEntity());
                            Promise.resolve().then(function () { return ClosedViewGeneration; }).then(function (CVG) {
                                CVG(rootSubjectEntity);
                            });
                        }
                        EntityManagerInstance$1.storeDataYjs();
                    }
                    else {
                        _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
                    }
                });
            });
        };
    }
};
const keySelectionValueAttributeHtml$1 = "<li class=\"key_value_attribute\" id=\"<%= id %>\">\n    <div class=\"key\"></div>\n    <div class=\"value\"></div>\n</li>";
let KeySelectionValueAttribute$1 = class KeySelectionValueAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, options) {
        super(id, name, subjectEntity);
        var _ymap = null;
        var _options = options;
        var _key = new Value$1(id + "[key]", "", this, this.getRootSubjectEntity());
        var _value = new SelectionValue$1(id + "[value]", "", this, this.getRootSubjectEntity(), _options);
        var _$node = $(lodash.template(keySelectionValueAttributeHtml$1)({ id: id }));
        this.setKey = function (key) {
            _key = key;
        };
        this.getKey = function () {
            return _key;
        };
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.key = _key.toJSON();
            json.value = _value.toJSON();
            return json;
        };
        this.setValueFromJSON = function (json) {
            _key.setValueFromJSON(json.key);
            _value.setValueFromJSON(json.value);
        };
        this.registerYMap = function () {
            _key.registerYType();
            _value.registerYType();
        };
        this.getYMap = function () {
            return _ymap;
        };
        _$node.find(".key").append(_key.get$node());
        _$node.find(".value").append(_value.get$node());
    }
};
const keySelectionValueListAttributeHtml$1 = "<div class=\"list_attribute\">\n    <div class=\"name\"></div>\n    <ul class=\"list\"></ul>\n</div>";
let KeySelectionValueListAttribute$1 = class KeySelectionValueListAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, options) {
        super(id, name, subjectEntity);
        var that = this;
        var _options = options;
        var _list = {};
        var _$node = $(lodash.template(keySelectionValueListAttributeHtml$1)());
        y = y || window.y;
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var processAttributeAddOperation = function (operation) {
            var attribute = new KeySelectionValueAttribute$1(operation.getEntityId(), "Attribute", that, _options);
            attribute.registerYMap();
            that.addAttribute(attribute);
            if (_$node.find(".list").find("#" + attribute.getEntityId()).length == 0)
                _$node.find(".list").append(attribute.get$node());
        };
        var processAttributeDeleteOperation = function (operation) {
            var attribute = that.getAttribute(operation.getEntityId());
            if (attribute) {
                that.deleteAttribute(attribute.getEntityId());
                attribute.get$node().remove();
            }
        };
        var propagateAttributeAddOperation = function (operation) {
            processAttributeAddOperation(operation);
        };
        var propagateAttributeDeleteOperation = function (operation) {
            processAttributeDeleteOperation(operation);
            var ymap = that.getRootSubjectEntity().getYMap();
            ymap.delete(operation.getEntityId() + "[key]");
        };
        var remoteAttributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeAddOperation(operation);
            }
        };
        var remoteAttributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        var localAttributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                propagateAttributeAddOperation(operation);
            }
        };
        var localAttributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                propagateAttributeDeleteOperation(operation);
            }
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_list.hasOwnProperty(id)) {
                _list[id] = attribute;
            }
        };
        this.getAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                return _list[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                delete _list[id];
            }
        };
        this.getAttributes = function () {
            return _list;
        };
        this.setAttributes = function (list) {
            _list = list;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.type = KeySelectionValueListAttribute$1.TYPE;
            var attr = {};
            lodash.forEach(this.getAttributes(), function (val, key) {
                attr[key] = val.toJSON();
            });
            json.list = attr;
            return json;
        };
        this.setValueFromJSON = function (json) {
            lodash.forEach(json.list, function (val, key) {
                var attribute = new KeySelectionValueAttribute$1(key, key, that, _options);
                attribute.setValueFromJSON(json.list[key]);
                that.addAttribute(attribute);
                if (_$node.find(".list").find("#" + attribute.getEntityId()).length == 0)
                    _$node.find(".list").append(attribute.get$node());
            });
        };
        this.registerCallbacks = function () {
            _iwcw.registerOnDataReceivedCallback(localAttributeAddCallback);
            _iwcw.registerOnDataReceivedCallback(localAttributeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            _iwcw.unregisterOnDataReceivedCallback(localAttributeAddCallback);
            _iwcw.unregisterOnDataReceivedCallback(localAttributeDeleteCallback);
        };
        _$node.find(".name").text(this.getName());
        for (var attributeId in _list) {
            if (_list.hasOwnProperty(attributeId)) {
                _$node.find(".list").append(_list[attributeId].get$node());
            }
        }
        if (_iwcw) {
            that.registerCallbacks();
        }
        this.registerYMap = function () {
            var ymap = that.getRootSubjectEntity().getYMap();
            var attrs = that.getAttributes();
            for (var key in attrs) {
                if (attrs.hasOwnProperty(key)) {
                    var attr = attrs[key];
                    attr.getKey().registerYType();
                    attr.getValue().registerYType();
                }
            }
            ymap.observe(function (event) {
                event.keysChanged;
                const array = Array.from(event.changes.keys.entries());
                array.forEach(([key, change]) => {
                    if (key.indexOf("[key]") != -1) {
                        var operation;
                        event.currentTarget.get(key);
                        switch (change.action) {
                            case "add": {
                                operation = new AttributeAddOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                                remoteAttributeAddCallback(operation);
                                break;
                            }
                            case "delete": {
                                operation = new AttributeDeleteOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                                remoteAttributeDeleteCallback(operation);
                                break;
                            }
                        }
                    }
                });
            });
        };
    }
    static { this.TYPE = "KeySelectionValueListAttribute"; }
};
const keySelectionValueSelectionValueAttributeHtml$1 = "<li class=\"key_value_attribute\" id=\"<%= id %>\">\n    <div class=\"key\"></div>\n    <div class=\"value\"></div>\n</li>";
let KeySelectionValueSelectionValueAttribute$1 = class KeySelectionValueSelectionValueAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, options, options2) {
        super(id, name, subjectEntity);
        var _options = options;
        var _options2 = options2;
        var _key = new Value$1(id + "[key]", "", this, this.getRootSubjectEntity());
        var _value = new SelectionValue$1(id + "[value]", "", this, this.getRootSubjectEntity(), _options);
        var _value2 = new SelectionValue$1(id + "[value2]", "", this, this.getRootSubjectEntity(), _options2);
        var _$node = $(lodash.template(keySelectionValueSelectionValueAttributeHtml$1)({ id: id }));
        this.setKey = function (key) {
            _key = key;
        };
        this.getKey = function () {
            return _key;
        };
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.setValue2 = function (value) {
            _value2 = value;
        };
        this.getValue2 = function () {
            return _value2;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.key = _key.toJSON();
            json.value = _value.toJSON();
            json.value2 = _value2.toJSON();
            return json;
        };
        this.setValueFromJSON = function (json) {
            _key.setValueFromJSON(json.key);
            _value.setValueFromJSON(json.value);
            _value2.setValueFromJSON(json.value2 || { value: "" });
        };
        this.registerYType = function () {
            _key.registerYType();
            _value.registerYType();
            _value2.registerYType();
        };
        _$node.find(".key").append(_key.get$node());
        _$node.find(".value").append(_value.get$node());
    }
};
const keySelectionValueSelectionValueListAttributeHtml$1 = "<div class=\"list_attribute\">\n    <div class=\"name\"></div>\n    <ul class=\"list\"></ul>\n</div>";
let KeySelectionValueSelectionValueListAttribute$1 = class KeySelectionValueSelectionValueListAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, options, options2) {
        super(id, name, subjectEntity);
        var that = this;
        var _options = options;
        var _options2 = options2;
        var _list = {};
        var _$node = $(lodash.template(keySelectionValueSelectionValueListAttributeHtml$1)());
        y = y || window.y;
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var processAttributeAddOperation = function (operation) {
            var attribute = new KeySelectionValueSelectionValueAttribute$1(operation.getEntityId(), "Attribute", that, _options, _options2);
            attribute.registerYType();
            that.addAttribute(attribute);
            if (_$node.find(".list").find("#" + attribute.getEntityId()).length == 0)
                _$node.find(".list").append(attribute.get$node());
        };
        var processAttributeDeleteOperation = function (operation) {
            var attribute = that.getAttribute(operation.getEntityId());
            if (attribute) {
                that.deleteAttribute(attribute.getEntityId());
                attribute.get$node().remove();
            }
        };
        var propagateAttributeAddOperation = function (operation) {
            processAttributeAddOperation(operation);
        };
        var propagateAttributeDeleteOperation = function (operation) {
            processAttributeDeleteOperation(operation);
            var ynode = that.getRootSubjectEntity().getYMap();
            ynode.delete(operation.getEntityId() + "[key]");
        };
        var remoteAttributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeAddOperation(operation);
            }
        };
        var remoteAttributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
                processAttributeDeleteOperation(operation);
            }
        };
        var localAttributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                propagateAttributeAddOperation(operation);
            }
        };
        var localAttributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                propagateAttributeDeleteOperation(operation);
            }
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_list.hasOwnProperty(id)) {
                _list[id] = attribute;
            }
        };
        this.getAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                return _list[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                _list[id];
                delete _list[id];
            }
        };
        this.getAttributes = function () {
            return _list;
        };
        this.setAttributes = function (list) {
            _list = list;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.type = KeySelectionValueSelectionValueListAttribute$1.TYPE;
            var attr = {};
            lodash.forEach(this.getAttributes(), function (val, key) {
                attr[key] = val.toJSON();
            });
            json.list = attr;
            return json;
        };
        this.setValueFromJSON = function (json) {
            lodash.forEach(json.list, function (val, key) {
                var attribute = new KeySelectionValueSelectionValueAttribute$1(key, key, that, _options, _options2);
                attribute.setValueFromJSON(json.list[key]);
                that.addAttribute(attribute);
                if (_$node.find(".list").find("#" + attribute.getEntityId()).length == 0)
                    _$node.find(".list").append(attribute.get$node());
            });
        };
        this.registerCallbacks = function () {
            _iwcw.registerOnDataReceivedCallback(localAttributeAddCallback);
            _iwcw.registerOnDataReceivedCallback(localAttributeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            _iwcw.unregisterOnDataReceivedCallback(localAttributeAddCallback);
            _iwcw.unregisterOnDataReceivedCallback(localAttributeDeleteCallback);
        };
        _$node.find(".name").text(this.getName());
        for (var attributeId in _list) {
            if (_list.hasOwnProperty(attributeId)) {
                _$node.find(".list").append(_list[attributeId].get$node());
            }
        }
        if (_iwcw) {
            that.registerCallbacks();
        }
        this.registerYMap = function () {
            var ymap = that.getRootSubjectEntity().getYMap();
            var attrs = that.getAttributes();
            for (var key in attrs) {
                if (attrs.hasOwnProperty(key)) {
                    var attr = attrs[key];
                    attr.registerYType();
                }
            }
            ymap.observe(function (event) {
                const array = Array.from(event.changes.keys.entries());
                array.forEach(([key, change]) => {
                    if (key.indexOf("[key]") != -1) {
                        var operation;
                        event.currentTarget.get(key);
                        switch (change.action) {
                            case "add": {
                                const jabberId = event.currentTarget.get("jabberId");
                                if (jabberId === _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID])
                                    return;
                                operation = new AttributeAddOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                                remoteAttributeAddCallback(operation);
                                break;
                            }
                            case "delete": {
                                operation = new AttributeDeleteOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                                remoteAttributeDeleteCallback(operation);
                                break;
                            }
                        }
                    }
                });
            });
        };
    }
    static { this.TYPE = "KeySelectionValueSelectionValueListAttribute"; }
};
const singleColorValueAttributeHtml$1 = "<div class=\"single_value_attribute\">\n    <div class=\"name\"></div>\n    <div class=\"value\"></div>\n</div>";
let SingleColorValueAttribute$1 = class SingleColorValueAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity) {
        super(id, name, subjectEntity);
        var _value = new Value$1(id, name, this, this.getRootSubjectEntity());
        var _$node = $(lodash.template(singleColorValueAttributeHtml$1)());
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.value = _value.toJSON();
            return json;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".name").text(this.getName());
        _$node.find(".value").append(_value.get$node());
    }
};
const multiLineValueHtml = "<div class=\"val\"><%= value %></div>";
let MultiLineValue$1 = class MultiLineValue extends AbstractValue$1 {
    constructor(id, name, subjectEntity, rootSubjectEntity, y) {
        super(id, name, subjectEntity, rootSubjectEntity);
        var that = this;
        var _ytext = null;
        y = y || window.y;
        if (y) {
            const yMap = rootSubjectEntity.getYMap();
            if (!yMap) {
                rootSubjectEntity.registerYMap();
            }
            if (rootSubjectEntity.getYMap()?.has(id))
                _ytext = rootSubjectEntity.getYMap().get(id);
            else {
                _ytext = new Text$1();
                rootSubjectEntity.getYMap().set(id, _ytext);
            }
        }
        var _value = "";
        var _$node = $(lodash.template(multiLineValueHtml)({ value: _value }));
        y = y || window.y;
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var getEntityIdChain = function () {
            var chain = [that.getEntityId()], entity = that;
            while (entity instanceof AbstractAttribute$1) {
                chain.unshift(entity.getSubjectEntity().getEntityId());
                entity = entity.getSubjectEntity();
            }
            return chain;
        };
        var propagateValueChangeOperation = function (operation) {
            operation.setEntityIdChain(getEntityIdChain());
            operation.setRemote(false);
            that.setValue(operation.getValue());
            operation.setRemote(true);
            const activityMap = y.getMap("activity");
            activityMap.set(ActivityOperation.TYPE, new ActivityOperation("ValueChangeActivity", that.getEntityId(), _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], ValueChangeOperation.getOperationDescription(that.getSubjectEntity().getName(), that.getRootSubjectEntity().getType(), that.getRootSubjectEntity().getLabel().getValue().getValue()), {
                value: _value,
                subjectEntityName: that.getSubjectEntity().getName(),
                rootSubjectEntityType: that.getRootSubjectEntity().getType(),
                rootSubjectEntityId: that.getRootSubjectEntity().getEntityId(),
            })
                .toNonOTOperation()
                .toJSON());
        };
        var localValueChangeCallback = function (operation) {
            if (operation instanceof ValueChangeOperation &&
                operation.getEntityId() === that.getEntityId()) {
                propagateValueChangeOperation(operation);
            }
        };
        this.setValue = function (value) {
            _value = value;
            _$node.text(value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractValue$1.prototype.toJSON.call(this);
            json.value = _value;
            return json;
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        this.registerCallbacks = function () {
            _iwcw.registerOnDataReceivedCallback(localValueChangeCallback);
        };
        this.unregisterCallbacks = function () {
            _iwcw.unregisterOnDataReceivedCallback(localValueChangeCallback);
        };
        this.registerYType = function () {
            if (!_ytext)
                throw new Error("_ytext is undefined");
            if (that.getValue() !== _ytext.toString()) {
                if (_ytext.toString().length > 0)
                    _ytext.delete(0, _ytext.toString().length - 1);
                _ytext.insert(0, that.getValue());
            }
            _ytext.observe(function (event) {
                _value = _ytext.toString();
                if (event.type !== "delete") {
                    y.getMap("users");
                    var jabberId = "User";
                    const activityMap = y.getMap("activity");
                    activityMap.set(ActivityOperation.TYPE, new ActivityOperation("ValueChangeActivity", that.getEntityId(), jabberId, ValueChangeOperation.getOperationDescription(that.getSubjectEntity().getName(), that.getRootSubjectEntity().getType(), that.getRootSubjectEntity().getLabel().getValue().getValue()), {
                        value: "",
                        subjectEntityName: that.getSubjectEntity().getName(),
                        rootSubjectEntityType: that.getRootSubjectEntity().getType(),
                        rootSubjectEntityId: that.getRootSubjectEntity().getEntityId(),
                    }).toJSON());
                }
            });
        };
        if (_iwcw) {
            that.registerCallbacks();
        }
    }
};
const singleMultiLineValueAttributeHtml$1 = "<div class=\"single_value_attribute\">\n    <div class=\"name\"></div>\n    <div class=\"value\"></div>\n</div>";
let SingleMultiLineValueAttribute$1 = class SingleMultiLineValueAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, y) {
        super(id, name, subjectEntity);
        var _value = new MultiLineValue$1(id, name, this, this.getRootSubjectEntity(), y);
        var _$node = $(lodash.template(singleMultiLineValueAttributeHtml$1)());
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.value = _value.toJSON();
            return json;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".name").text(this.getName());
        _$node.find(".value").append(_value.get$node());
    }
};
const singleSelectionAttributeHtml$1 = "<div class=\"single_value_attribute\">\n    <div class=\"name\"></div>\n    <div class=\"value\"></div>\n</div>";
let SingleSelectionAttribute$1 = class SingleSelectionAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, options, useAttributeHtml) {
        super(id, name, subjectEntity);
        useAttributeHtml =
            typeof useAttributeHtml !== "undefinded" ? useAttributeHtml : false;
        var that = this;
        var _value = new SelectionValue$1(id, name, this, this.getRootSubjectEntity(), options, useAttributeHtml);
        var _$node = $(lodash.template(singleSelectionAttributeHtml$1)());
        this.setValue = function (value) {
            _value = value;
            _$node.val(value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.getOptionValue = function () {
            return options.hasOwnProperty(_value.getValue())
                ? options[_value.getValue()]
                : null;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.value = _value.toJSON();
            json.option = that.getOptionValue();
            return json;
        };
        this.getOptions = function () {
            return options;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".name").text(this.getName());
        _$node.find(".value").append(_value.get$node());
    }
};
const canvasSingleValueAttributeHtml = "<div class=\"single_value_attribute\">\n    <div class=\"name\"></div>\n    <div class=\"value\"></div>\n</div>";
let SingleValueAttribute$1 = class SingleValueAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, y) {
        y = y || window.y;
        if (!y) {
            throw new Error("y is undefined");
        }
        super(id, name, subjectEntity);
        var _value = new Value$1(id, name, this, this.getRootSubjectEntity(), y);
        this.value = _value;
        var _$node = $(lodash.template(canvasSingleValueAttributeHtml)());
        this.setValue = function (value) {
            _value = value;
            this.value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.value = _value.toJSON();
            return json;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        this.registerYType = function () {
            _value.registerYType();
        };
        _$node.find(".name").text(this.getName());
        _$node.find(".value").append(_value.get$node());
    }
};
const singleValueListAttributeHtml$1 = "<div class=\"list_attribute\">\n    <div class=\"name\"></div>\n    <ul class=\"list\"></ul>\n</div>";
let SingleValueListAttribute$1 = class SingleValueListAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity) {
        super(id, name, subjectEntity);
        var that = this;
        var _list = {};
        var _$node = $(lodash.template(singleValueListAttributeHtml$1)());
        y = y || window.y;
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var processAttributeAddOperation = function (operation) {
            var attribute = new SingleValueAttribute$1(operation.getEntityId() + "[value]", "Attribute", that);
            attribute.registerYType();
            that.addAttribute(attribute);
            _$node.find(".list").append(attribute.get$node());
        };
        var processAttributeDeleteOperation = function (operation) {
            var attribute = that.getAttribute(operation.getEntityId());
            if (attribute) {
                that.deleteAttribute(attribute.getEntityId());
                attribute.get$node().remove();
            }
        };
        var propagateAttributeAddOperation = function (operation) {
            processAttributeAddOperation(operation);
        };
        var propagateAttributeDeleteOperation = function (operation) {
            processAttributeDeleteOperation(operation);
            var ynode = that.getRootSubjectEntity().getYMap();
            ynode.delete(operation.getEntityId());
        };
        var remoteAttributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeAddOperation(operation);
            }
        };
        var remoteAttributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        var localAttributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                propagateAttributeAddOperation(operation);
            }
        };
        var localAttributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                propagateAttributeDeleteOperation(operation);
            }
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_list.hasOwnProperty(id)) {
                _list[id] = attribute;
            }
        };
        this.getAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                return _list[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                delete _list[id];
            }
        };
        this.getAttributes = function () {
            return _list;
        };
        this.setAttributes = function (list) {
            _list = list;
        };
        this.get$node = function () {
            return _$node;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.type = SingleValueListAttribute$1.TYPE;
            var attr = {};
            lodash.forEach(this.getAttributes(), function (val, key) {
                attr[key] = val.toJSON();
            });
            json.list = attr;
            return json;
        };
        this.setValueFromJSON = function (json) {
            lodash.forEach(json.list, function (val, key) {
                var attribute = new SingleValueAttribute$1(key, key, that, y);
                attribute.setValueFromJSON(json.list[key]);
                that.addAttribute(attribute);
                _$node.find(".list").append(attribute.get$node());
            });
        };
        this.registerCallbacks = function () {
            _iwcw.registerOnDataReceivedCallback(localAttributeAddCallback);
            _iwcw.registerOnDataReceivedCallback(localAttributeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            _iwcw.unregisterOnDataReceivedCallback(localAttributeAddCallback);
            _iwcw.unregisterOnDataReceivedCallback(localAttributeDeleteCallback);
        };
        _$node.find(".name").text(this.getName());
        for (var attributeId in _list) {
            if (_list.hasOwnProperty(attributeId)) {
                _$node.find(".list").append(_list[attributeId].get$node());
            }
        }
        if (_iwcw) {
            that.registerCallbacks();
        }
        this.registerYMap = function (disableYText) {
            var ymap = that.getRootSubjectEntity().getYMap();
            var attrs = that.getAttributes();
            for (var key in attrs) {
                if (attrs.hasOwnProperty(key)) {
                    var attr = attrs[key];
                    attr.getValue().registerYType();
                }
            }
            ymap.observe(function (event) {
                var operation;
                const array = Array.from(event.changes.keys.entries());
                array.forEach(([key, change]) => {
                    if (key.indexOf("[value]") != -1) {
                        switch (change.action) {
                            case "add": {
                                const jabberId = event.target.get("jabberId");
                                if (jabberId === _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID])
                                    return;
                                operation = new AttributeAddOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                                remoteAttributeAddCallback(operation);
                                break;
                            }
                            case "delete": {
                                operation = new AttributeDeleteOperation(key, that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                                remoteAttributeDeleteCallback(operation);
                            }
                        }
                    }
                });
            });
        };
    }
    static { this.TYPE = "SingleValueListAttribute"; }
};
function makeViewEdge$1(type, arrowType, shapeType, color, dashstyle, overlay, overlayPosition, overlayRotate, attributes, edgeType, conditions, conj) {
    function ViewEdge(id, source, target) {
        var viewEdge = new edgeType(id, source, target);
        viewEdge.restyle(arrowType, color, shapeType, dashstyle, overlay, overlayPosition, overlayRotate, attributes);
        viewEdge.setCurrentViewType(type);
        return viewEdge;
    }
    ViewEdge.getConditions = function () {
        return conditions;
    };
    ViewEdge.getConditionConj = function () {
        return conj;
    };
    ViewEdge.getArrowType = function () {
        return arrowType;
    };
    ViewEdge.getShapeType = function () {
        return shapeType;
    };
    ViewEdge.getColor = function () {
        return color;
    };
    ViewEdge.getOverlay = function () {
        return overlay;
    };
    ViewEdge.getOverlayPosition = function () {
        return overlayPosition;
    };
    ViewEdge.getOverlayRotate = function () {
        return overlayRotate;
    };
    ViewEdge.getAttributes = function () {
        return attributes;
    };
    ViewEdge.getTargetEdgeType = function () {
        return edgeType;
    };
    ViewEdge.getType = function () {
        return type;
    };
    ViewEdge.getArrowOverlays = function () {
        var overlays = [];
        if (Arrows().hasOwnProperty(arrowType)) {
            overlays.push(Arrows(color)[arrowType]);
        }
        return overlays;
    };
    ViewEdge.getShape = function () {
        return this.getTargetEdgeType().getShape();
    };
    return ViewEdge;
}
function makeViewNode$1(type, $shape, anchors, attributes, nodeType, conditions, conj) {
    ViewNode.prototype.constructor = ViewNode;
    function ViewNode(id, left, top, width, height, zIndex) {
        var viewNode = new nodeType(id, left, top, width, height, zIndex);
        viewNode.set$shape($shape);
        viewNode.setAnchorOptions(anchors);
        viewNode.setCurrentViewType(type);
        return viewNode;
    }
    ViewNode.getConditions = function () {
        return conditions;
    };
    ViewNode.getConditionConj = function () {
        return conj;
    };
    ViewNode.get$shape = function () {
        return $shape;
    };
    ViewNode.getAnchors = function () {
        return anchors;
    };
    ViewNode.getTargetNodeType = function () {
        return nodeType;
    };
    return ViewNode;
}
const condition_predicateHtml$1 = "<li class=\"condition_predicate\">\n    <div class=\"property\"></div>\n    <div class=\"operator\"></div>\n    <div class=\"val\"></div>\n</li>";
let ConditionPredicateAttribute$1 = class ConditionPredicateAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, options, options2) {
        super(id, name, subjectEntity);
        var _options = options;
        var _options2 = options2;
        var _key = new Value$1(id + "[value]", "Attribute Value", this, this.getRootSubjectEntity());
        var _value = new SelectionValue$1(id + "[property]", "Attribute Name", this, this.getRootSubjectEntity(), _options);
        var _value2 = new SelectionValue$1(id + "[operator]", "Logical Operator", this, this.getRootSubjectEntity(), _options2);
        var _$node = $(lodash.template(condition_predicateHtml$1)());
        this.setKey = function (key) {
            _key = key;
        };
        this.getKey = function () {
            return _key;
        };
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.setValue2 = function (value) {
            _value2 = value;
        };
        this.getValue2 = function () {
            return _value2;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _key.setValueFromJSON(json.val);
            _value.setValueFromJSON(json.property);
            _value2.setValueFromJSON(json.operator || { value: "" });
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.val = _key.toJSON();
            json.property = _value.toJSON();
            json.operator = _value2.toJSON();
            return json;
        };
        _$node.find(".val").append(_key.get$node());
        _$node.find(".property").append(_value.get$node());
        _$node.find(".operator").append(_value2.get$node());
        this.registerYMap = function () {
            _key.registerYType();
            _value.registerYType();
            _value2.registerYType();
        };
    }
    static { this.TYPE = "ConditionPredicateAttribute"; }
};
function eventWasTriggeredByMe(yEvent) {
    const array = Array.from(yEvent.changes.keys.keys());
    if (!array)
        return false;
    const modifiedByKey = array.find((key) => key === "modifiedBy");
    if (modifiedByKey &&
        yEvent.currentTarget.get(modifiedByKey) === window.y.clientID)
        return true;
    return false;
}
const listHtml$1 = "<div class=\"list_attribute\">\n    <div class=\"name\"></div>\n    <ul class=\"list\"></ul>\n</div>";
let ConditionListAttribute$1 = class ConditionListAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, options, options2, y) {
        y = y || window.y;
        super(id, name, subjectEntity);
        var that = this;
        var _options = options;
        var _options2 = options2;
        var _list = {};
        var _$node = $(lodash.template(listHtml$1)());
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var processAttributeAddOperation = function (operation) {
            var attribute = new ConditionPredicateAttribute$1(operation.getEntityId(), "Attribute", that, _options, _options2);
            attribute.registerYMap();
            that.addAttribute(attribute);
            _$node.find(".list").append(attribute.get$node());
        };
        var propagateAttributeAddOperation = function (operation) {
            processAttributeAddOperation(operation);
        };
        var processAttributeDeleteOperation = function (operation) {
            var attribute = that.getAttribute(operation.getEntityId());
            if (attribute) {
                that.deleteAttribute(attribute.getEntityId());
                attribute.get$node().remove();
            }
        };
        var propagateAttributeDeleteOperation = function (operation) {
            processAttributeDeleteOperation(operation);
            var ymap = that.getRootSubjectEntity().getYMap();
            ymap.delete(operation.getEntityId() + "[val]");
        };
        var remoteAttributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeAddOperation(operation);
            }
        };
        var remoteAttributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        var localAttributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                propagateAttributeAddOperation(operation);
            }
        };
        var localAttributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                propagateAttributeDeleteOperation(operation);
            }
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_list.hasOwnProperty(id)) {
                _list[id] = attribute;
            }
        };
        this.getAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                return _list[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                delete _list[id];
            }
        };
        this.getAttributes = function () {
            return _list;
        };
        this.setAttributes = function (list) {
            _list = list;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setOptions = function (options) {
            _options = options;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.type = ConditionListAttribute$1.TYPE;
            var attr = {};
            lodash.forEach(this.getAttributes(), function (val, key) {
                attr[key] = val.toJSON();
            });
            json.list = attr;
            return json;
        };
        this.setValueFromJSON = function (json) {
            lodash.forEach(json.list, function (val, key) {
                var attribute = new ConditionPredicateAttribute$1(key, key, that, _options, _options2);
                attribute.setValueFromJSON(json.list[key]);
                that.addAttribute(attribute);
                _$node.find(".list").append(attribute.get$node());
            });
        };
        this.registerCallbacks = function () {
            _iwcw.registerOnDataReceivedCallback(localAttributeAddCallback);
            _iwcw.registerOnDataReceivedCallback(localAttributeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            _iwcw.unregisterOnDataReceivedCallback(localAttributeAddCallback);
            _iwcw.unregisterOnDataReceivedCallback(localAttributeDeleteCallback);
        };
        _$node.find(".name").text(this.getName());
        for (var attributeId in _list) {
            if (_list.hasOwnProperty(attributeId)) {
                _$node.find(".list").append(_list[attributeId].get$node());
            }
        }
        this.registerYMap = function () {
            var ymap = that.getRootSubjectEntity().getYMap();
            var attrs = that.getAttributes();
            for (var key in attrs) {
                if (attrs.hasOwnProperty(key)) {
                    attrs[key].registerYMap();
                }
            }
            ymap.observe(function (event) {
                const array = Array.from(event.changes.keys.entries());
                array.forEach(([key, change]) => {
                    if (key.indexOf("[value]") != -1) {
                        var operation;
                        event.currentTarget.get(key);
                        switch (change.action) {
                            case "add": {
                                if (eventWasTriggeredByMe(event))
                                    return;
                                const jabberId = event.currentTarget.get("jabberId");
                                if (jabberId === _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID])
                                    return;
                                operation = new AttributeAddOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                                remoteAttributeAddCallback(operation);
                                break;
                            }
                            case "delete": {
                                operation = new AttributeDeleteOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                                remoteAttributeDeleteCallback(operation);
                                break;
                            }
                        }
                    }
                    else if (key.indexOf("updateConditionOption") != -1) {
                        that.setOptions(event.value);
                    }
                });
            });
        };
        if (_iwcw) {
            that.registerCallbacks();
        }
    }
    static { this.TYPE = "ConditionListAttribute"; }
};
var LogicalConjunctions = {
    "AND": "&&",
    "OR": "||"
};
var LogicalOperator = {
    "greater": ">",
    "smaller": "<",
    "equal": "==",
    "greater_eq": ">=",
    "smaller_eq": "<=",
    "nequal": "!="
};
const renamingAttrHTML$1 = "<li class=\"renaming_attr\">\n    <div class=\"val\"></div>\n    <div class=\"ref\" ></div>\n    <div class=\"vis\"></div>\n</li>";
let RenamingAttribute$1 = class RenamingAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, options) {
        super(id, name, subjectEntity);
        var _options = options;
        var _key = new Value$1(id + "[val]", "Attribute Name", this, this.getRootSubjectEntity());
        var _ref = new Value$1(id + "[ref]", "Attribute Reference", this, this.getRootSubjectEntity());
        var _vis = new SelectionValue$1(id + "[vis]", "Attribute Visibility", this, this.getRootSubjectEntity(), _options);
        var _$node = $(lodash.template(renamingAttrHTML$1)());
        this.setKey = function (key) {
            _key = key;
        };
        this.getKey = function () {
            return _key;
        };
        this.getRef = function () {
            return _ref;
        };
        this.getVis = function () {
            return _vis;
        };
        this.setVis = function (value) {
            _vis = value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _key.setValueFromJSON(json.val);
            _ref.setValueFromJSON(json.ref);
            _vis.setValueFromJSON(json.vis || { value: "" });
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.val = _key.toJSON();
            json.ref = _ref.toJSON();
            json.vis = _vis.toJSON();
            return json;
        };
        _$node.find(".val").append(_key.get$node());
        _$node.find(".ref").append(_ref.get$node()).hide();
        _$node.find(".vis").append(_vis.get$node());
        this.registerYMap = function () {
            _key.registerYType();
            _ref.registerYType();
            _vis.registerYType();
        };
    }
    static { this.TYPE = "RenamingAttribute"; }
};
const listHtml = "<div class=\"list_attribute\">\n    <div class=\"name\"></div>\n    <ul class=\"list\"></ul>\n</div>";
let RenamingListAttribute$1 = class RenamingListAttribute extends AbstractAttribute$1 {
    constructor(id, name, subjectEntity, options, y) {
        y = y || window.y;
        super(id, name, subjectEntity);
        var that = this;
        var _options = options;
        var _list = {};
        var _$node = $(lodash.template(listHtml)());
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var processAttributeAddOperation = function (operation) {
            var attribute = new RenamingAttribute$1(operation.getEntityId(), "Attribute", that, _options);
            that.addAttribute(attribute);
            attribute.registerYMap();
            _$node.find(".list").append(attribute.get$node());
            return attribute;
        };
        this.propagateAttributeAddOperation = function (operation) {
            return processAttributeAddOperation(operation);
        };
        var processAttributeDeleteOperation = function (operation) {
            var attribute = that.getAttribute(operation.getEntityId());
            if (attribute) {
                that.deleteAttribute(attribute.getEntityId());
                attribute.get$node().remove();
            }
        };
        var propagateAttributeDeleteOperation = function (operation) {
            processAttributeDeleteOperation(operation);
            var ymap = that.getRootSubjectEntity().getYMap();
            ymap.delete(operation.getEntityId() + "[val]");
        };
        var remoteAttributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeAddOperation(operation);
                subjectEntity.showAttributes();
            }
        };
        var remoteAttributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        var localAttributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                propagateAttributeAddOperation(operation);
            }
        };
        var localAttributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                propagateAttributeDeleteOperation(operation);
            }
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_list.hasOwnProperty(id)) {
                _list[id] = attribute;
            }
        };
        this.getAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                return _list[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                delete _list[id];
            }
        };
        this.getAttributes = function () {
            return _list;
        };
        this.setAttributes = function (list) {
            _list = list;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setOptions = function (options) {
            _options = options;
        };
        this.toJSON = function () {
            var json = AbstractAttribute$1.prototype.toJSON.call(this);
            json.type = RenamingListAttribute$1.TYPE;
            var attr = {};
            lodash.forEach(this.getAttributes(), function (val, key) {
                attr[key] = val.toJSON();
            });
            json.list = attr;
            return json;
        };
        this.setValueFromJSON = function (json) {
            lodash.forEach(json.list, function (val, key) {
                var attribute = new RenamingAttribute$1(key, key, that, _options);
                attribute.setValueFromJSON(json.list[key]);
                that.addAttribute(attribute);
                _$node.find(".list").append(attribute.get$node());
            });
        };
        this.registerCallbacks = function () {
            _iwcw.registerOnDataReceivedCallback(localAttributeAddCallback);
            _iwcw.registerOnDataReceivedCallback(localAttributeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            _iwcw.unregisterOnDataReceivedCallback(localAttributeAddCallback);
            _iwcw.unregisterOnDataReceivedCallback(localAttributeDeleteCallback);
        };
        _$node.find(".name").text(this.getName());
        for (var attributeId in _list) {
            if (_list.hasOwnProperty(attributeId)) {
                _$node.find(".list").append(_list[attributeId].get$node());
            }
        }
        if (_iwcw) {
            that.registerCallbacks();
        }
        this.registerYMap = function () {
            var ymap = that.getRootSubjectEntity().getYMap();
            var attrs = that.getAttributes();
            for (var key in attrs) {
                if (attrs.hasOwnProperty(key)) {
                    var attr = attrs[key];
                    attr.registerYMap();
                }
            }
            ymap.observe(function (event) {
                const array = Array.from(event.changes.keys.entries());
                array.forEach(([key, change]) => {
                    if (key.indexOf("[val]") != -1) {
                        event.currentTarget.get(key);
                        switch (change.action) {
                            case "add": {
                                const operation = new AttributeAddOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                                remoteAttributeAddCallback(operation);
                                break;
                            }
                            case "delete": {
                                const operation = new AttributeDeleteOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                                remoteAttributeDeleteCallback(operation);
                                break;
                            }
                        }
                    }
                });
            });
        };
    }
    static { this.TYPE = "RenamingListAttribute"; }
};
const viewrelationshipNodeHtml$1 = "<div class=\"class_node\">\n    <div class=\"type\"><%= type %></div>\n    <div class=\"label\">&lt;&lt;ViewRelationship&gt;&gt;</div>\n    <div class=\"attributes\"></div>\n</div>";
const viewobjectNodeHtml = "<div class=\"class_node\">\n    <div class=\"type\"><%= type %></div>\n    <div class=\"label\">&lt;&lt;ViewObject&gt;&gt;</div>\n    <div class=\"attributes\"></div>\n</div>";
const nodeShapeNodeHtml$1 = "<div class=\"class_node nodeshape\">\n    <div class=\"type\"><%= type %></div>\n    <div class=\"label\">&lt;&lt;NodeShape&gt;&gt;</div>\n    <div class=\"attributes\"></div>\n</div>";
const modelAttributesNodeHtml$1 = "<div class=\"abstract_class_node\">\n    <div class=\"label\"></div>\n    <div class=\"attributes\"></div>\n</div>";
const relationshipGroupNodeHtml$1 = "<div class=\"class_node relation\">\n    <div class=\"type\"><%= type %></div>\n    <div class=\"label\">&lt;&lt;Relation&gt;&gt;</div>\n    <div class=\"attributes\"></div>\n</div>";
const enumNodeHtml$1 = "<div class=\"class_node enum\">\n    <div class=\"type\"><%= type %></div>\n    <div class=\"label\">&lt;&lt;Enumeration&gt;&gt;</div>\n    <div class=\"attributes\"></div>\n</div>";
const abstractEdgeHtml$1 = "<div>\n    <div class=\"type fixed\"><%= type %></div>\n    <div class=\"edge_label\"></div>\n</div>";
const edgeShapeNodeHtml$1 = "<div class=\"class_node edgeshape\">\n    <div class=\"type\"><%= type %></div>\n    <div class=\"label\">&lt;&lt;EdgeShape&gt;&gt;</div>\n    <div class=\"attributes\"></div>\n</div>";
const abstractNodeHtml$2 = "<div id=\"<%= id %>\" class=\"node\">\n</div>";
const awarenessTraceHtml = "<div id=\"<%= id %>\" class=\"trace_awareness\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 100 100\" style=\"overflow: visible;\">\n        <circle cx=\"0\" cy=\"0\" r=\"50\" stroke=\"lightgray\" stroke-width=\"0\" />\n</svg>\n</div>";
const abstractClassNodeHtml$1 = "<div class=\"class_node abstractclass\">\n  <div class=\"type\"><%= type %></div>\n  <div class=\"label\">&lt;&lt;abstract&gt;&gt;</div>\n  <div class=\"attributes\"></div>\n</div>\n";
const relationshipNodeHtml$1 = "<div class=\"class_node relationship\">\n    <div class=\"type\"><%= type %></div>\n    <div class=\"label\">&lt;&lt;Relationship&gt;&gt;</div>\n    <div class=\"attributes\"></div>\n</div>";
const actionNodeHtml = "<div class=\"custom_node\">\n    <div class=\"type\"><%= \"<\\%= type %\\>\" %></div>\n    <svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 100 100\" class=\"fill_parent\">\n        <rect x=\"0\" y=\"0\" rx=\"20\" ry=\"20\" width=\"100\" height=\"100\" fill=\"white\" stroke=\"lightgray\" stroke-width=\"2\" />\n    </svg>\n    <div class=\"fill_parent\" style=\"overflow:hidden;\">\n    \t<table style=\"width:100%; height:100%\">\n\t\t  <tr>\n\t\t    <td style=\"width:1px; white-space:nowrap; padding:10px;\"><i class=\"fa fa-<%= icon %> fa-2x\"></i></td>\n\t\t    <td style=\"text-align:center\"><%= label %></td>\t\t\n\t\t  </tr>\n\t\t</table>\n    </div>\n</div>";
const circleNodeHtml$1 = "<div class=\"custom_node\">\n  <div class=\"type\"><%= type %></div>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    preserveAspectRatio=\"none\"\n    viewBox=\"0 0 100 100\"\n    class=\"fill_parent\"\n  >\n    <circle\n      cx=\"50\"\n      cy=\"50\"\n      r=\"50\"\n      fill=\"<%= color %>\"\n      stroke=\"lightgray\"\n      stroke-width=\"2\"\n    />\n  </svg>\n  <div class=\"fill_parent\">\n    <div\n      style=\"\n        position: absolute;\n        left: 50%;\n        top: -10px;\n        -webkit-transform: translateY(-50%) translateX(-50%);\n      \"\n      class=\"label\"\n    ></div>\n  </div>\n</div>\n";
const diamondNodeHtml$1 = "<div class=\"custom_node\">\n  <div class=\"type\"><%= type %></div>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    preserveAspectRatio=\"none\"\n    viewBox=\"0 0 100 100\"\n    class=\"fill_parent\"\n  >\n    <rect\n      x=\"15\"\n      y=\"15\"\n      width=\"70\"\n      height=\"70\"\n      fill=\"<%= color %>\"\n      stroke=\"lightgray\"\n      stroke-width=\"2\"\n      transform=\"rotate(-45 50 50)\"\n    />\n  </svg>\n  <div class=\"fill_parent\">\n    <div\n      style=\"\n        position: absolute;\n        left: 50%;\n        top: -10px;\n        -webkit-transform: translateY(-50%) translateX(-50%);\n      \"\n      class=\"label\"\n    ></div>\n  </div>\n</div>\n";
const objectNodeHtml$1 = "<div class=\"class_node object\">\n    <div class=\"type\"><%= type %></div>\n    <div class=\"label\">&lt;&lt;Object&gt;&gt;</div>\n    <div class=\"attributes\"></div>\n</div>";
const rectangleNodeHtml$1 = "<div class=\"custom_node\">\n  <div class=\"type\"><%= type %></div>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    preserveAspectRatio=\"none\"\n    viewBox=\"0 0 100 100\"\n    class=\"fill_parent\"\n  >\n    <rect\n      x=\"0\"\n      y=\"0\"\n      width=\"100\"\n      height=\"100\"\n      fill=\"<%= color %>\"\n      stroke=\"lightgray\"\n      stroke-width=\"2\"\n    />\n  </svg>\n  <div class=\"fill_parent\">\n    <div\n      style=\"\n        position: absolute;\n        left: 50%;\n        top: -10px;\n        -webkit-transform: translateY(-50%) translateX(-50%);\n      \"\n      class=\"label\"\n    ></div>\n  </div>\n</div>\n";
const roundedRectangleNodeHtml$1 = "<div class=\"custom_node\">\n  <div class=\"type\"><%= type %></div>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    preserveAspectRatio=\"none\"\n    viewBox=\"0 0 100 100\"\n    class=\"fill_parent\"\n  >\n    <rect\n      x=\"0\"\n      y=\"0\"\n      rx=\"20\"\n      ry=\"20\"\n      width=\"100\"\n      height=\"100\"\n      fill=\"<%= color %>\"\n      stroke=\"lightgray\"\n      stroke-width=\"2\"\n    />\n  </svg>\n  <div class=\"fill_parent\">\n    <div\n      style=\"\n        position: absolute;\n        left: 50%;\n        top: -10px;\n        -webkit-transform: translateY(-50%) translateX(-50%);\n      \"\n      class=\"label\"\n    ></div>\n  </div>\n</div>\n";
const startActivityNodeHtml = "<div class=\"custom_node\">\n    <div class=\"type\"><%= type %></div>\n    <svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 100 100\" class=\"fill_parent\">\n        <defs>\n            <linearGradient id=\"startActivityGrad\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n              <stop offset=\"0%\" style=\"stop-color:#FFF2CC;stop-opacity:1\" />\n              <stop offset=\"100%\" style=\"stop-color:#FFD966;stop-opacity:1\" />\n            </linearGradient>\n          </defs>\n        <rect x=\"0\" y=\"0\" rx=\"20\" ry=\"20\" width=\"100\" height=\"100\" fill=\"url(#startActivityGrad)\" stroke=\"lightgray\" stroke-width=\"2\" />\n    </svg>\n    <div class=\"fill_parent\" style=\"overflow:hidden;\">\n    \t<table style=\"width:100%; height:100%\">\n\t\t  <tr>\n\t\t    <td style=\"width:1px; white-space:nowrap; padding:10px;\"><i class=\"fa fa-circle fa-2x\"></i></td>\n\t\t    <td style=\"text-align:center\" class=\"label\"></td>\t\t\n\t\t  </tr>\n\t\t</table>\n    </div>\n</div>";
const triangleNodeHtml$1 = "<div class=\"custom_node\">\n  <div class=\"type\"><%= type %></div>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    preserveAspectRatio=\"none\"\n    viewBox=\"0 0 100 100\"\n    class=\"fill_parent\"\n  >\n    <path\n      d=\"M0,100 L50,0 L100,100 L0,100\"\n      fill=\"<%= color %>\"\n      stroke=\"lightgray\"\n      stroke-width=\"2\"\n    />\n  </svg>\n  <div class=\"fill_parent\">\n    <div\n      style=\"\n        position: absolute;\n        left: 50%;\n        top: -10px;\n        -webkit-transform: translateY(-50%) translateX(-50%);\n      \"\n      class=\"label\"\n    ></div>\n  </div>\n</div>\n";
const activityFinalNodeHtml = "<div class=\"custom_node\">\n    <div class=\"type\"><%= type %></div>\n    <svg style=\"overflow:visible;\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\" class=\"fill_parent\">\n  <circle cx=\"50\" cy=\"50\" r=\"50\" stroke=\"black\" stroke-width=\"5\" fill=\"transparent\" />\n<circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"0\" fill=\"black\" /> \n</svg> \n    <div class=\"fill_parent\">\n    </div>\n</div>";
const callActivityNodeHtml = "<div class=\"custom_node\">\n    <div class=\"type\"><%= type %></div>\n    <svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 100 100\" class=\"fill_parent\">\n        <rect x=\"0\" y=\"0\" rx=\"20\" ry=\"20\" width=\"100\" height=\"100\" fill=\"white\" stroke=\"lightgray\" stroke-width=\"2\" />\n    </svg>\n    <div class=\"fill_parent\" style=\"overflow:hidden;\">\n      <table style=\"width:100%; height:100%\">\n      <tr>\n        <td style=\"width:1px; white-space:nowrap; padding:10px;\"><i class=\"fa fa-external-link fa-2x\"></i></td>\n        <td class=\"label\" style=\"text-align:center\"></td>   \n      </tr>\n    </table>\n    </div>\n</div>";
const entityNodeHtml = "<div class=\"custom_node\">\n    <div class=\"type\"><%= \"<\\%= type %\\>\" %></div>\n    <svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 100 100\" class=\"fill_parent\">\n        <defs>\n            <linearGradient id=\"entityGrad\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n              <stop offset=\"0%\" style=\"stop-color:#DAE8FC;stop-opacity:1\" />\n              <stop offset=\"100%\" style=\"stop-color:#7EA6E0;stop-opacity:1\" />\n            </linearGradient>\n          </defs>\n        <rect x=\"0\" y=\"0\" width=\"100\" height=\"100\" fill=\"url(#entityGrad)\" stroke=\"lightgray\" stroke-width=\"2\" />\n    </svg>\n    <div class=\"fill_parent\" style=\"overflow:hidden;\">\n    \t<table style=\"width:100%; height:100%\">\n\t\t  <tr>\n\t\t    <td style=\"width:1px; white-space:nowrap; padding:10px;\"><i class=\"fa fa-<%= icon %> fa-2x\"></i></td>\n\t\t    <td style=\"text-align:center\"><%= label %></td>\t\t\n\t\t  </tr>\n\t\t</table>\n    </div>\n</div>";
const setPropertyNodeHtml = "<div class=\"custom_node\">\n    <div class=\"type\"><%= \"<\\%= type %\\>\" %></div>\n    <svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 100 100\" class=\"fill_parent\">\n        <rect x=\"0\" y=\"0\" rx=\"20\" ry=\"20\" width=\"100\" height=\"100\" fill=\"white\" stroke=\"lightgray\" stroke-width=\"2\" />\n    </svg>\n    <div class=\"fill_parent\" style=\"overflow:hidden\">\n    \t<table style=\"width:100%; height:100%\">\n\t\t  <tr>\n\t\t    <td style=\"width:1px; white-space:nowrap; padding:10px;\"><i class=\"fa fa-pencil-square-o fa-2x\"></i></td>\n\t\t    <td style=\"text-align:center\" class=\"property\"></td>\t\t\n\t\t  </tr>\n\t\t</table>\n    </div>\n</div>";
var shapes = {
    straight: {
        type: StraightConnector.type,
        options: { gap: 0 },
    },
    curved: {
        type: BezierConnector.type,
        options: { gap: 0 },
    },
    segmented: {
        type: FlowchartConnector.type,
        options: { gap: 0 },
    },
};
function HistoryManager() {
    var bufferSize = 20;
    var _canvas = null;
    var latestOp = null;
    var undo = [];
    var redo = [];
    var $undo = $("#undo");
    var $redo = $("#redo");
    var propagateHistoryOperationFromJson = function (json) {
        var EntityManager = EntityManager;
        var operation = null, data = null, entity;
        switch (json.TYPE) {
            case NodeDeleteOperation.TYPE: {
                entity = EntityManager.findNode(json.id);
                if (entity) {
                    entity.triggerDeletion(true);
                    operation = new NodeDeleteOperation(json.id, json.type, json.left, json.top, json.width, json.height, json.zIndex, json.containment, json.json);
                }
                break;
            }
            case NodeAddOperation.TYPE: {
                _canvas.createNode(json.type, json.left, json.top, json.width, json.height, json.zIndex, json.containment, json.json, json.id, true);
                operation = new NodeAddOperation(json.id, json.type, json.left, json.top, json.width, json.height, json.zIndex, json.containment, json.json);
                break;
            }
            case EdgeAddOperation.TYPE: {
                _canvas.createEdge(json.type, json.source, json.target, json.json, json.id, true);
                operation = new EdgeAddOperation(json.id, json.type, json.source, json.target, json.json);
                break;
            }
            case EdgeDeleteOperation.TYPE: {
                entity = EntityManager.findEdge(json.id);
                if (entity) {
                    entity.triggerDeletion(true);
                    operation = new EdgeDeleteOperation(json.id, json.type, json.source, json.target, json.json);
                }
                break;
            }
            case NodeMoveOperation.TYPE: {
                entity = EntityManager.findNode(json.id);
                if (entity) {
                    const nodesMap = y.getMap("nodes");
                    operation = new NodeMoveOperation(json.id, json.offsetX, json.offsetY);
                    var ymap = nodesMap.get(json.id);
                    data = operation.toJSON();
                    data.historyFlag = true;
                    ymap.set(NodeMoveOperation.TYPE, data);
                }
                break;
            }
            case NodeMoveZOperation.TYPE: {
                entity = EntityManager.findNode(json.id);
                if (entity) {
                    operation = new NodeMoveZOperation(json.id, json.offsetZ);
                    const nodesMap = y.getMap("nodes");
                    var ymap = nodesMap.get(json.id);
                    data = operation.toJSON();
                    data.historyFlag = true;
                    ymap.set(NodeMoveZOperation.TYPE, data);
                }
                break;
            }
            case NodeResizeOperation.TYPE: {
                entity = EntityManager.findNode(json.id);
                if (entity) {
                    operation = new NodeResizeOperation(json.id, json.offsetX, json.offsetY);
                    const nodesMap = y.getMap("nodes");
                    var ymap = nodesMap.get(json.id);
                    data = operation.toJSON();
                    data.historyFlag = true;
                    ymap.set(NodeResizeOperation.TYPE, data);
                }
                break;
            }
        }
        return operation;
    };
    return {
        init: function (canvas) {
            if (!canvas)
                throw new Error("Canvas is null");
            _canvas = canvas;
        },
        add: function (operation) {
            if (operation.hasOwnProperty("inverse")) {
                var inverseOp = operation.inverse();
                var json = inverseOp.toJSON();
                json.TYPE = inverseOp.constructor.name;
                undo.push(json);
                redo = [];
                $undo.prop("disabled", false);
                $redo.prop("disabled", true);
            }
            if (undo.length > bufferSize) {
                undo.shift();
            }
        },
        undo: function () {
            if (undo.length > 0) {
                var jsonOp = undo.pop();
                if (undo.length === 0) {
                    $undo.prop("disabled", true);
                }
                var operation = propagateHistoryOperationFromJson(jsonOp);
                if (!operation) {
                    this.undo();
                    return;
                }
                else
                    latestOp = operation;
                var inverseOp = operation.inverse();
                var json = inverseOp.toJSON();
                json.TYPE = inverseOp.constructor.name;
                if (redo.length === 0)
                    $redo.prop("disabled", false);
                redo.push(json);
            }
            else {
                $undo.prop("disabled", true);
            }
        },
        redo: function () {
            if (redo.length > 0) {
                var jsonOp = redo.pop();
                if (redo.length === 0) {
                    $redo.prop("disabled", true);
                }
                var operation = propagateHistoryOperationFromJson(jsonOp);
                if (!operation) {
                    this.redo();
                    return;
                }
                else
                    latestOp = operation;
                var inverseOp = operation.inverse();
                var json = inverseOp.toJSON();
                json.TYPE = inverseOp.constructor.name;
                if (undo.length === 0)
                    $undo.prop("disabled", false);
                undo.push(json);
            }
            else {
                $redo.prop("disabled", true);
            }
        },
        clean: function (entityId) {
            var entityIdFilter = function (value, idx) {
                if (value.id === entityId)
                    return false;
                else
                    return true;
            };
            undo = undo.filter(entityIdFilter);
            redo = redo.filter(entityIdFilter);
            if (undo.length === 0) {
                $undo.prop("disabled", true);
            }
            if (redo.length === 0) {
                $redo.prop("disabled", true);
            }
        },
        getLatestOperation: function () {
            return latestOp;
        },
        getUndoList: function () {
            return undo;
        },
        getRedoList: function () {
            return redo;
        },
    };
}
const HistoryManagerInstance = new HistoryManager();
const openapp$1 = new OpenAppProvider().openapp;
var nodeShapeTypes = {
    circle: circleNodeHtml$1,
    diamond: diamondNodeHtml$1,
    rectangle: rectangleNodeHtml$1,
    rounded_rectangle: roundedRectangleNodeHtml$1,
    triangle: triangleNodeHtml$1,
};
var $colorTestElement = $("<div></div>");
var _layer = null;
var nodeTypes = {};
var _initNodeTypes = function (vls) {
    var _nodeTypes = {};
    var nodes = vls.nodes, node, shape, anchors;
    for (var nodeId in nodes) {
        if (nodes.hasOwnProperty(nodeId)) {
            node = nodes[nodeId];
            if (node.shape.customShape) {
                shape = node.shape.customShape;
            }
            else {
                shape = nodeShapeTypes.hasOwnProperty(node.shape.shape)
                    ? nodeShapeTypes[node.shape.shape]
                    : lodash.keys(nodeShapeTypes)[0];
            }
            if (node.shape.customAnchors) {
                try {
                    if (node.shape.customAnchors) {
                        anchors = JSON.parse(node.shape.customAnchors);
                    }
                    if (!node.shape.customAnchors instanceof Array) {
                        anchors = {
                            type: "Perimeter",
                            options: {
                                shape: "Rectangle",
                                anchorCount: 10,
                            },
                        };
                    }
                }
                catch (e) {
                    anchors = {
                        type: "Perimeter",
                        options: {
                            shape: "Rectangle",
                            anchorCount: 10,
                        },
                    };
                }
            }
            else {
                switch (node.shape.shape) {
                    case "circle":
                        anchors = {
                            type: "Perimeter",
                            options: {
                                shape: "Circle",
                                anchorCount: 10,
                            },
                        };
                        break;
                    case "diamond":
                        anchors = {
                            type: "Perimeter",
                            options: {
                                shape: "Diamond",
                                anchorCount: 10,
                            },
                        };
                        break;
                    case "rounded_rectangle":
                        anchors = {
                            type: "Perimeter",
                            options: {
                                shape: "Rectangle",
                                anchorCount: 10,
                            },
                        };
                        break;
                    case "triangle":
                        anchors = {
                            type: "Perimeter",
                            options: {
                                shape: "Triangle",
                                anchorCount: 10,
                            },
                        };
                        break;
                    default:
                    case "rectangle":
                        anchors = {
                            type: "Perimeter",
                            options: {
                                shape: "Rectangle",
                                anchorCount: 10,
                            },
                        };
                        break;
                }
            }
            var color = node.shape.color
                ? $colorTestElement
                    .css("color", "#FFFFFF")
                    .css("color", node.shape.color)
                    .css("color")
                : "#FFFFFF";
            var $shape = $(lodash.template(shape)({ color: color, type: node.label }));
            if (node.hasOwnProperty("targetName") &&
                !$.isEmptyObject(nodeTypes) &&
                nodeTypes.hasOwnProperty(node.targetName)) {
                _nodeTypes[node.label] = makeViewNode$1(node.label, $shape, anchors, node.attributes, nodeTypes[node.targetName], node.conditions, node.conjunction);
                nodeTypes[node.targetName].VIEWTYPE = node.label;
            }
            else {
                _nodeTypes[node.label] = makeNode$1(node.label, $shape, anchors, node.attributes);
            }
            _nodeTypes[node.label].TYPE = node.label;
            _nodeTypes[node.label].DEFAULT_WIDTH = node.shape.defaultWidth;
            _nodeTypes[node.label].DEFAULT_HEIGHT = node.shape.defaultHeight;
            _nodeTypes[node.label].CONTAINMENT = node.shape.containment;
            _nodeTypes[node.label].SHAPE = $shape;
        }
    }
    return _nodeTypes;
};
var _initEdgeTypes = function (vls) {
    var _edgeTypes = {};
    var _relations = {};
    var edges = vls.edges, edge;
    for (var edgeId in edges) {
        if (edges.hasOwnProperty(edgeId)) {
            edge = edges[edgeId];
            if (edge.hasOwnProperty("targetName") &&
                !$.isEmptyObject(edgeTypes) &&
                edgeTypes.hasOwnProperty(edge.targetName)) {
                _edgeTypes[edge.label] = makeViewEdge$1(edge.label, edge.shape.arrow, edge.shape.shape, edge.shape.color, edge.shape.dashstyle, edge.shape.overlay, edge.shape.overlayPosition, edge.shape.overlayRotate, edge.attributes, edgeTypes[edge.targetName], edge.conditions, edge.conjunction);
                edgeTypes[edge.targetName].VIEWTYPE = edge.label;
            }
            else {
                _edgeTypes[edge.label] = makeEdge$1(edge.label, edge.shape.arrow, edge.shape.shape, edge.shape.color, edge.shape.dashstyle, edge.shape.overlay, edge.shape.overlayPosition, edge.shape.overlayRotate, edge.attributes);
            }
            _edgeTypes[edge.label].TYPE = edge.label;
            _relations[edge.label] = edge.relations;
        }
    }
    return {
        edgeTypes: _edgeTypes,
        relations: _relations,
    };
};
var viewNodeTypes = {};
var viewEdgeTypes = {};
var edgeTypes = {};
var relations = {};
let AbstractEdge$1 = class AbstractEdge extends AbstractEntity$1 {
    constructor(id, type, source, target, overlayRotate, y) {
        super(id);
        y = y || window.y;
        var that = this;
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var _ymap = null;
        if (!y) {
            throw new Error("y is not defined");
        }
        const edgeMap = y.getMap("edges");
        if (edgeMap.has(id)) {
            _ymap = edgeMap.get(id);
        }
        else if (id && type && source && target) {
            _ymap = new Map$2();
            edgeMap.set(id, new Map$2());
            y.transact(() => {
                _ymap.set("id", id);
                _ymap.set("type", type);
                _ymap.set("source", source.getEntityId());
                _ymap.set("target", target.getEntityId());
                _ymap.set("jabberId", _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
            });
        }
        this.getYMap = function () {
            return _ymap;
        };
        var _type = type;
        var _label = new SingleValueAttribute$1(id + "[label]", "Label", this, y);
        var _appearance = {
            source: source,
            target: target,
        };
        var _overlayRotate = overlayRotate !== false;
        var _$overlay = $(lodash.template(abstractEdgeHtml$1)({ type: type }))
            .find(".edge_label")
            .append(_label.get$node())
            .parent();
        var _canvas = null;
        var _jsPlumbConnection = null;
        var _attributes = {};
        var _highlightColor = null;
        var _contextMenuItemCallback = function () {
            return {};
        };
        var processEdgeDeleteOperation = function (operation) {
            that.remove();
        };
        var propagateEdgeDeleteOperation = function (operation) {
            processEdgeDeleteOperation();
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
            const activityMap = y.getMap("activity");
            activityMap.set(ActivityOperation.TYPE, new ActivityOperation("EdgeDeleteActivity", operation.getEntityId(), _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], EdgeDeleteOperation.getOperationDescription(that.getType(), that.getLabel().getValue().getValue()), {}).toJSON());
        };
        this.remoteEdgeDeleteCallback = function (operation) {
            if (operation instanceof EdgeDeleteOperation &&
                operation.getEntityId() == that.getEntityId()) {
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
                processEdgeDeleteOperation();
            }
        };
        var getAllAssociatedDOMNodes = function () {
            var overlays, i, numOfOverlays, $e = $("." + id);
            if (_jsPlumbConnection) {
                overlays = _jsPlumbConnection.getOverlays();
                for (i = 0, numOfOverlays = overlays.length; i < numOfOverlays; i++) {
                    if (overlays[i] instanceof jsPlumb.Overlays.Custom) {
                        $e = $e.add(overlays[i].getElement());
                    }
                }
            }
            else
                throw new Error("jsPlumbConnection is null");
            return $e;
        };
        var _defaultPaintStyle;
        this.setDefaultPaintStyle = function (paintStyle) {
            _defaultPaintStyle = paintStyle;
        };
        this.getDefaultPaintStyle = function () {
            return _defaultPaintStyle;
        };
        this.triggerDeletion = function (historyFlag) {
            _canvas.select(null);
            var operation = new EdgeDeleteOperation(id, that.getType(), that.getSource().getEntityId(), that.getTarget().getEntityId());
            if (_ymap) {
                propagateEdgeDeleteOperation(operation);
                const edgeMap = y.getMap("edges");
                edgeMap.delete(that.getEntityId());
            }
            else {
                propagateEdgeDeleteOperation(operation);
            }
            if (!historyFlag)
                HistoryManagerInstance.add(operation);
        };
        this.getContextMenuItemCallback = function () {
            return _contextMenuItemCallback;
        };
        this.setContextMenuItemCallback = function (contextMenuItemCallback) {
            _contextMenuItemCallback = contextMenuItemCallback;
        };
        this.addToCanvas = function (canvas) {
            if (!canvas)
                throw new Error("Canvas is null");
            _canvas = canvas;
        };
        this.getCanvas = function () {
            return _canvas;
        };
        this.removeFromCanvas = function () {
            _canvas = null;
            $.contextMenu("destroy", "." + that.getEntityId());
            window.jsPlumbInstance.deleteConnection(_jsPlumbConnection, {
                fireEvent: false,
            });
            _jsPlumbConnection = null;
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_attributes.hasOwnProperty(id)) {
                _attributes[id] = attribute;
            }
        };
        this.setAttributes = function (attributes) {
            _attributes = attributes;
        };
        this.getAttributes = function () {
            return _attributes;
        };
        this.getAttribute = function (id) {
            if (_attributes.hasOwnProperty(id)) {
                return _attributes[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (!_attributes.hasOwnProperty(id)) {
                delete _attributes[id];
            }
        };
        this.setLabel = function (label) {
            _label = label;
        };
        this.getLabel = function () {
            return _label;
        };
        this.getType = function () {
            return _type;
        };
        this.getSource = function () {
            return _appearance.source;
        };
        this.getTarget = function () {
            return _appearance.target;
        };
        this.get$overlay = function () {
            return _$overlay;
        };
        this.setRotateOverlay = function (rotateOverlay) {
            _overlayRotate = rotateOverlay;
        };
        this.isRotateOverlay = function () {
            return _overlayRotate;
        };
        this.setJsPlumbConnection = function (jsPlumbConnection) {
            _jsPlumbConnection = jsPlumbConnection;
            _defaultPaintStyle = jsPlumbConnection.getPaintStyle();
        };
        this.getJsPlumbConnection = function () {
            return _jsPlumbConnection;
        };
        this.repaintOverlays = function () {
            function makeRotateOverlayCallback(angle) {
                return function rotateOverlay() {
                    var $this = $(this), oldTransform = $this.css("transform", "").css("transform");
                    if (oldTransform === "none")
                        oldTransform = "";
                    $this.css({
                        transform: oldTransform + " rotate(" + angle + "rad)",
                        "-o-transform": oldTransform + " rotate(" + angle + "rad)",
                        "-ms-transform": oldTransform + " rotate(" + angle + "rad)",
                        "-moz-transform": oldTransform + " rotate(" + angle + "rad)",
                        "-webkit-transform": oldTransform + " rotate(" + angle + "rad)",
                    });
                };
            }
            var i, numOfOverlays, overlays, sourceEndpoint, targetEndpoint, angle;
            if (_jsPlumbConnection) {
                sourceEndpoint = _jsPlumbConnection.endpoints[0].endpoint;
                targetEndpoint = _jsPlumbConnection.endpoints[1].endpoint;
                angle = Math.atan2(sourceEndpoint.y - targetEndpoint.y, sourceEndpoint.x - targetEndpoint.x);
                if (!_overlayRotate || Math.abs(angle) > Math.PI / 2) {
                    angle += Math.PI;
                }
                overlays = _jsPlumbConnection.getOverlays();
                for (i = 0, numOfOverlays = overlays.length; i < numOfOverlays; i++) {
                    if (overlays[i] instanceof jsPlumb.Overlays.Custom) {
                        $(overlays[i].getElement())
                            .find(".fixed")
                            .not(".segmented")
                            .each(makeRotateOverlayCallback(angle));
                        $(overlays[i].getElement())
                            .find(".fixed.type")
                            .not(".segmented")
                            .each(makeRotateOverlayCallback(Math.abs(angle - Math.PI) > Math.PI / 2
                            ? angle
                            : angle + Math.PI));
                    }
                }
            }
            else
                throw new Error("jsPlumbConnection is null");
        };
        this.setZIndex = function () {
            var $e = getAllAssociatedDOMNodes(), zIndex = Math.max(source.getZIndex(), target.getZIndex());
            $e.css("zIndex", zIndex);
        };
        this.connect = function () {
            source.addOutgoingEdge(this);
            target.addIngoingEdge(this);
            _jsPlumbConnection = window.jsPlumbInstance.connect({
                source: _appearance.source.get$node().get(0),
                target: _appearance.target.get$node().get(0),
                paintStyle: { stroke: "black", outlineWidth: 4 },
                endpoint: "Dot",
                connector: { type: FlowchartConnector.type },
                anchors: [source.getAnchorOptions(), target.getAnchorOptions()],
                overlays: [
                    {
                        type: "Custom",
                        options: {
                            create: function () {
                                return _$overlay.get(0);
                            },
                            location: 0.5,
                            id: "label",
                        },
                    },
                ],
                cssClass: id,
            });
            this.repaintOverlays();
            lodash.each(EntityManagerInstance$1.getEdges(), function (e) {
                e.setZIndex();
            });
        };
        this.lowlight = function () {
            $("." + id).addClass("lowlighted");
        };
        this.unlowlight = function () {
            $("." + id).removeClass("lowlighted");
        };
        this.select = function () {
            var paintStyle = lodash.clone(_defaultPaintStyle), overlays, i, numOfOverlays;
            function makeBold() {
                $(this).css("fontWeight", "bold");
            }
            this.unhighlight();
            if (_jsPlumbConnection) {
                paintStyle.lineWidth = 4;
                _jsPlumbConnection.setPaintStyle(paintStyle);
                overlays = _jsPlumbConnection.getOverlays();
                for (i = 0, numOfOverlays = overlays.length; i < numOfOverlays; i++) {
                    if (overlays[i] instanceof jsPlumb.Overlays.Custom) {
                        $(overlays[i].getElement()).find(".fixed").each(makeBold);
                    }
                }
            }
            else
                throw new Error("jsPlumbConnection is null");
        };
        this.unselect = function () {
            var overlays, i, numOfOverlays;
            function unmakeBold() {
                $(this).css("fontWeight", "");
            }
            this.highlight(_highlightColor);
            if (_jsPlumbConnection) {
                _jsPlumbConnection.setPaintStyle(_defaultPaintStyle);
                overlays = _jsPlumbConnection.getOverlays();
                for (i = 0, numOfOverlays = overlays.length; i < numOfOverlays; i++) {
                    if (overlays[i] instanceof jsPlumb.Overlays.Custom) {
                        $(overlays[i].getElement()).find(".fixed").each(unmakeBold);
                    }
                }
            }
            EntityManagerInstance$1.storeDataYjs();
        };
        this.highlight = function (color) {
            var paintStyle = lodash.clone(_defaultPaintStyle);
            if (color) {
                paintStyle.strokeStyle = color;
                paintStyle.lineWidth = 4;
                if (_jsPlumbConnection)
                    _jsPlumbConnection.setPaintStyle(paintStyle);
                else
                    throw new Error("jsPlumbConnection is null");
            }
        };
        this.unhighlight = function () {
            if (_jsPlumbConnection) {
                _jsPlumbConnection.setPaintStyle(_defaultPaintStyle);
            }
            else
                throw new Error("jsPlumbConnection is null");
        };
        this.remove = function () {
            source.deleteOutgoingEdge(this);
            target.deleteIngoingEdge(this);
            this.removeFromCanvas();
            EntityManagerInstance$1.deleteEdge(this.getEntityId());
            if (_ymap) {
                _ymap = null;
            }
        };
        this._toJSON = function () {
            var attr = {};
            lodash.forEach(this.getAttributes(), function (val, key) {
                attr[key] = val.toJSON();
            });
            return {
                label: _label.toJSON(),
                source: source.getEntityId(),
                target: target.getEntityId(),
                attributes: attr,
                type: _type,
            };
        };
        this.bindMoveToolEvents = function () {
            if (_jsPlumbConnection) {
                $("." + id).on("click", function (e) {
                    _canvas.select(that);
                });
                $(_jsPlumbConnection.getOverlay("label").canvas)
                    .find("input")
                    .prop("disabled", false)
                    .css("pointerEvents", "");
            }
            else
                throw new Error("jsPlumbConnection is null");
            if (id) {
                const widgetConfigMap = y.getMap("widgetConfig");
                var viewOnly = widgetConfigMap.get("view_only");
                if (viewOnly)
                    return;
            }
            $.contextMenu({
                selector: "." + id,
                zIndex: AbstractEntity$1.CONTEXT_MENU_Z_INDEX,
                build: function () {
                    var menuItems = lodash.extend(_contextMenuItemCallback(), {
                        delete: {
                            name: "Delete",
                            callback: function () {
                                that.triggerDeletion();
                            },
                        },
                    });
                    return {
                        items: menuItems,
                        events: {
                            show: function () {
                                _canvas.select(that);
                            },
                        },
                    };
                },
            });
        };
        this.unbindMoveToolEvents = function () {
            if (_jsPlumbConnection) {
                _jsPlumbConnection.unbind("click");
                $(_jsPlumbConnection.getOverlay("label").canvas)
                    .find("input")
                    .prop("disabled", true)
                    .css("pointerEvents", "none");
            }
            else
                throw new Error("jsPlumbConnection is null");
        };
        this._registerYMap = function () {
            that.getLabel().getValue().registerYType();
        };
    }
    toJSON() {
        return this._toJSON();
    }
    hide() {
        var connector = this.getJsPlumbConnection();
        connector.setVisible(false);
    }
    show() {
        var connector = this.getJsPlumbConnection();
        connector.setVisible(true);
    }
    registerYMap() {
        this._registerYMap();
    }
};
let AbstractNode$1 = class AbstractNode extends AbstractEntity$1 {
    constructor(id, type, left, top, width, height, zIndex, containment, json, y) {
        super(id);
        var that = this;
        y = y || window.y;
        if (!y) {
            throw new Error("y is undefined");
        }
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var _ymap = null;
        y = y || window.y;
        if (!y) {
            throw new Error("y is undefined");
        }
        const nodesMap = y.getMap("nodes");
        if (nodesMap.has(id)) {
            _ymap = nodesMap.get(id);
        }
        else {
            window.y.transact(() => {
                _ymap = new Map$2();
                nodesMap.set(id, _ymap);
                _ymap.set("modifiedBy", window.y.clientID);
                _ymap.set("left", left);
                _ymap.set("top", top);
                _ymap.set("width", width);
                _ymap.set("height", height);
                _ymap.set("zIndex", zIndex);
                _ymap.set("containment", containment);
                _ymap.set("type", type);
                _ymap.set("id", id);
                if (json)
                    _ymap.set("json", json);
                if (_iwcw.getUser().globalId !== -1)
                    _ymap.set("jabberId", _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
            });
        }
        this.getYMap = function () {
            return _ymap;
        };
        var _type = type;
        var _label = new SingleValueAttribute$1(id + "[label]", "Label", this, y);
        var _appearance = {
            left: left,
            top: top,
            width: width,
            height: height,
            containment: containment,
        };
        var _zIndex = zIndex;
        var _containment = containment;
        var _canvas = null;
        var _$node = $(lodash.template(abstractNodeHtml$2)({ id: id }));
        this._$node = _$node;
        const resizeHandle = $(`<div class="resize-handle p-1"><i class="bi bi-aspect-ratio" style="font-size:3em;"></i></div>`);
        resizeHandle.css({
            position: "absolute",
            bottom: "0",
            right: "0",
            cursor: "nwse-resize",
            zIndex: 100000,
        });
        _$node.append(resizeHandle);
        resizeHandle.on("mouseover", () => {
            this.disableDraggable();
        });
        resizeHandle.on("mouseout", () => {
            this.enableDraggable();
        });
        this.nodeSelector = getQuerySelectorFromNode(this._$node[0]);
        var _$awarenessTrace = $(lodash.template(awarenessTraceHtml)({ id: id + "_awareness" }));
        var _awarenessTimer = setInterval(function () {
            var opacity = _$awarenessTrace.css("opacity");
            opacity -= 0.1;
            if (opacity < 0)
                opacity = 0;
            _$awarenessTrace.css({
                opacity: opacity,
            });
        }, 3000);
        this._$node.on("mousedown", function (e) {
            _canvas.select(that);
            _canvas.unbindMoveToolEvents();
        });
        this._$node.on("mouseup", function (e) {
            _canvas.bindMoveToolEvents();
        });
        var _attributes = {};
        var _contextMenuItemCallback = function () {
            return {};
        };
        var _ingoingEdges = {};
        var _outgoingEdges = {};
        var _ingoingNeighbors = {};
        var _outgoingNeighbors = {};
        var _relatedGhostEdges = [];
        var processNodeMoveOperation = function (operation) {
            _canvas.hideGuidanceBox();
            that.move(operation.getOffsetX(), operation.getOffsetY(), 0);
            _canvas.showGuidanceBox();
        };
        var processNodeMoveZOperation = function (operation) {
            that.move(0, 0, operation.getOffsetZ());
        };
        this.propagateNodeMoveOperation = function (operation) {
            operation.setJabberId(_iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
            processNodeMoveOperation(operation);
            HistoryManagerInstance.add(operation);
            EntityManagerInstance$1.storeDataYjs();
            hideTraceAwareness();
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.HEATMAP, operation.getOTOperation());
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
            const activityMap = y.getMap("activity");
            activityMap.set(ActivityOperation.TYPE, new ActivityOperation("NodeMoveActivity", operation.getEntityId(), operation.getJabberId(), NodeMoveOperation.getOperationDescription(that.getType(), that.getLabel().getValue().getValue()), { nodeType: that.getType() }).toJSON());
            if (_ymap) {
                _ymap.set(NodeMoveOperation.TYPE, operation.toJSON());
            }
        };
        this.propagateNodeMoveZOperation = function (operation) {
            var jabberId = _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID];
            operation.setJabberId(jabberId);
            processNodeMoveZOperation(operation);
            HistoryManagerInstance.add(operation);
            hideTraceAwareness();
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
            const activityMap = y.getMap("activity");
            activityMap.set(ActivityOperation.TYPE, new ActivityOperation("NodeMoveActivity", operation.getEntityId(), jabberId, NodeMoveOperation.getOperationDescription(that.getType(), that.getLabel().getValue().getValue()), { nodeType: that.getType() }).toJSON());
            if (_ymap)
                _ymap.set(NodeMoveZOperation.TYPE, operation.toJSON());
        };
        var processNodeResizeOperation = function (operation) {
            _canvas.hideGuidanceBox();
            that.resize(operation.getOffsetX(), operation.getOffsetY());
            _canvas.showGuidanceBox();
        };
        this.propagateNodeResizeOperation = function (operation) {
            operation.setJabberId(_iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
            processNodeResizeOperation(operation);
            HistoryManagerInstance.add(operation);
            EntityManagerInstance$1.storeDataYjs();
            hideTraceAwareness();
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.HEATMAP, operation.getOTOperation());
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
            const activityMap = y.getMap("activity");
            activityMap.set(ActivityOperation.TYPE, new ActivityOperation("NodeResizeActivity", operation.getEntityId(), operation.getJabberId(), NodeResizeOperation.getOperationDescription(that.getType(), that.getLabel().getValue().getValue()), { nodeType: that.getType() }).toJSON());
            if (_ymap)
                _ymap.set("NodeResizeOperation", operation.toJSON());
        };
        var processNodeDeleteOperation = function (operation) {
            var edges = that.getEdges(), edgeId, edge;
            for (edgeId in edges) {
                if (edges.hasOwnProperty(edgeId)) {
                    edge = edges[edgeId];
                    edge.remove();
                }
            }
            for (var i = 0; i < _relatedGhostEdges.length; i++) {
                if (typeof _relatedGhostEdges[i].remove == "function")
                    _relatedGhostEdges[i].remove();
            }
            if (_ymap) {
                _ymap = null;
            }
            that.remove();
        };
        var propagateNodeDeleteOperation = function (operation) {
            processNodeDeleteOperation();
            EntityManagerInstance$1.storeDataYjs();
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.HEATMAP, operation.getOTOperation());
            const activityMap = y.getMap("activity");
            activityMap.set(ActivityOperation.TYPE, new ActivityOperation("NodeDeleteActivity", operation.getEntityId(), _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], NodeDeleteOperation.getOperationDescription(that.getType(), that.getLabel().getValue().getValue()), {}).toJSON());
        };
        var refreshTraceAwareness = function (color) {
            _$awarenessTrace.css({
                opacity: 1,
                fill: color,
            });
        };
        var hideTraceAwareness = function () {
            _$awarenessTrace.css({
                opacity: 0,
            });
        };
        var remoteNodeMoveCallback = function (operation) {
            if (operation instanceof NodeMoveOperation &&
                operation.getEntityId() === that.getEntityId()) {
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.HEATMAP, operation.getOTOperation());
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
                const userMap = y.getMap("users");
                if (userMap.get(y.clientID) !== operation.getJabberId()) {
                    const userList = y.getMap("userList");
                    var color = Util.getColor(userList.get(operation.getJabberId()).globalId);
                    refreshTraceAwareness(color);
                }
                processNodeMoveOperation(operation);
            }
        };
        var remoteNodeMoveZCallback = function (operation) {
            if (operation instanceof NodeMoveZOperation &&
                operation.getEntityId() === that.getEntityId()) {
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
                const userMap = y.getMap("users");
                if (userMap.get(y.clientID) !== operation.getJabberId()) {
                    const userList = y.getMap("userList");
                    var color = Util.getColor(userList.get(operation.getJabberId()).globalId);
                    refreshTraceAwareness(color);
                }
                processNodeMoveZOperation(operation);
            }
        };
        var remoteNodeResizeCallback = function (operation) {
            if (operation instanceof NodeResizeOperation &&
                operation.getEntityId() === that.getEntityId()) {
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.HEATMAP, operation.getOTOperation());
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
                const userMap = y.getMap("users");
                if (userMap.get(y.clientID) !== operation.getJabberId()) {
                    const userList = y.getMap("userList");
                    var color = Util.getColor(userList.get(operation.getJabberId()).globalId);
                    refreshTraceAwareness(color);
                }
                processNodeResizeOperation(operation);
            }
        };
        this.remoteNodeDeleteCallback = function (operation) {
            if (operation instanceof NodeDeleteOperation &&
                operation.getEntityId() === that.getEntityId()) {
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.getOTOperation());
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.HEATMAP, operation.getOTOperation());
                processNodeDeleteOperation();
                HistoryManagerInstance.clean(operation.getEntityId());
            }
        };
        this.init = function () {
            $.contextMenu({
                selector: "#" + id,
                zIndex: AbstractEntity$1.CONTEXT_MENU_Z_INDEX,
                build: function ($trigger, e) {
                    var menuItems;
                    var EntityManager = EntityManagerInstance$1;
                    $(e.target).offset();
                    that.getCanvas().get$node().offset();
                    if (_canvas.getSelectedEntity() === null ||
                        _canvas.getSelectedEntity() === that) {
                        menuItems = lodash.extend(_contextMenuItemCallback(), {
                            connectTo: EntityManager.generateConnectToMenu(that),
                            sepMove: "---------",
                            moveToForeground: {
                                name: "Move to Foreground",
                                callback: function () {
                                    that.propagateNodeMoveZOperation(new NodeMoveZOperation(that.getEntityId(), ++AbstractEntity$1.maxZIndex - _zIndex));
                                },
                            },
                            moveToBackground: {
                                name: "Move to Background",
                                callback: function () {
                                    that.propagateNodeMoveZOperation(new NodeMoveZOperation(that.getEntityId(), --AbstractEntity$1.minZIndex - _zIndex));
                                },
                            },
                            sepDelete: "---------",
                            delete: {
                                name: "Delete",
                                callback: function () {
                                    that.triggerDeletion();
                                },
                            },
                            quit: {
                                name: " ",
                                disabled: true,
                            },
                        });
                        return {
                            items: menuItems,
                            events: {
                                show: function () {
                                    _canvas.select(that);
                                },
                            },
                        };
                    }
                    else {
                        _canvas.select(null);
                        return false;
                    }
                },
            });
        };
        var _anchorOptions = AnchorLocations.AutoDefault;
        this.getAnchorOptions = function () {
            return _anchorOptions;
        };
        this.triggerDeletion = function (historyFlag) {
            var edgeId, edges = this.getEdges(), edge;
            _canvas.select(null);
            for (edgeId in edges) {
                if (edges.hasOwnProperty(edgeId)) {
                    edge = edges[edgeId];
                    edge.triggerDeletion();
                }
            }
            var operation = new NodeDeleteOperation(id, that.getType(), _appearance.left, _appearance.top, _appearance.width, _appearance.height, _zIndex, _appearance.containment, that.toJSON());
            if (_ymap) {
                propagateNodeDeleteOperation(operation);
                const nodesMap = y.getMap("nodes");
                nodesMap.delete(that.getEntityId());
            }
            else {
                propagateNodeDeleteOperation(operation);
            }
            if (!historyFlag)
                HistoryManagerInstance.add(operation);
        };
        this.getContextMenuItemCallback = function () {
            return _contextMenuItemCallback;
        };
        this.setContextMenuItemCallback = function (contextMenuItemCallback) {
            if (typeof contextMenuItemCallback === "function") {
                _contextMenuItemCallback = contextMenuItemCallback;
            }
        };
        this.getAppearance = function () {
            return _appearance;
        };
        this.getZIndex = function () {
            return _zIndex;
        };
        this.refreshTraceAwareness = function (color) {
            refreshTraceAwareness(color);
        };
        this.addToCanvas = function (canvas) {
            if (!canvas)
                throw new Error("Canvas is null");
            _canvas = canvas;
            canvas.get$canvas().append(_$awarenessTrace);
            canvas.get$canvas().append(this._$node);
        };
        this.getCanvas = function () {
            return _canvas;
        };
        this.removeFromCanvas = function () {
            this._$node.remove();
            $.contextMenu("destroy", "#" + that.getEntityId());
            _canvas = null;
            _$awarenessTrace.remove();
            if (this.hasOwnProperty("unregisterCallbacks"))
                this.unregisterCallbacks();
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_attributes.hasOwnProperty(id)) {
                _attributes[id] = attribute;
            }
        };
        this.getAttribute = function (id) {
            if (_attributes.hasOwnProperty(id)) {
                return _attributes[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (_attributes.hasOwnProperty(id)) {
                delete _attributes[id];
            }
        };
        this.setAttributes = function (attributes) {
            _attributes = attributes;
        };
        this.getAttributes = function () {
            return _attributes;
        };
        this.setLabel = function (label) {
            _label = label;
        };
        this.getLabel = function () {
            return _label;
        };
        this.getType = function () {
            return _type;
        };
        this.getContainment = function () {
            return _containment;
        };
        this._get$node = function () {
            return this._$node;
        };
        this._draw = function () {
            _$awarenessTrace.css({
                left: _appearance.left + _appearance.width / 2,
                top: _appearance.top + _appearance.height / 2,
                width: _appearance.width * 1.2,
                height: _appearance.height * 1.2,
                zIndex: _zIndex - 1,
            });
            this._$node.css({
                left: _appearance.left,
                top: _appearance.top,
                width: _appearance.width,
                height: _appearance.height,
                zIndex: _zIndex,
            });
        };
        this.move = function (offsetX, offsetY, offsetZ) {
            const x = _appearance.left + offsetX;
            const y = _appearance.top + offsetY;
            if (x < 0 ||
                y < 0 ||
                x > _canvas.width - _appearance.width ||
                y > _canvas.height - _appearance.height) {
                _$node.css({
                    left: _appearance.left,
                    top: _appearance.top,
                });
                console.error("Node cannot be moved outside of canvas");
                if (_ymap) {
                    window.y.transact(() => {
                        _ymap.set("left", _appearance.left);
                        _ymap.set("top", _appearance.top);
                        _ymap.set("zIndex", _zIndex);
                    });
                }
            }
            else {
                if (_ymap) {
                    window.y.transact(() => {
                        _ymap.set("left", (_appearance.left += offsetX));
                        _ymap.set("top", (_appearance.top += offsetY));
                        _ymap.set("zIndex", _zIndex);
                    });
                }
            }
            this._draw();
            this.repaint();
        };
        this.moveAbs = function (left, top, zIndex) {
            if (left < 0 || top < 0) {
                console.error("Node cannot be moved outside of canvas");
            }
            if (left > _canvas.width - _appearance.width ||
                top > _canvas.height - _appearance.height) {
                console.error("Node cannot be moved outside of canvas");
            }
            _appearance.left = left;
            _appearance.top = top;
            if (zIndex)
                _zIndex = zIndex;
            if (_ymap) {
                y.transact(() => {
                    _ymap.set("left", _appearance.left);
                    _ymap.set("top", _appearance.top);
                    if (zIndex)
                        _ymap.set("zIndex", _zIndex);
                });
            }
            this._draw();
            this.repaint();
        };
        this.resize = function (offsetX, offsetY) {
            _appearance.width += offsetX;
            _appearance.height += offsetY;
            if (_ymap) {
                y.transact(() => {
                    _ymap.set("width", _appearance.width);
                    _ymap.set("height", _appearance.height);
                });
            }
            this._draw();
            this.repaint();
        };
        this.addIngoingEdge = function (edge) {
            var id = edge.getEntityId();
            var source = edge.getSource();
            var sourceEntityId = source.getEntityId();
            if (!_ingoingEdges.hasOwnProperty(id)) {
                _ingoingEdges[id] = edge;
                if (!_ingoingNeighbors.hasOwnProperty(sourceEntityId)) {
                    _ingoingNeighbors[sourceEntityId] = source;
                }
            }
        };
        this.addOutgoingEdge = function (edge) {
            var id = edge.getEntityId();
            var target = edge.getTarget();
            var targetEntityId = target?.getEntityId();
            if (!_outgoingEdges.hasOwnProperty(id)) {
                _outgoingEdges[id] = edge;
                if (!_outgoingNeighbors.hasOwnProperty(targetEntityId)) {
                    _outgoingNeighbors[targetEntityId] = target;
                }
            }
        };
        this.deleteIngoingEdge = function (edge) {
            var id = edge.getEntityId();
            var source = edge.getSource();
            var sourceEntityId = source.getEntityId();
            var isMultiEdge = false;
            if (_ingoingEdges.hasOwnProperty(id)) {
                delete _ingoingEdges[id];
                for (var edgeId in _ingoingEdges) {
                    if (_ingoingEdges.hasOwnProperty(edgeId) &&
                        _ingoingEdges[edgeId].getSource().getEntityId() === sourceEntityId) {
                        isMultiEdge = true;
                    }
                }
                if (!isMultiEdge) {
                    delete _ingoingNeighbors[sourceEntityId];
                }
            }
        };
        this.deleteOutgoingEdge = function (edge) {
            var id = edge.getEntityId();
            var target = edge.getTarget();
            var targetEntityId = target?.getEntityId();
            var isMultiEdge = false;
            if (_outgoingEdges.hasOwnProperty(id)) {
                delete _outgoingEdges[id];
                for (var edgeId in _outgoingEdges) {
                    if (_outgoingEdges.hasOwnProperty(edgeId) &&
                        _outgoingEdges[edgeId].getTarget().getEntityId() === targetEntityId) {
                        isMultiEdge = true;
                    }
                }
                if (!isMultiEdge) {
                    delete _outgoingNeighbors[targetEntityId];
                }
            }
        };
        this.getIngoingEdges = function () {
            return _ingoingEdges;
        };
        this.getOutgoingEdges = function () {
            return _outgoingEdges;
        };
        this.getEdges = function () {
            return Util.union(_ingoingEdges, _outgoingEdges);
        };
        this.getIngoingNeighbors = function () {
            return _ingoingNeighbors;
        };
        this.getOutgoingNeighbors = function () {
            return _outgoingNeighbors;
        };
        this.getNeighbors = function () {
            return Util.union(_ingoingNeighbors, _outgoingNeighbors);
        };
        this.lowlight = function () {
            this._$node.addClass("lowlighted");
        };
        this.unlowlight = function () {
            this._$node.removeClass("lowlighted");
        };
        this.select = function () {
            this.unhighlight();
            this._$node.addClass("selected");
            Util.delay(100).then(function () {
                lodash.each(EntityManagerInstance$1.getEdges(), function (e) {
                    e.setZIndex();
                });
            });
        };
        this.unselect = function () {
            this._$node.removeClass("selected");
            EntityManagerInstance$1.storeDataYjs();
            Util.delay(100).then(function () {
                lodash.each(EntityManagerInstance$1.getEdges(), function (e) {
                    e.setZIndex();
                });
            });
        };
        this.highlight = function (color, username) {
            if (color && username) {
                this._$node.css({ border: "2px solid " + color });
                this._$node.append($("<div></div>")
                    .addClass("user_highlight")
                    .css("color", color)
                    .text(username));
                Util.delay(100).then(function () {
                    lodash.each(EntityManagerInstance$1.getEdges(), function (e) {
                        e.setZIndex();
                    });
                });
            }
        };
        this.unhighlight = function () {
            this._$node.css({ border: "" });
            this._$node.find(".user_highlight").remove();
            Util.delay(100).then(function () {
                lodash.each(EntityManagerInstance$1.getEdges(), function (e) {
                    e.setZIndex();
                });
            });
        };
        this.remove = function () {
            clearInterval(_awarenessTimer);
            this.removeFromCanvas();
            jsPlumbInstance.removeAllEndpoints(_$node.get(0));
            jsPlumbInstance.unmanage(_$node.get(0));
            EntityManagerInstance$1.deleteNode(this.getEntityId());
        };
        this._toJSON = function () {
            var attr = {};
            lodash.forEach(this.getAttributes(), function (val, key) {
                attr[key] = val.toJSON();
            });
            return {
                label: _label.toJSON(),
                left: _appearance.left,
                top: _appearance.top,
                width: _appearance.width,
                height: _appearance.height,
                zIndex: _zIndex,
                type: _type,
                attributes: attr,
            };
        };
        this.addGhostEdge = function (ghostEdge) {
            _relatedGhostEdges.push(ghostEdge);
        };
        this.bindMoveToolEvents = () => {
            this.enableDraggable();
            var originalPos = {
                left: 0,
                top: 0,
            };
            var $sizePreview = $('<div class="size-preview"></div>').hide();
            this.makeResizable(that, _canvas, $sizePreview, id);
            this._$node
                .contextMenu(true)
                .find("input")
                .prop("disabled", false)
                .css("pointerEvents", "");
            this.jsPlumbManagedElement = jsPlumbInstance.manage(this._$node.get(0));
            jsPlumbInstance.bind(EVENT_DRAG_START, (params) => {
                if (params.el.id !== this._$node.attr("id"))
                    return true;
                originalPos.top = params.el.offsetTop;
                originalPos.left = params.el.offsetLeft;
                _canvas.hideGuidanceBox();
                _$node.css({ opacity: 0.5 });
                return true;
            });
            jsPlumbInstance.bind(EVENT_DRAG_STOP, (params) => {
                if (params.el.id !== this._$node.attr("id"))
                    return true;
                _$node.css({ opacity: "" });
                _canvas.bindMoveToolEvents();
                var offsetX = Math.round(params.el.offsetLeft - originalPos.left);
                var offsetY = Math.round(params.el.offsetTop - originalPos.top);
                if (offsetX === 0 && offsetY === 0)
                    return;
                if (params.el.offsetLeft < 0 ||
                    params.el.offsetTop < 0 ||
                    params.el.offsetLeft > _canvas.width ||
                    params.el.offsetTop > _canvas.height) {
                    console.error(" offset bigger than canvas size");
                    return;
                }
                var operation = new NodeMoveOperation(that.getEntityId(), offsetX, offsetY);
                that.propagateNodeMoveOperation(operation);
                _canvas.showGuidanceBox();
            });
            const widgetConfigMap = y.getMap("widgetConfig");
            var viewOnly = widgetConfigMap.get("view_only");
            if (viewOnly) {
                this.disableDraggable();
                _$node.on("click").contextMenu(false);
            }
        };
        this.unbindMoveToolEvents = () => {
            this._$node
                .off("click")
                .contextMenu(false)
                .find("input")
                .prop("disabled", true)
                .css("pointerEvents", "none");
            this.disableDraggable();
        };
        this.makeSource = () => {
            _$node.addClass("source");
            this.endPoint = window.jsPlumbInstance.addEndpoint(this._$node.get(0), {
                connectorPaintStyle: { fill: "black", strokeWidth: 4 },
                source: true,
                endpoint: {
                    type: "Rectangle",
                    options: {
                        width: _$node.width() + 50,
                        height: _$node.height() + 50,
                    },
                },
                paintStyle: { fill: "transparent" },
                anchor: AnchorLocations.Center,
                deleteOnEmpty: true,
                uniqueEndpoint: false,
                deleteEndpointsOnDetach: true,
                onMaxConnections: function (info) {
                    console.log("element is ", info.element, "maxConnections is", info.maxConnections);
                },
            });
        };
        this.makeTarget = () => {
            _$node.addClass("target");
            this.endPoint = window.jsPlumbInstance.addEndpoint(this._$node.get(0), {
                target: true,
                endpoint: {
                    type: "Rectangle",
                    options: {
                        width: _$node.width() + 50,
                        height: _$node.height() + 50,
                    },
                },
                paintStyle: { fill: "transparent" },
                anchor: AnchorLocations.Center,
                uniqueEndpoint: false,
                deleteOnEmpty: true,
                onMaxConnections: function (info) {
                    console.log("user tried to drop connection", info.connection, "on element", info.element, "with max connections", info.maxConnections);
                },
            });
        };
        this.unbindEdgeToolEvents = function () {
            try {
                _$node.removeClass("source target");
                jsPlumbInstance.getEndpoints(_$node.get(0)).forEach((endpoint) => {
                    if (endpoint.connections.length === 0) {
                        jsPlumbInstance.deleteEndpoint(endpoint);
                    }
                });
            }
            catch (error) {
                console.error(error);
            }
        };
        that.init();
        this._registerYMap = function () {
            _ymap.observe(function (event) {
                const array = Array.from(event.changes.keys.entries());
                array.forEach(([key, change]) => {
                    var yUserId = event.currentTarget.doc.clientID;
                    if (y.clientID !== yUserId ||
                        (event.value && event.value.historyFlag)) {
                        var operation;
                        var data = event.value;
                        const userMap = y.getMap("users");
                        var jabberId = userMap.get(yUserId);
                        switch (key) {
                            case NodeMoveOperation.TYPE: {
                                operation = new NodeMoveOperation(data.id, data.offsetX, data.offsetY, jabberId);
                                remoteNodeMoveCallback(operation);
                                break;
                            }
                            case NodeMoveZOperation.TYPE: {
                                operation = new NodeMoveZOperation(data.id, data.offsetZ, jabberId);
                                remoteNodeMoveZCallback(operation);
                                break;
                            }
                            case NodeResizeOperation.TYPE: {
                                operation = new NodeResizeOperation(data.id, data.offsetX, data.offsetY, jabberId);
                                remoteNodeResizeCallback(operation);
                                break;
                            }
                        }
                    }
                });
            });
        };
        jsPlumbInstance.manage(this._$node.get(0));
    }
    repaint() {
        window.jsPlumbInstance.repaint(this._$node.get(0));
        lodash.each(EntityManagerInstance$1.getEdges(), function (e) {
            e.setZIndex();
        });
    }
    enableDraggable() {
        jsPlumbInstance.setDraggable(this._$node.get(0), true);
    }
    disableDraggable() {
        jsPlumbInstance.setDraggable(this._$node.get(0), false);
    }
    makeResizable(that, _canvas, $sizePreview, id) {
        const initialSize = {
            width: that._$node.width(),
            height: that._$node.height(),
        };
        interact(that.nodeSelector)
            .resizable({
            edges: { right: ".bi", bottom: ".bi" },
            square: true,
            listeners: {
                move(event) {
                    that.disableDraggable();
                    let { x, y } = event.target.dataset;
                    x = (parseFloat(x) || 0) + event.deltaRect.left;
                    y = (parseFloat(y) || 0) + event.deltaRect.top;
                    Object.assign(event.target.style, {
                        width: `${event.rect.width}px`,
                        height: `${event.rect.height}px`,
                        transform: `translate(${x}px, ${y}px)`,
                    });
                    Object.assign(event.target.dataset, { x, y });
                    event.rect.width = Math.max(50, event.rect.width);
                    event.rect.height = Math.max(50, event.rect.height);
                    $sizePreview.text(Math.round(event.rect.width) +
                        "\u00D7" +
                        Math.round(event.rect.height));
                },
            },
            modifiers: [
                interact.modifiers.restrictEdges({
                    outer: "parent",
                }),
                interact.modifiers.restrictSize({
                    min: { width: 40, height: 40 },
                }),
            ],
            inertia: { enabled: false },
        })
            .on(["resizestart"], (event) => {
            that._$node.addClass("resizing");
            that.disableDraggable();
            _canvas.hideGuidanceBox();
            $sizePreview.show();
            that._$node.css({ opacity: 0.5 });
            that._$node.append($sizePreview);
            initialSize.width = that._$node.width();
            initialSize.height = that._$node.height();
            _canvas.unbindMoveToolEvents();
        })
            .on(["resizeend"], (event) => {
            that._$node.removeClass("resizing");
            that.enableDraggable();
            const offsetX = event.rect.width - initialSize.width;
            const offsetY = event.rect.height - initialSize.height;
            $sizePreview.hide();
            that._$node.css({ opacity: "" });
            that.repaint();
            var operation = new NodeResizeOperation(id, offsetX, offsetY);
            that.propagateNodeResizeOperation(operation);
            _canvas.bindMoveToolEvents();
        })
            .draggable();
    }
    disableResizable() {
        interact(this.nodeSelector).unset();
    }
    draw() {
        return this._draw();
    }
    get$node() {
        return this._get$node();
    }
    toJSON() {
        return this._toJSON();
    }
    hide() {
        this.get$node().hide();
        window.jsPlumbInstance.hide(this.get$node());
    }
    show() {
        this.get$node().show();
        window.jsPlumbInstance.show(this.get$node()[0]);
        window.jsPlumbInstance.repaint(this.get$node()[0]);
    }
    registerYMap() {
        this._registerYMap();
    }
};
let EnumNode$1 = class EnumNode extends AbstractNode$1 {
    constructor(id, left, top, width, height, zIndex, json) {
        super(id, EnumNode$1.TYPE, left, top, width, height, zIndex, json);
        var that = this;
        var _$template = $(lodash.template(enumNodeHtml$1)({ type: that.getType() }));
        var _$node = AbstractNode$1.prototype.get$node
            .call(this)
            .append(_$template)
            .addClass("class");
        var _$attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        this.toJSON = function () {
            var json = AbstractNode$1.prototype.toJSON.call(this);
            json.type = EnumNode$1.TYPE;
            return json;
        };
        var attr = new SingleValueListAttribute$1("[attributes]", "Attributes", this);
        this.addAttribute(attr);
        this.registerYMap = function () {
            AbstractNode$1.prototype.registerYMap.call(this);
            that.getLabel().getValue().registerYType();
            attr.registerYMap();
        };
        this.unregisterCallbacks = function () {
            that.getAttribute("[attributes]").unregisterCallbacks();
        };
        this.registerYTextAttributes = function (map) {
            map.get(that.getLabel().getValue().getEntityId()).then(function (ytext) {
                that.getLabel().getValue().registerYType(ytext);
            });
        };
        _$node.find(".label").append(this.getLabel().get$node());
        for (var attributeKey in _attributes) {
            if (_attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(_attributes[attributeKey].get$node());
            }
        }
    }
    static { this.TYPE = "Enumeration"; }
    static { this.DEFAULT_WIDTH = 150; }
    static { this.DEFAULT_HEIGHT = 100; }
};
let NodeShapeNode$1 = class NodeShapeNode extends AbstractNode$1 {
    constructor(id, left, top, width, height, zIndex, containment, json) {
        super(id, "Node Shape", left, top, width, height, zIndex, containment, json);
        var that = this;
        var _$template = $(lodash.template(nodeShapeNodeHtml$1)({ type: that.getType() }));
        var _$node = AbstractNode$1.prototype.get$node
            .call(this)
            .append(_$template)
            .addClass("class");
        var _$attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        this.toJSON = function () {
            var json = AbstractNode$1.prototype.toJSON.call(this);
            json.type = NodeShapeNode$1.TYPE;
            return json;
        };
        var attrShapeSelect = new SingleSelectionAttribute$1(this.getEntityId() + "[shape]", "Shape", this, {
            circle: "Circle",
            diamond: "Diamond",
            rectangle: "Rectangle",
            rounded_rectangle: "Rounded Rectangle",
            triangle: "Triangle",
        });
        var attrWidth = new IntegerAttribute$1(this.getEntityId() + "[defaultWidth]", "Default Width", this);
        var attrHeight = new IntegerAttribute$1(this.getEntityId() + "[defaultHeight]", "Default Height", this);
        var attrColor = new SingleColorValueAttribute$1(this.getEntityId() + "[color]", "Color", this);
        var attrContaintment = new BooleanAttribute$1(this.getEntityId() + "[containment]", "Containment", this);
        var attrCustomShape = new SingleMultiLineValueAttribute$1(this.getEntityId() + "[customShape]", "Custom Shape", this);
        var attrAnchors = new SingleValueAttribute$1(this.getEntityId() + "[customAnchors]", "Custom Anchors", this);
        this.addAttribute(attrShapeSelect);
        this.addAttribute(attrColor);
        this.addAttribute(attrWidth);
        this.addAttribute(attrHeight);
        this.addAttribute(attrContaintment);
        this.addAttribute(attrCustomShape);
        this.addAttribute(attrAnchors);
        _$node.find(".label").append(this.getLabel().get$node());
        for (var attributeKey in _attributes) {
            if (_attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(_attributes[attributeKey].get$node());
            }
        }
        this.registerYMap = function () {
            AbstractNode$1.prototype.registerYMap.call(this);
            attrShapeSelect.getValue().registerYType();
            attrWidth.getValue().registerYType();
            attrHeight.getValue().registerYType();
            attrContaintment.getValue().registerYType();
            that.getLabel().getValue().registerYType();
            attrColor.getValue().registerYType();
            attrAnchors.getValue().registerYType();
            attrCustomShape.getValue().registerYType();
        };
    }
    static { this.TYPE = "Node Shape"; }
    static { this.DEFAULT_WIDTH = 150; }
    static { this.DEFAULT_HEIGHT = 150; }
};
let EntityManager$2 = class EntityManager {
    constructor() {
        this.y = null;
        var _viewId = undefined;
        var _modelAttributesNode = null;
        var _nodes = {};
        this._nodes = _nodes;
        var _edges = {};
        this._edges = _edges;
        var metamodel = null;
        var guidancemodel = null;
        return {
            createNode: function (type, id, left, top, width, height, zIndex, containment, json, y) {
                var node;
                AbstractEntity$1.maxZIndex = Math.max(AbstractEntity$1.maxZIndex, zIndex);
                AbstractEntity$1.minZIndex = Math.min(AbstractEntity$1.minZIndex, zIndex);
                if (_viewId && viewNodeTypes.hasOwnProperty(type)) {
                    node = viewNodeTypes[type](id, left, top, width, height, zIndex, containment, json, y);
                }
                else if (nodeTypes.hasOwnProperty(type)) {
                    node = new nodeTypes[type](id, left, top, width, height, zIndex, containment, json, y);
                }
                _nodes[id] = node;
                return node;
            },
            findObjectNodeByLabel(searchLabel) {
                const re = new RegExp(searchLabel, "gi");
                for (const [id, node] of Object.entries(_nodes)) {
                    const currentNode = y.getMap("nodes").get(id).toJSON();
                    for (const [key, property] of Object.entries(currentNode)) {
                        if (key.match(id)) {
                            if (property.match(re)) {
                                return node;
                            }
                        }
                    }
                }
                return null;
            },
            createModelAttributesNode: function (y) {
                if (_modelAttributesNode === null) {
                    if (metamodel)
                        _modelAttributesNode = new ModelAttributesNode$1("modelAttributes", metamodel.attributes, y);
                    else
                        _modelAttributesNode = new ModelAttributesNode$1("modelAttributes", null, y);
                    return _modelAttributesNode;
                }
                return _modelAttributesNode;
            },
            findNodeByAttribute: function (attr, name) {
                for (const key in _nodes) {
                    const node = _nodes[key];
                    if (node.getAttribute(attr) === name) {
                        return node;
                    }
                }
            },
            findNode: function (id) {
                if (_nodes.hasOwnProperty(id)) {
                    return _nodes[id];
                }
                return null;
            },
            find: function (id) {
                return this.findNode(id) || this.findEdge(id);
            },
            deleteNode: function (id) {
                if (_nodes.hasOwnProperty(id)) {
                    delete _nodes[id];
                }
            },
            getNodes: function () {
                return _nodes;
            },
            getNodesByType: function (type) {
                var nodeId, node, nodesByType = {};
                if (typeof type === "string") {
                    type = [type];
                }
                for (nodeId in _nodes) {
                    if (_nodes.hasOwnProperty(nodeId)) {
                        node = _nodes[nodeId];
                        if (type.indexOf(node.getType()) !== -1) {
                            nodesByType[nodeId] = node;
                        }
                    }
                }
                return nodesByType;
            },
            createEdge: function (type, id, source, target) {
                var edge;
                if (_viewId && viewEdgeTypes.hasOwnProperty(type)) {
                    edge = viewEdgeTypes[type](id, source, target);
                }
                else if (edgeTypes.hasOwnProperty(type)) {
                    edge = new edgeTypes[type](id, source, target);
                }
                else {
                    return undefined;
                }
                source.addOutgoingEdge(edge);
                target?.addIngoingEdge(edge);
                _edges[id] = edge;
                return edge;
            },
            findEdge: function (id) {
                if (_edges.hasOwnProperty(id)) {
                    return _edges[id];
                }
                return null;
            },
            deleteEdge: function (id) {
                if (_edges.hasOwnProperty(id)) {
                    delete _edges[id];
                }
            },
            getEdges: function () {
                return _edges;
            },
            getEdgesByType: function (type) {
                var edgeId, edge, edgesByType = {};
                for (edgeId in _edges) {
                    if (_edges.hasOwnProperty(edgeId)) {
                        edge = _edges[edgeId];
                        if (edge.getType() === type) {
                            edgesByType[edgeId] = edge;
                        }
                    }
                }
                return edgesByType;
            },
            graphToJSON: function () {
                var attributesJSON;
                var nodesJSON = {};
                var edgesJSON = {};
                attributesJSON = _modelAttributesNode
                    ? _modelAttributesNode.toJSON()
                    : {};
                lodash.forEach(_nodes, function (val, key) {
                    nodesJSON[key] = val.toJSON();
                });
                lodash.forEach(_edges, function (val, key) {
                    edgesJSON[key] = val.toJSON();
                });
                return {
                    attributes: attributesJSON,
                    nodes: nodesJSON,
                    edges: edgesJSON,
                };
            },
            createModelAttributesNodeFromJSON: function (json) {
                var node = this.createModelAttributesNode();
                if (node) {
                    node.getLabel().getValue().setValue(json.label.value.value);
                    for (var attrId in json.attributes) {
                        if (json.attributes.hasOwnProperty(attrId)) {
                            var attr = node.getAttribute(attrId);
                            if (attr) {
                                attr.setValueFromJSON(json.attributes[attrId]);
                            }
                        }
                    }
                }
                return node;
            },
            createNodeFromJSON: function (type, id, left, top, width, height, zIndex, containment, json, y) {
                var node = this.createNode(type, id, left, top, width, height, zIndex, containment, json, y);
                if (node) {
                    node.getLabel().getValue().setValue(json.label.value.value);
                    for (var attrId in json.attributes) {
                        if (json.attributes.hasOwnProperty(attrId)) {
                            var attr = node.getAttribute(attrId);
                            if (attr) {
                                attr.setValueFromJSON(json.attributes[attrId]);
                            }
                            else {
                                var newId = attrId.replace(/[^\[\]]*/, id);
                                attr = node.getAttribute(newId);
                                if (attr) {
                                    attr.setValueFromJSON(json.attributes[attrId]);
                                }
                            }
                        }
                    }
                }
                return node;
            },
            createEdgeFromJSON: function (type, id, source, target, json) {
                const sourceNode = this.findNode(source);
                const targetNode = this.findNode(target);
                var edge = this.createEdge(type, id, sourceNode, targetNode);
                if (edge) {
                    edge.getLabel().getValue().setValue(json.label.value.value);
                    for (var attrId in json.attributes) {
                        if (json.attributes.hasOwnProperty(attrId)) {
                            var attr = edge.getAttribute(attrId);
                            if (attr) {
                                attr.setValueFromJSON(json.attributes[attrId]);
                            }
                        }
                    }
                }
                return edge;
            },
            generateAddNodeMenu: function (canvas, left, top) {
                function makeAddNodeCallback(nodeType, width, height, containment) {
                    return function () {
                        canvas.createNode(nodeType, left, top, width, height, 32000, containment);
                    };
                }
                var items = {}, nodeType, _nodeTypes;
                if (_viewId && _layer === CONFIG$1.LAYER.MODEL) {
                    _nodeTypes = viewNodeTypes;
                }
                else {
                    _nodeTypes = nodeTypes;
                }
                for (nodeType in _nodeTypes) {
                    if (_nodeTypes.hasOwnProperty(nodeType)) {
                        if (_layer === CONFIG$1.LAYER.META &&
                            !_viewId &&
                            (nodeType === "ViewObject" || nodeType === "ViewRelationship"))
                            continue;
                        if (_layer === CONFIG$1.LAYER.META &&
                            _viewId &&
                            (nodeType === "Object" ||
                                nodeType === "Relationship" ||
                                nodeType === "Enumeration" ||
                                nodeType === "Abstract Class"))
                            continue;
                        items[nodeType] = {
                            name: ".." + nodeType,
                            callback: makeAddNodeCallback(nodeType, _nodeTypes[nodeType].DEFAULT_WIDTH, _nodeTypes[nodeType].DEFAULT_HEIGHT, _nodeTypes[nodeType].CONTAINMENT),
                        };
                    }
                }
                return items;
            },
            generateVisibilityNodeMenu: function (visibility) {
                var _applyVisibilityCallback = function (nodeType, vis) {
                    return function () {
                        if (vis !== "show" && vis !== "hide")
                            return;
                        var nodes;
                        if (_viewId && _layer === CONFIG$1.LAYER.MODEL) {
                            nodes = that.getNodesByViewType(nodeType);
                        }
                        else {
                            nodes = that.getNodesByType(nodeType);
                        }
                        for (var nKey in nodes) {
                            if (nodes.hasOwnProperty(nKey)) {
                                nodes[nKey][vis]();
                            }
                        }
                        if (vis === "hide") {
                            this.data("show" + nodeType + "Disabled", true);
                        }
                        else {
                            this.data("show" + nodeType + "Disabled", false);
                        }
                        return false;
                    };
                };
                var that = this;
                var items = {}, nodeType, _nodeTypes;
                if (_viewId && _layer === CONFIG$1.LAYER.MODEL) {
                    _nodeTypes = viewNodeTypes;
                }
                else {
                    _nodeTypes = nodeTypes;
                }
                for (nodeType in _nodeTypes) {
                    if (_nodeTypes.hasOwnProperty(nodeType)) {
                        if (_layer === CONFIG$1.LAYER.META &&
                            !_viewId &&
                            (nodeType === "ViewObject" || nodeType === "ViewRelationship"))
                            continue;
                        if (_layer === CONFIG$1.LAYER.META &&
                            _viewId &&
                            (nodeType === "Object" ||
                                nodeType === "Relationship" ||
                                nodeType === "Enumeration" ||
                                nodeType === "Abstract Class"))
                            continue;
                        items[visibility + nodeType] = {
                            name: ".." + nodeType,
                            callback: _applyVisibilityCallback(nodeType, visibility),
                            disabled: (function (nodeType) {
                                return function () {
                                    if (visibility === "hide")
                                        return this.data(visibility + nodeType + "Disabled");
                                    else
                                        return !this.data(visibility + nodeType + "Disabled");
                                };
                            })(nodeType),
                        };
                    }
                }
                return items;
            },
            generateVisibilityEdgeMenu: function (visibility) {
                function _applyVisibilityCallback(edgeType, vis) {
                    return function () {
                        if (vis !== "show" && vis !== "hide")
                            return;
                        var edges;
                        if (_viewId && _layer === CONFIG$1.LAYER.MODEL) {
                            edges = that.getEdgesByViewType(edgeType);
                        }
                        else {
                            edges = that.getEdgesByType(edgeType);
                        }
                        for (var eKey in edges) {
                            if (edges.hasOwnProperty(eKey)) {
                                edges[eKey][vis]();
                            }
                        }
                        if (vis === "hide") {
                            this.data("show" + edgeType + "Disabled", true);
                        }
                        else {
                            this.data("show" + edgeType + "Disabled", false);
                        }
                    };
                }
                var that = this;
                var items = {}, edgeType, _edgeTypes;
                if (_viewId && _layer === CONFIG$1.LAYER.MODEL) {
                    _edgeTypes = viewEdgeTypes;
                }
                else {
                    _edgeTypes = edgeTypes;
                }
                for (edgeType in _edgeTypes) {
                    if (_edgeTypes.hasOwnProperty(edgeType)) {
                        items[visibility + edgeType] = {
                            name: ".." + edgeType,
                            callback: _applyVisibilityCallback(edgeType, visibility),
                            disabled: (function (edgeType) {
                                return function () {
                                    if (visibility === "hide")
                                        return this.data(visibility + edgeType + "Disabled");
                                    else
                                        return !this.data(visibility + edgeType + "Disabled");
                                };
                            })(edgeType),
                        };
                    }
                }
                return items;
            },
            generateConnectToMenu: function (node) {
                function makeTargetNodeCallback(connectionType, targetNodeId) {
                    return function () {
                        node
                            .getCanvas()
                            .createEdge(connectionType, node.getEntityId(), targetNodeId);
                    };
                }
                var connectionType, sourceNodeTypes, targetNodeTypes, targetNodeType, connectionItems, targetNodeTypeItems, targetNodeItems, i, numOfRelations, j, numOfTargetTypes, targetNodes, targetNodeId, targetNode, targetAppearance, sourceAppearance = node.getAppearance();
                connectionItems = {};
                for (connectionType in relations) {
                    if (relations.hasOwnProperty(connectionType)) {
                        targetNodeTypeItems = {};
                        for (i = 0, numOfRelations = relations[connectionType].length; i < numOfRelations; i++) {
                            sourceNodeTypes = relations[connectionType][i].sourceTypes;
                            targetNodeTypes = relations[connectionType][i].targetTypes;
                            if (sourceNodeTypes.indexOf(node.getType()) !== -1 ||
                                (_layer === CONFIG$1.LAYER.MODEL &&
                                    _viewId &&
                                    sourceNodeTypes.indexOf(node.getCurrentViewType()) !== -1)) {
                                for (j = 0, numOfTargetTypes = targetNodeTypes.length; j < numOfTargetTypes; j++) {
                                    targetNodeType = targetNodeTypes[j];
                                    targetNodeItems = {};
                                    if (_viewId && _layer === CONFIG$1.LAYER.MODEL) {
                                        targetNodes = this.getNodesByViewType(targetNodeType);
                                    }
                                    else {
                                        targetNodes = this.getNodesByType(targetNodeType);
                                    }
                                    for (targetNodeId in targetNodes) {
                                        if (targetNodes.hasOwnProperty(targetNodeId)) {
                                            targetNode = targetNodes[targetNodeId];
                                            if (targetNode === node)
                                                continue;
                                            if (_layer === CONFIG$1.LAYER.MODEL &&
                                                _viewId &&
                                                targetNode.getCurrentViewType() === null)
                                                continue;
                                            targetAppearance = targetNode.getAppearance();
                                            if (!targetNode
                                                .getNeighbors()
                                                .hasOwnProperty(node.getEntityId())) {
                                                targetNodeItems[connectionType + targetNodeType + i + targetNodeId] = {
                                                    name: ".." +
                                                        (targetNode.getLabel().getValue().getValue() ||
                                                            targetNode.getType()),
                                                    callback: makeTargetNodeCallback(connectionType, targetNodeId),
                                                    distanceSquare: Math.pow(targetAppearance.left - sourceAppearance.left, 2) +
                                                        Math.pow(targetAppearance.top - sourceAppearance.top, 2),
                                                    targetNodeId: connectionType + targetNodeType + i + targetNodeId,
                                                };
                                            }
                                        }
                                    }
                                    if (lodash.size(targetNodeItems) > 0) {
                                        var targetNodeItemsTmp = lodash.sortBy(targetNodeItems, "distanceSquare");
                                        targetNodeItems = {};
                                        for (var k = 0, numOfItems = targetNodeItemsTmp.length; k < numOfItems; k++) {
                                            targetNodeItems[k + targetNodeItemsTmp[k].targetNodeId] =
                                                targetNodeItemsTmp[k];
                                        }
                                        targetNodeTypeItems[connectionType + targetNodeType + i] = {
                                            name: "..to " + targetNodeType + "..",
                                            items: targetNodeItems,
                                        };
                                    }
                                }
                            }
                        }
                        if (lodash.size(targetNodeTypeItems) > 0) {
                            connectionItems[connectionType] = {
                                name: "..with " + connectionType + "..",
                                items: targetNodeTypeItems,
                            };
                        }
                    }
                }
                return {
                    name: "Connect..",
                    items: connectionItems,
                    disabled: (function (connectionItems) {
                        return lodash.size(connectionItems) === 0;
                    })(connectionItems),
                };
            },
            generateGuidanceMetamodel: function () {
                var metamodel = this.generateMetaModel();
                var actionNodeLabels = [];
                var createEntityNodeLabels = [];
                var guidanceMetamodel = {
                    attributes: {},
                    nodes: {},
                    edges: {},
                };
                var initialNode = {
                    label: guidancemodel.INITIAL_NODE_LABEL,
                    shape: {
                        shape: "",
                        color: "",
                        defaultWidth: 200,
                        defaultHeight: 60,
                        containment: false,
                        customShape: startActivityNodeHtml,
                        customAnchors: "",
                    },
                    attributes: {},
                };
                initialNode.attributes[Util.generateRandomId()] = {
                    key: "label",
                    value: "string",
                };
                guidanceMetamodel.nodes[Util.generateRandomId()] = initialNode;
                var finalNode = {
                    label: guidancemodel.ACTIVITY_FINAL_NODE_LABEL,
                    shape: {
                        shape: "circle",
                        color: "",
                        defaultWidth: 50,
                        defaultHeight: 50,
                        containment: false,
                        customShape: activityFinalNodeHtml,
                        customAnchors: ["Perimeter", { shape: "Circle", anchorCount: 60 }],
                    },
                    attributes: {},
                };
                guidanceMetamodel.nodes[Util.generateRandomId()] = finalNode;
                var mergeNode = {
                    label: guidancemodel.MERGE_NODE_LABEL,
                    shape: {
                        shape: "diamond",
                        color: "yellow",
                        defaultWidth: 0,
                        defaultHeight: 0,
                        containment: false,
                        customShape: "",
                        customAnchors: "",
                    },
                    attributes: {},
                };
                guidanceMetamodel.nodes[Util.generateRandomId()] = mergeNode;
                var callActivityNode = {
                    label: guidancemodel.CALL_ACTIVITY_NODE_LABEL,
                    shape: {
                        shape: "rounded_rectangle",
                        color: "",
                        defaultWidth: 100,
                        defaultHeight: 50,
                        containment: false,
                        customShape: callActivityNodeHtml,
                        customAnchors: "",
                    },
                    attributes: {},
                };
                actionNodeLabels.push(guidancemodel.CALL_ACTIVITY_NODE_LABEL);
                callActivityNode.attributes[Util.generateRandomId()] = {
                    key: "label",
                    value: "string",
                };
                guidanceMetamodel.nodes[Util.generateRandomId()] = callActivityNode;
                var concurrencyNode = {
                    label: guidancemodel.CONCURRENCY_NODE_LABEL,
                    shape: {
                        shape: "rectangle",
                        color: "black",
                        defaultWidth: 10,
                        defaultHeight: 200,
                        containment: false,
                        customShape: "",
                        customAnchors: "",
                    },
                    attributes: {},
                };
                guidanceMetamodel.nodes[Util.generateRandomId()] = concurrencyNode;
                var flowEdgeRelations = [];
                var dataFlowEdgeRelations = [];
                var nodes = metamodel.nodes;
                for (var nodeId in nodes) {
                    if (nodes.hasOwnProperty(nodeId)) {
                        var node = nodes[nodeId];
                        var createObjectNodeToEntityNodeRelation = {
                            sourceTypes: [],
                            targetTypes: [],
                        };
                        var label = guidancemodel.getCreateObjectNodeLabelForType(node.label);
                        createObjectNodeToEntityNodeRelation.sourceTypes.push(label);
                        actionNodeLabels.push(label);
                        createEntityNodeLabels.push(label);
                        var id = Util.generateRandomId();
                        guidanceMetamodel.nodes[id] = {
                            label: label,
                            attributes: {},
                            shape: {
                                shape: "rounded_rectangle",
                                color: "",
                                defaultWidth: 100,
                                defaultHeight: 50,
                                containment: false,
                                customShape: lodash.template(actionNodeHtml)({
                                    label: node.label,
                                    icon: "plus",
                                }),
                                customAnchors: "",
                            },
                        };
                        var entityLabel = guidancemodel.getEntityNodeLabelForType(node.label);
                        createObjectNodeToEntityNodeRelation.targetTypes.push(label);
                        id = Util.generateRandomId();
                        guidanceMetamodel.nodes[id] = {
                            label: entityLabel,
                            attributes: {},
                            shape: {
                                shape: "rectangle",
                                color: "",
                                defaultWidth: 100,
                                defaultHeight: 50,
                                containment: false,
                                customShape: lodash.template(entityNodeHtml)({
                                    icon: "square",
                                    label: node.label,
                                }),
                                customAnchors: "",
                            },
                        };
                        setPropertyLabel = guidancemodel.getSetPropertyNodeLabelForType(node.label);
                        actionNodeLabels.push(setPropertyLabel);
                        id = Util.generateRandomId();
                        guidanceMetamodel.nodes[id] = {
                            label: setPropertyLabel,
                            attributes: {},
                            shape: {
                                shape: "",
                                defaultWidth: 130,
                                defaultHeight: 50,
                                containment: false,
                                customShape: lodash.template(setPropertyNodeHtml)(),
                                customAnchors: "",
                            },
                        };
                        var options = {};
                        for (var attributeId in node.attributes) {
                            var attribute = node.attributes[attributeId];
                            options[attribute.key] = attribute.key;
                        }
                        guidanceMetamodel.nodes[id].attributes[Util.generateRandomId()] = {
                            key: "Property",
                            value: "Value",
                            options: options,
                        };
                        dataFlowEdgeRelations.push({
                            sourceTypes: [label],
                            targetTypes: [entityLabel],
                        });
                        dataFlowEdgeRelations.push({
                            sourceTypes: [entityLabel],
                            targetTypes: [setPropertyLabel],
                        });
                        for (var edgeId in metamodel.edges) {
                            var edge = metamodel.edges[edgeId];
                            for (var relationId in edge.relations) {
                                var relation = edge.relations[relationId];
                                if (relation.sourceTypes.indexOf(node.label) > -1 ||
                                    relation.targetTypes.indexOf(node.label) > -1) {
                                    dataFlowEdgeRelations.push({
                                        sourceTypes: [entityLabel],
                                        targetTypes: guidancemodel.getCreateRelationshipNodeLabelForType(edge.label),
                                    });
                                    break;
                                }
                            }
                        }
                    }
                }
                var edgesByLabel = {};
                var edges = metamodel.edges;
                for (var edgeId in edges) {
                    if (edges.hasOwnProperty(edgeId)) {
                        var edge = edges[edgeId];
                        var label = guidancemodel.getCreateRelationshipNodeLabelForType(edge.label);
                        actionNodeLabels.push(label);
                        createEntityNodeLabels.push(label);
                        edgesByLabel[edge.label] = edge;
                        var id = Util.generateRandomId();
                        guidanceMetamodel.nodes[id] = {
                            label: label,
                            attributes: {},
                            shape: {
                                shape: "rounded_rectangle",
                                color: "",
                                defaultWidth: 100,
                                defaultHeight: 50,
                                containment: false,
                                customShape: lodash.template(actionNodeHtml)({
                                    label: edge.label,
                                    icon: "plus",
                                }),
                                customAnchors: "",
                            },
                        };
                        var entityLabel = guidancemodel.getEntityNodeLabelForType(edge.label);
                        var id = Util.generateRandomId();
                        guidanceMetamodel.nodes[id] = {
                            label: entityLabel,
                            attributes: {},
                            shape: {
                                shape: "rectangle",
                                color: "black",
                                defaultWidth: 100,
                                defaultHeight: 50,
                                containment: false,
                                customShape: lodash.template(entityNodeHtml)({
                                    icon: "exchange",
                                    label: edge.label,
                                }),
                                customAnchors: "",
                            },
                        };
                        if (Object.keys(edge.attributes).length > 0) {
                            var setPropertyLabel = guidancemodel.getSetPropertyNodeLabelForType(edge.label);
                            actionNodeLabels.push(setPropertyLabel);
                            id = Util.generateRandomId();
                            guidanceMetamodel.nodes[id] = {
                                label: setPropertyLabel,
                                attributes: {},
                                shape: {
                                    shape: "",
                                    defaultWidth: 0,
                                    defaultHeight: 0,
                                    containment: false,
                                    customShape: lodash.template(setPropertyNodeHtml)({
                                        type: setPropertyLabel,
                                        color: "white",
                                    }),
                                    customAnchors: "",
                                },
                            };
                            var options = {};
                            for (var attributeId in edge.attributes) {
                                var attribute = edge.attributes[attributeId];
                                options[attribute.key] = attribute.key;
                            }
                            guidanceMetamodel.nodes[id].attributes[Util.generateRandomId()] =
                                {
                                    key: "Property",
                                    value: "Value",
                                    options: options,
                                };
                        }
                        dataFlowEdgeRelations.push({
                            sourceTypes: [label],
                            targetTypes: [entityLabel],
                        });
                        dataFlowEdgeRelations.push({
                            sourceTypes: [entityLabel],
                            targetTypes: [setPropertyLabel],
                        });
                    }
                }
                flowEdgeRelations = flowEdgeRelations.concat({
                    sourceTypes: actionNodeLabels,
                    targetTypes: actionNodeLabels.concat([
                        guidancemodel.MERGE_NODE_LABEL,
                        guidancemodel.ACTIVITY_FINAL_NODE_LABEL,
                        guidancemodel.CONCURRENCY_NODE_LABEL,
                    ]),
                });
                flowEdgeRelations = flowEdgeRelations.concat({
                    sourceTypes: [guidancemodel.INITIAL_NODE_LABEL],
                    targetTypes: [
                        guidancemodel.CALL_ACTIVITY_NODE_LABEL,
                        guidancemodel.MERGE_NODE_LABEL,
                        guidancemodel.CONCURRENCY_NODE_LABEL,
                    ].concat(createEntityNodeLabels),
                });
                flowEdgeRelations = flowEdgeRelations.concat({
                    sourceTypes: [guidancemodel.MERGE_NODE_LABEL],
                    targetTypes: [
                        guidancemodel.ACTIVITY_FINAL_NODE_LABEL,
                        guidancemodel.MERGE_NODE_LABEL,
                        guidancemodel.CONCURRENCY_NODE_LABEL,
                    ].concat(actionNodeLabels),
                });
                flowEdgeRelations = flowEdgeRelations.concat({
                    sourceTypes: [guidancemodel.CONCURRENCY_NODE_LABEL],
                    targetTypes: [
                        guidancemodel.ACTIVITY_FINAL_NODE_LABEL,
                        guidancemodel.CONCURRENCY_NODE_LABEL,
                        guidancemodel.MERGE_NODE_LABEL,
                    ].concat(actionNodeLabels),
                });
                guidanceMetamodel.edges[Util.generateRandomId()] = {
                    label: "Action flow edge",
                    shape: {
                        arrow: "unidirassociation",
                        shape: "curved",
                        color: "black",
                        overlay: "",
                        overlayPosition: "top",
                        overlayRotate: true,
                    },
                    relations: flowEdgeRelations,
                };
                var dataFlowEdge = {
                    label: "Data flow edge",
                    shape: {
                        arrow: "unidirassociation",
                        shape: "curved",
                        color: "black",
                        overlay: "",
                        overlayPosition: "top",
                        overlayRotate: true,
                    },
                    attributes: {},
                    relations: dataFlowEdgeRelations,
                };
                dataFlowEdge.attributes[Util.generateRandomId()] = {
                    key: "Destination",
                    value: "Value",
                    options: {
                        Source: "Source",
                        Target: "Target",
                    },
                };
                guidanceMetamodel.edges[Util.generateRandomId()] = dataFlowEdge;
                guidanceMetamodel.edges[Util.generateRandomId()] = {
                    label: "Association edge",
                    shape: {
                        arrow: "unidirassociation",
                        shape: "curved",
                        color: "",
                        dashstyle: "4 2",
                        overlay: "",
                        overlayPosition: "hidden",
                        overlayRotate: true,
                    },
                    relations: [
                        {
                            sourceTypes: [guidancemodel.CALL_ACTIVITY_NODE_LABEL],
                            targetTypes: [guidancemodel.INITIAL_NODE_LABEL],
                        },
                    ],
                };
                return guidanceMetamodel;
            },
            generateLogicalGuidanceRepresentation: function (m) {
                const dataMap = y.getMap("data");
                var graph = new graphlib.Graph();
                var model;
                if (m)
                    model = m;
                else
                    model = dataMap.get("guidancemodel");
                if (!model)
                    return null;
                var nodes = model.nodes;
                var edges = model.edges;
                var getFlowSuccessors = function (nodeId) {
                    var targets = [];
                    var labels = [];
                    for (var edgeId in edges) {
                        var edge = edges[edgeId];
                        if (edge.source == nodeId) {
                            if (edge.type == "Action flow edge") {
                                targets.push(edge.target);
                                labels.push(edge.label.value.value);
                            }
                        }
                    }
                    return {
                        targets: targets,
                        labels: labels,
                    };
                };
                var getEntitySuccessor = function (nodeId) {
                    for (var edgeId in edges) {
                        var edge = edges[edgeId];
                        if (edge.source == nodeId) {
                            var targetType = nodes[edge.target].type;
                            if ((targetType = guidancemodel.isEntityNodeLabel(targetType)))
                                return edge.target;
                        }
                    }
                    return "";
                };
                var getEntityPredecessorsForCreateRelationshipAction = function (nodeId) {
                    var entities = {
                        Source: "",
                        Target: "",
                    };
                    for (var edgeId in edges) {
                        var edge = edges[edgeId];
                        if (edge.target == nodeId) {
                            var sourceType = nodes[edge.source].type;
                            if ((sourceType = guidancemodel.isEntityNodeLabel(sourceType))) {
                                var destination = getAttributeValue(edge, "Destination");
                                entities[destination] = edge.source;
                            }
                        }
                    }
                    return entities;
                };
                var getEntityPredecessorForSetPropertyAction = function (nodeId) {
                    for (var edgeId in edges) {
                        var edge = edges[edgeId];
                        if (edge.target == nodeId) {
                            var sourceType = nodes[edge.source].type;
                            if ((sourceType = guidancemodel.isEntityNodeLabel(sourceType))) {
                                return edge.source;
                            }
                        }
                    }
                    return "";
                };
                var getInitialNodeForCallActivityAction = function (nodeId) {
                    for (var edgeId in edges) {
                        var edge = edges[edgeId];
                        if (edge.source == nodeId && edge.type == "Association edge") {
                            return edge.target;
                        }
                    }
                    return "";
                };
                var getAttributeValue = function (node, attributeName) {
                    for (var attributeId in node.attributes) {
                        var attribute = node.attributes[attributeId];
                        if (attribute.name == attributeName)
                            return attribute.value.value;
                    }
                    return "";
                };
                for (var nodeId in nodes) {
                    var node = nodes[nodeId];
                    var type = node.type;
                    var subType = "";
                    if (type == guidancemodel.INITIAL_NODE_LABEL) {
                        var successors = getFlowSuccessors(nodeId);
                        graph.setNode(nodeId, {
                            type: "INITIAL_NODE",
                            name: getAttributeValue(node, "label"),
                        });
                        for (var i = 0; i < successors.targets.length; i++) {
                            graph.setEdge(nodeId, successors.targets[i], successors.labels[i]);
                        }
                    }
                    else if (type == guidancemodel.MERGE_NODE_LABEL) {
                        var successors = getFlowSuccessors(nodeId);
                        graph.setNode(nodeId, {
                            type: "MERGE_NODE",
                        });
                        for (var i = 0; i < successors.targets.length; i++) {
                            graph.setEdge(nodeId, successors.targets[i], successors.labels[i]);
                        }
                    }
                    else if (type == guidancemodel.CONCURRENCY_NODE_LABEL) {
                        var successors = getFlowSuccessors(nodeId);
                        graph.setNode(nodeId, {
                            type: "CONCURRENCY_NODE",
                        });
                        for (var i = 0; i < successors.targets.length; i++) {
                            graph.setEdge(nodeId, successors.targets[i], successors.labels[i]);
                        }
                    }
                    else if (type == guidancemodel.ACTIVITY_FINAL_NODE_LABEL) {
                        graph.setNode(nodeId, {
                            type: "ACTIVITY_FINAL_NODE",
                        });
                    }
                    else if ((subType = guidancemodel.isCreateObjectNodeLabel(type))) {
                        var successors = getFlowSuccessors(nodeId);
                        graph.setNode(nodeId, {
                            type: "CREATE_OBJECT_ACTION",
                            objectType: subType,
                            createdObjectId: getEntitySuccessor(nodeId),
                        });
                        for (var i = 0; i < successors.targets.length; i++) {
                            graph.setEdge(nodeId, successors.targets[i], successors.labels[i]);
                        }
                    }
                    else if ((subType = guidancemodel.isCreateRelationshipNodeLabel(type))) {
                        var entities = getEntityPredecessorsForCreateRelationshipAction(nodeId);
                        var successors = getFlowSuccessors(nodeId);
                        graph.setNode(nodeId, {
                            type: "CREATE_RELATIONSHIP_ACTION",
                            relationshipType: subType,
                            createdRelationshipId: getEntitySuccessor(nodeId),
                            sourceObjectId: entities["Source"],
                            targetObjectId: entities["Target"],
                        });
                        for (var i = 0; i < successors.targets.length; i++) {
                            graph.setEdge(nodeId, successors.targets[i], successors.labels[i]);
                        }
                    }
                    else if ((subType = guidancemodel.isSetPropertyNodeLabel(type))) {
                        var successors = getFlowSuccessors(nodeId);
                        graph.setNode(nodeId, {
                            type: "SET_PROPERTY_ACTION",
                            entityType: subType,
                            propertyName: getAttributeValue(node, "Property"),
                            sourceObjectId: getEntityPredecessorForSetPropertyAction(nodeId),
                        });
                        for (var i = 0; i < successors.targets.length; i++) {
                            graph.setEdge(nodeId, successors.targets[i], successors.labels[i]);
                        }
                    }
                    else if (type == guidancemodel.CALL_ACTIVITY_NODE_LABEL) {
                        var successors = getFlowSuccessors(nodeId);
                        graph.setNode(nodeId, {
                            type: "CALL_ACTIVITY_ACTION",
                            initialNodeId: getInitialNodeForCallActivityAction(nodeId),
                        });
                        for (var i = 0; i < successors.targets.length; i++) {
                            graph.setEdge(nodeId, successors.targets[i], successors.labels[i]);
                        }
                    }
                }
                return graphlib.json.write(graph);
            },
            generateGuidanceRules: function () {
                var guidanceRules = { objectToolRules: [] };
                var nodes = guidancemodel.guidancemodel.nodes;
                var edges = guidancemodel.guidancemodel.edges;
                for (var nodeId in nodes) {
                    var node = nodes[nodeId];
                    var type = node.type;
                    if (guidancemodel.isObjectToolType(type)) {
                        var srcObjectType = guidancemodel.getObjectTypeForObjectToolType(type);
                        var destObjectType = null;
                        var relationshipType = null;
                        var relevantEdges = [];
                        var label = "";
                        for (var attributeId in node.attributes) {
                            if (node.attributes[attributeId].name == "label")
                                label = node.attributes[attributeId].value.value;
                        }
                        var edgeId;
                        for (edgeId in edges) {
                            if (edges[edgeId].source == nodeId)
                                relevantEdges.push(edges[edgeId]);
                        }
                        for (var i = 0; i < relevantEdges.length; i++) {
                            var edge = relevantEdges[i];
                            var target = nodes[edge.target];
                            if (guidancemodel.isObjectContextType(target.type)) {
                                destObjectType =
                                    guidancemodel.getObjectTypeForObjectContextType(target.type);
                            }
                            else if (guidancemodel.isRelationshipContextType(target.type)) {
                                relationshipType =
                                    guidancemodel.getRelationshipTypeForRelationshipContextType(target.type);
                            }
                        }
                        if (destObjectType !== null && relationshipType !== null) {
                            var objectToolRule = {
                                srcObjectType: srcObjectType,
                                destObjectType: destObjectType,
                                relationshipType: relationshipType,
                                label: label,
                            };
                            guidanceRules.objectToolRules.push(objectToolRule);
                        }
                    }
                }
                return guidanceRules;
            },
            generateMetaModel: function () {
                function getConcreteObjectNodeTypes(node, visitedNodes) {
                    var edgeId, edge, ingoingEdges, source, type, classTypes = [];
                    if (!visitedNodes)
                        visitedNodes = [];
                    if (visitedNodes.indexOf(node) !== -1)
                        return [];
                    visitedNodes.push(node);
                    type = node.getLabel().getValue().getValue();
                    if (node instanceof ObjectNode$1 && classTypes.indexOf(type) === -1) {
                        classTypes.push(type);
                    }
                    ingoingEdges = node.getIngoingEdges();
                    for (edgeId in ingoingEdges) {
                        if (ingoingEdges.hasOwnProperty(edgeId)) {
                            edge = ingoingEdges[edgeId];
                            source = edge.getSource();
                            if ((edge instanceof GeneralisationEdge$1 &&
                                source instanceof ObjectNode$1) ||
                                (edge instanceof GeneralisationEdge$1 &&
                                    source instanceof AbstractClassNode$1)) {
                                classTypes = classTypes.concat(getConcreteObjectNodeTypes(source, visitedNodes));
                            }
                        }
                    }
                    return classTypes;
                }
                function getNodeAttributes(node, visitedNodes) {
                    var nodeAttributes, attributeId, attribute;
                    var edgeId, edge, edges;
                    var source, target;
                    var neighbor, options;
                    var attributes = {};
                    var obj = {};
                    if (!visitedNodes)
                        visitedNodes = [];
                    if (visitedNodes.indexOf(node) !== -1)
                        return {};
                    visitedNodes.push(node);
                    edges = node.getOutgoingEdges();
                    for (edgeId in edges) {
                        if (edges.hasOwnProperty(edgeId)) {
                            edge = edges[edgeId];
                            source = edge.getSource();
                            target = edge.getTarget();
                            if ((edge instanceof GeneralisationEdge$1 &&
                                target instanceof AbstractClassNode$1) ||
                                (edge instanceof GeneralisationEdge$1 &&
                                    node instanceof ObjectNode$1 &&
                                    target instanceof ObjectNode$1) ||
                                (edge instanceof GeneralisationEdge$1 &&
                                    node instanceof RelationshipNode$1 &&
                                    target instanceof RelationshipNode$1) ||
                                (edge instanceof GeneralisationEdge$1 &&
                                    node instanceof EnumNode$1 &&
                                    target instanceof EnumNode$1)) {
                                Util.merge(attributes, getNodeAttributes(target, visitedNodes));
                            }
                            else if ((edge instanceof BiDirAssociationEdge$1 &&
                                ((target === node &&
                                    (neighbor = source) instanceof EnumNode$1) ||
                                    (source === node &&
                                        (neighbor = target) instanceof EnumNode$1))) ||
                                (edge instanceof UniDirAssociationEdge$1 &&
                                    (neighbor = target) instanceof EnumNode$1)) {
                                options = {};
                                nodeAttributes = {};
                                Util.merge(nodeAttributes, getNodeAttributes(neighbor, []));
                                for (attributeId in nodeAttributes) {
                                    if (nodeAttributes.hasOwnProperty(attributeId)) {
                                        attribute = nodeAttributes[attributeId];
                                        options[attribute.value] = attribute.value;
                                    }
                                }
                                obj = {};
                                obj[neighbor.getEntityId()] = {
                                    key: edge.getLabel().getValue().getValue(),
                                    value: neighbor.getLabel().getValue().getValue(),
                                    options: options,
                                };
                                Util.merge(attributes, obj);
                            }
                        }
                    }
                    nodeAttributes = node.getAttribute("[attributes]").getAttributes();
                    for (attributeId in nodeAttributes) {
                        if (nodeAttributes.hasOwnProperty(attributeId)) {
                            attribute = nodeAttributes[attributeId];
                            if (node instanceof RelationshipNode$1) {
                                obj = {};
                                obj[attributeId] = {
                                    key: attribute.getKey().getValue(),
                                    value: attribute.getValue().getValue(),
                                    position: attribute.getValue2().getValue(),
                                };
                                Util.merge(attributes, obj);
                            }
                            else if (node instanceof EnumNode$1) {
                                obj = {};
                                obj[attributeId] = {
                                    value: attribute.getValue().getValue(),
                                };
                                Util.merge(attributes, obj);
                            }
                            else {
                                obj = {};
                                obj[attributeId] = {
                                    key: attribute.getKey().getValue(),
                                    value: attribute.getValue().getValue(),
                                };
                                Util.merge(attributes, obj);
                            }
                        }
                    }
                    return attributes;
                }
                var metamodel = {
                    attributes: {},
                    nodes: {},
                    edges: {},
                };
                var nodeId, node;
                var attributes;
                var edge, edgeId, edges;
                var source, target;
                var neighbor;
                var groupSource, groupTarget;
                var groupNeighbor;
                var shape;
                var sourceTypes, targetTypes, concreteTypes;
                var groupSourceTypes, groupTargetTypes, groupConcreteTypes;
                var relations;
                var groupEdge, groupEdgeId, groupEdges;
                for (nodeId in _nodes) {
                    if (_nodes.hasOwnProperty(nodeId)) {
                        node = _nodes[nodeId];
                        if (node instanceof ObjectNode$1) {
                            if (node.getLabel().getValue().getValue() === "Model Attributes") {
                                attributes = getNodeAttributes(node);
                                metamodel.attributes = attributes;
                            }
                            else {
                                attributes = getNodeAttributes(node);
                                edges = node.getEdges();
                                shape = null;
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        source = edge.getSource();
                                        target = edge.getTarget();
                                        if ((edge instanceof BiDirAssociationEdge$1 &&
                                            ((target === node &&
                                                (neighbor = source) instanceof NodeShapeNode$1) ||
                                                (source === node &&
                                                    (neighbor = target) instanceof NodeShapeNode$1))) ||
                                            (edge instanceof UniDirAssociationEdge$1 &&
                                                (neighbor = target) instanceof NodeShapeNode$1)) {
                                            shape = {
                                                shape: neighbor
                                                    .getAttribute(neighbor.getEntityId() + "[shape]")
                                                    .getValue()
                                                    .getValue(),
                                                color: neighbor
                                                    .getAttribute(neighbor.getEntityId() + "[color]")
                                                    .getValue()
                                                    .getValue(),
                                                defaultWidth: parseInt(neighbor
                                                    .getAttribute(neighbor.getEntityId() + "[defaultWidth]")
                                                    .getValue()
                                                    .getValue()),
                                                defaultHeight: parseInt(neighbor
                                                    .getAttribute(neighbor.getEntityId() + "[defaultHeight]")
                                                    .getValue()
                                                    .getValue()),
                                                containment: neighbor
                                                    .getAttribute(neighbor.getEntityId() + "[containment]")
                                                    .getValue()
                                                    .getValue(),
                                                customShape: neighbor
                                                    .getAttribute(neighbor.getEntityId() + "[customShape]")
                                                    .getValue()
                                                    .getValue(),
                                                customAnchors: neighbor
                                                    .getAttribute(neighbor.getEntityId() + "[customAnchors]")
                                                    .getValue()
                                                    .getValue(),
                                            };
                                        }
                                    }
                                }
                                metamodel.nodes[nodeId] = {
                                    label: node.getLabel().getValue().getValue(),
                                    attributes: attributes,
                                    shape: shape || {
                                        shape: "rectangle",
                                        color: "white",
                                        containment: false,
                                        customShape: "",
                                        customAnchors: "",
                                        defaultWidth: 0,
                                        defaultHeight: 0,
                                    },
                                };
                            }
                        }
                        else if (node instanceof RelationshipNode$1) {
                            attributes = getNodeAttributes(node);
                            edges = node.getEdges();
                            sourceTypes = [];
                            targetTypes = [];
                            relations = [];
                            shape = null;
                            for (edgeId in edges) {
                                if (edges.hasOwnProperty(edgeId)) {
                                    edge = edges[edgeId];
                                    source = edge.getSource();
                                    target = edge.getTarget();
                                    if (edge instanceof BiDirAssociationEdge$1 &&
                                        ((target === node &&
                                            (neighbor = source) instanceof ObjectNode$1) ||
                                            (source === node &&
                                                (neighbor = target) instanceof ObjectNode$1))) {
                                        concreteTypes = getConcreteObjectNodeTypes(neighbor);
                                        sourceTypes = sourceTypes.concat(concreteTypes);
                                        targetTypes = targetTypes.concat(concreteTypes);
                                    }
                                    else if (edge instanceof UniDirAssociationEdge$1 &&
                                        source === node &&
                                        target instanceof ObjectNode$1) {
                                        targetTypes = targetTypes.concat(getConcreteObjectNodeTypes(target));
                                    }
                                    else if (edge instanceof UniDirAssociationEdge$1 &&
                                        target === node &&
                                        source instanceof ObjectNode$1) {
                                        sourceTypes = sourceTypes.concat(getConcreteObjectNodeTypes(source));
                                    }
                                    else if (edge instanceof BiDirAssociationEdge$1 &&
                                        ((target === node &&
                                            (neighbor = source) instanceof AbstractClassNode$1) ||
                                            (source === node &&
                                                (neighbor = target) instanceof AbstractClassNode$1))) {
                                        concreteTypes = getConcreteObjectNodeTypes(neighbor);
                                        sourceTypes = sourceTypes.concat(concreteTypes);
                                        targetTypes = targetTypes.concat(concreteTypes);
                                    }
                                    else if (edge instanceof UniDirAssociationEdge$1 &&
                                        source === node &&
                                        target instanceof AbstractClassNode$1) {
                                        targetTypes = targetTypes.concat(getConcreteObjectNodeTypes(target));
                                    }
                                    else if (edge instanceof UniDirAssociationEdge$1 &&
                                        target === node &&
                                        source instanceof AbstractClassNode$1) {
                                        sourceTypes = sourceTypes.concat(getConcreteObjectNodeTypes(source));
                                    }
                                    else if ((edge instanceof BiDirAssociationEdge$1 &&
                                        ((target === node &&
                                            (neighbor = source) instanceof EdgeShapeNode$1) ||
                                            (source === node &&
                                                (neighbor = target) instanceof EdgeShapeNode$1))) ||
                                        (edge instanceof UniDirAssociationEdge$1 &&
                                            source === node &&
                                            (neighbor = target) instanceof EdgeShapeNode$1)) {
                                        shape = {
                                            arrow: neighbor
                                                .getAttribute(neighbor.getEntityId() + "[arrow]")
                                                .getValue()
                                                .getValue(),
                                            shape: neighbor
                                                .getAttribute(neighbor.getEntityId() + "[shape]")
                                                .getValue()
                                                .getValue(),
                                            color: neighbor
                                                .getAttribute(neighbor.getEntityId() + "[color]")
                                                .getValue()
                                                .getValue(),
                                            overlay: neighbor
                                                .getAttribute(neighbor.getEntityId() + "[overlay]")
                                                .getValue()
                                                .getValue(),
                                            overlayPosition: neighbor
                                                .getAttribute(neighbor.getEntityId() + "[overlayPosition]")
                                                .getValue()
                                                .getValue(),
                                            overlayRotate: neighbor
                                                .getAttribute(neighbor.getEntityId() + "[overlayRotate]")
                                                .getValue()
                                                .getValue(),
                                        };
                                    }
                                    else if (edge instanceof GeneralisationEdge$1 &&
                                        target === node &&
                                        (neighbor = source) instanceof RelationshipGroupNode$1) {
                                        groupEdges = neighbor.getEdges();
                                        groupSourceTypes = [];
                                        groupTargetTypes = [];
                                        for (groupEdgeId in groupEdges) {
                                            if (groupEdges.hasOwnProperty(groupEdgeId)) {
                                                groupEdge = groupEdges[groupEdgeId];
                                                groupSource = groupEdge.getSource();
                                                groupTarget = groupEdge.getTarget();
                                                if (groupEdge instanceof BiDirAssociationEdge$1 &&
                                                    ((groupTarget === neighbor &&
                                                        (groupNeighbor = groupSource) instanceof
                                                            ObjectNode$1) ||
                                                        (groupSource === neighbor &&
                                                            (groupNeighbor = groupTarget) instanceof
                                                                ObjectNode$1))) {
                                                    groupConcreteTypes =
                                                        getConcreteObjectNodeTypes(groupNeighbor);
                                                    groupSourceTypes =
                                                        groupSourceTypes.concat(groupConcreteTypes);
                                                    groupTargetTypes =
                                                        groupTargetTypes.concat(groupConcreteTypes);
                                                }
                                                else if (groupEdge instanceof UniDirAssociationEdge$1 &&
                                                    groupSource === neighbor &&
                                                    groupTarget instanceof ObjectNode$1) {
                                                    groupTargetTypes = groupTargetTypes.concat(getConcreteObjectNodeTypes(groupTarget));
                                                }
                                                else if (groupEdge instanceof UniDirAssociationEdge$1 &&
                                                    groupTarget === neighbor &&
                                                    groupSource instanceof ObjectNode$1) {
                                                    groupSourceTypes = groupSourceTypes.concat(getConcreteObjectNodeTypes(groupSource));
                                                }
                                                else if (groupEdge instanceof BiDirAssociationEdge$1 &&
                                                    ((groupTarget === neighbor &&
                                                        (groupNeighbor = groupSource) instanceof
                                                            AbstractClassNode$1) ||
                                                        (groupSource === neighbor &&
                                                            (groupNeighbor = groupTarget) instanceof
                                                                AbstractClassNode$1))) {
                                                    groupConcreteTypes =
                                                        getConcreteObjectNodeTypes(groupNeighbor);
                                                    groupSourceTypes =
                                                        groupSourceTypes.concat(groupConcreteTypes);
                                                    groupTargetTypes =
                                                        groupTargetTypes.concat(groupConcreteTypes);
                                                }
                                                else if (groupEdge instanceof UniDirAssociationEdge$1 &&
                                                    groupSource === neighbor &&
                                                    groupTarget instanceof AbstractClassNode$1) {
                                                    groupTargetTypes = groupTargetTypes.concat(getConcreteObjectNodeTypes(groupTarget));
                                                }
                                                else if (groupEdge instanceof UniDirAssociationEdge$1 &&
                                                    groupTarget === neighbor &&
                                                    groupSource instanceof AbstractClassNode$1) {
                                                    groupSourceTypes = groupSourceTypes.concat(getConcreteObjectNodeTypes(groupSource));
                                                }
                                            }
                                        }
                                        if (groupSourceTypes.length > 0 &&
                                            groupTargetTypes.length > 0) {
                                            relations.push({
                                                sourceTypes: groupSourceTypes,
                                                targetTypes: groupTargetTypes,
                                            });
                                        }
                                    }
                                }
                            }
                            if (sourceTypes.length > 0 && targetTypes.length > 0) {
                                relations.push({
                                    sourceTypes: sourceTypes,
                                    targetTypes: targetTypes,
                                });
                            }
                            metamodel.edges[nodeId] = {
                                label: node.getLabel().getValue().getValue(),
                                shape: shape || {
                                    arrow: "bidirassociation",
                                    shape: "straight",
                                    color: "black",
                                    overlay: "",
                                    overlayPosition: "top",
                                    overlayRotate: true,
                                },
                                relations: relations,
                                attributes: attributes,
                            };
                        }
                    }
                }
                return metamodel;
            },
            storeData: function () {
                var resourceSpace = new openapp$1.oo.Resource(openapp$1.param.space());
                var data = this.graphToJSON();
                var resourcesToSave = [];
                var promises = [];
                if (guidancemodel.isGuidanceEditor()) {
                    resourcesToSave.push({
                        typeName: CONFIG$1.NS.MY.GUIDANCEMODEL,
                        representation: data,
                    });
                }
                else if (!metamodel.hasOwnProperty("nodes")) {
                    resourcesToSave.push({
                        typeName: CONFIG$1.NS.MY.METAMODELPREVIEW,
                        representation: this.generateMetaModel(),
                    });
                    resourcesToSave.push({
                        typeName: CONFIG$1.NS.MY.GUIDANCEMETAMODEL,
                        representation: this.generateGuidanceMetamodel(),
                    });
                    resourcesToSave.push({
                        typeName: CONFIG$1.NS.MY.MODEL,
                        representation: data,
                    });
                }
                else {
                    resourcesToSave.push({
                        typeName: CONFIG$1.NS.MY.MODEL,
                        representation: data,
                    });
                }
                var recreateResource = function (type, representation) {
                    var deferred = $.Deferred();
                    var innerDeferred = $.Deferred();
                    resourceSpace.getSubResources({
                        relation: openapp$1.ns.role + "data",
                        type: type,
                        onEach: function (doc) {
                            doc.del();
                        },
                        onAll: function () {
                            innerDeferred.resolve();
                        },
                    });
                    innerDeferred.then(function () {
                        resourceSpace.create({
                            relation: openapp$1.ns.role + "data",
                            type: type,
                            representation: representation,
                            callback: function () {
                                deferred.resolve();
                            },
                        });
                    });
                    return deferred.promise();
                };
                for (var i = 0; i < resourcesToSave.length; i++) {
                    var item = resourcesToSave[i];
                    promises.push(recreateResource(item.typeName, item.representation));
                }
                return $.when.apply($, promises);
            },
            storeDataYjs: function () {
                var data = this.graphToJSON();
                const dataMap = y.getMap("data");
                if (guidancemodel.isGuidanceEditor()) {
                    dataMap.set("guidancemodel", data);
                }
                else if (!metamodel) {
                    dataMap.set("metamodelpreview", this.generateMetaModel());
                    dataMap.set("guidancemetamodel", this.generateGuidanceMetamodel());
                    dataMap.set("model", data);
                }
                else {
                    dataMap.set("model", data);
                }
            },
            deleteModelAttribute: function () {
                _modelAttributesNode = null;
            },
            reset: function () {
                _nodes = {};
                _edges = {};
                this.deleteModelAttribute();
            },
            initNodeTypes: function (vls) {
                nodeTypes = _initNodeTypes(vls);
            },
            initEdgeTypes: function (vls) {
                var res = _initEdgeTypes(vls);
                edgeTypes = res.edgeTypes;
                relations = res.relations;
            },
            initModelTypes: function (vls) {
                this.initNodeTypes(vls);
                this.initEdgeTypes(vls);
            },
            getNodeType: function (type) {
                return nodeTypes.hasOwnProperty(type) ? nodeTypes[type] : null;
            },
            getEdgeType: function (type) {
                return edgeTypes.hasOwnProperty(type) ? edgeTypes[type] : null;
            },
            initViewNodeTypes: function (vvs) {
                for (var nodeTypeName in nodeTypes) {
                    if (nodeTypes.hasOwnProperty(nodeTypeName)) {
                        delete nodeTypes[nodeTypeName].VIEWTYPE;
                    }
                }
                viewNodeTypes = _initNodeTypes(vvs);
            },
            initViewEdgeTypes: function (vvs) {
                for (var edgeTypeName in edgeTypes) {
                    if (edgeTypes.hasOwnProperty(edgeTypeName)) {
                        delete edgeTypes[edgeTypeName].VIEWTYPE;
                    }
                }
                var res = _initEdgeTypes(vvs);
                viewEdgeTypes = res.edgeTypes;
                relations = res.relations;
            },
            initViewTypes: function (vvs) {
                this.setViewId(vvs.id);
                this.initViewNodeTypes(vvs);
                this.initViewEdgeTypes(vvs);
            },
            getViewNodeType: function (type) {
                return viewNodeTypes.hasOwnProperty(type) ? viewNodeTypes[type] : null;
            },
            getViewEdgeType: function (type) {
                return viewEdgeTypes.hasOwnProperty(type) ? viewEdgeTypes[type] : null;
            },
            setViewId: function (viewId) {
                _viewId = viewId;
            },
            getViewId: function () {
                return _viewId;
            },
            getNodesByViewType: function (type) {
                if (viewNodeTypes.hasOwnProperty(type)) {
                    return this.getNodesByType(viewNodeTypes[type].getTargetNodeType().TYPE);
                }
                return null;
            },
            getEdgesByViewType: function (type) {
                if (viewEdgeTypes.hasOwnProperty(type)) {
                    return this.getEdgesByType(viewEdgeTypes[type].getTargetEdgeType().TYPE);
                }
                return null;
            },
            getLayer: function () {
                return _layer;
            },
            getRelations: function () {
                return relations;
            },
            setGuidance: function (guidance) {
                guidancemodel = guidance;
            },
            init: function (mm) {
                metamodel = mm;
                if (metamodel && metamodel.hasOwnProperty("nodes")) {
                    nodeTypes = _initNodeTypes(metamodel);
                    _layer = CONFIG$1.LAYER.MODEL;
                }
                else {
                    _layer = CONFIG$1.LAYER.META;
                    nodeTypes[ObjectNode$1.TYPE] = ObjectNode$1;
                    nodeTypes[AbstractClassNode$1.TYPE] = AbstractClassNode$1;
                    nodeTypes[RelationshipNode$1.TYPE] = RelationshipNode$1;
                    nodeTypes[RelationshipGroupNode$1.TYPE] = RelationshipGroupNode$1;
                    nodeTypes[EnumNode$1.TYPE] = EnumNode$1;
                    nodeTypes[NodeShapeNode$1.TYPE] = NodeShapeNode$1;
                    nodeTypes[EdgeShapeNode$1.TYPE] = EdgeShapeNode$1;
                    nodeTypes[ViewObjectNode$1.TYPE] = ViewObjectNode$1;
                    nodeTypes[ViewRelationshipNode$2.TYPE] = ViewRelationshipNode$2;
                }
                if (metamodel && metamodel.hasOwnProperty("edges")) {
                    var res = _initEdgeTypes(metamodel);
                    edgeTypes = res.edgeTypes;
                    relations = res.relations;
                }
                else {
                    edgeTypes[GeneralisationEdge$1.TYPE] = GeneralisationEdge$1;
                    edgeTypes[BiDirAssociationEdge$1.TYPE] = BiDirAssociationEdge$1;
                    edgeTypes[UniDirAssociationEdge$1.TYPE] = UniDirAssociationEdge$1;
                    relations[BiDirAssociationEdge$1.TYPE] = BiDirAssociationEdge$1.RELATIONS;
                    relations[UniDirAssociationEdge$1.TYPE] =
                        UniDirAssociationEdge$1.RELATIONS;
                    relations[GeneralisationEdge$1.TYPE] = GeneralisationEdge$1.RELATIONS;
                }
            },
        };
    }
    setSharedDocument(y) {
        this.y = y;
    }
};
const EntityManagerInstance$1 = new EntityManager$2();
function makeNode$1(type, $shape, anchors, attributes) {
    class Node extends AbstractNode$1 {
        constructor(id, left, top, width, height, zIndex, containment) {
            super(id, type, left, top, width, height, zIndex, containment);
            var that = this;
            var currentViewType = null;
            this.setCurrentViewType = function (type) {
                currentViewType = type;
            };
            this.getCurrentViewType = function () {
                return currentViewType;
            };
            var _$template = $shape.clone();
            var _$node = AbstractNode$1.prototype.get$node
                .call(this)
                .append(_$template);
            var _anchorOptions = anchors;
            this.nodeSelector = getQuerySelectorFromNode(_$node);
            var init = function () {
                var attribute, attributeId, attrObj;
                attrObj = {};
                for (attributeId in attributes) {
                    if (attributes.hasOwnProperty(attributeId)) {
                        attribute = attributes[attributeId];
                        var key = attribute.key.toLowerCase();
                        switch (attribute.value) {
                            case "boolean":
                                attrObj[attributeId] = new BooleanAttribute$1(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            case "string":
                                attrObj[attributeId] = new SingleValueAttribute$1(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                if (attribute.key.toLowerCase() === "label" ||
                                    attribute.key.toLowerCase() === "title" ||
                                    attribute.key.toLowerCase() === "name") {
                                    that.setLabel(attrObj[attributeId]);
                                }
                                break;
                            case "integer":
                                attrObj[attributeId] = new IntegerAttribute$1(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            case "file":
                                attrObj[attributeId] = new FileAttribute$1(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            case "quiz":
                                attrObj[attributeId] = new QuizAttribute$1(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                if (attribute.key.toLowerCase() === "label" ||
                                    attribute.key.toLowerCase() === "title" ||
                                    attribute.key.toLowerCase() === "name") {
                                    that.setLabel(attrObj[attributeId]);
                                }
                            default:
                                if (attribute.options) {
                                    attrObj[attributeId] = new SingleSelectionAttribute$1(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that, attribute.options);
                                }
                        }
                        _$node.find("." + key).append(attrObj[attributeId].get$node());
                    }
                }
                that.setAttributes(attrObj);
            };
            this.getAnchorOptions = function () {
                return _anchorOptions;
            };
            this.setAnchorOptions = function (anchors) {
                _anchorOptions = anchors;
            };
            this.makeSource = () => {
                _$node.addClass("source");
                window.jsPlumbInstance.addEndpoint(_$node.get(0), {
                    connectorPaintStyle: { fill: "black", strokeWidth: 4 },
                    source: true,
                    endpoint: {
                        type: "Rectangle",
                        options: {
                            width: _$node.width() + 50,
                            height: _$node.height() + 50,
                        },
                    },
                    paintStyle: { fill: "transparent" },
                    anchor: AnchorLocations.Center,
                    deleteOnEmpty: true,
                    uuid: id + "_eps1",
                    uniqueEndpoint: false,
                    deleteEndpointsOnDetach: true,
                    onMaxConnections: function (info) {
                        console.log("element is ", info.element, "maxConnections is", info.maxConnections);
                    },
                });
            };
            this.makeTarget = () => {
                _$node.addClass("target");
                window.jsPlumbInstance.addEndpoint(_$node.get(0), {
                    target: true,
                    endpoint: {
                        type: "Rectangle",
                        options: {
                            width: _$node.width() + 50,
                            height: _$node.height() + 50,
                        },
                    },
                    uuid: id + "_ept1",
                    paintStyle: { fill: "transparent" },
                    anchor: AnchorLocations.Center,
                    uniqueEndpoint: false,
                    deleteOnEmpty: true,
                    onMaxConnections: function (info) {
                        console.log("user tried to drop connection", info.connection, "on element", info.element, "with max connections", info.maxConnections);
                    },
                });
                window.jsPlumbInstance.bind("beforeDrop", function (info) {
                    var allConn = window.jsPlumbInstance.getConnections({
                        target: info.targetId,
                        source: info.sourceId,
                    });
                    var length = allConn.length;
                    if (length > 0)
                        return false;
                    else
                        return true;
                });
            };
            this.unbindEdgeToolEvents = function () {
                try {
                    _$node.removeClass("source target");
                    jsPlumbInstance.getEndpoints(_$node.get(0)).forEach((endpoint) => {
                        if (endpoint.connections.length === 0) {
                            jsPlumbInstance.deleteEndpoint(endpoint);
                        }
                    });
                }
                catch (error) {
                    console.error(error);
                }
            };
            this.toJSON = function () {
                var json = AbstractNode$1.prototype.toJSON.call(this);
                json.type = type;
                return json;
            };
            this.set$shape = function ($shape) {
                _$template.remove();
                var _$shape = $shape.clone();
                var attributes = that.getAttributes();
                for (var attrKey in attributes) {
                    if (attributes.hasOwnProperty(attrKey)) {
                        var attribute = attributes[attrKey];
                        var $tmp = _$shape.find("." + attribute.getName().toLowerCase());
                        if ($tmp.length > 0) {
                            if (attribute.getValue().hasOwnProperty("init"))
                                attribute.getValue().init();
                            $tmp.append(attribute.get$node());
                            break;
                        }
                    }
                }
                _$template = _$shape;
                _$node.append(_$shape);
            };
            this.get$node = function () {
                return _$node;
            };
            init();
            this.registerYMap = function () {
                AbstractNode$1.prototype.registerYMap.call(this);
                var labelAttr = that.getLabel();
                if (labelAttr)
                    labelAttr.registerYType();
                var attr = that.getAttributes();
                for (var key in attr) {
                    if (attr.hasOwnProperty(key)) {
                        var val = attr[key].getValue();
                        if (val.hasOwnProperty("registerYType")) {
                            val.registerYType();
                        }
                    }
                }
            };
        }
        static get$shape() {
            return $shape;
        }
        static getAnchors() {
            return anchors;
        }
        static getAttributes() {
            return attributes;
        }
    }
    return Node;
}
let ObjectNode$1 = class ObjectNode extends AbstractNode$1 {
    constructor(id, left, top, width, height, zIndex, json, y) {
        super(id, ObjectNode$1.TYPE, left, top, width, height, zIndex, json, y);
        var that = this;
        var _$template = $(lodash.template(objectNodeHtml$1)({ type: that.getType() }));
        var _$node = AbstractNode$1.prototype.get$node
            .call(this)
            .append(_$template)
            .addClass("object");
        var _$attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        this.toJSON = function () {
            return AbstractNode$1.prototype.toJSON.call(this);
        };
        var attr = new KeySelectionValueListAttribute$1("[attributes]", "Attributes", this, {
            string: "String",
            boolean: "Boolean",
            integer: "Integer",
            file: "File",
            quiz: "Questions",
        });
        this.addAttribute(attr);
        this.registerYMap = function () {
            AbstractNode$1.prototype.registerYMap.call(this);
            that.getLabel().getValue().registerYType();
            attr.registerYMap();
        };
        _$node.find(".label").append(this.getLabel().get$node());
        for (var attributeKey in _attributes) {
            if (_attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(_attributes[attributeKey].get$node());
            }
        }
        this.unregisterCallbacks = function () {
            that.getAttribute("[attributes]").unregisterCallbacks();
        };
        this.setContextMenuItemCallback(function () {
            return {
                addShape: {
                    name: "Add Node Shape",
                    callback: function () {
                        var canvas = that.getCanvas(), appearance = that.getAppearance();
                        const id = canvas.createNode(NodeShapeNode$1.TYPE, appearance.left + appearance.width + 50, appearance.top, 150, 100);
                        canvas.createEdge(BiDirAssociationEdge$1.TYPE, that.getEntityId(), id);
                    },
                    disabled: function () {
                        var edges = that.getEdges(), edge, edgeId;
                        for (edgeId in edges) {
                            if (edges.hasOwnProperty(edgeId)) {
                                edge = edges[edgeId];
                                if ((edge instanceof BiDirAssociationEdge$1 &&
                                    ((edge.getTarget() === that &&
                                        edge.getSource() instanceof NodeShapeNode$1) ||
                                        (edge.getSource() === that &&
                                            edge.getTarget() instanceof NodeShapeNode$1))) ||
                                    (edge instanceof UniDirAssociationEdge$1 &&
                                        edge.getTarget() instanceof NodeShapeNode$1)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    },
                },
                sepConvertTo: "---------",
                convertTo: {
                    name: "Convert to..",
                    items: {
                        abstractClassNode: {
                            name: "..Abstract Class",
                            callback: function () {
                                var canvas = that.getCanvas(), appearance = that.getAppearance(), nodeId;
                                nodeId = canvas.createNode(AbstractClassNode$1.TYPE, appearance.left, appearance.top, appearance.width, appearance.height, that.getZIndex(), that.toJSON());
                                var edges = that.getOutgoingEdges(), edge, edgeId;
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        canvas.createEdge(edge.getType(), nodeId, edge.getTarget().getEntityId(), edge.toJSON());
                                    }
                                }
                                edges = that.getIngoingEdges();
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        if (edge.getSource() !== edge.getTarget()) {
                                            canvas.createEdge(edge.getType(), edge.getSource().getEntityId(), nodeId, edge.toJSON());
                                        }
                                    }
                                }
                                that.triggerDeletion();
                            },
                        },
                        relationshipNode: {
                            name: "..Relationship",
                            callback: function () {
                                var canvas = that.getCanvas(), appearance = that.getAppearance(), nodeId;
                                nodeId = canvas.createNode(RelationshipNode$1.TYPE, appearance.left, appearance.top, appearance.width, appearance.height, that.getZIndex(), that.toJSON());
                                var edges = that.getOutgoingEdges(), edge, edgeId;
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        canvas.createEdge(edge.getType(), nodeId, edge.getTarget().getEntityId(), edge.toJSON());
                                    }
                                }
                                edges = that.getIngoingEdges();
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        if (edge.getSource() !== edge.getTarget()) {
                                            canvas.createEdge(edge.getType(), edge.getSource().getEntityId(), nodeId, edge.toJSON());
                                        }
                                    }
                                }
                                that.triggerDeletion();
                            },
                        },
                        relationshipGroupNode: {
                            name: "..Relationship Group",
                            callback: function () {
                                var canvas = that.getCanvas(), appearance = that.getAppearance(), nodeId;
                                nodeId = canvas.createNode(RelationshipGroupNode$1.TYPE, appearance.left, appearance.top, appearance.width, appearance.height, that.getZIndex(), that.toJSON());
                                var edges = that.getOutgoingEdges(), edge, edgeId;
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        canvas.createEdge(edge.getType(), nodeId, edge.getTarget().getEntityId(), edge.toJSON());
                                    }
                                }
                                edges = that.getIngoingEdges();
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        if (edge.getSource() !== edge.getTarget()) {
                                            canvas.createEdge(edge.getType(), edge.getSource().getEntityId(), nodeId, edge.toJSON());
                                        }
                                    }
                                }
                                that.triggerDeletion();
                            },
                        },
                    },
                },
                sep: "---------",
            };
        });
    }
    static { this.TYPE = "Object"; }
    static { this.DEFAULT_WIDTH = 150; }
    static { this.DEFAULT_HEIGHT = 100; }
};
let AbstractClassNode$1 = class AbstractClassNode extends AbstractNode$1 {
    constructor(id, left, top, width, height, zIndex, json) {
        super(id, AbstractClassNode$1.TYPE, left, top, width, height, zIndex, json);
        var that = this;
        var _$template = $(lodash.template(abstractClassNodeHtml$1)({ type: that.getType() }));
        var _$node = AbstractNode$1.prototype.get$node
            .call(this)
            .append(_$template)
            .addClass("class");
        var _$attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        this.toJSON = function () {
            var json = AbstractNode$1.prototype.toJSON.call(this);
            json.type = AbstractClassNode$1.TYPE;
            return json;
        };
        var attr = new KeySelectionValueListAttribute$1("[attributes]", "Attributes", this, {
            string: "String",
            boolean: "Boolean",
            integer: "Integer",
            file: "File",
            quiz: "Questions",
        });
        this.addAttribute(attr);
        this.registerYMap = function () {
            AbstractNode$1.prototype.registerYMap.call(this);
            that.getLabel().getValue().registerYType();
            attr.registerYMap();
        };
        this.unregisterCallbacks = function () {
            that.getAttribute("[attributes]").unregisterCallbacks();
        };
        _$node.find(".label").append(this.getLabel().get$node());
        for (var attributeKey in _attributes) {
            if (_attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(_attributes[attributeKey].get$node());
            }
        }
        this.setContextMenuItemCallback(function () {
            return {
                convertTo: {
                    name: "Convert to..",
                    items: {
                        objectNode: {
                            name: "..Object",
                            callback: function () {
                                var canvas = that.getCanvas(), appearance = that.getAppearance(), nodeId;
                                nodeId = canvas.createNode(ObjectNode$1.TYPE, appearance.left, appearance.top, appearance.width, appearance.height, that.getZIndex(), that.getContainment(), that.toJSON());
                                var edges = that.getOutgoingEdges(), edge, edgeId;
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        canvas.createEdge(edge.getType(), nodeId, edge.getTarget().getEntityId(), edge.toJSON());
                                    }
                                }
                                edges = that.getIngoingEdges();
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        if (edge.getSource() !== edge.getTarget()) {
                                            canvas.createEdge(edge.getType(), edge.getSource().getEntityId(), nodeId, edge.toJSON());
                                        }
                                    }
                                }
                                that.triggerDeletion();
                            },
                        },
                        relationshipNode: {
                            name: "..Relationship",
                            callback: function () {
                                var canvas = that.getCanvas(), appearance = that.getAppearance(), nodeId;
                                nodeId = canvas.createNode(RelationshipNode$1.TYPE, appearance.left, appearance.top, appearance.width, appearance.height, that.getZIndex(), that.getContainment(), that.toJSON());
                                var edges = that.getOutgoingEdges(), edge, edgeId;
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        canvas.createEdge(edge.getType(), nodeId, edge.getTarget().getEntityId(), edge.toJSON());
                                    }
                                }
                                edges = that.getIngoingEdges();
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        if (edge.getSource() !== edge.getTarget()) {
                                            canvas.createEdge(edge.getType(), edge.getSource().getEntityId(), nodeId, edge.toJSON());
                                        }
                                    }
                                }
                                that.triggerDeletion();
                            },
                        },
                        relationshipGroupNode: {
                            name: "..Relationship Group",
                            callback: function () {
                                var canvas = that.getCanvas(), appearance = that.getAppearance(), nodeId;
                                nodeId = canvas.createNode(RelationshipGroupNode$1.TYPE, appearance.left, appearance.top, appearance.width, appearance.height, that.getZIndex(), that.getContainment(), that.toJSON());
                                var edges = that.getOutgoingEdges(), edge, edgeId;
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        canvas.createEdge(edge.getType(), nodeId, edge.getTarget().getEntityId(), edge.toJSON());
                                    }
                                }
                                edges = that.getIngoingEdges();
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        if (edge.getSource() !== edge.getTarget()) {
                                            canvas.createEdge(edge.getType(), edge.getSource().getEntityId(), nodeId, edge.toJSON());
                                        }
                                    }
                                }
                                that.triggerDeletion();
                            },
                        },
                    },
                },
                sep: "---------",
            };
        });
    }
    static { this.TYPE = "Abstract Class"; }
    static { this.DEFAULT_WIDTH = 150; }
    static { this.DEFAULT_HEIGHT = 100; }
};
let RelationshipNode$1 = class RelationshipNode extends AbstractNode$1 {
    constructor(id, left, top, width, height, zIndex, json) {
        super(id, "Relationship", left, top, width, height, zIndex, json);
        var that = this;
        var _$template = $(lodash.template(relationshipNodeHtml$1)({ type: that.getType() }));
        var $node = AbstractNode$1.prototype.get$node
            .call(this)
            .append(_$template)
            .addClass("relation");
        var _$attributeNode = $node.find(".attributes");
        var _attributes = this.getAttributes();
        this.toJSON = function () {
            return AbstractNode$1.prototype.toJSON.call(this);
        };
        var attr = new KeySelectionValueSelectionValueListAttribute$1("[attributes]", "Attributes", this, {
            string: "String",
            boolean: "Boolean",
            integer: "Integer",
            file: "File",
        }, { hidden: "Hide", top: "Top", center: "Center", bottom: "Bottom" });
        this.addAttribute(attr);
        this.registerYMap = function () {
            AbstractNode$1.prototype.registerYMap.call(this);
            that.getLabel().getValue().registerYType();
            attr.registerYMap();
        };
        this.unregisterCallbacks = function () {
            that.getAttribute("[attributes]").unregisterCallbacks();
        };
        $node.find(".label").append(this.getLabel().get$node());
        for (var attributeKey in _attributes) {
            if (_attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(_attributes[attributeKey].get$node());
            }
        }
        this.setContextMenuItemCallback(function () {
            return {
                addShape: {
                    name: "Add Edge Shape",
                    callback: function () {
                        var canvas = that.getCanvas(), appearance = that.getAppearance();
                        canvas
                            .createNode(EdgeShapeNode$1.TYPE, appearance.left + appearance.width + 50, appearance.top, 150, 100)
                            .done(function (nodeId) {
                            canvas.createEdge(BiDirAssociationEdge$1.TYPE, that.getEntityId(), nodeId);
                        });
                    },
                    disabled: function () {
                        var edges = that.getEdges(), edge, edgeId;
                        for (edgeId in edges) {
                            if (edges.hasOwnProperty(edgeId)) {
                                edge = edges[edgeId];
                                if ((edge instanceof BiDirAssociationEdge$1 &&
                                    ((edge.getTarget() === that &&
                                        edge.getSource() instanceof EdgeShapeNode$1) ||
                                        (edge.getSource() === that &&
                                            edge.getTarget() instanceof EdgeShapeNode$1))) ||
                                    (edge instanceof UniDirAssociationEdge$1 &&
                                        edge.getTarget() instanceof EdgeShapeNode$1)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    },
                },
                sepConvertTo: "---------",
                convertTo: {
                    name: "Convert to..",
                    items: {
                        abstractNode: {
                            name: "..Abstract Class Node",
                            callback: function () {
                                var canvas = that.getCanvas(), appearance = that.getAppearance(), nodeId;
                                nodeId = canvas.createNode(AbstractClassNode$1.TYPE, appearance.left, appearance.top, appearance.width, appearance.height, that.getZIndex(), that.toJSON());
                                var edges = that.getOutgoingEdges(), edge, edgeId;
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        canvas.createEdge(edge.getType(), nodeId, edge.getTarget().getEntityId(), edge.toJSON());
                                    }
                                }
                                edges = that.getIngoingEdges();
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        if (edge.getSource() !== edge.getTarget()) {
                                            canvas.createEdge(edge.getType(), edge.getSource().getEntityId(), nodeId, edge.toJSON());
                                        }
                                    }
                                }
                                that.triggerDeletion();
                            },
                        },
                        objectNode: {
                            name: "..Object Node",
                            callback: function () {
                                var canvas = that.getCanvas(), appearance = that.getAppearance(), nodeId;
                                nodeId = canvas.createNode(ObjectNode$1.TYPE, appearance.left, appearance.top, appearance.width, appearance.height, that.getZIndex(), that.toJSON());
                                var edges = that.getOutgoingEdges(), edge, edgeId;
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        canvas.createEdge(edge.getType(), nodeId, edge.getTarget().getEntityId(), edge.toJSON());
                                    }
                                }
                                edges = that.getIngoingEdges();
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        if (edge.getSource() !== edge.getTarget()) {
                                            canvas.createEdge(edge.getType(), edge.getSource().getEntityId(), nodeId, edge.toJSON());
                                        }
                                    }
                                }
                                that.triggerDeletion();
                            },
                        },
                        relationshipGroupNode: {
                            name: "..Relationship Group",
                            callback: function () {
                                var canvas = that.getCanvas(), appearance = that.getAppearance(), nodeId;
                                nodeId = canvas.createNode(RelationshipGroupNode$1.TYPE, appearance.left, appearance.top, appearance.width, appearance.height, that.getZIndex(), that.toJSON());
                                var edges = that.getOutgoingEdges(), edge, edgeId;
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        canvas.createEdge(edge.getType(), nodeId, edge.getTarget().getEntityId(), edge.toJSON());
                                    }
                                }
                                edges = that.getIngoingEdges();
                                for (edgeId in edges) {
                                    if (edges.hasOwnProperty(edgeId)) {
                                        edge = edges[edgeId];
                                        if (edge.getSource() !== edge.getTarget()) {
                                            canvas.createEdge(edge.getType(), edge.getSource().getEntityId(), nodeId, edge.toJSON());
                                        }
                                    }
                                }
                                that.triggerDeletion();
                            },
                        },
                    },
                },
                sep: "---------",
            };
        });
    }
    static { this.TYPE = "Relationship"; }
    static { this.DEFAULT_WIDTH = 150; }
    static { this.DEFAULT_HEIGHT = 100; }
};
let EdgeShapeNode$1 = class EdgeShapeNode extends AbstractNode$1 {
    constructor(id, left, top, width, height, zIndex, json) {
        super(id, EdgeShapeNode$1.TYPE, left, top, width, height, zIndex, json);
        var that = this;
        var _$template = $(lodash.template(edgeShapeNodeHtml$1)({ type: that.getType() }));
        var _$node = AbstractNode$1.prototype.get$node
            .call(this)
            .append(_$template)
            .addClass("class");
        var _$attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        this.toJSON = function () {
            var json = AbstractNode$1.prototype.toJSON.call(this);
            json.type = EdgeShapeNode$1.TYPE;
            return json;
        };
        var attrArrow = new SingleSelectionAttribute$1(this.getEntityId() + "[arrow]", "Arrow", this, {
            bidirassociation: "---",
            unidirassociation: "-->",
            generalisation: "--▷",
            diamond: "-◁▷",
        });
        var attrShape = new SingleSelectionAttribute$1(this.getEntityId() + "[shape]", "Shape", this, { straight: "Straight", curved: "Curved", segmented: "Segmented" });
        var attrColor = new SingleColorValueAttribute$1(this.getEntityId() + "[color]", "Color", this);
        var attrOverlay = new SingleValueAttribute$1(this.getEntityId() + "[overlay]", "Overlay Text", this);
        var attrOverlayPos = new SingleSelectionAttribute$1(this.getEntityId() + "[overlayPosition]", "Overlay Position", this, { hidden: "Hide", top: "Top", center: "Center", bottom: "Bottom" });
        var attrOverlayRotate = new BooleanAttribute$1(this.getEntityId() + "[overlayRotate]", "Autoflip Overlay", this);
        this.addAttribute(attrArrow);
        this.addAttribute(attrShape);
        this.addAttribute(attrColor);
        this.addAttribute(attrOverlay);
        this.addAttribute(attrOverlayPos);
        this.addAttribute(attrOverlayRotate);
        this.registerYMap = function (map, disableYText) {
            AbstractNode$1.prototype.registerYMap.call(this, map);
            attrArrow.getValue().registerYType();
            attrShape.getValue().registerYType();
            attrOverlayPos.getValue().registerYType();
            attrOverlayRotate.getValue().registerYType();
            that.getLabel().getValue().registerYType();
            attrColor.getValue().registerYType();
            attrOverlay.getValue().registerYType();
        };
        _$node.find(".label").append(this.getLabel().get$node());
        for (var attributeKey in _attributes) {
            if (_attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(_attributes[attributeKey].get$node());
            }
        }
    }
    static { this.TYPE = "Edge Shape"; }
    static { this.DEFAULT_WIDTH = 150; }
    static { this.DEFAULT_HEIGHT = 150; }
};
function makeEdge$1(type, arrowType, shapeType, color, dashstyle, overlay, overlayPosition, overlayRotate, attributes) {
    var shape = shapes.hasOwnProperty(shapeType)
        ? shapes[shapeType]
        : lodash.values(shapes)[0];
    color = color
        ? $colorTestElement.css("color", "#000000").css("color", color).css("color")
        : "#000000";
    class Edge extends AbstractEdge$1 {
        constructor(id, source, target) {
            super(id, type, source, target, overlayRotate);
            var that = this;
            var currentViewType = null;
            this.setCurrentViewType = function (type) {
                currentViewType = type;
            };
            this.getCurrentViewType = function () {
                return currentViewType;
            };
            var overlays = [];
            var makeOverlayFunction = function (text) {
                return function () {
                    return $("<div></div>").append($("<div></div>")
                        .addClass("edge_label fixed")
                        .css("color", color)
                        .text(text));
                };
            };
            var makeAttributeOverlayFunction = function (attribute) {
                return function () {
                    const $node = $("<div></div>").append($("<div></div>").addClass("edge_label").append(attribute.get$node()));
                    return $node.get(0);
                };
            };
            var init = function () {
                var attribute, attributeId, attrObj;
                if (Arrows().hasOwnProperty(arrowType)) {
                    overlays.push(Arrows(color)[arrowType]);
                }
                if (overlay) {
                    switch (overlayPosition) {
                        case "top":
                            overlays.push({
                                type: "Custom",
                                options: {
                                    create: makeOverlayFunction(overlay),
                                    location: 0.9,
                                    id: "label",
                                },
                            });
                            break;
                        case "bottom":
                            overlays.push({
                                type: "Custom",
                                options: {
                                    create: makeOverlayFunction(overlay),
                                    location: 0.1,
                                    id: "label",
                                },
                            });
                            break;
                        default:
                        case "center":
                            overlays.push({
                                type: "Custom",
                                options: {
                                    create: makeOverlayFunction(overlay),
                                    location: 0.5,
                                    id: "label",
                                },
                            });
                            break;
                    }
                }
                attrObj = {};
                for (attributeId in attributes) {
                    if (attributes.hasOwnProperty(attributeId)) {
                        attribute = attributes[attributeId];
                        switch (attribute.value) {
                            case "boolean":
                                attrObj[attributeId] = new BooleanAttribute$1(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            case "string":
                                attrObj[attributeId] = new SingleValueAttribute$1(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            case "integer":
                                attrObj[attributeId] = new IntegerAttribute$1(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            case "file":
                                attrObj[attributeId] = new FileAttribute$1(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            default:
                                if (attribute.options) {
                                    attrObj[attributeId] = new SingleSelectionAttribute$1(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that, attribute.options);
                                }
                        }
                        switch (attribute.position) {
                            case "top":
                                overlays.push({
                                    type: "Custom",
                                    options: {
                                        create: makeAttributeOverlayFunction(attrObj[attributeId]),
                                        location: 1,
                                        id: "label " + attributeId,
                                    },
                                });
                                break;
                            case "center":
                                overlays.push({
                                    type: "Custom",
                                    options: {
                                        create: makeAttributeOverlayFunction(attrObj[attributeId]),
                                        location: 0.5,
                                        id: "label " + attributeId,
                                    },
                                });
                                break;
                            case "bottom":
                                overlays.push({
                                    type: "Custom",
                                    options: {
                                        create: makeAttributeOverlayFunction(attrObj[attributeId]),
                                        location: 0,
                                        id: "label " + attributeId,
                                    },
                                });
                                break;
                        }
                    }
                }
                that.setAttributes(attrObj);
                overlays.push({
                    type: "Custom",
                    options: {
                        create: function () {
                            that.get$overlay().hide().find(".type").addClass(shapeType);
                            return that.get$overlay().get(0);
                        },
                        location: 0.5,
                        id: "label",
                    },
                });
                if (overlay) {
                    that
                        .get$overlay()
                        .find("input[name='Label']")
                        .css("visibility", "hidden");
                }
                that.setDefaultPaintStyle({
                    stroke: color,
                    strokeWidth: 4,
                });
            };
            this.connect = function () {
                var source = this.getSource();
                var target = this.getTarget();
                var connectOptions = {
                    source: source.get$node().get(0),
                    target: target.get$node().get(0),
                    paintStyle: that.getDefaultPaintStyle(),
                    endpoint: "Dot",
                    anchors: [source.getAnchorOptions(), target.getAnchorOptions()],
                    connector: shape,
                    overlays: overlays,
                    cssClass: this.getEntityId(),
                };
                if (source === target) {
                    connectOptions.anchors = ["TopCenter", "LeftMiddle"];
                }
                source.addOutgoingEdge(this);
                target.addIngoingEdge(this);
                this.setJsPlumbConnection(window.jsPlumbInstance.connect(connectOptions));
                this.repaintOverlays();
                lodash.each(EntityManagerInstance$1.getEdges(), function (e) {
                    e.setZIndex();
                });
            };
            this.toJSON = function () {
                var json = AbstractEdge$1.prototype.toJSON.call(this);
                json.type = type;
                return json;
            };
            this.restyle = function (arrowType, color, shapeType, dashstyle, overlay, overlayPosition, overlayRotate, attributes) {
                overlays = [];
                color = color
                    ? $colorTestElement
                        .css("color", "black")
                        .css("color", color)
                        .css("color")
                    : "black";
                if (Arrows().hasOwnProperty(arrowType)) {
                    overlays.push(Arrows(color)[arrowType]);
                }
                if (overlay) {
                    switch (overlayPosition) {
                        case "top":
                            overlays.push({
                                type: "Custom",
                                options: {
                                    create: makeOverlayFunction(overlay),
                                    location: 0.9,
                                    id: "label",
                                },
                            });
                            break;
                        case "bottom":
                            overlays.push({
                                type: "Custom",
                                options: {
                                    create: makeOverlayFunction(overlay),
                                    location: 0.1,
                                    id: "label",
                                },
                            });
                            break;
                        default:
                        case "center":
                            overlays.push({
                                type: "Custom",
                                options: {
                                    create: makeOverlayFunction(overlay),
                                    location: 0.5,
                                    id: "label",
                                },
                            });
                            break;
                    }
                }
                overlays.push({
                    type: "Custom",
                    options: {
                        create: function () {
                            that.get$overlay().hide().find(".type").addClass(shapeType);
                            return that.get$overlay().get(0);
                        },
                        location: 0.5,
                        id: "label",
                    },
                });
                if (overlay) {
                    that
                        .get$overlay()
                        .find("input[name='Label']")
                        .css("visibility", "hidden");
                }
                for (var attributeId in attributes) {
                    if (attributes.hasOwnProperty(attributeId)) {
                        var attribute = attributes[attributeId];
                        switch (attribute.position) {
                            case "top":
                                overlays.push({
                                    type: "Custom",
                                    options: {
                                        create: makeAttributeOverlayFunction(that.getAttribute(attributeId)),
                                        location: 1,
                                        id: "label " + attributeId,
                                    },
                                });
                                break;
                            case "center":
                                overlays.push({
                                    type: "Custom",
                                    options: {
                                        create: makeAttributeOverlayFunction(that.getAttribute(attributeId)),
                                        location: 0.5,
                                        id: "label " + attributeId,
                                    },
                                });
                                break;
                            case "bottom":
                                overlays.push({
                                    type: "Custom",
                                    options: {
                                        create: makeAttributeOverlayFunction(that.getAttribute(attributeId)),
                                        location: 0,
                                        id: "label " + attributeId,
                                    },
                                });
                                break;
                        }
                    }
                }
                var paintStyle = {
                    strokeStyle: color,
                    lineWidth: 2,
                    dashstyle: dashstyle,
                };
                that.setDefaultPaintStyle(paintStyle);
                that.setRotateOverlay(overlayRotate);
                if (that.getJsPlumbConnection()) {
                    that.getJsPlumbConnection().removeAllOverlays();
                    for (var i = 0; i < overlays.length; i++) {
                        that.getJsPlumbConnection().addOverlay(overlays[i]);
                    }
                    that.getJsPlumbConnection().setPaintStyle(paintStyle);
                    that.repaintOverlays();
                }
            };
            this.registerYMap = function () {
                AbstractEdge$1.prototype.registerYMap.call(this);
                var attr = that.getAttributes();
                for (var key in attr) {
                    if (attr.hasOwnProperty(key)) {
                        var val = attr[key].getValue();
                        if (val.hasOwnProperty("registerYType")) {
                            val.registerYType();
                        }
                    }
                }
            };
            init();
        }
        static getArrowType() {
            return arrowType;
        }
        static getShapeType() {
            return shapeType;
        }
        static getShape() {
            return shape;
        }
        static getColor() {
            return color;
        }
        static getOverlay() {
            return overlay;
        }
        static getOverlayPosition() {
            return overlayPosition;
        }
        static getOverlayRotate() {
            return overlayRotate;
        }
        static getAttributes() {
            return attributes;
        }
        static getType() {
            return type;
        }
        static getArrowOverlays() {
            var overlays = [];
            if (Arrows().hasOwnProperty(arrowType)) {
                overlays.push(Arrows(color)[arrowType]);
            }
            return overlays;
        }
    }
    return Edge;
}
let RelationshipGroupNode$1 = class RelationshipGroupNode extends AbstractNode$1 {
    constructor(id, left, top, width, height, zIndex) {
        super(id, RelationshipGroupNode$1.TYPE, left, top, width, height, zIndex);
        var that = this;
        var _$template = $(lodash.template(relationshipGroupNodeHtml$1)({ type: that.getType() }));
        var _$node = AbstractNode$1.prototype.get$node
            .call(this)
            .append(_$template)
            .addClass("class");
        var _$attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        this.toJSON = function () {
            var json = AbstractNode$1.prototype.toJSON.call(this);
            json.type = RelationshipGroupNode$1.TYPE;
            return json;
        };
        this.registerYMap = function () {
            AbstractNode$1.prototype.registerYMap.call(this);
            that.getLabel().getValue().registerYType();
        };
        _$node.find(".label").append(this.getLabel().get$node());
        for (var attributeKey in _attributes) {
            if (_attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(_attributes[attributeKey].get$node());
            }
        }
    }
    static { this.TYPE = "Relation"; }
    static { this.DEFAULT_WIDTH = 150; }
    static { this.DEFAULT_HEIGHT = 100; }
};
let ModelAttributesNode$1 = class ModelAttributesNode extends AbstractNode$1 {
    constructor(id, attr, y) {
        super(id, ModelAttributesNode$1.TYPE, 0, 0, 0, 0, 0, null, null, y);
        y = y || window.y;
        if (!y) {
            throw new Error("y is not defined");
        }
        var _$template = $(lodash.template(modelAttributesNodeHtml$1)());
        var _$node = AbstractNode$1.prototype.get$node
            .call(this)
            .append(_$template)
            .addClass("class");
        var _$attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        this.toJSON = function () {
            var json = AbstractNode$1.prototype.toJSON.call(this);
            json.type = ModelAttributesNode$1.TYPE;
            return json;
        };
        if (attr) {
            for (var attrKey in attr) {
                if (attr.hasOwnProperty(attrKey)) {
                    switch (attr[attrKey].value) {
                        case "boolean":
                            this.addAttribute(new BooleanAttribute$1(this.getEntityId() +
                                "[" +
                                attr[attrKey].key.toLowerCase() +
                                "]", attr[attrKey].key, this));
                            break;
                        case "string":
                            this.addAttribute(new SingleValueAttribute$1(this.getEntityId() +
                                "[" +
                                attr[attrKey].key.toLowerCase() +
                                "]", attr[attrKey].key, this));
                            break;
                        case "integer":
                            this.addAttribute(new IntegerAttribute$1(this.getEntityId() +
                                "[" +
                                attr[attrKey].key.toLowerCase() +
                                "]", attr[attrKey].key, this));
                            break;
                        case "file":
                            this.addAttribute(new FileAttribute$1(this.getEntityId() +
                                "[" +
                                attr[attrKey].key.toLowerCase() +
                                "]", attr[attrKey].key, this));
                            break;
                        default:
                            if (attr[attrKey].options) {
                                this.addAttribute(new SingleSelectionAttribute$1(this.getEntityId() +
                                    "[" +
                                    attr[attrKey].key.toLowerCase() +
                                    "]", attr[attrKey].key, this, attr[attrKey].options));
                            }
                            break;
                    }
                }
            }
        }
        else {
            this.addAttribute(new SingleValueAttribute$1(this.getEntityId() + "[name]", "Name", this, y));
            this.addAttribute(new SingleMultiLineValueAttribute$1(this.getEntityId() + "[description]", "Description", this, y));
        }
        this.getLabel().getValue().setValue("Model Attributes");
        _$node.find(".label").text("Model Attributes");
        _$node.hide();
        for (var attributeKey in _attributes) {
            if (_attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(_attributes[attributeKey].get$node());
            }
        }
        this.registerYMap = function () {
            AbstractNode$1.prototype.registerYMap.call(this);
            var attrs = this.getAttributes();
            for (var key in attrs) {
                if (attrs.hasOwnProperty(key)) {
                    var attr = attrs[key];
                    if (attr instanceof SingleValueAttribute$1 ||
                        attr instanceof SingleMultiLineValueAttribute$1) {
                        attr.getValue().registerYType();
                    }
                    else if (!(attr instanceof FileAttribute$1) &&
                        !(attr instanceof SingleValueAttribute$1) &&
                        !(attr instanceof SingleMultiLineValueAttribute$1)) {
                        attr.getValue().registerYType();
                    }
                }
            }
        };
    }
    static { this.TYPE = "ModelAttributesNode"; }
};
let ViewObjectNode$1 = class ViewObjectNode extends AbstractNode$1 {
    constructor(id, left, top, width, height, zIndex, json) {
        var that = this;
        super(id, "ViewObject", left, top, width, height, zIndex, json);
        var _$template = $(lodash.template(viewobjectNodeHtml)({ type: that.getType() }));
        var _$node = AbstractNode$1.prototype.get$node
            .call(this)
            .append(_$template)
            .addClass("viewobject");
        var _$attributeNode = _$node.find(".attributes");
        this.getAttributes();
        this.toJSON = function () {
            return AbstractNode$1.prototype.toJSON.call(this);
        };
        this.createConditionListAttribute = function (refAttrs) {
            var targetAttrList = {};
            if (refAttrs && refAttrs.constructor.name === "RenamingListAttribute") {
                var attrs = refAttrs.getAttributes();
                for (var key in attrs) {
                    if (attrs.hasOwnProperty(key)) {
                        targetAttrList[key] = attrs[key].getKey().getValue();
                    }
                }
            }
            else {
                for (var key in refAttrs) {
                    if (refAttrs.hasOwnProperty(key)) {
                        targetAttrList[key] = refAttrs[key].val.value;
                    }
                }
            }
            var conditionListAttr = new ConditionListAttribute$1("[condition]", "Conditions", that, targetAttrList, LogicalOperator);
            that.addAttribute(conditionListAttr);
            _$attributeNode.append(conditionListAttr.get$node());
            conditionListAttr.get$node().hide();
            return conditionListAttr;
        };
        this.registerYMap = function () {
            AbstractNode$1.prototype.registerYMap.call(this);
            that.getLabel().getValue().registerYType();
            renamingList.registerYMap();
            if (cla)
                cla.registerYMap();
            targetAttribute.getValue().registerYType();
            conjSelection.getValue().registerYType();
        };
        this.showAttributes = function () {
            if (renamingList.get$node().is(":hidden"))
                renamingList.get$node().show();
            if (conjSelection.get$node().is(":hidden"))
                conjSelection.get$node().show();
            if (cla.get$node().is(":hidden"))
                cla.get$node().show();
            if (!targetAttribute.get$node().is(":hidden"))
                targetAttribute.get$node().hide();
        };
        var targetAttribute, renamingList, conjSelection, cla;
        _$node.find(".label").append(this.getLabel().get$node());
        if (window.hasOwnProperty("y")) {
            const dataMap = y.getMap("data");
            var model = dataMap.get("model");
            if (model) {
                var selectionValues = ViewTypesUtil.GetAllNodesOfBaseModelAsSelectionList2(model.nodes, [
                    "Object",
                ]);
                targetAttribute = new SingleSelectionAttribute$1(id + "[target]", "Target", that, selectionValues);
                that.addAttribute(targetAttribute);
                _$attributeNode.prepend(targetAttribute.get$node());
            }
            if (json)
                cla = that.createConditionListAttribute(json.attributes["[attributes]"].list);
            else
                cla = that.createConditionListAttribute();
        }
        renamingList = new RenamingListAttribute$1("[attributes]", "Attributes", that, {
            show: "Visible",
            hide: "Hidden",
        });
        that.addAttribute(renamingList);
        _$attributeNode.append(renamingList.get$node());
        renamingList.get$node().hide();
        conjSelection = new SingleSelectionAttribute$1(id + "[conjunction]", "Conjunction", that, LogicalConjunctions);
        that.addAttribute(conjSelection);
        _$attributeNode.append(conjSelection.get$node());
        conjSelection.get$node().hide();
        if (json && conjSelection && cla && renamingList && targetAttribute)
            that.showAttributes();
        this.setContextMenuItemCallback(function () {
            var viewId = $("#lblCurrentView").text();
            return {
                addShape: {
                    name: "Add Node Shape",
                    callback: function () {
                        var canvas = that.getCanvas(), appearance = that.getAppearance();
                        canvas
                            .createNode(NodeShapeNode$1.TYPE, appearance.left + appearance.width + 50, appearance.top, 150, 100)
                            .done(function (nodeId) {
                            canvas.createEdge(BiDirAssociationEdge$1.TYPE, that.getEntityId(), nodeId, null, null, viewId);
                        });
                    },
                    disabled: function () {
                        var edges = that.getEdges(), edge, edgeId;
                        for (edgeId in edges) {
                            if (edges.hasOwnProperty(edgeId)) {
                                edge = edges[edgeId];
                                if ((edge instanceof BiDirAssociationEdge$1 &&
                                    ((edge.getTarget() === that &&
                                        edge.getSource() instanceof NodeShapeNode$1) ||
                                        (edge.getSource() === that &&
                                            edge.getTarget() instanceof NodeShapeNode$1))) ||
                                    (edge instanceof UniDirAssociationEdge$1 &&
                                        edge.getTarget() instanceof NodeShapeNode$1)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    },
                },
                sep: "---------",
            };
        });
    }
    static { this.TYPE = "ViewObject"; }
    static { this.DEFAULT_WIDTH = 150; }
    static { this.DEFAULT_HEIGHT = 100; }
};
let ViewRelationshipNode$2 = class ViewRelationshipNode extends AbstractNode$1 {
    constructor(id, left, top, width, height, zIndex, json) {
        super(id, "ViewRelationship", left, top, width, height, zIndex, json);
        var that = this;
        var _$template = $(lodash.template(viewrelationshipNodeHtml$1)({
            type: that.getType(),
        }));
        var _$node = AbstractNode$1.prototype.get$node
            .call(this)
            .append(_$template)
            .addClass("viewrelationship");
        var _$attributeNode = _$node.find(".attributes");
        this.getAttributes();
        this.toJSON = function () {
            return AbstractNode$1.prototype.toJSON.call(this);
        };
        this.registerYMap = function () {
            AbstractNode$1.prototype.registerYMap.call(this);
            that.getLabel().getValue().registerYType();
            attributeList.registerYMap();
            if (cla)
                cla.registerYMap();
            attribute.getValue().registerYType();
            conjSelection.getValue().registerYType();
        };
        this.showAttributes = function () {
            if (renamingList.get$node().is(":hidden"))
                renamingList.get$node().show();
            if (conjSelection.get$node().is(":hidden"))
                conjSelection.get$node().show();
            if (cla.get$node().is(":hidden"))
                cla.get$node().show();
            if (!targetAttribute.get$node().is(":hidden"))
                targetAttribute.get$node().hide();
        };
        this.createConditionListAttribute = function (refAttrs) {
            var targetAttrList = {};
            if (refAttrs && refAttrs.constructor.name === "RenamingListAttribute") {
                var attrs = refAttrs.getAttributes();
                for (var key in attrs) {
                    if (attrs.hasOwnProperty(key)) {
                        targetAttrList[key] = attrs[key].getKey().getValue();
                    }
                }
            }
            else {
                for (var key in refAttrs) {
                    if (refAttrs.hasOwnProperty(key)) {
                        targetAttrList[key] = refAttrs[key].val.value;
                    }
                }
            }
            var conditionListAttr = new ConditionListAttribute$1("[condition]", "Conditions", that, targetAttrList, LogicalOperator);
            that.addAttribute(conditionListAttr);
            _$attributeNode.append(conditionListAttr.get$node());
            conditionListAttr.get$node().hide();
            return conditionListAttr;
        };
        this.registerYMap = function () {
            AbstractNode$1.prototype.registerYMap.call(this);
            that.getLabel().getValue().registerYType();
            renamingList.registerYMap();
            if (cla)
                cla.registerYMap();
            targetAttribute.getValue().registerYType();
            conjSelection.getValue().registerYType();
        };
        var targetAttribute, renamingList, conjSelection, cla;
        _$node.find(".label").append(this.getLabel().get$node());
        if (window.hasOwnProperty("y")) {
            const dataMap = y.getMap("data");
            var model = dataMap.get("model");
            if (model) {
                var selectionValues = ViewTypesUtil.GetAllNodesOfBaseModelAsSelectionList2(model.nodes, [
                    "Relationship",
                ]);
                targetAttribute = new SingleSelectionAttribute$1(id + "[target]", "Reference", that, selectionValues);
                that.addAttribute(targetAttribute);
                _$attributeNode.prepend(targetAttribute.get$node());
                if (json)
                    cla = that.createConditionListAttribute(json.attributes["[attributes]"].list);
                else
                    cla = that.createConditionListAttribute();
            }
        }
        renamingList = new RenamingListAttribute$1("[attributes]", "Attributes", that, {
            hidden: "Show",
            top: "Show Top",
            center: "Show Center",
            bottom: "Show Bottom",
            hide: "Hide",
        });
        that.addAttribute(renamingList);
        _$attributeNode.append(renamingList.get$node());
        renamingList.get$node().hide();
        conjSelection = new SingleSelectionAttribute$1(id + "[conjunction]", "Conjunction", that, LogicalConjunctions);
        that.addAttribute(conjSelection);
        _$attributeNode.append(conjSelection.get$node());
        conjSelection.get$node().hide();
        if (json && conjSelection && cla && renamingList && targetAttribute)
            that.showAttributes();
        this.setContextMenuItemCallback(function () {
            var viewId = $("#lblCurrentView").text();
            return {
                addShape: {
                    name: "Add Edge Shape",
                    callback: function () {
                        var canvas = that.getCanvas(), appearance = that.getAppearance(), nodeId;
                        canvas.createNode(EdgeShapeNode$1.TYPE, appearance.left + appearance.width + 50, appearance.top, 150, 100);
                        canvas.createEdge(BiDirAssociationEdge$1.TYPE, that.getEntityId(), nodeId, null, null, viewId);
                    },
                    disabled: function () {
                        var edges = that.getEdges(), edge, edgeId;
                        for (edgeId in edges) {
                            if (edges.hasOwnProperty(edgeId)) {
                                edge = edges[edgeId];
                                if ((edge instanceof BiDirAssociationEdge$1 &&
                                    ((edge.getTarget() === that &&
                                        edge.getSource() instanceof EdgeShapeNode$1) ||
                                        (edge.getSource() === that &&
                                            edge.getTarget() instanceof EdgeShapeNode$1))) ||
                                    (edge instanceof UniDirAssociationEdge$1 &&
                                        edge.getTarget() instanceof EdgeShapeNode$1)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    },
                },
                sep: "---------",
            };
        });
    }
    static { this.TYPE = "ViewRelationship"; }
    static { this.DEFAULT_WIDTH = 150; }
    static { this.DEFAULT_HEIGHT = 100; }
};
let GeneralisationEdge$1 = class GeneralisationEdge extends AbstractEdge$1 {
    constructor(id, source, target) {
        super(id, GeneralisationEdge$1.TYPE, source, target);
        var that = this;
        this.connect = function () {
            var source = this.getSource();
            var target = this.getTarget();
            var connectOptions = {
                source: source.get$node().get(0),
                target: target.get$node().get(0),
                paintStyle: {
                    stroke: "black",
                    strokeWidth: 4,
                },
                endpoint: "Dot",
                anchors: [source.getAnchorOptions(), target.getAnchorOptions()],
                connector: {
                    type: StraightConnector.type,
                    options: { gap: 0 },
                },
                overlays: [
                    {
                        type: "Arrow",
                        options: {
                            width: 20,
                            length: 25,
                            location: 1,
                            foldback: 1,
                            paintStyle: {
                                fill: "#ffffff",
                                outlineWidth: 2,
                                dashstyle: "black",
                            },
                        },
                    },
                    {
                        type: "Custom",
                        options: {
                            create: function () {
                                return that.get$overlay().get(0);
                            },
                            location: 0.5,
                            id: "label",
                        },
                    },
                ],
                cssClass: this.getEntityId(),
            };
            if (source === target) {
                connectOptions.anchor = ["TopCenter", "LeftMiddle"];
            }
            source.addOutgoingEdge(this);
            target.addIngoingEdge(this);
            this.setJsPlumbConnection(window.jsPlumbInstance.connect(connectOptions));
            this.repaintOverlays();
            lodash.each(EntityManagerInstance$1.getEdges(), function (e) {
                e.setZIndex();
            });
        };
        this.get$overlay().find(".type").addClass("segmented");
    }
    static { this.TYPE = "Generalisation"; }
    static { this.RELATIONS = [
        {
            sourceTypes: [ObjectNode$1.TYPE],
            targetTypes: [ObjectNode$1.TYPE, AbstractClassNode$1.TYPE],
        },
        {
            sourceTypes: [RelationshipNode$1.TYPE],
            targetTypes: [RelationshipNode$1.TYPE, AbstractClassNode$1.TYPE],
        },
        {
            sourceTypes: [RelationshipGroupNode$1.TYPE],
            targetTypes: [RelationshipNode$1.TYPE, ViewRelationshipNode$2.TYPE],
        },
        {
            sourceTypes: [AbstractClassNode$1.TYPE],
            targetTypes: [AbstractClassNode$1.TYPE],
        },
        {
            sourceTypes: [EnumNode$1.TYPE],
            targetTypes: [EnumNode$1.TYPE],
        },
    ]; }
};
let UniDirAssociationEdge$1 = class UniDirAssociationEdge extends AbstractEdge$1 {
    constructor(id, source, target) {
        super(id, UniDirAssociationEdge$1.TYPE, source, target);
        var that = this;
        this.connect = function () {
            var source = this.getSource();
            var target = this.getTarget();
            var connectOptions = {
                source: source.get$node().get(0),
                target: target.get$node().get(0),
                paintStyle: {
                    stroke: "black",
                    strokeWidth: 4,
                },
                endpoint: "Dot",
                anchors: [source.getAnchorOptions(), target.getAnchorOptions()],
                connector: {
                    type: StraightConnector.type,
                    options: { gap: 0 },
                },
                overlays: [
                    {
                        type: "Arrow",
                        options: {
                            width: 20,
                            length: 30,
                            location: 1,
                            foldback: 0.5,
                            paintStyle: {
                                fill: "#ffffff",
                                outlineWidth: 2,
                                outlineStroke: "black",
                            },
                        },
                    },
                    {
                        type: "Custom",
                        options: {
                            create: function () {
                                return that.get$overlay().get(0);
                            },
                            location: 0.5,
                            id: "label",
                        },
                    },
                ],
                cssClass: this.getEntityId(),
            };
            if (source === target) {
                connectOptions.anchors = ["TopCenter", "LeftMiddle"];
            }
            source.addOutgoingEdge(this);
            target.addIngoingEdge(this);
            this.setJsPlumbConnection(window.jsPlumbInstance.connect(connectOptions));
            this.repaintOverlays();
            lodash.each(EntityManagerInstance$1.getEdges(), function (e) {
                e.setZIndex();
            });
        };
        this.get$overlay().find(".type").addClass("segmented");
    }
    static { this.TYPE = "Uni-Dir-Association"; }
    static { this.RELATIONS = [
        {
            sourceTypes: [ObjectNode$1.TYPE],
            targetTypes: [
                EnumNode$1.TYPE,
                NodeShapeNode$1.TYPE,
                RelationshipNode$1.TYPE,
                RelationshipGroupNode$1.TYPE,
                ViewRelationshipNode$2.TYPE,
            ],
        },
        {
            sourceTypes: [RelationshipNode$1.TYPE],
            targetTypes: [
                EnumNode$1.TYPE,
                EdgeShapeNode$1.TYPE,
                ObjectNode$1.TYPE,
                AbstractClassNode$1.TYPE,
                ViewObjectNode$1.TYPE,
            ],
        },
        {
            sourceTypes: [RelationshipGroupNode$1.TYPE],
            targetTypes: [ObjectNode$1.TYPE, AbstractClassNode$1.TYPE],
        },
        {
            sourceTypes: [AbstractClassNode$1.TYPE],
            targetTypes: [
                EnumNode$1.TYPE,
                RelationshipNode$1.TYPE,
                RelationshipGroupNode$1.TYPE,
            ],
        },
        {
            sourceTypes: [ViewObjectNode$1.TYPE],
            targetTypes: [
                EnumNode$1.TYPE,
                NodeShapeNode$1.TYPE,
                RelationshipNode$1.TYPE,
                RelationshipGroupNode$1.TYPE,
                ViewRelationshipNode$2.TYPE,
            ],
        },
        {
            sourceTypes: [ViewRelationshipNode$2.TYPE],
            targetTypes: [
                EnumNode$1.TYPE,
                EdgeShapeNode$1.TYPE,
                ObjectNode$1.TYPE,
                AbstractClassNode$1.TYPE,
                ViewObjectNode$1.TYPE,
            ],
        },
    ]; }
};
let BiDirAssociationEdge$1 = class BiDirAssociationEdge extends AbstractEdge$1 {
    constructor(id, source, target) {
        super(id, BiDirAssociationEdge$1.TYPE, source, target);
        var that = this;
        this.connect = function () {
            var source = this.getSource();
            var target = this.getTarget();
            var connectOptions = {
                source: source.get$node().get(0),
                target: target.get$node().get(0),
                paintStyle: {
                    stroke: "black",
                    strokeWidth: 4,
                },
                endpoint: "Dot",
                anchors: [source.getAnchorOptions(), target.getAnchorOptions()],
                connector: {
                    type: StraightConnector.type,
                    options: { gap: 0 },
                },
                overlays: [
                    {
                        type: "Custom",
                        options: {
                            create: function () {
                                return that.get$overlay().get(0);
                            },
                            location: 0.5,
                            id: "label",
                        },
                    },
                ],
                cssClass: this.getEntityId(),
            };
            if (source === target) {
                connectOptions.anchors = ["TopCenter", "LeftMiddle"];
            }
            source.addOutgoingEdge(this);
            target.addIngoingEdge(this);
            this.setJsPlumbConnection(window.jsPlumbInstance.connect(connectOptions));
            this.repaintOverlays();
            lodash.each(EntityManagerInstance$1.getEdges(), function (e) {
                e.setZIndex();
            });
        };
        this.get$overlay().find(".type").addClass("segmented");
    }
    static { this.TYPE = "Bi-Dir-Association"; }
    static { this.RELATIONS = [
        {
            sourceTypes: [ObjectNode$1.TYPE],
            targetTypes: [
                EnumNode$1.TYPE,
                NodeShapeNode$1.TYPE,
                RelationshipNode$1.TYPE,
                RelationshipGroupNode$1.TYPE,
                ViewRelationshipNode$2.TYPE,
            ],
        },
        {
            sourceTypes: [RelationshipNode$1.TYPE],
            targetTypes: [
                EnumNode$1.TYPE,
                EdgeShapeNode$1.TYPE,
                ObjectNode$1.TYPE,
                AbstractClassNode$1.TYPE,
                ViewObjectNode$1.TYPE,
            ],
        },
        {
            sourceTypes: [RelationshipGroupNode$1.TYPE],
            targetTypes: [ObjectNode$1.TYPE, AbstractClassNode$1.TYPE],
        },
        {
            sourceTypes: [AbstractClassNode$1.TYPE],
            targetTypes: [
                EnumNode$1.TYPE,
                RelationshipNode$1.TYPE,
                RelationshipGroupNode$1.TYPE,
            ],
        },
        {
            sourceTypes: [EnumNode$1.TYPE],
            targetTypes: [
                ObjectNode$1.TYPE,
                RelationshipNode$1.TYPE,
                AbstractClassNode$1.TYPE,
            ],
        },
        {
            sourceTypes: [NodeShapeNode$1.TYPE],
            targetTypes: [ObjectNode$1.TYPE],
        },
        {
            sourceTypes: [EdgeShapeNode$1.TYPE],
            targetTypes: [RelationshipNode$1.TYPE],
        },
        {
            sourceTypes: [ViewObjectNode$1.TYPE],
            targetTypes: [
                EnumNode$1.TYPE,
                NodeShapeNode$1.TYPE,
                RelationshipNode$1.TYPE,
                RelationshipGroupNode$1.TYPE,
                ViewRelationshipNode$2.TYPE,
            ],
        },
        {
            sourceTypes: [ViewRelationshipNode$2.TYPE],
            targetTypes: [
                EnumNode$1.TYPE,
                EdgeShapeNode$1.TYPE,
                ObjectNode$1.TYPE,
                AbstractClassNode$1.TYPE,
                ViewObjectNode$1.TYPE,
            ],
        },
    ]; }
};
class AbstractCanvasTool {
    constructor(name, className, description) {
        var _canvas = null;
        var _name = name || "AbstractTool";
        var _className = className || "tool-abstract";
        var _description = description || "An abstract canvas tool";
        this.setCanvas = function (canvas) {
            if (!canvas)
                throw new Error("Canvas is null");
            _canvas = canvas;
        };
        this.getCanvas = function () {
            return _canvas;
        };
        this.getName = function () {
            return _name;
        };
        this.getClassName = function () {
            return _className;
        };
        this.getDescription = function () {
            return _description;
        };
        this._mount = function () {
            _canvas.get$canvas().addClass(_className);
        };
        this._unmount = function () {
            _canvas.get$canvas().removeClass(_className);
        };
    }
    mount() {
        this._mount();
    }
    unmount() {
        this._unmount();
    }
}
let NodeTool$1 = class NodeTool extends AbstractCanvasTool {
    constructor(name, className, description, containment, defaultWidth, defaultHeight) {
        super(name, className || "tool-node", description || "Add a node");
        var _defaultWidth = defaultWidth || 100, _defaultHeight = defaultHeight || 50;
        this.mount = function (defaultLabel, defaultAttributeValues) {
            var $canvas = this.getCanvas().get$canvas();
            var that = this;
            AbstractCanvasTool.prototype.mount.call(this);
            $canvas.on("mouseup.nodeadd", function (ev) {
                var offsetCanvas;
                if (ev.which != 1)
                    return;
                offsetCanvas = $canvas.offset();
                var zoom = that.getCanvas().getZoom();
                var nodeX = (ev.pageX - offsetCanvas.left) / zoom - _defaultWidth / 2;
                var nodeY = (ev.pageY - offsetCanvas.top) / zoom - _defaultHeight / 2;
                that
                    .getCanvas()
                    .createNode(that.getName(), nodeX, nodeY, _defaultWidth, _defaultHeight, null, containment, null, null, null, defaultLabel, defaultAttributeValues);
                that.getCanvas().resetTool();
            });
            $canvas.bind("contextmenu", function (ev) {
                if (ev.target == this) {
                    ev.preventDefault();
                    that.getCanvas().resetTool();
                    return false;
                }
                return true;
            });
            $canvas.find(".node").bind("contextmenu", function (ev) {
                ev.preventDefault();
                that.getCanvas().resetTool();
                that.getCanvas().select(EntityManagerInstance$1.findNode($(this).attr("id")));
                return false;
            });
        };
        this.unmount = function () {
            var $canvas = this.getCanvas().get$canvas();
            AbstractCanvasTool.prototype.unmount.call(this);
            $canvas.off("mouseup.nodeadd");
            $canvas.unbind("contextmenu");
            $canvas.find(".node").unbind("contextmenu");
        };
    }
};
let AbstractClassNodeTool$1 = class AbstractClassNodeTool extends NodeTool$1 {
    constructor() {
        super(AbstractClassNode$1.TYPE, null, null, null, AbstractClassNode$1.DEFAULT_WIDTH, AbstractClassNode$1.DEFAULT_HEIGHT);
    }
};
let EdgeTool$1 = class EdgeTool extends AbstractCanvasTool {
    constructor(name, relations, className, description) {
        super(name, className || "tool-edge", description || "Add an edge");
        const jsPlumbInstance = window.jsPlumbInstance;
        var _relations = relations;
        this.mount = function () {
            AbstractCanvasTool.prototype.mount.call(this);
            function makeNeighborhoodFilter(nodeId) {
                return function (n) {
                    return (n.getEntityId() !== nodeId &&
                        !n.getNeighbors().hasOwnProperty(nodeId));
                };
            }
            function makeMakeTargetCallback() {
                return function (node) {
                    node.makeTarget();
                    node.unlowlight();
                };
            }
            var that = this;
            var $canvas = this.getCanvas().get$canvas();
            var nodes = EntityManagerInstance$1.getNodes();
            var nodeId, node, nodeType, strGetNodesByType;
            var i, numOfRelations;
            for (nodeId in nodes) {
                if (nodes.hasOwnProperty(nodeId)) {
                    node = nodes[nodeId];
                    node.lowlight();
                    if (EntityManagerInstance$1.getViewId() === undefined ||
                        EntityManagerInstance$1.getLayer() === CONFIG$1.LAYER.META) {
                        nodeType = node.getType();
                        strGetNodesByType = "getNodesByType";
                    }
                    else {
                        nodeType = node.getCurrentViewType();
                        strGetNodesByType = "getNodesByViewType";
                    }
                    for (i = 0, numOfRelations = _relations.length; i < numOfRelations; i++) {
                        if (relations[i].sourceTypes.indexOf(nodeType) !== -1) {
                            if (lodash.size(lodash.filter(EntityManagerInstance$1[strGetNodesByType](relations[i].targetTypes), makeNeighborhoodFilter(node.getEntityId()))) > 0) {
                                node.makeSource();
                                node.unbindMoveToolEvents();
                                node.unlowlight();
                                break;
                            }
                        }
                    }
                }
            }
            jsPlumbInstance.bind("beforeDrag", function (info) {
                var sourceNode = EntityManagerInstance$1.findNode(info.sourceId), sourceType, i, numOfRelations, strGetNodesByType;
                if (sourceNode) {
                    if (EntityManagerInstance$1.getViewId() === undefined ||
                        EntityManagerInstance$1.getLayer() === CONFIG$1.LAYER.META) {
                        sourceType = sourceNode.getType();
                        strGetNodesByType = "getNodesByType";
                    }
                    else {
                        sourceType = sourceNode.getCurrentViewType();
                        strGetNodesByType = "getNodesByViewType";
                    }
                    for (i = 0, numOfRelations = _relations.length; i < numOfRelations; i++) {
                        if (relations[i].sourceTypes.indexOf(sourceType) !== -1) {
                            lodash.each(lodash.filter(EntityManagerInstance$1[strGetNodesByType](relations[i].targetTypes), makeNeighborhoodFilter(sourceNode.getEntityId())), makeMakeTargetCallback());
                        }
                    }
                }
                $(info.source).addClass("current");
                $canvas.addClass("dragging");
                return true;
            });
            jsPlumbInstance.bind("beforeDrop", function () {
                $canvas.removeClass("dragging");
                $(".node.current").removeClass("current");
                return true;
            });
            jsPlumbInstance.bind("beforeDetach", function (info) {
                if (info.connection?.pending) {
                    $(".node.current").removeClass("current");
                    $canvas.removeClass("dragging");
                }
                return true;
            });
            jsPlumbInstance.bind("connection", function (info, originalEvent) {
                if (typeof originalEvent !== "undefined") {
                    if (info.connection) {
                        jsPlumbInstance.deleteConnection(info.connection, {
                            fireEvent: false,
                        });
                    }
                    that
                        .getCanvas()
                        .createEdge(that.getName(), info.sourceId, info.targetId);
                }
                return true;
            });
            $canvas.bind("contextmenu", function (ev) {
                if (ev.target == this) {
                    ev.preventDefault();
                    that.getCanvas().resetTool();
                    return false;
                }
                return true;
            });
            $canvas.find(".node").bind("contextmenu", function (ev) {
                ev.preventDefault();
                that.getCanvas().resetTool();
                that.getCanvas().select(EntityManagerInstance$1.findNode($(this).attr("id")));
                return false;
            });
        };
        this.unmount = function () {
            AbstractCanvasTool.prototype.unmount.call(this, arguments);
            var $canvas = this.getCanvas().get$canvas();
            var nodes = EntityManagerInstance$1.getNodes();
            var nodeId, node;
            for (nodeId in nodes) {
                if (nodes.hasOwnProperty(nodeId)) {
                    node = nodes[nodeId];
                    node.unlowlight();
                    node.unbindEdgeToolEvents();
                    node.bindMoveToolEvents();
                }
            }
            jsPlumbInstance.unbind("connectionDrag");
            jsPlumbInstance.unbind("beforeDrop");
            jsPlumbInstance.unbind("connection");
            $canvas.unbind("contextmenu");
            $canvas.find(".node").unbind("contextmenu");
        };
    }
};
let BiDirAssociationEdgeTool$1 = class BiDirAssociationEdgeTool extends EdgeTool$1 {
    constructor() {
        super(BiDirAssociationEdge$1.TYPE, BiDirAssociationEdge$1.RELATIONS);
    }
};
function DagreLayout() {
    return {
        apply: function () {
            var node, edge, e, appearance, relX, relY, x, y;
            var g = new dagre.graphlib.Graph();
            g.setGraph({});
            g.setDefaultEdgeLabel(function () {
                return {};
            });
            var nodes = EntityManagerInstance$1.getNodes();
            for (var nodeId in nodes) {
                if (nodes.hasOwnProperty(nodeId)) {
                    node = nodes[nodeId];
                    appearance = node.getAppearance();
                    g.setNode(nodeId, {
                        width: appearance.width,
                        height: appearance.height,
                    });
                }
            }
            var edges = EntityManagerInstance$1.getEdges();
            for (var edgeId in edges) {
                if (edges.hasOwnProperty(edgeId)) {
                    edge = edges[edgeId];
                    g.setEdge(edge.getSource().getEntityId(), edge.getTarget().getEntityId());
                }
            }
            dagre.layout(g, {
                rankdir: "BT",
                align: "UL",
                ranker: "tight-tree",
                marginx: 9000,
                marginy: 9000,
            });
            relX = 4500 - g.graph().width / 2;
            relY = 4500 - g.graph().height / 2;
            g.nodes().forEach(function (v) {
                e = EntityManagerInstance$1.findNode(v);
                if (e) {
                    appearance = e.getAppearance();
                    node = g.node(v);
                    x = relX + node.x;
                    y = relY + node.y;
                    if (appearance.top !== x || appearance.top !== y)
                        e.moveAbs(x, y);
                }
            });
        },
    };
}
var DagreLayout$1 = DagreLayout();
const selectToolGuidanceHtml$1 = "<button class=\"bs-btn bs-btn-default\">\n\t<i class=\"fa fa-users\"></i>\n\t<%= text %>\n</button>";
class CollaborationGuidance {
    constructor(id, label, activityId, objectId, canvas, y) {
        y = y || window.y;
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var _canvas = canvas;
        var _$node = $(lodash.template(selectToolGuidanceHtml$1)({ text: label, icon: "users" }));
        _$node.click(function () {
            var operation = new CollaborateInActivityOperation(activityId);
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.toNonOTOperation());
            _canvas.hideGuidanceBox();
            _canvas.scrollNodeIntoView(objectId);
        });
        this.get$node = function () {
            return _$node;
        };
    }
}
class GhostEdge {
    constructor(canvas, edgeFunction, source, target) {
        var _jsPlumbConnection = null;
        var _label = edgeFunction.getType();
        source.addGhostEdge(this);
        target.addGhostEdge(this);
        this.getLabel = function () {
            return _label;
        };
        this.connect = function (button) {
            if (_jsPlumbConnection)
                return;
            var overlays = edgeFunction.getArrowOverlays();
            overlays.push([
                "Custom",
                {
                    create: function (component) {
                        return $("<div></div>").append(button);
                    },
                    location: 0.5,
                    id: "customOverlay",
                    cssClass: "ghost-edge-overlay",
                },
            ]);
            var connectOptions = {
                source: source.get$node(),
                target: target.get$node(),
                paintStyle: {
                    stroke: edgeFunction.getColor(),
                    strokeWidth: 4,
                    dashstyle: "",
                },
                endpoint: "Dot",
                anchors: [source.getAnchorOptions(), target.getAnchorOptions()],
                connector: edgeFunction.getShape(),
                overlays: overlays,
                cssClass: "ghost-edge",
            };
            if (source === target) {
                connectOptions.anchors = ["TopCenter", "LeftMiddle"];
            }
            _jsPlumbConnection = window.JsPlumbInstance.connect(connectOptions);
            lodash.each(EntityManagerInstance$1.getEdges(), function (e) {
                e.setZIndex();
            });
        };
        this.remove = function () {
            if (_jsPlumbConnection)
                window.JsPlumbInstance.destroyConnector(_jsPlumbConnection);
            _jsPlumbConnection = null;
        };
        this.getEdgeFunction = function () {
            return edgeFunction;
        };
        this.getSource = function () {
            return source;
        };
        this.getTarget = function () {
            return target;
        };
    }
}
const ghostEdgeHtml = "<!-- <button class='bs-btn bs-btn-default bs-btn-s' style=\"z-index: 30000; opacity:0.4;\">\n\t<i class='fa fa-plus' style='margin-right:5px;'></i><%= label %>\n</button> -->\n<!-- Split button -->\n<div class=\"bs-btn-group\" style=\"z-index: 30000; opacity:0.4;\">\n  <button type=\"bs-button\" class=\"bs-btn bs-btn-default create-edge-button\"><i class='fa fa-plus' style='margin-right:5px;'></i><span class=\"label\"></span></button>\n  <button type=\"bs-button\" class=\"bs-btn bs-btn-default bs-dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\" style=\"min-height:34px;\">\n    <span class=\"bs-caret\"></span>\n  </button>\n  <ul class=\"bs-dropdown-menu edge-list\">\n  </ul>\n</div>";
function GhostEdgeGuidance(canvas, node1, node2) {
    var _button = $(ghostEdgeHtml);
    var _dropdown = _button.find(".bs-dropdown-toggle");
    _dropdown.detach();
    var _dropdownList = _button.find(".edge-list");
    _dropdownList.detach();
    var _canvas = canvas;
    var that = this;
    var _edges = [];
    var _node1 = node1;
    var _node2 = node2;
    var _currentEdge = null;
    _node1.addGhostEdge(this);
    _node2.addGhostEdge(this);
    _button.hover(function () {
        $(this).css({ opacity: 1 });
    }, function () {
        $(this).css({ opacity: 0.4 });
    });
    this.show = function () {
        _currentEdge.connect(_button);
    };
    this.addEdge = function (edgeFunction, source, target) {
        var edge = new GhostEdge(_canvas, edgeFunction, source, target);
        _edges.push(edge);
        var listItem = $("<li><a href='javascript:;'></a></li>");
        listItem.click(function () {
            that.remove();
            that.setCurrentEdge(edge);
            that.show();
        });
        listItem.find("a").text(edge.getLabel());
        _dropdownList.append(listItem);
        if (_edges.length == 1) {
            this.setCurrentEdge(edge);
        }
        if (_edges.length == 2) {
            _button.append(_dropdown);
            _button.append(_dropdownList);
        }
    };
    this.remove = function () {
        _button.detach();
        if (_currentEdge)
            _currentEdge.remove();
    };
    this.getNode1 = function () {
        return _node1;
    };
    this.getNode2 = function () {
        return _node2;
    };
    this.setCurrentEdge = function (edge) {
        if (_currentEdge)
            _currentEdge.remove();
        _currentEdge = edge;
        _button.find(".label").text(_currentEdge.getLabel());
        var createEdgeButton = _button.find(".create-edge-button");
        createEdgeButton.off("click");
        createEdgeButton.click(function (event) {
            event.stopPropagation();
            that.remove();
            _canvas.createEdge(_currentEdge.getEdgeFunction().getType(), _currentEdge.getSource().getEntityId(), _currentEdge.getTarget().getEntityId());
        });
    };
}
const abstractNodeHtml$1 = "<div id=\"<%= id %>\" class=\"node\">\n</div>";
const guidanceBoxNodeHtml = "<div class=\"guidance-box bs-panel bs-panel-info\" style=\"opacity:0.5;\">\n  <div class=\"bs-panel-body\" style=\"padding:2px;\">\n  \t\t<div class=\"bs-btn-group bs-gtn-group-s buttons\" role=\"group\">\n\t\t</div>\n  </div>\n  <div class=\"bs-panel-footer\" style=\"padding-top:0px; padding-bottom:0px; background-color:#337ab7; color:white; font-size:12px; overflow:hidden;\">\n  \t<p class=\"scroll-text\" style=\"width:1; white-space:nowrap; position:relative; margin:0px;\"><i class=\"fa fa-puzzle-piece\" style=\"margin-right:5px;\"></i>Guidance</p>\n  </div>\n</div>";
function GuidanceBox(id, label, left, top) {
    var _$node = $(lodash.template(abstractNodeHtml$1)({ id: id })).append(guidanceBoxNodeHtml);
    _$node.find(".guidance-box").hover(function () {
        $(this).css({ opacity: 1 });
    }, function () {
        $(this).css({ opacity: 0.5 });
    });
    var _appearance = {
        left: left,
        top: top,
    };
    this.get$node = function () {
        return _$node;
    };
    this.addGuidance = function (guidance) {
        _$node.find(".buttons").append(guidance.get$node());
    };
    this.draw = function () {
        var width = _$node.width();
        _$node.css({
            left: _appearance.left - width / 2,
            top: _appearance.top,
            zIndex: 30000,
        });
    };
    this.addToCanvas = function (canvas) {
        canvas.get$canvas().append(_$node);
    };
    this.remove = function () {
        _$node.remove();
    };
}
const selectToolGuidanceHtml = "<button class=\"bs-btn bs-btn-default\">\n\t<i class=\"fa fa-<%= icon %>\"></i>\n\t<%= text %>\n</button>";
function SelectToolGuidance(id, label, tool, canvas, icon) {
    var _canvas = canvas;
    var _$node = $(lodash.template(selectToolGuidanceHtml)({
        text: label,
        icon: icon || "plus-circle",
    }));
    _$node.click(function () {
        if (EntityManagerInstance$1.getViewId() !== undefined &&
            EntityManagerInstance$1.getLayer() === CONFIG$1.LAYER.MODEL) {
            if (EntityManagerInstance$1.getNodeType(tool) !== null) {
                _canvas.mountTool(EntityManagerInstance$1.getNodeType(tool).VIEWTYPE);
            }
            else {
                _canvas.mountTool(tool);
            }
        }
        else
            _canvas.mountTool(tool);
        _canvas.hideGuidanceBox();
    });
    this.get$node = function () {
        return _$node;
    };
}
const setPropertyGuidanceHtml = "<div class=\"bs-btn-group\" role=\"group\">\n<button class=\"bs-btn bs-btn-default bs-dropdown-toggle\" data-toggle=\"dropdown\">\n\t<i class=\"fa fa-<%= icon %>\"></i>\n\t<%= text %>\n</button>\n<ul class=\"bs-dropdown-menu\">\n\t<li class=\"property-input\"></li>\n</ul>\n</div>";
function SetPropertyGuidance(id, label, entity, propertyName, canvas) {
    var _entityId = entity.getEntityId();
    var _canvas = canvas;
    var _entityAttribute = null;
    var _$node = $(lodash.template(setPropertyGuidanceHtml)({ text: label, icon: "edit" }));
    var _propertyInput;
    var entityAttributes = entity.getAttributes();
    for (var attribId in entityAttributes) {
        var attrib = entityAttributes[attribId];
        if (attrib.getEntityId() ==
            entity.getEntityId() + "[" + propertyName.toLowerCase() + "]")
            _entityAttribute = attrib;
    }
    if (_entityAttribute instanceof SingleValueAttribute$1) {
        _propertyInput = new SingleValueAttribute$1(entity.getEntityId() + "[" + propertyName.toLowerCase() + "]", propertyName, entity);
        _propertyInput.getValue().setValue(_entityAttribute.getValue().getValue());
        if (_entityAttribute.getRootSubjectEntity().constructor.name === "Edge") {
            const edgeMap = y.getMap("edges");
            var ymap = edgeMap.get(entity.getEntityId());
            var ytext = ymap.get(entity.getEntityId() + "[" + propertyName.toLowerCase() + "]");
            ytext.bind(_propertyInput.getValue().get$node()[0]);
        }
        else {
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(entity.getEntityId());
            var ytext = ymap.get(entity.getEntityId() + "[" + propertyName.toLowerCase() + "]");
            ytext.bind(_propertyInput.getValue().get$node()[0]);
        }
        _$node
            .find(".property-input")
            .append(_propertyInput.get$node().find(".val").prop("disabled", false));
    }
    else if (_entityAttribute instanceof SingleSelectionAttribute$1) {
        var options = _entityAttribute.getOptions();
        _propertyInput = new SingleSelectionAttribute$1(entity.getEntityId() + "[" + propertyName.toLowerCase() + "]", propertyName, entity, options, true);
        _propertyInput.getValue().setValue(_entityAttribute.getValue().getValue());
        _propertyInput
            .getValue()
            .get$node()
            .bind("change", function (ev) {
            _entityAttribute
                .getValue()
                .setValue(_propertyInput.getValue().getValue());
        });
        _$node.find(".property-input").append(_propertyInput.getValue().get$node());
        _$node.find(".property-input").click(function (ev) {
            ev.stopPropagation();
        });
    }
    else if (_entityAttribute instanceof IntegerAttribute$1) {
        _propertyInput = new IntegerAttribute$1(entity.getEntityId() + "[" + propertyName.toLowerCase() + "]", propertyName, entity, true);
        _propertyInput.getValue().setValue(_entityAttribute.getValue().getValue());
        _entityAttribute
            .get$node()
            .find(".val")
            .bind("change", function () {
            _propertyInput
                .getValue()
                .setValue(_entityAttribute.getValue().getValue());
        });
        _propertyInput
            .get$node()
            .find(".val")
            .bind("change", function (ev) {
            _entityAttribute
                .getValue()
                .setValue(_propertyInput.getValue().getValue());
        });
        _$node
            .find(".property-input")
            .append(_propertyInput.get$node().find(".val").prop("disabled", false));
        _$node.find(".property-input").click(function (ev) {
            ev.stopPropagation();
        });
    }
    else if (_entityAttribute instanceof BooleanAttribute$1) {
        _propertyInput = new BooleanAttribute$1(entity.getEntityId() + "[" + propertyName.toLowerCase() + "]", propertyName, entity, true);
        _propertyInput.getValue().setValue(_entityAttribute.getValue().getValue());
        _entityAttribute
            .get$node()
            .find(".val")
            .bind("change", function () {
            _propertyInput
                .getValue()
                .setValue(_entityAttribute.getValue().getValue());
        });
        _propertyInput
            .get$node()
            .find(".val")
            .bind("change", function (ev) {
            _entityAttribute
                .getValue()
                .setValue(_propertyInput.getValue().getValue());
        });
        _$node
            .find(".property-input")
            .append(_propertyInput.get$node().find(".val"));
        _$node.find(".property-input").click(function (ev) {
            ev.stopPropagation();
        });
    }
    else if (_entityAttribute instanceof FileAttribute$1) {
        _propertyInput = new FileAttribute$1(entity.getEntityId() + "[" + propertyName.toLowerCase() + "]", propertyName, entity, true);
        _propertyInput.getValue().setValue(_entityAttribute.getValue().getValue());
        _propertyInput.getValue().setValue(_entityAttribute.getValue().getValue());
        _$node.find(".property-input").append(_propertyInput.getValue().get$node());
        _$node.find(".property-input").click(function (ev) {
            ev.stopPropagation();
        });
    }
    if (_propertyInput)
        _propertyInput
            .get$node()
            .find(".val")
            .keypress(function (ev) {
            if (ev.which == 13) {
                _$node.find(".bs-dropdown-toggle").dropdown("toggle");
            }
        });
    _$node.hover(function () {
        if (_entityId)
            _canvas.highlightEntity(_entityId);
    }, function () {
        if (_entityId)
            _canvas.unhighlightEntity(_entityId);
    });
    this.get$node = function () {
        return _$node;
    };
}
let MoveTool$1 = class MoveTool extends AbstractCanvasTool {
    constructor() {
        super(MoveTool$1.TYPE, "tool-move", "Move Nodes and Edges");
        this.mount = function () {
            AbstractCanvasTool.prototype.mount.call(this);
            this.getCanvas().bindMoveToolEvents();
        };
        this.unmount = function () {
            AbstractCanvasTool.prototype.unmount.call(this);
            this.getCanvas().unbindMoveToolEvents();
        };
    }
    static { this.TYPE = "MoveTool"; }
};
class AbstractCanvas {
    constructor($node) {
        var that = this;
        var _tools = {};
        var _currentToolName = null;
        var _$node = $node;
        this.get$canvas = function () {
            return _$node;
        };
        this.addTool = function (name, tool) {
            if (!_tools.hasOwnProperty(name) &&
                typeof tool.mount === "function" &&
                typeof tool.unmount === "function" &&
                typeof tool.setCanvas === "function") {
                tool.setCanvas(this);
                _tools[name] = tool;
            }
        };
        this.getTool = function (name) {
            if (_tools.hasOwnProperty(name)) {
                return _tools[name];
            }
            return null;
        };
        this.mountTool = function (name, defaultLabel, defaultAttributeValues) {
            if (_currentToolName && _tools[_currentToolName])
                _tools[_currentToolName].unmount();
            if (_tools.hasOwnProperty(name)) {
                _tools[name].mount(defaultLabel, defaultAttributeValues);
            }
            else {
                if (name !== "MoveTool") {
                    throw new Error("Tool " + name + " not found");
                }
                _tools["MoveTool"].mount();
            }
            _currentToolName = name;
        };
        this.remountCurrentTool = function () {
            that.mountTool(_currentToolName);
        };
        this.getCurrentToolName = function () {
            return _currentToolName;
        };
        this.removeTools = function () {
            _tools = {};
        };
    }
}
class Canvas extends AbstractCanvas {
    constructor($node, y = window.y) {
        super($node);
        var that = this;
        var _$node = $node;
        var _zoom = 1;
        var _canvasWidth = 9000;
        this.width = _canvasWidth;
        var _canvasHeight = 9000;
        this.height = _canvasHeight;
        var _modelAttributesNode = null;
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
        var _selectedEntity = null;
        var canvasOffset = _$node.offset();
        var _guidanceBox = null;
        var _guidanceBoxLabel = "";
        var _guidanceDefinition = null;
        var _ghostEdges = [];
        var _guidanceBoxEntityId = null;
        const jsPlumbInstance = newInstance({
            container: _$node.get(0),
            elementsDraggable: true,
            connectionsDetachable: false,
            dragOptions: {
                filter: ".resizing",
            },
        });
        window.jsPlumbInstance = jsPlumbInstance;
        $(window).resize(function () {
            sendViewChangeOperation();
        });
        var processToolSelectOperation = function (operation) {
            that.mountTool(operation.getSelectedToolName(), operation.getDefaultLabel(), operation.getDefaultAttributeValues());
        };
        var processNodeAddOperation = function (operation) {
            var node;
            if (operation.getJSON()) {
                node = EntityManagerInstance$1.createNodeFromJSON(operation.getType(), operation.getEntityId(), operation.getLeft(), operation.getTop(), operation.getWidth(), operation.getHeight(), operation.getZIndex(), operation.getContainment(), operation.getJSON());
            }
            else {
                node = EntityManagerInstance$1.createNode(operation.getType(), operation.getEntityId(), operation.getLeft(), operation.getTop(), operation.getWidth(), operation.getHeight(), operation.getZIndex(), operation.getContainment());
            }
            if (operation.getDefaultLabel()) {
                node.getLabel().getValue().setValue(operation.getDefaultLabel());
            }
            if (operation.getDefaultAttributeValues()) {
                for (const [key, value] of Object.entries(operation.getDefaultAttributeValues())) {
                    node.getAttribute(key).getValue().setValue(value);
                }
            }
            const userMap = y.getMap("users");
            if (userMap.get(y.clientID) !== operation.getJabberId()) {
                const userList = y.getMap("userList");
                var color = Util.getColor(userList.get(operation.getJabberId()).globalId);
                node.refreshTraceAwareness(color);
            }
            if (y)
                node.registerYMap();
            node.draw();
            node.addToCanvas(that);
            node.bindMoveToolEvents();
            that.remountCurrentTool();
        };
        var propagateNodeAddOperation = function (operation) {
            processNodeAddOperation(operation);
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.HEATMAP, operation.getOTOperation());
            const activityMap = y.getMap("activity");
            activityMap.set(ActivityOperation.TYPE, new ActivityOperation("NodeAddActivity", operation.getEntityId(), _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], NodeAddOperation.getOperationDescription(operation.getType()), {
                nodeType: operation.getType(),
            }).toJSON());
        };
        var processEdgeAddOperation = function (operation) {
            var edge;
            if (operation.getJSON()) {
                edge = EntityManagerInstance$1.createEdgeFromJSON(operation.getType(), operation.getEntityId(), operation.getSource(), operation.getTarget(), operation.getJSON());
            }
            else {
                edge = EntityManagerInstance$1.createEdge(operation.getType(), operation.getEntityId(), EntityManagerInstance$1.findNode(operation.getSource()), EntityManagerInstance$1.findNode(operation.getTarget()));
            }
            if (window.hasOwnProperty("y"))
                edge.registerYMap();
            edge.connect();
            edge.addToCanvas(that);
            edge.bindMoveToolEvents();
            that.remountCurrentTool();
        };
        var propagateEdgeAddOperation = function (operation) {
            var sourceNode = EntityManagerInstance$1.findNode(operation.getSource());
            var targetNode = EntityManagerInstance$1.findNode(operation.getTarget());
            processEdgeAddOperation(operation);
            EntityManagerInstance$1.storeDataYjs();
            _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.getOTOperation());
            const activityMap = y.getMap("activity");
            activityMap.set(ActivityOperation.TYPE, new ActivityOperation("EdgeAddActivity", operation.getEntityId(), _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], EdgeAddOperation.getOperationDescription(operation.getType(), "", sourceNode.getLabel().getValue().getValue(), sourceNode.getType(), targetNode.getType(), targetNode.getLabel().getValue().getValue()), {
                nodeType: operation.getType(),
                sourceNodeId: operation.getSource(),
                sourceNodeLabel: sourceNode.getLabel().getValue().getValue(),
                sourceNodeType: sourceNode.getType(),
                targetNodeId: operation.getTarget(),
                targetNodeLabel: targetNode.getLabel().getValue().getValue(),
                targetNodeType: targetNode.getType(),
            }).toJSON());
        };
        var remoteNodeAddCallback = function (operation) {
            if (operation instanceof NodeAddOperation) {
                _iwcw.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.HEATMAP, operation.getOTOperation());
                if (operation.getViewId() === EntityManagerInstance$1.getViewId() &&
                    EntityManagerInstance$1.getLayer() === CONFIG$1.LAYER.META) {
                    processNodeAddOperation(operation);
                }
                else if (EntityManagerInstance$1.getLayer() === CONFIG$1.LAYER.MODEL) {
                    var type, node, viewType;
                    if (!operation.getViewId()) {
                        type = operation.getType();
                    }
                    else {
                        type = operation.getOriginType();
                    }
                    if (EntityManagerInstance$1.getViewId()) {
                        viewType = EntityManagerInstance$1.getNodeType(type).VIEWTYPE;
                        if (viewType) {
                            type = viewType;
                        }
                    }
                    if (operation.getJSON()) {
                        node = EntityManagerInstance$1.createNodeFromJSON(type, operation.getEntityId(), operation.getLeft(), operation.getTop(), operation.getWidth(), operation.getHeight(), operation.getZIndex(), operation.getContainment(), operation.getJSON());
                    }
                    else {
                        node = EntityManagerInstance$1.createNode(type, operation.getEntityId(), operation.getLeft(), operation.getTop(), operation.getWidth(), operation.getHeight(), operation.getZIndex(), operation.getContainment());
                    }
                    if (operation.getDefaultLabel()) {
                        node.getLabel().getValue().setValue(operation.getDefaultLabel());
                    }
                    if (operation.getDefaultAttributeValues()) {
                        for (const [key, value] of Object.entries(operation.getDefaultAttributeValues())) {
                            node.getAttribute(key).getValue().setValue(value);
                        }
                    }
                    node.registerYMap();
                    node.draw();
                    node.addToCanvas(that);
                    node.bindMoveToolEvents();
                    if (!viewType && EntityManagerInstance$1.getViewId()) {
                        node.hide();
                    }
                    else {
                        const userMap = y.getMap("users");
                        if (userMap.get(y.clientID) !== operation.getJabberId() &&
                            operation.getJabberId() != null) {
                            const userList = y.getMap("userList");
                            var color = Util.getColor(userList.get(operation.getJabberId()).globalId);
                            node.refreshTraceAwareness(color);
                        }
                    }
                    that.remountCurrentTool();
                }
            }
        };
        var sendViewChangeOperation = function () {
            var canvasFrame = $("#canvas-frame");
            var operation = new CanvasViewChangeOperation(_$node.position().left, _$node.position().top, canvasFrame.width(), canvasFrame.height(), _zoom);
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.HEATMAP, operation.toNonOTOperation());
        };
        var remoteEdgeAddCallback = function (operation) {
            if (operation instanceof EdgeAddOperation) {
                EntityManagerInstance$1.findNode(operation.getSource());
                EntityManagerInstance$1.findNode(operation.getTarget());
                if (operation.getViewId() === EntityManagerInstance$1.getViewId() ||
                    EntityManagerInstance$1.getLayer() === CONFIG$1.LAYER.META) {
                    processEdgeAddOperation(operation);
                }
                else if (EntityManagerInstance$1.getLayer() === CONFIG$1.LAYER.MODEL) {
                    var type, edge, viewType;
                    if (!operation.getViewId()) {
                        type = operation.getType();
                    }
                    else {
                        type = operation.getOriginType();
                    }
                    if (EntityManagerInstance$1.getViewId()) {
                        viewType = EntityManagerInstance$1.getEdgeType(type).VIEWTYPE;
                        if (viewType) {
                            type = viewType;
                        }
                    }
                    if (operation.getJSON()) {
                        edge = EntityManagerInstance$1.createEdgeFromJSON(type, operation.getEntityId(), operation.getSource(), operation.getTarget(), operation.getJSON());
                    }
                    else {
                        edge = EntityManagerInstance$1.createEdge(type, operation.getEntityId(), EntityManagerInstance$1.findNode(operation.getSource()), EntityManagerInstance$1.findNode(operation.getTarget()));
                    }
                    edge.registerYMap();
                    edge.connect();
                    edge.addToCanvas(that);
                    if (!viewType && EntityManagerInstance$1.getViewId()) {
                        edge.hide();
                    }
                    that.remountCurrentTool();
                }
            }
        };
        var localToolSelectCallback = function (operation) {
            if (operation instanceof ToolSelectOperation) {
                processToolSelectOperation(operation);
            }
        };
        var localShowGuidanceBoxCallback = function (operation) {
            if (operation instanceof ShowGuidanceBoxOperation) {
                processShowGuidanceBoxOperation(operation);
            }
        };
        var processShowGuidanceBoxOperation = function (operation) {
            _guidanceDefinition = operation.getGuidance();
            _guidanceBoxLabel = operation.getLabel();
            that.showGuidanceBox(operation.getEntityId());
        };
        var localExportMetaModelCallback = function (operation) {
            if (operation instanceof ExportMetaModelOperation) {
                if (operation.getData() === null) {
                    operation.setData(EntityManagerInstance$1.generateMetaModel());
                    _iwcw.sendLocalNonOTOperation(operation.getRequestingComponent(), operation.toNonOTOperation());
                }
                else {
                    var data = operation.getData();
                    var op = new ActivityOperation("EditorGenerateActivity", "-1", _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], '..generated new Editor <a href="' +
                        data.spaceURI +
                        '" target="_blank">' +
                        data.spaceTitle +
                        "</a>", {});
                    const activityMap = y.getMap("activity");
                    activityMap.set("EditorGenerateActivity", op.toJSON());
                }
            }
        };
        var localMoveCanvasOperation = function (operation) {
            if (operation instanceof MoveCanvasOperation) {
                that.scrollEntityIntoView(operation.getObjectId());
            }
        };
        var localExportLogicalGuidanceRepresentationCallback = function (operation) {
            if (operation instanceof ExportLogicalGuidanceRepresentationOperation) {
                if (operation.getData() === null) {
                    operation.setData(EntityManagerInstance$1.generateLogicalGuidanceRepresentation());
                    _iwcw.sendLocalNonOTOperation(operation.getRequestingComponent(), operation.toNonOTOperation());
                }
            }
        };
        var localGuidanceStrategyOperationCallback = function (operation) {
            const canvasMap = y.getMap("canvas");
            if (operation instanceof GuidanceStrategyOperation) {
                canvasMap.set(GuidanceStrategyOperation.TYPE, operation.toJSON());
            }
        };
        var localRevokeSharedActivityOperationCallback = function (operation) {
            if (operation instanceof RevokeSharedActivityOperation) {
                const canvasMap = y.getMap("canvas");
                canvasMap.set(RevokeSharedActivityOperation.TYPE, operation.toJSON());
            }
        };
        var remoteGuidanceStrategyOperation = function (operation) {
            if (operation instanceof GuidanceStrategyOperation) {
                _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.toNonOTOperation());
            }
        };
        var remoteRevokeSharedActivityOperationCallback = function (operation) {
            if (operation instanceof RevokeSharedActivityOperation) {
                _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.toNonOTOperation());
            }
        };
        var localExportImageCallback = function (operation) {
            if (operation instanceof ExportImageOperation) {
                that.toPNG().then(function (url) {
                    operation.setData(url);
                    _iwcw.sendLocalNonOTOperation(operation.getRequestingComponent(), operation.toNonOTOperation());
                });
            }
        };
        var init = function () {
            var $canvasFrame = _$node.parent();
            that.addTool(MoveTool$1.TYPE, new MoveTool$1());
            _$node.css({
                width: _canvasWidth,
                height: _canvasHeight,
                left: (-_canvasWidth + $canvasFrame.width()) / 2,
                top: (-_canvasHeight + $canvasFrame.height()) / 2,
            });
            _$node.draggable({
                stop: function () {
                    sendViewChangeOperation();
                },
            });
            if (_$node.transformable != null) {
                _$node.transformable({
                    rotatable: false,
                    skewable: false,
                    scalable: false,
                });
            }
            _$node.mousewheel(function (event) {
                that.setZoom(that.getZoom() + 0.1 * event.deltaY);
                event.preventDefault();
            });
        };
        this.get$node = function () {
            return _$node;
        };
        this.showGuidanceBox = function (entityId) {
            this.hideGuidanceBox();
            var entity;
            if (typeof entityId == "undefined") {
                entityId = _guidanceBoxEntityId;
            }
            else {
                _guidanceBoxEntityId = entityId;
            }
            if (_guidanceDefinition === null)
                return;
            if (_guidanceDefinition.length == 0)
                return;
            if (!entityId)
                entityId = _selectedEntity.getEntityId();
            entity = EntityManagerInstance$1.findNode(entityId);
            if (!entity)
                return;
            var entityAppearance = entity.getAppearance();
            var appearance = {
                top: entityAppearance.top,
                left: entityAppearance.left,
                width: entityAppearance.width,
                height: entityAppearance.height,
            };
            appearance.top += entityAppearance.height + 10;
            appearance.left += entityAppearance.width / 2;
            _guidanceBox = new GuidanceBox(Util.generateRandomId(), _guidanceBoxLabel, appearance.left, appearance.top);
            var inView = false;
            if (EntityManagerInstance$1.getViewId() != null &&
                EntityManagerInstance$1.getLayer() === CONFIG$1.LAYER.MODEL) {
                inView = true;
            }
            for (var i = 0; i < _guidanceDefinition.length; i++) {
                var guidanceItem = null;
                switch (_guidanceDefinition[i].type) {
                    case "SELECT_TOOL_GUIDANCE":
                        var tool;
                        if (inView &&
                            EntityManagerInstance$1.getNodeType(_guidanceDefinition[i].tool)
                                .VIEWTYPE === null)
                            continue;
                        else if (inView)
                            tool = EntityManagerInstance$1.getNodeType(_guidanceDefinition[i].tool).VIEWTYPE;
                        else
                            tool = _guidanceDefinition[i].tool;
                        guidanceItem = new SelectToolGuidance(_guidanceDefinition[i].id, _guidanceDefinition[i].label, tool, that, _guidanceDefinition[i].icon);
                        break;
                    case "SET_PROPERTY_GUIDANCE":
                        var entity = EntityManagerInstance$1.findNode(_guidanceDefinition[i].entityId);
                        if (!entity)
                            entity = EntityManagerInstance$1.findEdge(_guidanceDefinition[i].entityId);
                        guidanceItem = new SetPropertyGuidance(_guidanceDefinition[i].id, _guidanceDefinition[i].label, entity, _guidanceDefinition[i].propertyName, that);
                        break;
                    case "COLLABORATION_GUIDANCE":
                        guidanceItem = new CollaborationGuidance("", _guidanceDefinition[i].label, _guidanceDefinition[i].activityId, _guidanceDefinition[i].objectId, that);
                        break;
                    case "GHOST_EDGE_GUIDANCE":
                        var relationshipType;
                        if (inView &&
                            EntityManagerInstance$1.getEdgeType(_guidanceDefinition[i].relationshipType)
                                .VIEWTYPE === undefined)
                            continue;
                        else if (inView) {
                            relationshipType = EntityManagerInstance$1.getEdgeType(_guidanceDefinition[i].relationshipType).VIEWTYPE;
                        }
                        else {
                            relationshipType = _guidanceDefinition[i].relationshipType;
                        }
                        that.showGhostEdge(_guidanceDefinition[i].sourceId, _guidanceDefinition[i].targetId, relationshipType);
                        break;
                }
                if (guidanceItem)
                    _guidanceBox.addGuidance(guidanceItem);
            }
            _guidanceBox.addToCanvas(that);
            _guidanceBox.draw();
        };
        this.hideGuidanceBox = function () {
            if (_guidanceBox !== null)
                _guidanceBox.remove();
            _guidanceBox = null;
            for (var i = 0; i < _ghostEdges.length; i++) {
                _ghostEdges[i].remove();
            }
            _ghostEdges = [];
        };
        this.setModelAttributesNode = function (node) {
            _modelAttributesNode = node;
        };
        this.getModelAttributesNode = function () {
            return _modelAttributesNode;
        };
        this.bindMoveToolEvents = function () {
            _$node.draggable("enable");
            const widgetConfigMap = y.getMap("widgetConfig");
            var viewOnly = widgetConfigMap.get("view_only");
            if (viewOnly) {
                $.contextMenu({
                    selector: "#" + _$node.attr("id"),
                    build: function ($trigger, e) {
                        return false;
                    },
                });
                return;
            }
            $.contextMenu({
                selector: "#" + _$node.attr("id"),
                zIndex: AbstractEntity$1.CONTEXT_MENU_Z_INDEX,
                build: function ($trigger, e) {
                    if (_selectedEntity === null) {
                        return {
                            items: {
                                addNode: {
                                    name: "Add node..",
                                    items: EntityManagerInstance$1.generateAddNodeMenu(that, e.originalEvent.offsetX, e.originalEvent.offsetY),
                                },
                                hide: {
                                    name: "Hide entities..",
                                    items: {
                                        nodes: {
                                            name: "nodes..",
                                            items: EntityManagerInstance$1.generateVisibilityNodeMenu("hide"),
                                        },
                                        edges: {
                                            name: "edges..",
                                            items: EntityManagerInstance$1.generateVisibilityEdgeMenu("hide"),
                                        },
                                    },
                                },
                                show: {
                                    name: "Show entities..",
                                    items: {
                                        nodes: {
                                            name: "nodes..",
                                            items: EntityManagerInstance$1.generateVisibilityNodeMenu("show"),
                                        },
                                        edges: {
                                            name: "edges..",
                                            items: EntityManagerInstance$1.generateVisibilityEdgeMenu("show"),
                                        },
                                    },
                                },
                            },
                        };
                    }
                    else {
                        that.select(null);
                        return false;
                    }
                },
            });
        };
        this.unbindMoveToolEvents = function () {
            _$node.draggable("disable");
            if (_$node.transformable != null) {
                _$node.transformable("destroy");
            }
            _$node.unbind("contextmenu");
        };
        this.select = function (entity) {
            if (_selectedEntity != entity) {
                if (_selectedEntity)
                    _selectedEntity.unselect();
                if (entity)
                    entity.select();
            }
            var operation = new EntitySelectOperation(entity ? entity.getEntityId() : null, entity ? entity.getType() : null, _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.toNonOTOperation());
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.GUIDANCE, operation.toNonOTOperation());
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.METADATA, operation.toNonOTOperation());
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.OPENAPI, operation.toNonOTOperation());
            const selectionMap = y.getMap("select");
            const userMap = y.getMap("users");
            if (entity === null) {
                selectionMap.set(userMap.get(y.clientID), null);
            }
            else {
                selectionMap.set(userMap.get(y.clientID), entity.getEntityId());
            }
            _selectedEntity = entity;
        };
        this.getSelectedEntity = function () {
            return _selectedEntity;
        };
        this.setZoom = function (zoom) {
            if (zoom < 0.1 || zoom > 2) {
                return;
            }
            _zoom = zoom;
            _$node.css("transform", `scaleX(${zoom}) scaleY(${zoom})`);
            _$node.animate({
                transform: `scaleX(${zoom}) scaleY(${zoom})`,
            });
            window.jsPlumbInstance.setZoom(zoom);
            sendViewChangeOperation();
        };
        this.showGhostEdge = function (sourceId, targetId, relationshipType) {
            var source = EntityManagerInstance$1.findNode(sourceId);
            var target = EntityManagerInstance$1.findNode(targetId);
            if (!source || !target) {
                return;
            }
            var ghostEdgeGuidance = null;
            for (var i = 0; i < _ghostEdges.length; i++) {
                var ghostEdge = _ghostEdges[i];
                var node1 = ghostEdge.getNode1();
                var node2 = ghostEdge.getNode2();
                if ((source == node1 && target == node2) ||
                    (source == node2 && target == node1)) {
                    ghostEdgeGuidance = ghostEdge;
                    break;
                }
            }
            if (!ghostEdgeGuidance) {
                ghostEdgeGuidance = new GhostEdgeGuidance(that, source, target);
                _ghostEdges.push(ghostEdgeGuidance);
            }
            if (EntityManagerInstance$1.getViewId() &&
                EntityManagerInstance$1.getLayer() === CONFIG$1.LAYER.MODEL) {
                ghostEdgeGuidance.addEdge(EntityManagerInstance$1.getViewEdgeType(relationshipType), source, target);
            }
            else {
                ghostEdgeGuidance.addEdge(EntityManagerInstance$1.getEdgeType(relationshipType), source, target);
            }
            for (var j = 0; j < _ghostEdges.length; j++) {
                _ghostEdges[j].show();
            }
        };
        this.highlightEntity = function (entityId) {
            var entity = EntityManagerInstance$1.findNode(entityId);
            if (entity)
                entity.highlight("blue", "Set property");
            else {
                entity = EntityManagerInstance$1.findEdge(entityId);
                entity.highlight("blue");
            }
        };
        this.unhighlightEntity = function (entityId) {
            var entity = EntityManagerInstance$1.findNode(entityId);
            if (!entity)
                entity = EntityManagerInstance$1.findEdge(entityId);
            entity.unhighlight();
        };
        this.getZoom = function () {
            return _zoom;
        };
        this.resetTool = function () {
            var operation = new ToolSelectOperation(MoveTool$1.TYPE);
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.PALETTE, operation.toNonOTOperation());
            this.mountTool(MoveTool$1.TYPE);
        };
        this.createNode = function (type, left, top, width, height, zIndex, containment, json, identifier, historyFlag, defaultLabel, defaultAttributeValues) {
            var id, oType = null;
            if (identifier)
                id = identifier;
            else
                id = Util.generateRandomId(24);
            zIndex = zIndex || AbstractEntity$1.maxZIndex + 1;
            if (EntityManagerInstance$1.getViewId() !== undefined &&
                EntityManagerInstance$1.getLayer() === CONFIG$1.LAYER.MODEL) {
                oType = EntityManagerInstance$1.getViewNodeType(type).getTargetNodeType().TYPE;
            }
            var operation = new NodeAddOperation(id, type, left, top, width, height, zIndex, containment, json || null, EntityManagerInstance$1.getViewId(), oType, _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], defaultLabel, defaultAttributeValues);
            try {
                propagateNodeAddOperation(operation);
            }
            catch (error) {
                console.error(error);
            }
            if (y) {
                const canvasMap = y.getMap("canvas");
                canvasMap.set(NodeAddOperation.TYPE, operation.toJSON());
            }
            if (!historyFlag)
                HistoryManagerInstance.add(operation);
            return id;
        };
        this.createEdge = function (type, source, target, json, identifier, historyFlag) {
            var id = null, oType = null;
            if (identifier)
                id = identifier;
            else
                id = Util.generateRandomId(24);
            if (EntityManagerInstance$1.getViewId() !== undefined &&
                EntityManagerInstance$1.getLayer() === CONFIG$1.LAYER.MODEL) {
                oType = EntityManagerInstance$1.getViewEdgeType(type).getTargetEdgeType().TYPE;
            }
            var operation = new EdgeAddOperation(id, type, source, target, json || null, EntityManagerInstance$1.getViewId(), oType, _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
            propagateEdgeAddOperation(operation);
            if (window.hasOwnProperty("y")) {
                const canvasMap = y.getMap("canvas");
                canvasMap.set(EdgeAddOperation.TYPE, operation.toJSON());
            }
            if (!historyFlag)
                HistoryManagerInstance.add(operation);
            return id;
        };
        this.scrollNodeIntoView = function (node) {
            if (!node)
                return;
            var frameOffset = $("#canvas-frame").offset();
            var frameWidth = $("#canvas-frame").width();
            var frameHeight = $("#canvas-frame").height();
            var nodeOffset = node.get$node().offset();
            var nodeWidth = node.get$node().width();
            var nodeHeight = node.get$node().height();
            var scrollX = nodeOffset.left - frameOffset.left;
            var scrollY = nodeOffset.top - frameOffset.top;
            _$node.position().top;
            _$node.position().left;
            _$node.animate({
                top: "+=" + (frameHeight / 2 - scrollY - nodeHeight / 2),
                left: "+=" + (frameWidth / 2 - scrollX - nodeWidth / 2),
            }, 1000);
        };
        this.scrollEdgeIntoView = function (edge) {
            if (!edge)
                return;
            var frameOffset = $("#canvas-frame").offset();
            var frameWidth = $("#canvas-frame").width();
            var frameHeight = $("#canvas-frame").height();
            var srcNode = edge.getSource();
            var targetNode = edge.getTarget();
            var srcNodeOffset = srcNode.get$node().offset();
            var srcNodeWidth = srcNode.get$node().width();
            var srcNodeHeight = srcNode.get$node().height();
            var targetNodeOffset = targetNode.get$node().offset();
            var targetNodeWidth = targetNode.get$node().width();
            var targetNodeHeight = targetNode.get$node().height();
            var scrollX = (srcNodeOffset.left + targetNodeOffset.left) / 2 - frameOffset.left;
            var scrollY = (srcNodeOffset.top + targetNodeOffset.top) / 2 - frameOffset.top;
            _$node.position().top;
            _$node.position().left;
            _$node.animate({
                top: "+=" +
                    (frameHeight / 2 -
                        scrollY -
                        Math.max(srcNodeHeight, targetNodeHeight) / 2),
                left: "+=" +
                    (frameWidth / 2 -
                        scrollX -
                        Math.max(srcNodeWidth, targetNodeWidth) / 2),
            }, 1000);
        };
        this.scrollEntityIntoView = function (entityId) {
            if (!entityId)
                return null;
            if (entityId.indexOf("[") != -1 && entityId.indexOf("]") != -1)
                entityId = entityId.replace(/\[\w*\]/g, "");
            var entity = EntityManagerInstance$1.findNode(entityId);
            if (!entity) {
                entity = EntityManagerInstance$1.findEdge(entityId);
                if (!entity)
                    return null;
                else
                    that.scrollEdgeIntoView(entity);
            }
            else
                that.scrollNodeIntoView(entity);
            return true;
        };
        this.toPNG = function () {
            var $renderedCanvas = $("<canvas></canvas>")
                .insertAfter(_$node)
                .attr("width", _$node.width())
                .attr("height", _$node.height()), ctx = $renderedCanvas[0].getContext("2d"), deferred = $.Deferred(), promises = [], oldZoom = this.getZoom();
            $("#loading").show();
            this.setZoom(1);
            canvasOffset = _$node.offset();
            ctx.beginPath();
            ctx.rect(0, 0, _canvasWidth, _canvasHeight);
            ctx.fillStyle = _$node.css("backgroundColor");
            ctx.fill();
            _.each(_.sortBy($.makeArray(_$node.children()), function (e) {
                return $(e).css("zIndex");
            }), function (e) {
                var $this = $(e);
                if (typeof $this.attr("id") === "undefined" ||
                    (!$this.attr("id").startsWith("modelAttributes") &&
                        !$this.attr("id").endsWith("awareness"))) {
                    promises.push(convertNodeTreeToCanvas($this, ctx));
                }
            });
            $.when.apply($, promises).then(function () {
                var tempCanvas = document.createElement("canvas"), tCtx = tempCanvas.getContext("2d"), minLeft = _canvasWidth, minTop = _canvasHeight, maxRight = 0, maxBottom = 0, nodes = EntityManagerInstance$1.getNodes(), nodeId, appearance, width, height, padding = 20, nodeExists = false;
                for (nodeId in nodes) {
                    if (nodes.hasOwnProperty(nodeId)) {
                        nodeExists = true;
                        appearance = nodes[nodeId].getAppearance();
                        minLeft = Math.min(minLeft, appearance.left);
                        minTop = Math.min(minTop, appearance.top);
                        maxRight = Math.max(maxRight, appearance.left + appearance.width);
                        maxBottom = Math.max(maxBottom, appearance.top + appearance.height);
                    }
                }
                if (!nodeExists) {
                    minLeft = _canvasWidth / 2;
                    minTop = _canvasHeight / 2;
                    maxRight = _canvasWidth / 2;
                    maxBottom = _canvasHeight / 2;
                }
                minLeft -= padding;
                minTop -= padding;
                maxRight += padding;
                maxBottom += padding;
                width = maxRight - minLeft;
                height = maxBottom - minTop;
                tempCanvas.width = width;
                tempCanvas.height = height;
                tCtx.drawImage($renderedCanvas[0], minLeft, minTop, width, height, 0, 0, width, height);
                that.setZoom(oldZoom);
                $("#loading").hide();
                deferred.resolve(tempCanvas.toDataURL());
            });
            return deferred.promise();
        };
        var convertNodeTreeToCanvas = function ($node, ctx) {
            function drawSVGOnCanvas(ctx, svgMarkup, x, y) {
                var svg = new Blob([svgMarkup], {
                    type: "image/svg+xml;charset=utf-8",
                }), DOMURL = self.URL || self.webkitURL || self, url = DOMURL.createObjectURL(svg), img = new Image(), deferred = $.Deferred();
                img.onload = function () {
                    ctx.drawImage(img, x, y);
                    DOMURL.revokeObjectURL(url);
                    deferred.resolve();
                };
                img.src = url;
                setTimeout(function () {
                    deferred.resolve();
                }, 500);
                return deferred.promise();
            }
            function convertNodeToSVG($node) {
                if ($node[0].nodeType === Node.TEXT_NODE) {
                    if ($.trim($node.text()) === "") {
                        return $.Deferred().resolve().promise();
                    }
                    else {
                        $node = $node.wrap($("<span></span>")).parent();
                    }
                }
                if (!$node.is(":visible")) {
                    return $.Deferred().resolve().promise();
                }
                var height = $node.height(), width = $node.width(), padding = {
                    left: parseInt($node.css("paddingLeft"), 10),
                    top: parseInt($node.css("paddingTop"), 10),
                    right: parseInt($node.css("paddingRight"), 10),
                    bottom: parseInt($node.css("paddingBottom"), 10),
                }, border = {
                    width: parseInt($node.css("borderWidth")),
                    color: $node.css("borderColor"),
                    left: {
                        width: parseInt($node.css("borderLeftWidth")),
                        color: $node.css("borderLeftColor"),
                    },
                    top: {
                        width: parseInt($node.css("borderTopWidth")),
                        color: $node.css("borderTopColor"),
                    },
                    right: {
                        width: parseInt($node.css("borderRightWidth")),
                        color: $node.css("borderRightColor"),
                    },
                    bottom: {
                        width: parseInt($node.css("borderBottomWidth")),
                        color: $node.css("borderBottomColor"),
                    },
                }, borderMarkup = [], backgroundColor = $node.css("backgroundColor"), color = $node.css("color"), font = $node.css("font"), fontSize = parseInt($node.css("fontSize"), 10), textDecoration = $node.css("textDecoration").split(" ")[0], offset = $node.offset(), value, textX, textY = height, textAnchor, contents = $node.contents();
                if ($node[0].nodeName.toLowerCase() === "svg") {
                    $node.attr("width", width);
                    $node.attr("height", height);
                    return drawSVGOnCanvas(ctx, $node[0].outerHTML
                        .replace(/style="[^"]*"/, "")
                        .replace(/http:\/\/www\.w3\.org\/1999\/xhtml/g, "http://www.w3.org/2000/svg"), offset.left - canvasOffset.left, offset.top - canvasOffset.top);
                }
                if (contents.length === 1 && contents[0].nodeType === Node.TEXT_NODE) {
                    value = $node.text();
                }
                else {
                    value = $node.val();
                }
                var tagsToReplace = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                };
                value = $.trim(value).replace(/[&<>]/g, function (tag) {
                    return tagsToReplace[tag] || tag;
                });
                switch ($node.css("textAlign")) {
                    case "right":
                        textX = width;
                        textAnchor = "right";
                        break;
                    case "center":
                        textX = width / 2;
                        textAnchor = "middle";
                        break;
                    default:
                    case "left":
                        textX = 0;
                        textAnchor = "left";
                        break;
                }
                textX += padding.left;
                textY +=
                    padding.top + border.width - Math.ceil((height - fontSize) / 2) - 1;
                height += padding.top + padding.bottom + 2 * border.width;
                width += padding.left + padding.right + 2 * border.width;
                if (border.color.split(" ").length !== 1 ||
                    border.width.split(" ").length !== 1) {
                    border.width = 0;
                    if (border.left.width > 0) {
                        borderMarkup.push('<line x1="0" y1="0" x2="0" y2="' +
                            height +
                            '" style="stroke:' +
                            border.left.color +
                            "; stroke-width:" +
                            border.left.width +
                            '" />');
                    }
                    if (border.top.width > 0) {
                        borderMarkup.push('<line x1="0" y1="0" x2="' +
                            width +
                            '" y2="0" style="stroke:' +
                            border.top.color +
                            "; stroke-width:" +
                            border.top.width +
                            '" />');
                    }
                    if (border.right.width > 0) {
                        borderMarkup.push('<line x1="' +
                            width +
                            '" y1="0" x2="' +
                            width +
                            '" y2="' +
                            height +
                            '" style="stroke:' +
                            border.right.color +
                            "; stroke-width:" +
                            border.right.width +
                            '" />');
                    }
                    if (border.bottom.width > 0) {
                        borderMarkup.push('<line x1="0" y1="' +
                            height +
                            '" x2="' +
                            width +
                            '" y2="' +
                            height +
                            '" style="stroke:' +
                            border.bottom.color +
                            "; stroke-width:" +
                            border.bottom.width +
                            '" />');
                    }
                }
                return drawSVGOnCanvas(ctx, '<svg xmlns="http://www.w3.org/2000/svg" width="' +
                    width +
                    '" height="' +
                    height +
                    '">' +
                    '<rect x="0" y="0" width="' +
                    width +
                    '" height="' +
                    height +
                    '" fill="' +
                    backgroundColor +
                    '" style="stroke: ' +
                    border.color +
                    "; stroke-width: " +
                    border.width +
                    '"/>' +
                    borderMarkup.join("\n") +
                    '<text x="' +
                    textX +
                    '" y="' +
                    textY +
                    '" fill="' +
                    color +
                    '" style="text-anchor: ' +
                    textAnchor +
                    "; font: " +
                    font +
                    "; text-decoration: " +
                    textDecoration +
                    ';">' +
                    value +
                    "</text>" +
                    "</svg>", offset.left - canvasOffset.left, offset.top - canvasOffset.top);
            }
            var contents = $node.contents();
            return convertNodeToSVG($node).then(function () {
                var promises = [];
                if (contents.length !== 1 || contents[0].nodeType !== Node.TEXT_NODE) {
                    contents.each(function () {
                        var $this = $(this);
                        if ($node[0].nodeName.toLowerCase() !== "svg") {
                            promises.push(convertNodeTreeToCanvas($this, ctx));
                        }
                    });
                }
                return $.when.apply($, promises).then(function () {
                    return true;
                });
            });
        };
        this.registerCallbacks = function () {
            _iwcw.registerOnDataReceivedCallback(localToolSelectCallback);
            _iwcw.registerOnDataReceivedCallback(localExportMetaModelCallback);
            _iwcw.registerOnDataReceivedCallback(localExportLogicalGuidanceRepresentationCallback);
            _iwcw.registerOnDataReceivedCallback(localExportImageCallback);
            _iwcw.registerOnDataReceivedCallback(localShowGuidanceBoxCallback);
            _iwcw.registerOnDataReceivedCallback(localRevokeSharedActivityOperationCallback);
            _iwcw.registerOnDataReceivedCallback(localMoveCanvasOperation);
            _iwcw.registerOnDataReceivedCallback(localGuidanceStrategyOperationCallback);
        };
        this.unregisterCallbacks = function () {
            _iwcw.unregisterOnDataReceivedCallback(localToolSelectCallback);
            _iwcw.unregisterOnDataReceivedCallback(localExportMetaModelCallback);
            _iwcw.unregisterOnDataReceivedCallback(localExportLogicalGuidanceRepresentationCallback);
            _iwcw.unregisterOnDataReceivedCallback(localExportImageCallback);
            _iwcw.unregisterOnDataReceivedCallback(localShowGuidanceBoxCallback);
            _iwcw.unregisterOnLocalDataReceivedCallback(localRevokeSharedActivityOperationCallback);
            _iwcw.unregisterOnLocalDataReceivedCallback(localMoveCanvasOperation);
            _iwcw.unregisterOnLocalDataReceivedCallback(localGuidanceStrategyOperationCallback);
        };
        init();
        if (window.hasOwnProperty("y")) {
            const canvasMap = y.getMap("canvas");
            canvasMap.observe(function (event) {
                var yUserId = event.currentTarget.doc.clientID;
                event.keysChanged.forEach(function (key) {
                    const data = event.currentTarget.get(key);
                    const eventTriggeredLocally = window.y.clientID === data.triggeredBy;
                    if (!eventTriggeredLocally || data.historyFlagSet) {
                        const userMap = y.getMap("users");
                        var jabberId = userMap.get(yUserId);
                        var operation;
                        switch (key) {
                            case NodeAddOperation.TYPE: {
                                operation = new NodeAddOperation(data.id, data.type, data.left, data.top, data.width, data.height, data.zIndex, data.containment, data.json, data.viewId, data.oType, jabberId || data.jabberId, data.defaultLabel, data.defaultAttributeValues);
                                remoteNodeAddCallback(operation);
                                break;
                            }
                            case EdgeAddOperation.TYPE: {
                                operation = new EdgeAddOperation(data.id, data.type, data.source, data.target, data.json, data.viewId, data.oType, jabberId || data.jabberId);
                                remoteEdgeAddCallback(operation);
                                break;
                            }
                            case RevokeSharedActivityOperation.TYPE: {
                                operation = new RevokeSharedActivityOperation(data.id);
                                remoteRevokeSharedActivityOperationCallback(operation);
                                break;
                            }
                            case GuidanceStrategyOperation.TYPE: {
                                operation = new GuidanceStrategyOperation(data.data);
                                remoteGuidanceStrategyOperation(operation);
                                break;
                            }
                            case "ViewApplyActivity": {
                                var activityOperation = new ActivityOperation("ViewApplyActivity", event.value.viewId, event.value.jabberId);
                                const activityMap = y.getMap("activity");
                                activityMap.set(ActivityOperation.TYPE, activityOperation.toJSON());
                                break;
                            }
                            case "triggerSave": {
                                if (data.value === _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID])
                                    EntityManagerInstance$1.storeDataYjs();
                                break;
                            }
                            case "applyLayout": {
                                DagreLayout$1.apply();
                                jsPlumbInstance.repaintEverything();
                                break;
                            }
                            case "highlight": {
                                var userId = _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID];
                                if (!event.value.remote && userId !== event.value.userId)
                                    return;
                                if (event.value.moveCanvasToEntity) {
                                    var entityId = event.value.moveCanvasToEntity;
                                    var entity = EntityManagerInstance$1.find(entityId);
                                    that.scrollEntityIntoView(entityId);
                                    that.select(entity);
                                }
                                for (var i = 0; i < event.value.entities.length; i++) {
                                    var entityId = event.value.entities[i];
                                    var entity = EntityManagerInstance$1.find(entityId);
                                    if (entity) {
                                        entity.highlight(event.value.color, event.value.label);
                                    }
                                }
                                break;
                            }
                            case "unhighlight": {
                                var userId = _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID];
                                if (!event.value.remote && userId !== event.value.userId)
                                    return;
                                for (var i = 0; i < event.value.entities.length; i++) {
                                    var entityId = event.value.entities[i];
                                    var entity = EntityManagerInstance$1.find(entityId);
                                    if (entity) {
                                        entity.unhighlight();
                                    }
                                }
                                break;
                            }
                            case NodeDeleteOperation.TYPE: {
                                var userId = _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID];
                                const nodesMap = y.getMap("nodes");
                                if (event.value.jabberId === userId)
                                    nodesMap.delete(event.value.entityId);
                                setTimeout(function () {
                                    EntityManagerInstance$1.storeDataYjs();
                                }, 300);
                                break;
                            }
                            case EdgeDeleteOperation.TYPE: {
                                break;
                            }
                        }
                    }
                    else if (key === "applyLayout") {
                        DagreLayout$1.apply();
                        EntityManagerInstance$1.storeDataYjs();
                    }
                });
            });
            const selectionMap = y.getMap("select");
            selectionMap.observe(function (event) {
                const array = Array.from(event.changes.keys.entries());
                array.forEach(([key, change]) => {
                    const userMap = y.getMap("users");
                    if (key !== userMap.get(y.clientID)) {
                        const userList = y.getMap("userList");
                        var userInfo = userList.get(key);
                        if (event.oldValue != null) {
                            var unselectedEntity = EntityManagerInstance$1.find(event.oldValue);
                            if (unselectedEntity)
                                unselectedEntity.unhighlight();
                        }
                        if (event.value != null) {
                            var selectedEntity = EntityManagerInstance$1.find(event.value);
                            if (selectedEntity)
                                selectedEntity.highlight(Util.getColor(userInfo.globalId), userInfo[CONFIG$1.NS.PERSON.TITLE]);
                        }
                    }
                });
            });
            const nodesMap = y.getMap("nodes");
            nodesMap.observe(function (event) {
                if (eventWasTriggeredByMe(event))
                    return;
                const array = Array.from(event.changes.keys.entries());
                array.forEach(([key, change]) => {
                    switch (change.action) {
                        case "delete": {
                            var node = EntityManagerInstance$1.findNode(key);
                            if (node)
                                node.remoteNodeDeleteCallback(new NodeDeleteOperation(key));
                            break;
                        }
                    }
                });
            });
            const edgeMap = y.getMap("edges");
            edgeMap.observe(function (event) {
                const array = Array.from(event.changes.keys.entries());
                array.forEach(([key, change]) => {
                    switch (change.action) {
                        case "delete": {
                            var edge = EntityManagerInstance$1.findEdge(key);
                            if (edge)
                                edge.remoteEdgeDeleteCallback(new EdgeDeleteOperation(key));
                            break;
                        }
                    }
                });
            });
        }
        if (_iwcw) {
            that.registerCallbacks();
        }
    }
}
let EdgeShapeNodeTool$1 = class EdgeShapeNodeTool extends NodeTool$1 {
    constructor() {
        super(EdgeShapeNode$1.TYPE, null, null, null, EdgeShapeNode$1.DEFAULT_WIDTH, EdgeShapeNode$1.DEFAULT_HEIGHT);
    }
};
let EnumNodeTool$1 = class EnumNodeTool extends NodeTool$1 {
    constructor() {
        super(EnumNode$1.TYPE, null, null, null, EnumNode$1.DEFAULT_WIDTH, EnumNode$1.DEFAULT_HEIGHT);
    }
};
let GeneralisationEdgeTool$1 = class GeneralisationEdgeTool extends EdgeTool$1 {
    constructor() {
        super(GeneralisationEdge$1.TYPE, GeneralisationEdge$1.RELATIONS);
    }
};
const viewrelationshipNodeHtml = "<div class=\"class_node\">\n    <div class=\"type\"><%= type %></div>\n    <div class=\"label\">&lt;&lt;ViewRelationship&gt;&gt;</div>\n    <div class=\"attributes\"></div>\n</div>";
let ViewRelationshipNode$1 = class ViewRelationshipNode extends AbstractNode$1 {
    constructor(id, left, top, width, height, zIndex, json) {
        super(id, "ViewRelationship", left, top, width, height, zIndex, json);
        var that = this;
        var _$template = $(lodash.template(viewrelationshipNodeHtml)({
            type: that.getType(),
        }));
        var _$node = AbstractNode$1.prototype.get$node
            .call(this)
            .append(_$template)
            .addClass("viewrelationship");
        var _$attributeNode = _$node.find(".attributes");
        this.getAttributes();
        this.toJSON = function () {
            return AbstractNode$1.prototype.toJSON.call(this);
        };
        this.registerYMap = function () {
            AbstractNode$1.prototype.registerYMap.call(this);
            that.getLabel().getValue().registerYType();
            attributeList.registerYMap();
            if (cla)
                cla.registerYMap();
            attribute.getValue().registerYType();
            conjSelection.getValue().registerYType();
        };
        this.showAttributes = function () {
            if (renamingList.get$node().is(":hidden"))
                renamingList.get$node().show();
            if (conjSelection.get$node().is(":hidden"))
                conjSelection.get$node().show();
            if (cla.get$node().is(":hidden"))
                cla.get$node().show();
            if (!targetAttribute.get$node().is(":hidden"))
                targetAttribute.get$node().hide();
        };
        this.createConditionListAttribute = function (refAttrs) {
            var targetAttrList = {};
            if (refAttrs && refAttrs.constructor.name === "RenamingListAttribute") {
                var attrs = refAttrs.getAttributes();
                for (var key in attrs) {
                    if (attrs.hasOwnProperty(key)) {
                        targetAttrList[key] = attrs[key].getKey().getValue();
                    }
                }
            }
            else {
                for (var key in refAttrs) {
                    if (refAttrs.hasOwnProperty(key)) {
                        targetAttrList[key] = refAttrs[key].val.value;
                    }
                }
            }
            var conditionListAttr = new ConditionListAttribute$1("[condition]", "Conditions", that, targetAttrList, LogicalOperator);
            that.addAttribute(conditionListAttr);
            _$attributeNode.append(conditionListAttr.get$node());
            conditionListAttr.get$node().hide();
            return conditionListAttr;
        };
        this.registerYMap = function () {
            AbstractNode$1.prototype.registerYMap.call(this);
            that.getLabel().getValue().registerYType();
            renamingList.registerYMap();
            if (cla)
                cla.registerYMap();
            targetAttribute.getValue().registerYType();
            conjSelection.getValue().registerYType();
        };
        var targetAttribute, renamingList, conjSelection, cla;
        _$node.find(".label").append(this.getLabel().get$node());
        if (window.hasOwnProperty("y")) {
            const dataMap = y.getMap("data");
            var model = dataMap.get("model");
            if (model) {
                var selectionValues = ViewTypesUtil$1.GetAllNodesOfBaseModelAsSelectionList2(model.nodes, [
                    "Relationship",
                ]);
                targetAttribute = new SingleSelectionAttribute$1(id + "[target]", "Reference", that, selectionValues);
                that.addAttribute(targetAttribute);
                _$attributeNode.prepend(targetAttribute.get$node());
                if (json)
                    cla = that.createConditionListAttribute(json.attributes["[attributes]"].list);
                else
                    cla = that.createConditionListAttribute();
            }
        }
        renamingList = new RenamingListAttribute$1("[attributes]", "Attributes", that, {
            hidden: "Show",
            top: "Show Top",
            center: "Show Center",
            bottom: "Show Bottom",
            hide: "Hide",
        });
        that.addAttribute(renamingList);
        _$attributeNode.append(renamingList.get$node());
        renamingList.get$node().hide();
        conjSelection = new SingleSelectionAttribute$1(id + "[conjunction]", "Conjunction", that, LogicalConjunctions);
        that.addAttribute(conjSelection);
        _$attributeNode.append(conjSelection.get$node());
        conjSelection.get$node().hide();
        if (json && conjSelection && cla && renamingList && targetAttribute)
            that.showAttributes();
        this.setContextMenuItemCallback(function () {
            var viewId = $("#lblCurrentView").text();
            return {
                addShape: {
                    name: "Add Edge Shape",
                    callback: function () {
                        var canvas = that.getCanvas(), appearance = that.getAppearance(), nodeId;
                        canvas.createNode(EdgeShapeNode$1.TYPE, appearance.left + appearance.width + 50, appearance.top, 150, 100);
                        canvas.createEdge(BiDirAssociationEdge$1.TYPE, that.getEntityId(), nodeId, null, null, viewId);
                    },
                    disabled: function () {
                        var edges = that.getEdges(), edge, edgeId;
                        for (edgeId in edges) {
                            if (edges.hasOwnProperty(edgeId)) {
                                edge = edges[edgeId];
                                if ((edge instanceof BiDirAssociationEdge$1 &&
                                    ((edge.getTarget() === that &&
                                        edge.getSource() instanceof EdgeShapeNode$1) ||
                                        (edge.getSource() === that &&
                                            edge.getTarget() instanceof EdgeShapeNode$1))) ||
                                    (edge instanceof UniDirAssociationEdge$1 &&
                                        edge.getTarget() instanceof EdgeShapeNode$1)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    },
                },
                sep: "---------",
            };
        });
    }
    static { this.TYPE = "ViewRelationship"; }
    static { this.DEFAULT_WIDTH = 150; }
    static { this.DEFAULT_HEIGHT = 100; }
};
function GenerateViewpointModel(viewpointModel, y) {
    EntityManagerInstance$1.init();
    for (var node_key in viewpointModel.nodes) {
        if (viewpointModel.nodes.hasOwnProperty(node_key)) {
            var vpNode = viewpointModel.nodes[node_key];
            const width = vpNode.width || vpNode.containment.width;
            const height = vpNode.height || vpNode.containment.height;
            const left = vpNode.left || vpNode.containment.left;
            const top = vpNode.top || vpNode.containment.top;
            const zIndex = vpNode.zIndex || vpNode.containment.zIndex;
            EntityManagerInstance$1.createNodeFromJSON(vpNode.type, node_key, left, top, width, height, zIndex, vpNode.containment, vpNode, y);
        }
    }
    for (var edge_key in viewpointModel.edges) {
        if (viewpointModel.edges.hasOwnProperty(edge_key)) {
            var vpEdge = viewpointModel.edges[edge_key];
            EntityManagerInstance$1.createEdgeFromJSON(vpEdge.type, edge_key, vpEdge.source, vpEdge.target, vpEdge);
        }
    }
    function getConcreteObjectNodeTypes(node, visitedNodes) {
        var edgeId, edge, ingoingEdges, source, type, classTypes = [];
        if (!visitedNodes)
            visitedNodes = [];
        if (visitedNodes.indexOf(node) !== -1)
            return [];
        visitedNodes.push(node);
        type = node.getLabel().getValue().getValue();
        if ((node instanceof ObjectNode$1 || node instanceof ViewObjectNode$1) &&
            classTypes.indexOf(type) === -1) {
            classTypes.push(type);
        }
        ingoingEdges = node.getIngoingEdges();
        for (edgeId in ingoingEdges) {
            if (ingoingEdges.hasOwnProperty(edgeId)) {
                edge = ingoingEdges[edgeId];
                source = edge.getSource();
                if ((edge instanceof GeneralisationEdge$1 &&
                    source instanceof ObjectNode$1) ||
                    (edge instanceof GeneralisationEdge$1 &&
                        source instanceof AbstractClassNode$1) ||
                    (edge instanceof GeneralisationEdge$1 &&
                        source instanceof ViewObjectNode$1)) {
                    classTypes = classTypes.concat(getConcreteObjectNodeTypes(source, visitedNodes));
                }
            }
        }
        return classTypes;
    }
    function getNodeAttributes(node, visitedNodes) {
        var nodeAttributes, attributeId, attribute;
        var edgeId, edge, outgoingEdges;
        var source, target;
        var neighbor, options;
        var attributes = {};
        var obj = {};
        if (!visitedNodes)
            visitedNodes = [];
        if (visitedNodes.indexOf(node) !== -1)
            return {};
        visitedNodes.push(node);
        outgoingEdges = node.getOutgoingEdges();
        for (edgeId in outgoingEdges) {
            if (outgoingEdges.hasOwnProperty(edgeId)) {
                edge = outgoingEdges[edgeId];
                source = edge.getSource();
                target = edge.getTarget();
                if ((edge instanceof GeneralisationEdge$1 &&
                    target instanceof AbstractClassNode$1) ||
                    (edge instanceof GeneralisationEdge$1 &&
                        node instanceof ObjectNode$1 &&
                        target instanceof ObjectNode$1) ||
                    (edge instanceof GeneralisationEdge$1 &&
                        node instanceof RelationshipNode$1 &&
                        target instanceof RelationshipNode$1) ||
                    (edge instanceof GeneralisationEdge$1 &&
                        node instanceof EnumNode$1 &&
                        target instanceof EnumNode$1)) {
                    Util.merge(attributes, getNodeAttributes(target, visitedNodes));
                }
                else if ((edge instanceof BiDirAssociationEdge$1 &&
                    ((target === node && (neighbor = source) instanceof EnumNode$1) ||
                        (source === node && (neighbor = target) instanceof EnumNode$1))) ||
                    (edge instanceof UniDirAssociationEdge$1 &&
                        (neighbor = target) instanceof EnumNode$1)) {
                    options = {};
                    nodeAttributes = {};
                    Util.merge(nodeAttributes, getNodeAttributes(neighbor, []));
                    for (attributeId in nodeAttributes) {
                        if (nodeAttributes.hasOwnProperty(attributeId)) {
                            attribute = nodeAttributes[attributeId];
                            options[attribute.value] = attribute.value;
                        }
                    }
                    obj = {};
                    obj[neighbor.getEntityId()] = {
                        key: edge.getLabel().getValue().getValue(),
                        value: neighbor.getLabel().getValue().getValue(),
                        options: options,
                    };
                    Util.merge(attributes, obj);
                }
            }
        }
        nodeAttributes = node.getAttribute("[attributes]").getAttributes();
        for (attributeId in nodeAttributes) {
            if (nodeAttributes.hasOwnProperty(attributeId)) {
                attribute = nodeAttributes[attributeId];
                if (node instanceof RelationshipNode$1) {
                    obj = {};
                    obj[attributeId] = {
                        key: attribute.getKey().getValue(),
                        value: attribute.getValue().getValue(),
                        position: attribute.getValue2().getValue(),
                    };
                    Util.merge(attributes, obj);
                }
                else if (node instanceof ViewRelationshipNode$1) {
                    obj = {};
                    obj[attributeId] = {
                        key: attribute.getKey().getValue(),
                        ref: attribute.getRef().getValue(),
                        position: attribute.getVis().getValue(),
                    };
                    Util.merge(attributes, obj);
                }
                else if (node instanceof EnumNode$1) {
                    obj = {};
                    obj[attributeId] = {
                        value: attribute.getValue().getValue(),
                    };
                    Util.merge(attributes, obj);
                }
                else if (node instanceof ViewObjectNode$1) {
                    obj = {};
                    obj[attributeId] = {
                        key: attribute.getKey().getValue(),
                        ref: attribute.getRef().getValue(),
                        visibility: attribute.getVis().getValue(),
                    };
                    Util.merge(attributes, obj);
                }
                else {
                    obj = {};
                    obj[attributeId] = {
                        key: attribute.getKey().getValue(),
                        value: attribute.getValue().getValue(),
                    };
                    Util.merge(attributes, obj);
                }
            }
        }
        return attributes;
    }
    function getViewTypeAttributes(node) {
        var target, targetName;
        var conjunction;
        var conditions = {};
        var nodeid = node.getEntityId();
        if (viewpointModel.nodes.hasOwnProperty(nodeid)) {
            if (viewpointModel.nodes[nodeid].attributes.hasOwnProperty(nodeid + "[target]")) {
                var attr = viewpointModel.nodes[nodeid].attributes[nodeid + "[target]"];
                target = attr.value.value;
                targetName = attr.hasOwnProperty("option") ? attr.option : null;
            }
            if (viewpointModel.nodes[nodeid].attributes.hasOwnProperty("[condition]")) {
                var conditionsList = viewpointModel.nodes[nodeid].attributes["[condition]"].list;
                for (var condId in conditionsList) {
                    if (conditionsList.hasOwnProperty(condId)) {
                        conditions[condId] = {
                            property: conditionsList[condId].property.value,
                            operator: conditionsList[condId].operator.value,
                            value: conditionsList[condId].val.value,
                        };
                    }
                }
            }
            if (viewpointModel.nodes[nodeid].attributes.hasOwnProperty(nodeid + "[conjunction]")) {
                conjunction =
                    viewpointModel.nodes[nodeid].attributes[nodeid + "[conjunction]"]
                        .value.value;
            }
        }
        return {
            target: target,
            targetName: targetName,
            conditions: conditions,
            conjunction: conjunction,
        };
    }
    var metamodel = {
        attributes: {},
        nodes: {},
        edges: {},
    };
    var nodeId, node;
    var attributes;
    var edge, edgeId, edges;
    var source, target;
    var neighbor;
    var groupSource, groupTarget;
    var groupNeighbor;
    var shape;
    var sourceTypes, targetTypes, concreteTypes;
    var groupSourceTypes, groupTargetTypes, groupConcreteTypes;
    var relations;
    var groupEdge, groupEdgeId, groupEdges;
    var viewtypeAttrs;
    var _nodes = EntityManagerInstance$1.getNodes();
    for (nodeId in _nodes) {
        if (_nodes.hasOwnProperty(nodeId)) {
            node = _nodes[nodeId];
            if (node instanceof ObjectNode$1 || node instanceof ViewObjectNode$1) {
                if (node.getLabel().getValue().getValue() === "Model Attributes") {
                    attributes = getNodeAttributes(node);
                    metamodel.attributes = attributes;
                }
                else {
                    attributes = getNodeAttributes(node);
                    edges = node.getEdges();
                    shape = null;
                    for (edgeId in edges) {
                        if (edges.hasOwnProperty(edgeId)) {
                            edge = edges[edgeId];
                            source = edge.getSource();
                            target = edge.getTarget();
                            if ((edge instanceof BiDirAssociationEdge$1 &&
                                ((target === node &&
                                    (neighbor = source) instanceof NodeShapeNode$1) ||
                                    (source === node &&
                                        (neighbor = target) instanceof NodeShapeNode$1))) ||
                                (edge instanceof UniDirAssociationEdge$1 &&
                                    (neighbor = target) instanceof NodeShapeNode$1)) {
                                shape = {
                                    shape: neighbor
                                        .getAttribute(neighbor.getEntityId() + "[shape]")
                                        .getValue()
                                        .getValue(),
                                    color: neighbor
                                        .getAttribute(neighbor.getEntityId() + "[color]")
                                        .getValue()
                                        .getValue(),
                                    defaultWidth: parseInt(neighbor
                                        .getAttribute(neighbor.getEntityId() + "[defaultWidth]")
                                        .getValue()
                                        .getValue()),
                                    defaultHeight: parseInt(neighbor
                                        .getAttribute(neighbor.getEntityId() + "[defaultHeight]")
                                        .getValue()
                                        .getValue()),
                                    containment: neighbor
                                        .getAttribute(neighbor.getEntityId() + "[containment]")
                                        .getValue()
                                        .getValue(),
                                    customShape: neighbor
                                        .getAttribute(neighbor.getEntityId() + "[customShape]")
                                        .getValue()
                                        .getValue(),
                                    customAnchors: neighbor
                                        .getAttribute(neighbor.getEntityId() + "[customAnchors]")
                                        .getValue()
                                        .getValue(),
                                };
                            }
                        }
                    }
                    metamodel.nodes[nodeId] = {
                        label: node.getLabel().getValue().getValue(),
                        attributes: attributes,
                        shape: shape || {
                            shape: "rectangle",
                            color: "white",
                            containment: false,
                            customShape: "",
                            customAnchors: "",
                            defaultWidth: 0,
                            defaultHeight: 0,
                        },
                    };
                    if (node instanceof ViewObjectNode$1) {
                        viewtypeAttrs = getViewTypeAttributes(node);
                        Util.merge(metamodel.nodes[nodeId], viewtypeAttrs);
                    }
                }
            }
            else if (node instanceof RelationshipNode$1 ||
                node instanceof ViewRelationshipNode$1) {
                attributes = getNodeAttributes(node);
                edges = node.getEdges();
                sourceTypes = [];
                targetTypes = [];
                relations = [];
                shape = null;
                for (edgeId in edges) {
                    if (edges.hasOwnProperty(edgeId)) {
                        edge = edges[edgeId];
                        source = edge.getSource();
                        target = edge.getTarget();
                        if (edge instanceof BiDirAssociationEdge$1 &&
                            ((target === node && (neighbor = source) instanceof ObjectNode$1) ||
                                (target === node &&
                                    (neighbor = source) instanceof ViewObjectNode$1) ||
                                (source === node &&
                                    (neighbor = target) instanceof ObjectNode$1) ||
                                (source === node &&
                                    (neighbor = target) instanceof ViewObjectNode$1))) {
                            concreteTypes = getConcreteObjectNodeTypes(neighbor);
                            sourceTypes = sourceTypes.concat(concreteTypes);
                            targetTypes = targetTypes.concat(concreteTypes);
                        }
                        else if (edge instanceof UniDirAssociationEdge$1 &&
                            source === node &&
                            (target instanceof ObjectNode$1 || target instanceof ViewObjectNode$1)) {
                            targetTypes = targetTypes.concat(getConcreteObjectNodeTypes(target));
                        }
                        else if (edge instanceof UniDirAssociationEdge$1 &&
                            target === node &&
                            (source instanceof ObjectNode$1 || source instanceof ViewObjectNode$1)) {
                            sourceTypes = sourceTypes.concat(getConcreteObjectNodeTypes(source));
                        }
                        else if (edge instanceof BiDirAssociationEdge$1 &&
                            ((target === node &&
                                (neighbor = source) instanceof AbstractClassNode$1) ||
                                (source === node &&
                                    (neighbor = target) instanceof AbstractClassNode$1))) {
                            concreteTypes = getConcreteObjectNodeTypes(neighbor);
                            sourceTypes = sourceTypes.concat(concreteTypes);
                            targetTypes = targetTypes.concat(concreteTypes);
                        }
                        else if (edge instanceof UniDirAssociationEdge$1 &&
                            source === node &&
                            target instanceof AbstractClassNode$1) {
                            targetTypes = targetTypes.concat(getConcreteObjectNodeTypes(target));
                        }
                        else if (edge instanceof UniDirAssociationEdge$1 &&
                            target === node &&
                            source instanceof AbstractClassNode$1) {
                            sourceTypes = sourceTypes.concat(getConcreteObjectNodeTypes(source));
                        }
                        else if ((edge instanceof BiDirAssociationEdge$1 &&
                            ((target === node &&
                                (neighbor = source) instanceof EdgeShapeNode$1) ||
                                (source === node &&
                                    (neighbor = target) instanceof EdgeShapeNode$1))) ||
                            (edge instanceof UniDirAssociationEdge$1 &&
                                source === node &&
                                (neighbor = target) instanceof EdgeShapeNode$1)) {
                            shape = {
                                arrow: neighbor
                                    .getAttribute(neighbor.getEntityId() + "[arrow]")
                                    .getValue()
                                    .getValue(),
                                shape: neighbor
                                    .getAttribute(neighbor.getEntityId() + "[shape]")
                                    .getValue()
                                    .getValue(),
                                color: neighbor
                                    .getAttribute(neighbor.getEntityId() + "[color]")
                                    .getValue()
                                    .getValue(),
                                overlay: neighbor
                                    .getAttribute(neighbor.getEntityId() + "[overlay]")
                                    .getValue()
                                    .getValue(),
                                overlayPosition: neighbor
                                    .getAttribute(neighbor.getEntityId() + "[overlayPosition]")
                                    .getValue()
                                    .getValue(),
                                overlayRotate: neighbor
                                    .getAttribute(neighbor.getEntityId() + "[overlayRotate]")
                                    .getValue()
                                    .getValue(),
                            };
                        }
                        else if (edge instanceof GeneralisationEdge$1 &&
                            target === node &&
                            (neighbor = source) instanceof RelationshipGroupNode$1) {
                            groupEdges = neighbor.getEdges();
                            groupSourceTypes = [];
                            groupTargetTypes = [];
                            for (groupEdgeId in groupEdges) {
                                if (groupEdges.hasOwnProperty(groupEdgeId)) {
                                    groupEdge = groupEdges[groupEdgeId];
                                    groupSource = groupEdge.getSource();
                                    groupTarget = groupEdge.getTarget();
                                    if (groupEdge instanceof BiDirAssociationEdge$1 &&
                                        ((groupTarget === neighbor &&
                                            (groupNeighbor = groupSource) instanceof ObjectNode$1) ||
                                            (groupSource === neighbor &&
                                                (groupNeighbor = groupTarget) instanceof ObjectNode$1) ||
                                            (groupTarget === neighbor &&
                                                (groupNeighbor = groupSource) instanceof
                                                    ViewObjectNode$1) ||
                                            (groupSource === neighbor &&
                                                (groupNeighbor = groupTarget) instanceof
                                                    ViewObjectNode$1))) {
                                        groupConcreteTypes =
                                            getConcreteObjectNodeTypes(groupNeighbor);
                                        groupSourceTypes =
                                            groupSourceTypes.concat(groupConcreteTypes);
                                        groupTargetTypes =
                                            groupTargetTypes.concat(groupConcreteTypes);
                                    }
                                    else if (groupEdge instanceof UniDirAssociationEdge$1 &&
                                        groupSource === neighbor &&
                                        (groupTarget instanceof ObjectNode$1 ||
                                            groupTarget instanceof ViewObjectNode$1)) {
                                        groupTargetTypes = groupTargetTypes.concat(getConcreteObjectNodeTypes(groupTarget));
                                    }
                                    else if (groupEdge instanceof UniDirAssociationEdge$1 &&
                                        groupTarget === neighbor &&
                                        (groupSource instanceof ObjectNode$1 ||
                                            groupSource instanceof ViewObjectNode$1)) {
                                        groupSourceTypes = groupSourceTypes.concat(getConcreteObjectNodeTypes(groupSource));
                                    }
                                    else if (groupEdge instanceof BiDirAssociationEdge$1 &&
                                        ((groupTarget === neighbor &&
                                            (groupNeighbor = groupSource) instanceof
                                                AbstractClassNode$1) ||
                                            (groupSource === neighbor &&
                                                (groupNeighbor = groupTarget) instanceof
                                                    AbstractClassNode$1))) {
                                        groupConcreteTypes =
                                            getConcreteObjectNodeTypes(groupNeighbor);
                                        groupSourceTypes =
                                            groupSourceTypes.concat(groupConcreteTypes);
                                        groupTargetTypes =
                                            groupTargetTypes.concat(groupConcreteTypes);
                                    }
                                    else if (groupEdge instanceof UniDirAssociationEdge$1 &&
                                        groupSource === neighbor &&
                                        groupTarget instanceof AbstractClassNode$1) {
                                        groupTargetTypes = groupTargetTypes.concat(getConcreteObjectNodeTypes(groupTarget));
                                    }
                                    else if (groupEdge instanceof UniDirAssociationEdge$1 &&
                                        groupTarget === neighbor &&
                                        groupSource instanceof AbstractClassNode$1) {
                                        groupSourceTypes = groupSourceTypes.concat(getConcreteObjectNodeTypes(groupSource));
                                    }
                                }
                            }
                            if (groupSourceTypes.length > 0 && groupTargetTypes.length > 0) {
                                relations.push({
                                    sourceTypes: groupSourceTypes,
                                    targetTypes: groupTargetTypes,
                                });
                            }
                        }
                    }
                }
                if (sourceTypes.length > 0 && targetTypes.length > 0) {
                    relations.push({
                        sourceTypes: sourceTypes,
                        targetTypes: targetTypes,
                    });
                }
                metamodel.edges[nodeId] = {
                    label: node.getLabel().getValue().getValue(),
                    shape: shape || {
                        arrow: "bidirassociation",
                        shape: "straight",
                        color: "black",
                        overlay: "",
                        overlayPosition: "top",
                        overlayRotate: true,
                    },
                    relations: relations,
                    attributes: attributes,
                };
                if (node instanceof ViewRelationshipNode$1) {
                    viewtypeAttrs = getViewTypeAttributes(node);
                    Util.merge(metamodel.edges[nodeId], viewtypeAttrs);
                }
            }
        }
    }
    metamodel["id"] = viewpointModel.id;
    EntityManagerInstance$1.reset();
    return metamodel;
}
function JSONtoGraph(json, canvas) {
    if (!canvas)
        return new Error("No canvas object defined!");
    $.Deferred();
    var numberOfNodes = lodash.keys(json.nodes).length;
    var numberOfEdges = lodash.keys(json.edges).length;
    var createdNodes = 0;
    var createdEdges = 0;
    var report = {
        widget: "CANVAS",
        createdYText: 0,
        modelAttributes: { attributes: {} },
        nodes: {},
        edges: {},
    };
    if (!lodash.isEmpty(json.attributes)) {
        var modelAttributesNode = EntityManagerInstance$1.createModelAttributesNodeFromJSON(json.attributes);
        modelAttributesNode.registerYMap();
        canvas.setModelAttributesNode(modelAttributesNode);
        modelAttributesNode.addToCanvas(canvas);
    }
    function createNode(nodeId, jsonNode) {
        const nodesMap = y.getMap("nodes");
        var map = nodesMap.get(nodeId);
        var node = null;
        if (map) {
            node = EntityManagerInstance$1.createNodeFromJSON(jsonNode.type, nodeId, map.get("left") ? map.get("left") : jsonNode.left, map.get("top") ? map.get("top") : jsonNode.top, map.get("width") ? map.get("width") : jsonNode.width, map.get("height") ? map.get("height") : jsonNode.height, map.get("zIndex") ? map.get("zIndex") : jsonNode.zIndex, map.get("containment") ? map.get("containment") : jsonNode.containment, jsonNode);
        }
        else {
            node = EntityManagerInstance$1.createNodeFromJSON(jsonNode.type, nodeId, jsonNode.left, jsonNode.top, jsonNode.width, jsonNode.height, jsonNode.zIndex, jsonNode.containment, jsonNode);
        }
        if (node === undefined) {
            console.error("SYNCMETA: Node undefined. Check if " +
                jsonNode.type +
                "  type is defined in the VLS");
            var $errorMsg = $("#errorMsg");
            $("#loading").hide();
            $("#canvas-frame").hide();
            $errorMsg.parent().css("display", "inline-table");
            $errorMsg.text("SYNCMETA: Model is not compatible to the current Metamodel! Delete the current model or change the metamodel.");
            return;
        }
        node.registerYMap();
        node.addToCanvas(canvas);
        node.bindMoveToolEvents();
        node.draw();
    }
    function createNodes(nodes) {
        for (var nodeId in nodes) {
            if (nodes.hasOwnProperty(nodeId)) {
                createNode(nodeId, nodes[nodeId]);
                createdNodes++;
            }
        }
    }
    function createEdges(edges) {
        for (const edgeId in edges) {
            if (edges.hasOwnProperty(edgeId)) {
                var edge = EntityManagerInstance$1.createEdgeFromJSON(edges[edgeId].type, edgeId, edges[edgeId].source, edges[edgeId].target, edges[edgeId]);
                if (edge === undefined) {
                    console.error("SYNCMETA: Edge undefined. Check if " +
                        edges[edgeId].type +
                        "  type is defined in the VLS");
                    var $errorMsg = $("#errorMsg");
                    $errorMsg.parent().show();
                    $("#canvas-frame").hide();
                    $("#loading").hide();
                    $errorMsg.parent().css("display", "inline-table");
                    $errorMsg.text("SYNCMETA: Model is not compatible to the current Metamodel! Delete the current model or change the metamodel.");
                    continue;
                }
                edge.registerYMap();
                edge.addToCanvas(canvas);
                edge.connect();
                edge.bindMoveToolEvents();
                createdEdges++;
            }
        }
    }
    if (numberOfNodes > 0) {
        createNodes(json.nodes);
        if (createdNodes === numberOfNodes) {
            if (numberOfEdges > 0) {
                createEdges(json.edges);
                if (createdEdges === numberOfEdges) {
                    canvas.resetTool();
                    report.createdNodes = createdNodes;
                    report.createdEdges = createdEdges;
                }
            }
            else {
                report.createdNodes = createdNodes;
                report.createdEdges = 0;
            }
        }
    }
    return report;
}
let NodeShapeNodeTool$1 = class NodeShapeNodeTool extends NodeTool$1 {
    constructor() {
        super(NodeShapeNode$1.TYPE, null, null, null, NodeShapeNode$1.DEFAULT_WIDTH, NodeShapeNode$1.DEFAULT_HEIGHT);
    }
};
let ObjectNodeTool$1 = class ObjectNodeTool extends NodeTool$1 {
    constructor() {
        super(ObjectNode$1.TYPE, null, null, null, ObjectNode$1.DEFAULT_WIDTH, ObjectNode$1.DEFAULT_HEIGHT);
    }
};
let RelationshipGroupNodeTool$1 = class RelationshipGroupNodeTool extends NodeTool$1 {
    constructor() {
        super(RelationshipGroupNode$1.TYPE, null, null, null, RelationshipGroupNode$1.DEFAULT_WIDTH, RelationshipGroupNode$1.DEFAULT_HEIGHT);
    }
};
let RelationshipNodeTool$1 = class RelationshipNodeTool extends NodeTool$1 {
    constructor() {
        super(RelationshipNode$1.TYPE, null, null, null, RelationshipNode$1.DEFAULT_WIDTH, RelationshipNode$1.DEFAULT_HEIGHT);
    }
};
let UniDirAssociationEdgeTool$1 = class UniDirAssociationEdgeTool extends EdgeTool$1 {
    constructor() {
        super(UniDirAssociationEdge$1.TYPE, UniDirAssociationEdge$1.RELATIONS);
    }
};
function ViewGenerator$1() { }
function applyNodeTypeToNode$1(nodeType, node) {
    if (checkConditions(nodeType, node)) {
        node.set$shape(nodeType.get$shape());
        node.setAnchorOptions(nodeType.getAnchors());
        node.setCurrentViewType(nodeType.TYPE);
        node.show();
    }
    else {
        node.setCurrentViewType(null);
        node.hide();
    }
}
function checkConditions(type, entity) {
    if (type.name === "Edge" || type.name === "Node") {
        return true;
    }
    var cond, conj = type.getConditionConj(), conditions = type.getConditions();
    for (var cKey in conditions) {
        if (conditions.hasOwnProperty(cKey)) {
            cond = conditions[cKey];
            var attr = entity.getAttribute(cond.property);
            if (attr) {
                var res = resolveCondition(attr.getValue().getValue(), cond.operator, cond.value);
                if (conj === "AND" && !res) {
                    return false;
                }
                else if (conj === "OR" && res) {
                    return true;
                }
            }
        }
    }
    if (conj === "AND") {
        return true;
    }
    else if (conj === "OR") {
        return false;
    }
}
function resolveCondition(attrValue, operator, value) {
    var val = null;
    try {
        if (typeof val === "boolean")
            val = value;
        else
            val = parseInt(value);
        if (isNaN(val))
            val = value;
    }
    catch (e) {
        val = value;
    }
    switch (operator) {
        case "greater":
            return attrValue > val;
        case "smaller":
            return attrValue < val;
        case "equal":
            return attrValue === val;
        case "greater_eq":
            return attrValue >= val;
        case "smaller_eq":
            return attrValue <= val;
        case "nequal":
            return attrValue != val;
    }
}
function applyNodeTypeToNodes$1(nodeType, nodes) {
    for (var nodeKey in nodes) {
        if (nodes.hasOwnProperty(nodeKey)) {
            applyNodeTypeToNode$1(nodeType, nodes[nodeKey]);
        }
    }
}
function applyEdgeTypeToEdge$1(edgeType, edge) {
    if (checkConditions(edgeType, edge)) {
        edge.restyle(edgeType.getArrowType(), edgeType.getColor(), edgeType.getShapeType(), null, edgeType.getOverlay(), edgeType.getOverlayPosition(), edgeType.getOverlayRotate(), edgeType.getAttributes());
        edge.setCurrentViewType(edgeType.TYPE);
    }
    else {
        edge.hide();
    }
}
function applyEdgeTypeToEdges$1(edgeType, edges) {
    for (var edgeKey in edges) {
        if (edges.hasOwnProperty(edgeKey)) {
            applyEdgeTypeToEdge$1(edgeType, edges[edgeKey]);
        }
    }
}
ViewGenerator$1.generate = function (vls, vvs) {
    var _processed = {};
    var viewpointNodes = vvs.nodes;
    for (var vpNodeKey in viewpointNodes) {
        if (viewpointNodes.hasOwnProperty(vpNodeKey)) {
            var nodeViewType = viewpointNodes[vpNodeKey];
            if (nodeViewType.hasOwnProperty("target")) {
                _processed[nodeViewType.target] = true;
                var viewNodeTypeObject = EntityManagerInstance$1.getViewNodeType(nodeViewType.label);
                applyNodeTypeToNodes$1(viewNodeTypeObject, EntityManagerInstance$1.getNodesByType(viewNodeTypeObject.getTargetNodeType().TYPE));
            }
        }
    }
    var nodeTypes = vls.nodes;
    for (var nodeTypeKey in nodeTypes) {
        if (nodeTypes.hasOwnProperty(nodeTypeKey) &&
            !_processed.hasOwnProperty(nodeTypeKey)) {
            var nodes = EntityManagerInstance$1.getNodesByType(nodeTypes[nodeTypeKey].label);
            for (var nodeKey in nodes) {
                if (nodes.hasOwnProperty(nodeKey)) {
                    nodes[nodeKey].hide();
                }
            }
        }
    }
    var viewpointEdges = vvs.edges;
    for (var vpEdgeKey in viewpointEdges) {
        if (viewpointEdges.hasOwnProperty(vpEdgeKey)) {
            var edgeViewType = viewpointEdges[vpEdgeKey];
            if (edgeViewType.hasOwnProperty("target")) {
                _processed[edgeViewType.target] = true;
                var viewEdgeTypeObject = EntityManagerInstance$1.getViewEdgeType(edgeViewType.label);
                applyEdgeTypeToEdges$1(viewEdgeTypeObject, EntityManagerInstance$1.getEdgesByType(viewEdgeTypeObject.getTargetEdgeType().TYPE));
            }
        }
    }
    var edgeTypes = vls.edges;
    for (var edgeTypeKey in edgeTypes) {
        if (edgeTypes.hasOwnProperty(edgeTypeKey) &&
            !_processed.hasOwnProperty(edgeTypeKey)) {
            var edges = EntityManagerInstance$1.getEdgesByType(edgeTypes[edgeTypeKey].label);
            for (var edgeKey in edges) {
                if (edges.hasOwnProperty(edgeKey)) {
                    edges[edgeKey].hide();
                }
            }
        }
    }
    window.jsPlumbInstance.repaintEverything();
    _.each(EntityManagerInstance$1.getEdges(), function (e) {
        e.setZIndex();
    });
};
ViewGenerator$1.reset = function (vls) {
    var typeName;
    var nodes = vls.nodes;
    for (var nodeKey in nodes) {
        if (nodes.hasOwnProperty(nodeKey)) {
            typeName = nodes[nodeKey].label;
            applyNodeTypeToNodes$1(EntityManagerInstance$1.getNodeType(typeName), EntityManagerInstance$1.getNodesByType(typeName));
        }
    }
    var edges = vls.edges;
    for (var edgeKey in edges) {
        if (edges.hasOwnProperty(edgeKey)) {
            typeName = edges[edgeKey].label;
            applyEdgeTypeToEdges$1(EntityManagerInstance$1.getEdgeType(typeName), EntityManagerInstance$1.getEdgesByType(typeName));
        }
    }
    window.jsPlumbInstance.repaintEverything();
    _.each(EntityManagerInstance$1.getEdges(), function (e) {
        e.setZIndex();
    });
};
const optionHtml = "<option id=\"<%= id %>\"><%= id %></option>";
function ViewManager() {
    var _$selection = $("#ddmViewSelection");
    var optionTpl = lodash.template(optionHtml);
    return {
        GetViewpointList: function () {
            y = window.y;
            const viewsMap = y.getMap("views");
            _$selection.empty();
            var viewpointList = viewsMap.keys();
            for (var i = 0; i < viewpointList.length; i++) {
                var viewpoint = viewsMap.get(viewpointList[i]);
                if (viewpoint) {
                    _$selection.append($(optionTpl({
                        id: viewpointList[i],
                    })));
                }
                else
                    viewsMap.delete(viewpointList[i]);
            }
        },
        existsView: function (viewId) {
            const viewsMap = y.getMap("views");
            return viewsMap.has(viewId);
        },
        getViewIdOfSelected: function () {
            return this.getSelected$node().attr("id");
        },
        getSelected$node: function () {
            return _$selection.find("option:selected");
        },
        addView: function (viewId) {
            const viewsMap = y.getMap("views");
            if (viewsMap.has(viewId)) {
                viewsMap.set(viewId, {
                    viewId: viewId,
                    attributes: {},
                    nodes: {},
                    edges: {},
                });
                return true;
            }
            else
                return false;
        },
        deleteView: function (viewId) {
            const viewsMap = y.getMap("views");
            viewsMap.delete(viewId);
            _$selection.find("#" + viewId).remove();
        },
        updateViewContent: function (viewId) {
            const viewsMap = y.getMap("views");
            var data = this.viewToJSON(viewId);
            viewsMap.set(viewId, data);
        },
        viewToJSON: function (viewId) {
            var vls = EntityManagerInstance$1.graphToJSON();
            vls["id"] = viewId;
            return vls;
        },
    };
}
var ViewManager$1 = new ViewManager();
let ViewObjectNodeTool$1 = class ViewObjectNodeTool extends NodeTool$1 {
    constructor() {
        super(ViewObjectNode$1.TYPE, null, null, null, ViewObjectNode$1.DEFAULT_WIDTH, ViewObjectNode$1.DEFAULT_HEIGHT);
    }
};
let ViewRelationshipNodeTool$1 = class ViewRelationshipNodeTool extends NodeTool$1 {
    constructor() {
        super(ViewRelationshipNode$1.TYPE, null, null, null, ViewRelationshipNode$1.DEFAULT_WIDTH, ViewRelationshipNode$1.DEFAULT_HEIGHT);
    }
};
function getGuidanceModeling() {
    var guidancemodeling = {};
    var activityName = $(".activityEntry.activitySel", parent.document)
        .find(".activity-title")
        .text();
    guidancemodeling.INITIAL_NODE_LABEL = "Initial node";
    guidancemodeling.MERGE_NODE_LABEL = "Decision node";
    guidancemodeling.CALL_ACTIVITY_NODE_LABEL = "Call activity node";
    guidancemodeling.ACTIVITY_FINAL_NODE_LABEL = "Activity final node";
    guidancemodeling.CONCURRENCY_NODE_LABEL = "Fork node";
    guidancemodeling.isGuidanceEditor = function () {
        return activityName == "Guidance modeling";
    };
    guidancemodeling.getCreateObjectNodeLabelForType = function (type) {
        return "Create " + type + " object";
    };
    guidancemodeling.isCreateObjectNodeLabel = function (label) {
        var match = /Create (.*?) object/.exec(label);
        if (match)
            return match[1];
        else
            return "";
    };
    guidancemodeling.getCreateRelationshipNodeLabelForType = function (type) {
        return "Create " + type + " relationship";
    };
    guidancemodeling.isCreateRelationshipNodeLabel = function (label) {
        var match = /Create (.*?) relationship/.exec(label);
        if (match)
            return match[1];
        else
            return "";
    };
    guidancemodeling.getSetPropertyNodeLabelForType = function (type) {
        return "Set property for " + type;
    };
    guidancemodeling.isSetPropertyNodeLabel = function (label) {
        var match = /Set property for (.*)/.exec(label);
        if (match)
            return match[1];
        else
            return "";
    };
    guidancemodeling.getEntityNodeLabelForType = function (type) {
        return type + " entity";
    };
    guidancemodeling.isEntityNodeLabel = function (label) {
        var match = /(.*?) entity/.exec(label);
        if (match)
            return match[1];
        else
            return "";
    };
    guidancemodeling.getObjectContextLabelForType = function (type) {
        return type + " Object Context";
    };
    guidancemodeling.getObjectTypeForObjectContextType = function (type) {
        var i = type.lastIndexOf(" Object Context");
        return type.substring(0, i);
    };
    guidancemodeling.isObjectContextType = function (type) {
        return (type.indexOf(" Object Context", type.length - " Object Context".length) !== -1);
    };
    guidancemodeling.getRelationshipContextLabelForType = function (type) {
        return type + " Relationship Context";
    };
    guidancemodeling.getRelationshipTypeForRelationshipContextType = function (type) {
        var i = type.lastIndexOf(" Relationship Context");
        return type.substring(0, i);
    };
    guidancemodeling.isRelationshipContextType = function (type) {
        return (type.indexOf(" Relationship Context", type.length - " Relationship Context".length) !== -1);
    };
    guidancemodeling.getObjectToolLabelForType = function (type) {
        return type + " Tool";
    };
    guidancemodeling.getObjectTypeForObjectToolType = function (type) {
        var i = type.lastIndexOf(" Tool");
        return type.substring(0, i);
    };
    guidancemodeling.isObjectToolType = function (type) {
        return type.indexOf(" Tool", type.length - " Tool".length) !== -1;
    };
    return guidancemodeling;
}
async function yjsSync(spaceTitle, yjsServer = "localhost:1234", yjsProtocol = "ws") {
    let title;
    if (!spaceTitle) {
        if (window.caeRoom) {
            title = window.caeRoom;
        }
        else if (localStorage.getItem("syncmetaSpace")) {
            title = localStorage.getItem("syncmetaSpace");
        }
        else {
            title = Util.getSpaceTitle(location.href);
        }
    }
    if (window.y && title === spaceTitle) {
        return new Promise((resolve) => resolve(window.y));
    }
    const doc = new Doc();
    const websocketProvider = new WebsocketProvider(`${yjsProtocol}://${yjsServer}`, title, doc);
    await new Promise((resolve, reject) => {
        websocketProvider.on("status", (event) => {
            if (event.status == "connected") {
                if (!window.y) {
                    window.y = doc;
                }
                resolve(title);
            }
        });
        setTimeout(() => {
            reject("YJS connection timed out. This means syncmeta widgets wont work");
        }, 5000);
    });
    if (window.y) {
        return window.y;
    }
    return doc;
}
async function getUserInfo() {
    const url = localStorage.getItem("userinfo_endpoint") ||
        "https://auth.las2peer.org/auth/realms/main/protocol/openid-connect/userinfo";
    const response = await fetch(url, {
        headers: { Authorization: "Bearer " + localStorage.access_token },
    }).catch((error) => {
        console.warn("Error while fetching profile information : " + error);
    });
    try {
        if (response && response.ok) {
            const data = await response.json();
            const space = { user: {} };
            space.user[CONFIG$1.NS.PERSON.TITLE] = data.preferred_username;
            space.user[CONFIG$1.NS.PERSON.JABBERID] = data.sub;
            space.user[CONFIG$1.NS.PERSON.MBOX] = data.email;
            space.user.globalId = -1;
            space.user.self = true;
            return space;
        }
    }
    catch (error) {
        console.error(error);
    }
    return { user: Util.generateAnonymousUser() };
}
function init() {
    var createReloadHandler = function () {
        var iwcClient = window._iwc_instance_;
        var intent_listener = [];
        if (iwcClient && iwcClient.onIntent != null) {
            var previous_iwc_onIntent = iwcClient.onIntent;
            iwcClient.onIntent = function (message) {
                if (message.action === "RELOAD") {
                    console.log(" K!!!!!!!!!!!!!!!!!!!!!!!!!!!! RELOAD!!!!!!!!!!!!!!!!!!!!!");
                    window.location.reload();
                }
                else {
                    for (var i = 0; i < intent_listener.length; i++) {
                        intent_listener[i].apply(this, arguments);
                    }
                }
                previous_iwc_onIntent.apply(this, arguments);
            };
            window._addIwcIntentListener = function (f) {
                intent_listener.push(f);
            };
            window._reloadThisFuckingInstance = function () {
                console.log("Reloading Everything");
                var message = {
                    action: "RELOAD",
                    component: "",
                    data: "",
                    dataType: "",
                    flags: ["PUBLISH_GLOBAL"],
                    extras: {
                        reload: true,
                    },
                };
                iwcClient.publish(message);
            };
        }
        else {
            setTimeout(createReloadHandler, 5000);
        }
    };
    setTimeout(createReloadHandler, 10000);
}
const SyncMetaWidget = (superClass, widgetName) => {
    if (!widgetName) {
        throw new Error("widgetName cannot be empty");
    }
    class SyncMetaWidgetElement extends superClass {
        constructor() {
            super(...arguments);
            this.widgetName = widgetName;
        }
        createRenderRoot() {
            return this;
        }
        render() {
            return html ` <error-alert></error-alert> `;
        }
        firstUpdated() {
            this.hideErrorAlert();
        }
        connectedCallback() {
            super.connectedCallback();
            init();
            if (!window.hasOwnProperty("y")) {
                yjsSync().then((y) => {
                    if (!window.hasOwnProperty("y"))
                        window.y = y;
                });
            }
        }
        disconnectedCallback() {
            super.disconnectedCallback();
        }
        hideErrorAlert() {
            $(this.widgetName).find("#alert-message").text("");
            $(this.widgetName).find("error-alert").hide();
        }
        showErrorAlert(message) {
            $(this.widgetName).find("#alert-message").text(message);
            $(this.widgetName).find("error-alert").hide();
        }
    }
    SyncMetaWidgetElement.styles = css `
      .loading {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        /*noinspection CssUnknownTarget*/
        background: white url("/img/loading.gif") no-repeat center center;
        z-index: 32032;
        opacity: 0.75;
      }

      #oauthPersonalize,
      #oauthPersonalizeDone,
      #oauthPersonalizeComplete {
        position: relative;
        z-index: 32033;
      }

      #q {
        position: absolute;
        width: 100%;
        height: 3px;
        bottom: 0;
        left: 0;
        cursor: s-resize;
      }
    `;
    return SyncMetaWidgetElement;
};
let CanvasWidget = class CanvasWidget extends SyncMetaWidget(LitElement, getWidgetTagName(CONFIG$1.WIDGET.NAME.MAIN)) {
    render() {
        return html `
      <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/jquery-contextmenu/2.9.2/jquery.contextMenu.min.css"
      />

      <style>
        ${getWidgetTagName(CONFIG$1.WIDGET.NAME.MAIN)} {
          height: 100%;
        }
        .ui-resizable {
          /*jquery-ui adds this class to resizable objects. 
          However, the jsplumb library requires the position to be absolute, otherwise 
          offsets will be wrong. So we need to override this here.
          see https://github.com/rwth-acis/syncmeta/issues/86
          */
          position: absolute !important;
        }
        .button_bar {
          width: 50%;
          float: left;
          display: flex;
          flex-wrap: wrap;
        }
        .main-container {
          position: relative;
        }
        .button_bar.left {
          text-align: left;
        }
        .button_bar.right {
          text-align: right;
        }
        .node {
          z-index: 1;
          position: absolute;
          overflow: visible;
          border: 2px solid transparent;
        }
        .trace_awareness {
          z-index: 0;
          position: absolute;
          overflow: visible;
          opacity: 0;
          pointer-events: none;
        }
        div.class_node {
          height: inherit;
          width: inherit;
          border: 1px solid #aaa;
          border-radius: 1px;
          box-shadow: 2px 2px 2px #cccccc;
          color: #666 !important;
          font-size: 12px;
        }
        div.default_node {
          height: inherit;
          width: inherit;
        }
        div.custom_node {
          height: 100%;
          width: 100%;
          position: relative;
        }
        div.custom_node .fill_parent {
          position: absolute;
          top: 0;
          left: 0;
          bottom: 0;
          right: 0;
          width: inherit;
          height: inherit;
        }
        /*adjust label of custom nodes*/
        div.custom_node .fill_parent > div {
          left: 50%;
          top: -8px !important;
          -webkit-transform: translateY(-50%) translateX(-50%);
          -moz-transform: translateY(-50%) translateX(-50%);
          transform: translateY(-50%) translateX(-50%);
          pointer-events: none;
          overflow-x: auto;
        }

        div.simple_node {
          height: inherit;
          width: inherit;
          display: table;
        }

        .center .single_value_attribute .name {
          display: none;
        }
        .center .single_value_attribute .value .val {
          text-align: center;
        }

        div.simple_node div.label {
          display: table-cell;
          text-align: center;
          vertical-align: middle;
        }
        .box-overlay {
          position: absolute;
          background-color: #bbbbbb;
          opacity: 0;
          border-radius: 10px;
          cursor: move;
        }
        .selected {
          border: 3px solid #2bff6e;
        }
        #canvas-frame {
          overflow: hidden;
          width: 100%;
          height: 100%;
          position: relative;
        }
        #canvas {
          width: 100%;
          height: 100%;
          max-width: none !important;
          max-height: none !important;
          border-radius: 6px;
          position: relative !important; /*important because jsplumb will position according to this*/
          background-image: url("../images/grid.png");
          opacity: 1 !important;
        }
        #canvas.tool-move {
          cursor: move !important;
        }
        #canvas.tool-move ._jsPlumb_connector {
          cursor: pointer !important;
        }
        #canvas.tool-node {
          cursor: pointer !important;
        }
        #canvas.tool-edge {
          cursor: default !important;
        }
        #canvas.tool-edge.dragging {
          cursor: move !important;
        }
        #canvas.tool-edge .node,
        #canvas.tool-node .node {
          opacity: 1;
        }
        #canvas.tool-edge .node {
          cursor: pointer !important;
        }
        #canvas.tool-edge.dragging .node {
          cursor: move !important;
        }

        #feedback {
          margin: 10px;
          color: #777777;
        }

        button[disabled="disabled"],
        button:disabled {
          opacity: 0.5;
        }

        ._jsPlumb_overlay {
          font-size: 12px;
        }

        .class_node,
        .edge_shape_node,
        .node_shape_node,
        .enum_node,
        .abstract_class_node,
        .object_node,
        .relation_node {
          overflow: hidden;
        }

        .class_node .label,
        .edge_shape_node .label,
        .node_shape_node .label,
        .enum_node .label,
        .abstract_class_node .label,
        .object_node .label,
        .relation_node .label {
          border-bottom: 1px solid #999999;
        }

        .edge_label .single_value_attribute .name,
        .label .single_value_attribute .name,
        .title .single_value_attribute .name,
        .name .single_value_attribute .name {
          display: none;
        }

        .class_node .label,
        .edge_shape_node .label,
        .node_shape_node .label,
        .enum_node .label,
        .abstract_class_node .label,
        .object_node .label,
        .relation_node .label {
          text-align: center;
          font-weight: bold;
          display: block;
        }

        .value input {
          border: 0;
          background: none;
          outline: none;
        }

        .edge_label {
          width: 200px;
          cursor: pointer;
        }

        .edge_label.fixed {
          background-color: #f5f5f5;
          width: auto;
          font-size: 14px;
        }

        .edge_label .single_value_attribute .value input,
        .label .single_value_attribute .value input,
        .title .single_value_attribute .value input,
        .name .single_value_attribute .value input {
          border: 0;
          background: none;
          width: 100%;
          text-align: center;
          font-weight: bold;
          outline: none;
          margin: 2px auto;
          display: block;
        }

        .edge_label .single_value_attribute .value div.val {
          text-align: center;
        }

        .attributes .list_attribute .name {
          display: none;
        }

        .attributes .list_attribute ul.list {
          padding: 2px;
          margin: 0;
          list-style: none;
        }

        .attributes .list_attribute ul.list li.key_value_attribute,
        .attributes .list_attribute ul.list li.condition_predicate,
        .attributes .list_attribute ul.list li.renaming_attr {
          overflow: hidden;
        }

        .attributes .list_attribute ul.list li.key_value_attribute div.key {
          float: left;
          width: 50%;
        }

        .attributes .list_attribute ul.list li.key_value_attribute div.value {
          float: left;
          width: 50%;
        }
        .attributes .list_attribute ul.list li.condition_predicate div.property,
        .attributes .list_attribute ul.list li.condition_predicate div.operator,
        .attributes .list_attribute ul.list li.condition_predicate div.val,
        .attributes
          .list_attribute
          ul.list
          li.condition_predicate
          div.operator2 {
          float: left;
          margin-left: 3px;
        }

        .attributes .list_attribute ul.list li.renaming_attr div.val,
        .attributes .list_attribute ul.list li.renaming_attr div.ref {
          float: left;
          margin-left: 3px;
          width: 50%;
        }

        .attributes .list_attribute ul.list li.renaming_attr div.vis {
          float: right;
          margin-left: 3px;
        }

        .attributes
          .list_attribute
          ul.list
          li.key_value_attribute
          div.key
          input,
        .attributes
          .list_attribute
          ul.list
          li.key_value_attribute
          div.value
          input,
        .attributes
          .list_attribute
          ul.list
          li.condition_predicate
          div.val
          input,
        .attributes .list_attribute ul.list li.renaming_attr div.val input,
        .attributes .list_attribute ul.list li.renaming_attr div.ref input {
          width: 100%;
          border: 0;
          outline: none;
          background: none;
        }

        .attributes .single_value_attribute {
          overflow: hidden;
          margin-left: 1px;
        }

        .attributes .single_value_attribute .name {
          width: 50%;
          float: left;
          margin: 3px 0;
        }

        .attributes .single_value_attribute .value {
          width: 50%;
          float: left;
        }

        .attributes .single_value_attribute .value input {
          border: 0;
          color: #666 !important;
          margin: 0;
          background: none;
        }

        .attributes .value div.val {
          text-align: right;
          margin: 3px;
        }

        .attributes .value input.val {
          text-align: right;
          float: right;
        }

        .size-preview {
          z-index: 99;
          background-color: #ffffff;
          color: #666666;
          position: absolute;
          top: 0;
          left: 0;
          border: 1px dashed black;
        }

        #canvas.tool-edge .node.lowlighted,
        #canvas.tool-edge .node.target {
          opacity: 0.5;
        }

        #canvas.tool-edge .node.source {
          opacity: 1;
        }

        #canvas.tool-edge.dragging .node.source {
          opacity: 0.5;
        }

        #canvas.tool-edge.dragging .node.source.current,
        #canvas.tool-edge.dragging .node.target {
          opacity: 1;
        }

        #canvas.tool-edge ._jsPlumb_connector {
          opacity: 0.5;
        }

        #canvas.tool-edge ._jsPlumb_connector._jsPlumb_dragging {
          opacity: 1;
        }

        /*noinspection CssUnknownProperty*/
        .type {
          position: absolute;
          bottom: 105%;
          left: 50%;
          transform: translateX(-50%);
          -o-transform: translateX(-50%);
          -ms-transform: translateX(-50%);
          -moz-transform: translateX(-50%);
          -webkit-transform: translateX(-50%);
          text-align: center;
          overflow: visible;
          white-space: nowrap;
          color: #aaaaaa;
          font-size: 0.9em;
        }

        #canvas.hide_type .type {
          display: none;
        }

        #viewsHide {
          display: none;
        }

        #lblCurrentView {
          display: none;
        }
        .user_highlight {
          position: absolute;
          top: 100%;
          left: 0;
          font-size: 12px;
          font-weight: bold;
          white-space: nowrap;
          text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
        }

        .jtk-endpoint {
          z-index: 300000;
        }

        .ghost-edge {
          opacity: 0.3;
          z-index: 30000;
        }

        .ghost-edge-overlay {
          z-index: 31000;
        }
        /* VML colors */
        .object {
          background-color: rgb(213, 235, 253);
        }
        .nodeshape {
          background-color: rgba(213, 235, 253, 0.5);
        }
        .enum {
          background-color: #f9ffc6;
        }
        .relationship {
          background-color: #ffcece;
        }
        .edgeshape {
          background-color: rgba(255, 206, 206, 0.5);
        }
        .relation {
          background-color: #d5f5d5;
        }
        .abstractclass {
          background-color: #ffffff;
        }
        .main-container {
          position: relative;
        }
      </style>
      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.1/font/bootstrap-icons.css"
      />
      <link
        rel="stylesheet"
        type="text/css"
        href="https://code.jquery.com/ui/1.13.1/themes/smoothness/jquery-ui.css"
      />
      <link
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
        rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
        crossorigin="anonymous"
      />

      <div class="main-container p-2 d-flex flex-column h-100">
        <error-alert></error-alert>
        <div id="loading" class="loading"></div>
        <div class="row mb-2" id="main-widget-utilities-container">
          <div class="col-9">
            <button
              id="viewsHide"
              class="btn btn-light"
              title="Close the View Panel"
            >
              <i class="bi bi-caret-up"></i>
            </button>
            <button
              id="viewsShow"
              class="btn btn-light"
              title="Show the View Panel"
            >
              <i class="bi bi-caret-down"></i>
            </button>
            <button
              id="save"
              class="btn btn-light"
              title="Save the current state of the model"
            >
              <i class="bi bi-save"></i>
            </button>
            <!-- Uncommented the below line for Export as PNG! -->
            <button id="save_image" class="btn btn-light">
              <i class="bi bi-camera"></i>
            </button>
            <!--<button id="generate" style="display: none"><img width="20px" height="20px" src="<%= grunt.config('baseUrl') %>/img/generate.png" /></button>-->
            <button
              id="showtype"
              class="btn btn-light"
              title="Show the types of nodes and edges"
            >
              <i class="bi bi-tag"></i>
            </button>
            <button
              id="hideType"
              class="btn btn-light"
              title="Hide types of nodes and edges"
            >
              <i class="bi bi-tag-fill"></i>
            </button>
            <button id="applyLayout" class="btn btn-light" title="Apply Layout">
              <i class="bi bi-layout-wtf"></i>
            </button>
            <button id="zoomIn" class="btn btn-light" title="Zoom in">
              <i class="bi bi-zoom-in"></i>
            </button>
            <button id="zoomOut" class="btn btn-light" title="Zoom out">
              <i class="bi bi-zoom-out"></i>
            </button>
            <button
              id="undo"
              class="btn btn-light"
              title="Undo your latest changes"
            >
              <i class="bi bi-arrow-counterclockwise"></i>
            </button>
            <button
              id="redo"
              class="btn btn-light"
              title="Redo your latest changes"
            >
              <i class="bi bi-arrow-clockwise"></i>
            </button>
            <span id="feedback"></span>
            <strong id="lblCurrentView"
              >View:<span id="lblCurrentViewId"></span
            ></strong>
          </div>
          <div class="col-3">
            <div class="input-group mb-3">
              <input
                type="text"
                class="form-control"
                placeholder="Search Node..."
                aria-label="Search Node..."
                aria-describedby="button-addon2"
                id="searchNodeInput"
              />
              <button
                class="btn btn-outline-secondary"
                type="button"
                id="searchNodeButton"
              >
                <i class="bi bi-search"></i>
              </button>
            </div>
          </div>
          <div id="ViewCtrlContainer" class="flex my-2" style="display:none">
            <button
              id="btnCreateViewpoint"
              class="btn btn-light"
              title="Create a viewpoint"
            >
              <i class="bi bi-plus-circle"></i>
            </button>
            <button
              class="btn btn-light"
              id="btnCancelCreateViewpoint"
              title="Cancel"
              style="display: none;"
            >
              <i class="bi bi-x-circle"></i>
            </button>
            <input
              id="txtNameViewpoint"
              type="text"
              placeholder="name"
              style="display: none;"
            />
            <select id="ddmViewpointSelection" style="display: none;"></select>
            <button
              class="btn btn-light"
              id="btnAddViewpoint"
              title="Create an empty viewpoint"
              style="display: none;"
            >
              <i class="bi bi-check"></i>
            </button>

            <select id="ddmViewSelection"></select>
            <button
              id="btnShowView"
              class="btn btn-light"
              title="Apply a viewpoint to the current model or visualize the viewpoint"
            >
              Show
            </button>
            <button
              class="btn btn-light"
              id="btnRefreshView"
              title="Refresh viewpoint list"
              style="display: none;"
            >
              Refresh
            </button>
            <button
              class="btn btn-light"
              id="btnDelViewPoint"
              title="Delete current viewpoint in the list"
            >
              <i class="bi bi-trash"></i>
            </button>
          </div>

          <div
            class="col"
            id="dialog"
            style="display:none"
            title="Generate editor"
          >
            <p>
              <strong>Editor space url:</strong>
              <br />
              <span id="space_link_input"
                ><%= grunt.config('roleSandboxUrl') %>/<input
                  size="16"
                  type="text"
                  id="space_label"
              /></span>
              <span id="space_link_text" style="display: none"
                ><a id="space_link" target="_blank" href="#"></a
              ></span>
              <br />
              <span
                id="space_link_comment"
                style="color: #FF3333; display: none"
                >Space already exists, will be overwritten!</span
              >
            </p>
            <p>
              <strong>Editor space title:</strong
              ><input size="32" type="text" id="space_title" />
            </p>
          </div>
        </div>
        <div
          class="ui-state-error ui-corner-all"
          style="margin-top: 20px; padding: 0 .7em; display:none"
        >
          <p id="errorMsg">
            <span
              class="ui-icon ui-icon-alert"
              style="float: left; margin-right: .3em;"
            ></span>
            <strong>SYNCMETA!</strong>
          </p>
        </div>
        <div
          class="row mx-auto border border-dark border-2 rounded"
          id="canvas-frame"
        >
          <div id="canvas"></div>
        </div>
        <div id="q"></div>
        <loading-spinner></loading-spinner>
      </div>
    `;
    }
    connectedCallback() {
        super.connectedCallback();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
    }
    async firstUpdated(e) {
        super.firstUpdated(e);
        const alertDiv = $(getWidgetTagName(CONFIG$1.WIDGET.NAME.MAIN)).find(".alert");
        alertDiv.attr("style", "display:none !important");
        const user = await getUserInfo();
        if (!user) {
            console.error("user is undefined");
        }
        yjsSync()
            .then((y) => {
            console.info("CANVAS: Yjs Initialized successfully in room " +
                window.spaceTitle +
                " with y-user-id: " +
                y.clientID);
            const _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.MAIN, y);
            _iwcw.setSpace(user);
            const userMap = y.getMap("users");
            const dataMap = y.getMap("data");
            setTimeout(() => {
                try {
                    const user = _iwcw.getUser();
                    if (!user) {
                        throw new Error("User not set");
                    }
                    if (user.globalId !== -1) {
                        userMap.set(y.clientID.toString(), _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
                    }
                }
                catch (error) {
                    console.error(error);
                }
                if (!userMap.get(_iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID])) {
                    var userInfo = _iwcw.getUser();
                    userInfo.globalId = Util.getGlobalId(user, y);
                    userMap.set(_iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], userInfo);
                }
                let metamodel, model;
                const guidancemodel = getGuidanceModeling();
                if (guidancemodel.isGuidanceEditor()) {
                    model = dataMap.get("guidancemodel");
                    metamodel = dataMap.get("guidancemetamodel");
                }
                else {
                    metamodel = dataMap.get("metamodel");
                    model = dataMap.get("model");
                }
                if (model) {
                    console.info("CANVAS: Found model in yjs room with " +
                        Object.keys(model.nodes).length +
                        " nodes and " +
                        Object.keys(model.edges).length +
                        " edges.");
                }
                EntityManagerInstance$1.init(metamodel);
                EntityManagerInstance$1.setGuidance(guidancemodel);
                InitMainWidget(metamodel, model, _iwcw, user, y);
                window.onbeforeunload = function () {
                    const userList = y.getMap("userList");
                    const userMap = y.getMap("users");
                    userList.delete(_iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
                    userMap.delete(y.clientID.toString());
                    const activityMap = y.getMap("activity");
                    const leaveActivity = new ActivityOperation("UserLeftActivity", null, _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
                    activityMap.set("UserLeftActivity", leaveActivity.toJSON());
                };
            }, 1000);
        })
            .catch(function (message) {
            console.warn(message);
            alertDiv.find("#alert-message").text("Cannot connect to Yjs server.");
            alertDiv.show();
            const $mainWidgetRef = $(getWidgetTagName(CONFIG$1.WIDGET.NAME.MAIN));
            const $spinner = $mainWidgetRef.find("loading-spinner");
            $spinner.hide();
            alert("ERROR: " + message);
        });
    }
};
CanvasWidget = __decorate([
    e(getWidgetTagName(CONFIG$1.WIDGET.NAME.MAIN))
], CanvasWidget);
function registerOnDataReceivedCallback(_iwcw, y, userList, user) {
    _iwcw.registerOnDataReceivedCallback(function (operation) {
        const canvasMap = y.getMap("canvas");
        if (operation instanceof SetModelAttributeNodeOperation) {
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, new SetModelAttributeNodeOperation().toNonOTOperation());
        }
        else if (operation instanceof UpdateViewListOperation) {
            canvasMap.set(UpdateViewListOperation.TYPE, true);
        }
        else if (operation instanceof UpdateMetamodelOperation) {
            const dataMap = y.getMap("data");
            var model = dataMap.get("model");
            var vls = GenerateViewpointModel(model);
            yjsSync(operation.getModelingRoomName())
                .then(function (y) {
                const dataMap = y.getMap("data");
                dataMap.set("metamodel", vls);
                const metaModelStatus = y.getMap("metaModelStatus");
                metaModelStatus.set("uploaded", true);
            })
                .fail(() => {
                const metaModelStatus = y.getMap("metaModelStatus");
                metaModelStatus.set("error", true);
            });
        }
        else if (operation.hasOwnProperty("getType")) {
            if (operation.getType() === "WaitForCanvasOperation") {
                switch (operation.getData().widget) {
                    case CONFIG$1.WIDGET.NAME.ACTIVITY:
                        _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ACTIVITY, new NonOTOperation("WaitForCanvasOperation", JSON.stringify({ local: user, list: userList })));
                        break;
                    case CONFIG$1.WIDGET.NAME.HEATMAP:
                        _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.HEATMAP, new NonOTOperation("WaitForCanvasOperation", JSON.stringify(user)));
                        break;
                    case CONFIG$1.WIDGET.NAME.ATTRIBUTE:
                        _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, new NonOTOperation("WaitForCanvasOperation", JSON.stringify(user)));
                        break;
                    case CONFIG$1.WIDGET.NAME.PALETTE:
                        const dataMap = y.getMap("data");
                        var metamodel = dataMap.get("metamodel");
                        if (!metamodel)
                            metamodel = "{}";
                        else
                            metamodel = JSON.stringify(metamodel);
                        _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.PALETTE, new NonOTOperation("WaitForCanvasOperation", metamodel));
                        break;
                }
            }
        }
    });
}
function InitMainWidget(metamodel, model, _iwcw, user, y) {
    const $mainWidgetRef = $(getWidgetTagName(CONFIG$1.WIDGET.NAME.MAIN));
    const $spinner = $mainWidgetRef.find("loading-spinner");
    const userList = [];
    const canvasElement = $("#canvas");
    const canvas = new Canvas(canvasElement);
    const joinMap = y.getMap("join");
    HistoryManagerInstance.init(canvas);
    joinMap.forEach(function (value, key) {
        userList.push(key);
    });
    joinMap.observe(function (event) {
        event.keysChanged.forEach(function (key) {
            const userId = event.keysChanged[key];
            if (userList.indexOf(userId) === -1) {
                userList.push(userId);
            }
            if (userId !== _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]) {
                const joinMap = y.getMap("join");
                if (!joinMap.has(_iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]))
                    joinMap.set(_iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], true);
            }
            else {
                canvas.resetTool();
            }
        });
        const canvasMap = y.getMap("canvas");
        canvasMap.observe(function (event) {
            event.keysChanged.forEach((key) => {
                var _a;
                switch (key) {
                    case UpdateViewListOperation.TYPE: {
                        ViewManager$1.GetViewpointList();
                        break;
                    }
                    case "ReloadWidgetOperation": {
                        var text;
                        const value = event.currentTarget.get(key);
                        switch (value) {
                            case "import": {
                                const dataMap = y.getMap("data");
                                var model = dataMap.get("model");
                                text =
                                    "ATTENTION! Imported new model containing <strong>" +
                                        Object.keys(model.nodes).length +
                                        " nodes</strong> and <strong>" +
                                        Object.keys(model.edges).length +
                                        " edges</strong>. Some widgets will reload";
                                break;
                            }
                            case "delete": {
                                text =
                                    "ATTENTION! Deleted current model. Some widgets will reload";
                                break;
                            }
                            case "meta_delete": {
                                text =
                                    "ATTENTION! Deleted current metamodel. Some widgets will reload";
                                break;
                            }
                            case "meta_import": {
                                text =
                                    "ATTENTION! Imported new metamodel. Some widgets will reload";
                                break;
                            }
                        }
                        const dataMap = y.getMap("data");
                        const nodesMap = y.getMap("nodes");
                        for (var key of nodesMap.keys()) {
                            var nodeInModel = (_a = dataMap.get("model")) === null || _a === void 0 ? void 0 : _a.nodes[key];
                            if (nodeInModel) {
                                nodesMap.get(key).set("left", nodeInModel.left);
                                nodesMap.get(key).set("top", nodeInModel.top);
                            }
                        }
                        const activityMap = y.getMap("activity");
                        activityMap.set("ReloadWidgetOperation", new ActivityOperation("ReloadWidgetOperation", undefined, _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], text).toJSON());
                        location.reload();
                    }
                }
            });
        });
    });
    registerOnDataReceivedCallback(_iwcw, y, userList, user);
    if (metamodel) {
        if (metamodel.hasOwnProperty("nodes")) {
            let nodes = metamodel.nodes, node;
            for (const nodeId in nodes) {
                if (nodes.hasOwnProperty(nodeId)) {
                    node = nodes[nodeId];
                    canvas.addTool(node.label, new NodeTool$1(node.label, null, null, node.shape.containment, node.shape.defaultWidth, node.shape.defaultHeight));
                }
            }
        }
        if (metamodel.hasOwnProperty("edges")) {
            var edges = metamodel.edges, edge;
            for (var edgeId in edges) {
                if (edges.hasOwnProperty(edgeId)) {
                    edge = edges[edgeId];
                    canvas.addTool(edge.label, new EdgeTool$1(edge.label, edge.relations));
                }
            }
        }
        ViewManager$1.GetViewpointList();
        $("#btnCreateViewpoint").hide();
        $("#btnDelViewPoint").hide();
        var initTools = function (vvs) {
            if (vvs && vvs.hasOwnProperty("nodes")) {
                var nodes = vvs.nodes, node;
                for (var nodeId in nodes) {
                    if (nodes.hasOwnProperty(nodeId)) {
                        node = nodes[nodeId];
                        canvas.addTool(node.label, new NodeTool$1(node.label, null, null, node.shape.containment, node.shape.defaultWidth, node.shape.defaultHeight));
                    }
                }
            }
            if (vvs && vvs.hasOwnProperty("edges")) {
                var edges = vvs.edges, edge;
                for (var edgeId in edges) {
                    if (edges.hasOwnProperty(edgeId)) {
                        edge = edges[edgeId];
                        canvas.addTool(edge.label, new EdgeTool$1(edge.label, edge.relations));
                    }
                }
            }
        };
        $("#btnShowView").click(function () {
            var viewId = ViewManager$1.getViewIdOfSelected();
            var $currentViewIdLabel = $("#lblCurrentViewId");
            if (viewId === $currentViewIdLabel.text())
                return;
            const viewsMap = y.getMap("views");
            var vvs = viewsMap.get(viewId);
            EntityManagerInstance$1.initViewTypes(vvs);
            var operation = new InitModelTypesOperation(vvs, true).toNonOTOperation();
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.PALETTE, operation);
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation);
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.METADATA, operation);
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.OPENAPI, operation);
            var activityOperation = new ActivityOperation("ViewApplyActivity", vvs.id, _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
            _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ACTIVITY, activityOperation.toNonOTOperation());
            const canvasMap = y.getMap("canvas");
            canvasMap.set("ViewApplyActivity", {
                viewId: viewId,
                jabberId: _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID],
            });
            initTools(vvs);
            ViewGenerator$1.generate(metamodel, vvs);
            $("#lblCurrentView").show();
            $currentViewIdLabel.text(viewId);
        });
        $("#viewsHide").click(function () {
            $(this).hide();
            $("#viewsShow").show();
            $("#ViewCtrlContainer").hide();
            var $lblCurrentViewId = $("#lblCurrentViewId");
            var viewpointId = $lblCurrentViewId.text();
            if (viewpointId.length > 0) {
                var operation = new InitModelTypesOperation(metamodel, true);
                _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.PALETTE, operation.toNonOTOperation());
                _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.toNonOTOperation());
                var activityOperation = new ActivityOperation("ViewApplyActivity", "", _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
                _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ACTIVITY, activityOperation.toNonOTOperation());
                const canvasMap = y.getMap("canvas");
                canvasMap.set("ViewApplyActivity", {
                    viewId: "",
                    jabberId: _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID],
                });
                EntityManagerInstance$1.setViewId(null);
                EntityManagerInstance$1.initModelTypes(metamodel);
                initTools(metamodel);
                ViewGenerator$1.reset(metamodel);
                $("#lblCurrentView").hide();
                $lblCurrentViewId.text("");
            }
        });
        var $saveImage = $("#save_image");
        $saveImage.show();
        $saveImage.click(function () {
            canvas.toPNG().then(function (uri) {
                var link = document.createElement("a");
                link.download = "export.png";
                link.href = uri;
                link.click();
            });
        });
    }
    else {
        canvas.addTool(ObjectNode$1.TYPE, new ObjectNodeTool$1());
        canvas.addTool(AbstractClassNode$1.TYPE, new AbstractClassNodeTool$1());
        canvas.addTool(RelationshipNode$1.TYPE, new RelationshipNodeTool$1());
        canvas.addTool(RelationshipGroupNode$1.TYPE, new RelationshipGroupNodeTool$1());
        canvas.addTool(EnumNode$1.TYPE, new EnumNodeTool$1());
        canvas.addTool(NodeShapeNode$1.TYPE, new NodeShapeNodeTool$1());
        canvas.addTool(EdgeShapeNode$1.TYPE, new EdgeShapeNodeTool$1());
        canvas.addTool(GeneralisationEdge$1.TYPE, new GeneralisationEdgeTool$1());
        canvas.addTool(BiDirAssociationEdge$1.TYPE, new BiDirAssociationEdgeTool$1());
        canvas.addTool(UniDirAssociationEdge$1.TYPE, new UniDirAssociationEdgeTool$1());
        canvas.addTool(ViewObjectNode$1.TYPE, new ViewObjectNodeTool$1());
        canvas.addTool(ViewRelationshipNode$1.TYPE, new ViewRelationshipNodeTool$1());
        $("#btnCreateViewpoint").click(function () {
            ShowViewCreateMenu();
        });
        $("#btnCancelCreateViewpoint").click(function () {
            HideCreateMenu();
        });
        $("#btnShowView").click(function () {
            var viewId = ViewManager$1.getViewIdOfSelected();
            if (viewId === $("#lblCurrentViewId").text())
                return;
            $("#loading").show();
            $("#lblCurrentView").show();
            $("#lblCurrentViewId").text(viewId);
            visualizeView(viewId);
        });
        $("#btnDelViewPoint").click(function () {
            const viewsMap = y.getMap("views");
            var viewId = ViewManager$1.getViewIdOfSelected();
            if (viewId && viewId !== $("#lblCurrentViewId").text()) {
                viewsMap.delete(viewId);
                _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, new DeleteViewOperation(viewId).toNonOTOperation());
                ViewManager$1.deleteView(viewId);
            }
            else {
                viewsMap.set(viewId, null);
                ViewManager$1.deleteView(viewId);
                $("#viewsHide").click();
            }
        });
        $("#btnAddViewpoint").click(function () {
            var viewId = $("#txtNameViewpoint").val();
            if (ViewManager$1.existsView(viewId)) {
                alert("View already exists");
                return;
            }
            ViewManager$1.addView(viewId);
            HideCreateMenu();
            const canvasMap = y.getMap("canvas");
            canvasMap.set(UpdateViewListOperation.TYPE, true);
        });
        $("#viewsHide").click(function () {
            $(this).hide();
            $("#viewsShow").show();
            $("#ViewCtrlContainer").hide("fast");
            var $lblCurrentViewId = $("#lblCurrentViewId");
            const dataMap = y.getMap("data");
            if ($lblCurrentViewId.text().length > 0) {
                var $loading = $("#loading");
                $loading.show();
                var model = dataMap.get("model");
                var operation = new SetViewTypesOperation(false);
                _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.PALETTE, operation.toNonOTOperation());
                var activityOperation = new ActivityOperation("ViewApplyActivity", "", _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
                _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ACTIVITY, activityOperation.toNonOTOperation());
                const canvasMap = y.getMap("canvas");
                canvasMap.set("ViewApplyActivity", {
                    viewId: "",
                    jabberId: _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID],
                });
                resetCanvas();
                JSONtoGraph(model, canvas);
                $("#loading").hide();
                canvas.resetTool();
                $("#lblCurrentView").hide();
                $lblCurrentViewId.text("");
                EntityManagerInstance$1.setViewId(null);
            }
        });
    }
    var ShowViewCreateMenu = function () {
        $("#btnCreateViewpoint").hide();
        $("#ddmViewSelection").hide();
        $("#btnShowView").hide();
        $("#btnDelViewPoint").hide();
        $("#txtNameViewpoint").show();
        $("#btnAddViewpoint").show();
        $("#btnCancelCreateViewpoint").show();
    };
    var HideCreateMenu = function () {
        $("#btnCreateViewpoint").show();
        $("#ddmViewSelection").show();
        $("#btnDelViewPoint").show();
        $("#btnShowView").show();
        $("#txtNameViewpoint").hide();
        $("#btnAddViewpoint").hide();
        $("#btnCancelCreateViewpoint").hide();
    };
    function resetCanvas() {
        var edges = EntityManagerInstance$1.getEdges();
        for (edgeId in edges) {
            if (edges.hasOwnProperty(edgeId)) {
                var edge = EntityManagerInstance$1.findEdge(edgeId);
                edge.remove();
            }
        }
        var nodes = EntityManagerInstance$1.getNodes();
        for (const nodeId in nodes) {
            if (nodes.hasOwnProperty(nodeId)) {
                var node = EntityManagerInstance$1.findNode(nodeId);
                node.remove();
            }
        }
        EntityManagerInstance$1.deleteModelAttribute();
    }
    var visualizeView = function (viewId) {
        const viewsMap = y.getMap("views");
        var viewData = viewsMap.get(viewId);
        if (viewData) {
            resetCanvas();
            ViewToGraph(viewData);
            $("#lblCurrentView").show();
            $("#lblCurrentViewId").text(viewData.id);
            EntityManagerInstance$1.setViewId(viewData.id);
            canvas.resetTool();
        }
    };
    function ViewToGraph(json) {
        var operation = new ViewInitOperation(json);
        _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, operation.toNonOTOperation());
        operation = new SetViewTypesOperation(true);
        _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.PALETTE, operation.toNonOTOperation());
        var activityOperation = new ActivityOperation("ViewApplyActivity", json.id, _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
        _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ACTIVITY, activityOperation.toNonOTOperation());
        const canvasMap = y.getMap("canvas");
        canvasMap.set("ViewApplyActivity", {
            viewId: json.id,
            jabberId: _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID],
        });
        JSONtoGraph(json, canvas);
        $("#loading").hide();
        canvas.resetTool();
    }
    var $undo = $("#undo");
    $undo.prop("disabled", true);
    var $redo = $("#redo");
    $redo.prop("disabled", true);
    $undo.click(function () {
        HistoryManagerInstance.undo();
    });
    $redo.click(function () {
        HistoryManagerInstance.redo();
    });
    $("#showtype")
        .click(function () {
        canvas.get$node().removeClass("hide_type");
        $(this).hide();
        $("#hideType").show();
    })
        .hide();
    $("#hideType").click(function () {
        canvas.get$node().addClass("hide_type");
        $(this).hide();
        $("#showtype").show();
    });
    $("#viewsShow").click(function () {
        $(this).hide();
        $("#viewsHide").show();
        $("#ViewCtrlContainer").show("fast");
    });
    $("#zoomIn").click(function () {
        canvas.setZoom(canvas.getZoom() + 0.1);
    });
    $("#zoomOut").click(function () {
        canvas.setZoom(canvas.getZoom() - 0.1);
    });
    $("#applyLayout").click(function () {
        const userMap = window.y.getMap("users");
        const canvasMap = window.y.getMap("canvas");
        canvasMap.set("applyLayout", userMap.get(window.y.clientID.toString()));
        const activityMap = window.y.getMap("activity");
        activityMap.set("ApplyLayoutActivity", new ActivityOperation("ApplyLayoutActivity", null, userMap.get(window.y.clientID.toString()), "..applied Layout").toJSON());
    });
    var $feedback = $("#feedback");
    var saveFunction = function () {
        $feedback.text("Saving...");
        var viewId = $("#lblCurrentViewId").text();
        if (viewId.length > 0 && !metamodel) {
            ViewManager$1.updateViewContent(viewId);
            $feedback.text("Saved!");
            setTimeout(function () {
                $feedback.text("");
            }, 1000);
        }
        else {
            EntityManagerInstance$1.storeDataYjs();
            $feedback.text("Saved!");
            setTimeout(function () {
                $feedback.text("");
            }, 1000);
        }
    };
    $("#save").click(function () {
        saveFunction();
    });
    $("#dialog").dialog({
        autoOpen: false,
        resizable: false,
        height: 350,
        width: 400,
        modal: true,
        buttons: {
            Generate: function (event) {
                var title = $("#space_title").val();
                var label = $("#space_label")
                    .val()
                    .toString()
                    .replace(/[^a-zA-Z]/g, "")
                    .toLowerCase();
                if (title === "" || label === "")
                    return;
                EntityManagerInstance$1.generateSpace(label, title).then(function (spaceObj) {
                    var operation = new ActivityOperation("EditorGenerateActivity", "-1", _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID], '..generated new Editor <a href="' +
                        spaceObj.spaceURI +
                        '" target="_blank">' +
                        spaceObj.spaceTitle +
                        "</a>", {}).toNonOTOperation();
                    _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ACTIVITY, operation);
                    $("#space_link")
                        .text(spaceObj.spaceURI)
                        .attr({ href: spaceObj.spaceURI })
                        .show();
                    $("#space_link_text").show();
                    $("#space_link_input").hide();
                    $(event.target).parent().hide();
                });
            },
            Close: function () {
                $(this).dialog("close");
            },
        },
        open: function () {
            var name = canvas
                .getModelAttributesNode()
                .getAttribute("modelAttributes[name]")
                .getValue()
                .getValue();
            var $spaceTitle = $("#space_title");
            var $spaceLabel = $("#space_label");
            if ($spaceTitle.val() === "")
                $spaceTitle.val(name);
            if ($spaceLabel.val() === "")
                $spaceLabel.val(name.replace(/[^a-zA-Z]/g, "").toLowerCase());
            $(":button:contains('Generate')").show();
        },
        close: function () {
            $("#space_link_text").hide();
            $("#space_link_input").show();
        },
    });
    var $generate = $("#generate").click(function () {
        $("#dialog").dialog("open");
    });
    if (!metamodel ||
        (!metamodel.hasOwnProperty("nodes") && !metamodel.hasOwnProperty("edges"))) {
        $generate.show();
    }
    if (metamodel) {
        var op = new InitModelTypesOperation(metamodel);
        _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.PALETTE, op.toNonOTOperation());
        _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.ATTRIBUTE, op.toNonOTOperation());
    }
    const $searchInput = $("#searchNodeInput");
    const $searchButton = $("#searchNodeButton");
    $searchButton.click(function () {
        const searchValue = $searchInput.val();
        const searchResultNode = EntityManagerInstance$1.findObjectNodeByLabel(searchValue);
        if (searchResultNode) {
            canvas.scrollNodeIntoView(searchResultNode);
            canvas.select(searchResultNode);
        }
    });
    $searchInput.keypress(function (e) {
        if (e.which == 13) {
            $searchButton.click();
        }
    });
    if (model) {
        var report = JSONtoGraph(model, canvas);
        console.info("CANVAS: Initialization of model completed ", report);
        const dataMap = y.getMap("data");
        if (EntityManagerInstance$1.getLayer() === CONFIG$1.LAYER.META) {
            dataMap.set("guidancemetamodel", EntityManagerInstance$1.generateGuidanceMetamodel());
            dataMap.set("metamodelpreview", EntityManagerInstance$1.generateMetaModel());
        }
    }
    else {
        if (canvas.getModelAttributesNode() === null) {
            var modelAttributesNode = EntityManagerInstance$1.createModelAttributesNode(y);
            modelAttributesNode.registerYMap();
            canvas.setModelAttributesNode(modelAttributesNode);
            modelAttributesNode.addToCanvas(canvas);
        }
    }
    const userId = _iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID];
    if (!joinMap.has(_iwcw.getUser()[CONFIG$1.NS.PERSON.JABBERID]))
        joinMap.set(userId.toString(), false);
    ViewManager$1.GetViewpointList();
    $spinner.hide();
}
class AbstractEntity {
    constructor(id) {
        var _id = id;
        this.getEntityId = function () {
            return _id;
        };
    }
}
const abstractAttributeHtml = "<div class=\"attribute\"></div>";
class AbstractAttribute extends AbstractEntity {
    constructor(id, name, subjectEntity) {
        super(id);
        var _name = name;
        var _$node = $(lodash.template(abstractAttributeHtml)());
        var _subjectEntity = subjectEntity;
        this.setName = function (name) {
            _name = name;
        };
        this.getName = function () {
            return _name;
        };
        this.getSubjectEntity = function () {
            return _subjectEntity;
        };
        this.getRootSubjectEntity = function () {
            var rootSubjectEntity = this.getSubjectEntity();
            while (rootSubjectEntity instanceof AbstractAttribute) {
                rootSubjectEntity = rootSubjectEntity.getSubjectEntity();
            }
            return rootSubjectEntity;
        };
        this.getSubjectEntityId = function () {
            return _subjectEntity.getEntityId();
        };
        this._get$node = function () {
            return _$node;
        };
    }
    get$node() {
        this._get$node();
    }
}
class AbstractValue {
    constructor(id, name, subjectEntity, rootSubjectEntity) {
        var _id = id;
        var _name = name;
        var _subjectEntity = subjectEntity;
        var _rootSubjectEntity = rootSubjectEntity;
        this.getEntityId = function () {
            return _id;
        };
        this.getName = function () {
            return _name;
        };
        this.getSubjectEntity = function () {
            return _subjectEntity;
        };
        this.getRootSubjectEntity = function () {
            return _rootSubjectEntity;
        };
    }
}
const booleanValueHtml = "<input\n  class=\"form-check-input val\"\n  type=\"checkbox\"\n  name=\"<%= name %>\"\n  <% if (value) { %> checked=\"checked\" <% } %> />\n";
class BooleanValue extends AbstractValue {
    constructor(id, name, subjectEntity, rootSubjectEntity, options) {
        super(id, name, subjectEntity, rootSubjectEntity);
        var that = this;
        var _value = false;
        var _$node = $(lodash.template(booleanValueHtml)({
            name: name,
            options: options,
            value: _value,
        }));
        var _iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var processValueChangeOperation = function (operation) {
            that.setValue(operation.getValue());
        };
        var propagateValueChange = function (type, value) {
            var operation = new ValueChangeOperation(that.getEntityId(), value, type, null, _iwc.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
            propagateValueChangeOperation(operation);
        };
        var propagateValueChangeOperation = function (operation) {
            processValueChangeOperation(operation);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(rootSubjectEntity.getEntityId());
            if (ymap) {
                var json = operation.toJSON();
                json.userId = _iwc.getUser()[CONFIG$1.NS.PERSON.JABBERID];
                ymap.set(that.getEntityId(), json);
            }
        };
        var valueChangeCallback = function (operation) {
            if (operation instanceof ValueChangeOperation &&
                operation.getEntityId() === that.getEntityId()) {
                processValueChangeOperation(operation);
            }
        };
        var init = function () {
            _$node.off();
            _$node.change(function () {
                propagateValueChange(CONFIG$1.OPERATION.TYPE.UPDATE, this.checked);
            });
        };
        this.setValue = function (value) {
            _value = value;
            _$node.prop("checked", value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.registerCallbacks = function () {
            _iwc.registerOnDataReceivedCallback(valueChangeCallback);
        };
        this.unregisterCallbacks = function () {
            _iwc.unregisterOnDataReceivedCallback(valueChangeCallback);
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        init();
        if (_iwc) {
            that.registerCallbacks();
        }
    }
}
const booleanAttributeHtml = "<div class=\"attribute_single_value_attribute input-group mb-3\">\n  <div class=\"attribute_name\"></div>\n  <div class=\"attribute_value\"></div>\n</div>\n";
class BooleanAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity, options) {
        super(id, name, subjectEntity);
        var _value = new BooleanValue(id, name, this, this.getRootSubjectEntity(), options);
        var _$node = $(lodash.template(booleanAttributeHtml)());
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".attribute_name").text(this.getName());
        _$node.find(".attribute_value").append(_value.get$node());
        if (window.hasOwnProperty("y")) {
            const widgetConfigMap = y.getMap("widgetConfig");
            if (widgetConfigMap.get("view_only_property_browser")) {
                _$node.find(".val").attr("disabled", "true");
            }
        }
    }
}
const openapp = new OpenAppProvider().openapp;
const fileValueHtml = "<div class=\"file\">\n  <div class=\"select_file\">\n    <input class=\"form-control\" type=\"file\" id=\"file_object\" />\n    <input class=\"form-control\" type=\"button\" id=\"file_submit\" value=\"Submit\" />\n  </div>\n  <div class=\"manage_file\">\n    <span id=\"file_name\"></span>\n    <button id=\"file_preview\">Preview</button>\n    <button>\n      <a\n        id=\"file_download\"\n        href=\"#\"\n        target=\"_blank\"\n        style=\"color: #000; text-decoration: none\"\n        >Download</a\n      >\n    </button>\n    <button id=\"file_delete\">Delete</button>\n  </div>\n</div>\n";
class FileValue extends AbstractValue {
    constructor(id, name, subjectEntity, rootSubjectEntity, options) {
        super(id, name, subjectEntity, rootSubjectEntity);
        var that = this;
        var _value = "";
        var _$node = $(lodash.template(fileValueHtml)({ name: name, options: options }));
        var _$selectFile = _$node.find(".select_file");
        var _$manageFile = _$node.find(".manage_file");
        var _iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var processValueChangeOperation = function (operation) {
            that.setValue(operation.getValue());
        };
        var propagateValueChange = function (type, value, position) {
            var operation = new ValueChangeOperation(that.getEntityId(), value, type, position);
            propagateValueChangeOperation(operation);
        };
        var propagateValueChangeOperation = function (operation) {
            processValueChangeOperation(operation);
            _iwc.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.getOTOperation());
        };
        var valueChangeCallback = function (operation) {
            if (operation instanceof ValueChangeOperation &&
                operation.getEntityId() === that.getEntityId()) {
                processValueChangeOperation(operation);
            }
        };
        var uploadFile = function (name, type, data) {
            var resourceSpace = new openapp.oo.Resource(openapp.param.space());
            resourceSpace.create({
                relation: openapp.ns.role + "data",
                type: "my:ns:file",
                representation: {
                    name: name,
                    type: type,
                    data: data,
                },
                callback: function (d) {
                    if (d.uri) {
                        propagateValueChange(CONFIG$1.OPERATION.TYPE.UPDATE, d.uri, 0);
                    }
                },
            });
        };
        var init = function () {
            _$selectFile.find("#file_object").change(function () {
                var files = $(this)[0].files, file;
                if (!files || files.length === 0)
                    return;
                file = files[0];
                if (file.size > 1048576) {
                    alert("Chosen file is too large. Maximum size: 1MB");
                }
            });
            _$selectFile.find("#file_submit").click(function () {
                var fileReader, files = _$selectFile.find("#file_object")[0].files, file;
                if (!files || files.length === 0)
                    return;
                file = files[0];
                fileReader = new FileReader();
                fileReader.onload = function (e) {
                    uploadFile(file.name, file.type, e.target.result);
                };
                fileReader.readAsDataURL(file);
            });
            _$manageFile.find("#file_delete").click(function () {
                propagateValueChange(CONFIG$1.OPERATION.TYPE.UPDATE, "", 0);
            });
            _$selectFile.show();
            _$manageFile.hide();
        };
        this.setValue = function (value) {
            var $fileObject = _$selectFile.find("#file_object"), $fileName = _$manageFile.find("#file_name"), $downloadLink = _$manageFile.find("#file_download"), $previewLink = _$manageFile.find("#file_preview");
            _value = value;
            if (_value === "") {
                $fileObject.replaceWith($fileObject.clone(true));
                _$selectFile.show();
                _$manageFile.hide();
            }
            else {
                $.get(_value + "/:representation").done(function (data) {
                    $downloadLink[0].download = data.name;
                    $downloadLink[0].href = data.data;
                    $previewLink.click(function (e) {
                        e.preventDefault();
                        window.open(data.data, "_blank");
                    });
                    $fileName.text(data.name.length > 15
                        ? data.name.substr(0, 5) + ".." + data.name.substr(-10)
                        : data.name);
                    _$selectFile.hide();
                    _$manageFile.show();
                });
            }
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.registerCallbacks = function () {
            _iwc.registerOnDataReceivedCallback(valueChangeCallback);
        };
        this.unregisterCallbacks = function () {
            _iwc.unregisterOnDataReceivedCallback(valueChangeCallback);
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        init();
        if (_iwc) {
            that.registerCallbacks();
        }
    }
}
const fileAttributeHtml = "<div class=\"attribute_single_value_attribute input-group mb-3\">\n  <div class=\"attribute_name\"></div>\n  <div class=\"attribute_value\"></div>\n</div>\n";
class FileAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity, options) {
        super(id, name, subjectEntity);
        var _value = new FileValue(id, name, this, this.getRootSubjectEntity(), options);
        var _$node = $(lodash.template(fileAttributeHtml)());
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".attribute_name").text(this.getName());
        _$node.find(".attribute_value").append(_value.get$node());
    }
}
const integerValueHtml = "<input\n  class=\"form-control h-100 val\"\n  type=\"number\"\n  name=\"<%= name %>\"\n  value=\"0\"\n/>\n";
class IntegerValue extends AbstractValue {
    constructor(id, name, subjectEntity, rootSubjectEntity, options) {
        super(id, name, subjectEntity, rootSubjectEntity);
        var that = this;
        var _value = 0;
        var _$node = $(lodash.template(integerValueHtml)({ name: name, options: options }));
        var _iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var processValueChangeOperation = function (operation) {
            that.setValue(operation.getValue());
        };
        var propagateValueChange = function (type, value, position) {
            var operation = new ValueChangeOperation(that.getEntityId(), value, type, position, _iwc.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
            propagateValueChangeOperation(operation);
        };
        var propagateValueChangeOperation = function (operation) {
            processValueChangeOperation(operation);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(rootSubjectEntity.getEntityId());
            if (ymap) {
                ymap.set(that.getEntityId(), operation.toJSON());
            }
        };
        var valueChangeCallback = function (operation) {
            if (operation instanceof ValueChangeOperation &&
                operation.getEntityId() === that.getEntityId()) {
                processValueChangeOperation(operation);
            }
        };
        var init = function () {
            _$node.off();
            _$node.change(function () {
                var value = parseInt(_$node.val());
                if (isNaN(value)) {
                    value = 0;
                }
                propagateValueChange(CONFIG$1.OPERATION.TYPE.UPDATE, value, 0);
            });
        };
        this.setValue = function (value) {
            _value = value;
            _$node.val(value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.registerCallbacks = function () {
            _iwc.registerOnDataReceivedCallback(valueChangeCallback);
        };
        this.unregisterCallbacks = function () {
            _iwc.unregisterOnDataReceivedCallback(valueChangeCallback);
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        init();
        if (_iwc) {
            that.registerCallbacks();
        }
    }
}
const integerAttributeHtml = "<div class=\"attribute_single_value_attribute input-group mb-3 flex-nowrap\">\n  <div\n    class=\"attribute_name input-group-text overflow-auto\"\n    style=\"max-width: 50%\"\n  ></div>\n  <div class=\"attribute_value flex-fill\"></div>\n</div>\n";
class IntegerAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity, options) {
        super(id, name, subjectEntity);
        var _value = new IntegerValue(id, name, this, this.getRootSubjectEntity(), options);
        var _$node = $(lodash.template(integerAttributeHtml)());
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".attribute_name").text(this.getName());
        _$node.find(".attribute_value").append(_value.get$node());
        if (window.hasOwnProperty("y")) {
            const widgetConfigMap = y.getMap("widgetConfig");
            if (widgetConfigMap.get("view_only_property_browser")) {
                _$node.find(".val").attr("disabled", "true");
            }
        }
    }
}
var quill = { exports: {} };
(function (module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
        module.exports = factory();
    })(typeof self !== 'undefined' ? self : commonjsGlobal, function () {
        return (function (modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
                if (installedModules[moduleId]) {
                    return installedModules[moduleId].exports;
                }
                var module = installedModules[moduleId] = {
                    i: moduleId,
                    l: false,
                    exports: {}
                };
                modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                module.l = true;
                return module.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.d = function (exports, name, getter) {
                if (!__webpack_require__.o(exports, name)) {
                    Object.defineProperty(exports, name, {
                        configurable: false,
                        enumerable: true,
                        get: getter
                    });
                }
            };
            __webpack_require__.n = function (module) {
                var getter = module && module.__esModule ?
                    function getDefault() { return module['default']; } :
                    function getModuleExports() { return module; };
                __webpack_require__.d(getter, 'a', getter);
                return getter;
            };
            __webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
            __webpack_require__.p = "";
            return __webpack_require__(__webpack_require__.s = 109);
        })([
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", { value: true });
                var container_1 = __webpack_require__(17);
                var format_1 = __webpack_require__(18);
                var leaf_1 = __webpack_require__(19);
                var scroll_1 = __webpack_require__(45);
                var inline_1 = __webpack_require__(46);
                var block_1 = __webpack_require__(47);
                var embed_1 = __webpack_require__(48);
                var text_1 = __webpack_require__(49);
                var attributor_1 = __webpack_require__(12);
                var class_1 = __webpack_require__(32);
                var style_1 = __webpack_require__(33);
                var store_1 = __webpack_require__(31);
                var Registry = __webpack_require__(1);
                var Parchment = {
                    Scope: Registry.Scope,
                    create: Registry.create,
                    find: Registry.find,
                    query: Registry.query,
                    register: Registry.register,
                    Container: container_1.default,
                    Format: format_1.default,
                    Leaf: leaf_1.default,
                    Embed: embed_1.default,
                    Scroll: scroll_1.default,
                    Block: block_1.default,
                    Inline: inline_1.default,
                    Text: text_1.default,
                    Attributor: {
                        Attribute: attributor_1.default,
                        Class: class_1.default,
                        Style: style_1.default,
                        Store: store_1.default,
                    },
                };
                exports.default = Parchment;
            }),
            (function (module, exports, __webpack_require__) {
                var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b)
                            if (b.hasOwnProperty(p))
                                d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                Object.defineProperty(exports, "__esModule", { value: true });
                var ParchmentError = (function (_super) {
                    __extends(ParchmentError, _super);
                    function ParchmentError(message) {
                        var _this = this;
                        message = '[Parchment] ' + message;
                        _this = _super.call(this, message) || this;
                        _this.message = message;
                        _this.name = _this.constructor.name;
                        return _this;
                    }
                    return ParchmentError;
                }(Error));
                exports.ParchmentError = ParchmentError;
                var attributes = {};
                var classes = {};
                var tags = {};
                var types = {};
                exports.DATA_KEY = '__blot';
                var Scope;
                (function (Scope) {
                    Scope[Scope["TYPE"] = 3] = "TYPE";
                    Scope[Scope["LEVEL"] = 12] = "LEVEL";
                    Scope[Scope["ATTRIBUTE"] = 13] = "ATTRIBUTE";
                    Scope[Scope["BLOT"] = 14] = "BLOT";
                    Scope[Scope["INLINE"] = 7] = "INLINE";
                    Scope[Scope["BLOCK"] = 11] = "BLOCK";
                    Scope[Scope["BLOCK_BLOT"] = 10] = "BLOCK_BLOT";
                    Scope[Scope["INLINE_BLOT"] = 6] = "INLINE_BLOT";
                    Scope[Scope["BLOCK_ATTRIBUTE"] = 9] = "BLOCK_ATTRIBUTE";
                    Scope[Scope["INLINE_ATTRIBUTE"] = 5] = "INLINE_ATTRIBUTE";
                    Scope[Scope["ANY"] = 15] = "ANY";
                })(Scope = exports.Scope || (exports.Scope = {}));
                function create(input, value) {
                    var match = query(input);
                    if (match == null) {
                        throw new ParchmentError("Unable to create " + input + " blot");
                    }
                    var BlotClass = match;
                    var node = input instanceof Node || input['nodeType'] === Node.TEXT_NODE ? input : BlotClass.create(value);
                    return new BlotClass(node, value);
                }
                exports.create = create;
                function find(node, bubble) {
                    if (bubble === void 0) {
                        bubble = false;
                    }
                    if (node == null)
                        return null;
                    if (node[exports.DATA_KEY] != null)
                        return node[exports.DATA_KEY].blot;
                    if (bubble)
                        return find(node.parentNode, bubble);
                    return null;
                }
                exports.find = find;
                function query(query, scope) {
                    if (scope === void 0) {
                        scope = Scope.ANY;
                    }
                    var match;
                    if (typeof query === 'string') {
                        match = types[query] || attributes[query];
                    }
                    else if (query instanceof Text || query['nodeType'] === Node.TEXT_NODE) {
                        match = types['text'];
                    }
                    else if (typeof query === 'number') {
                        if (query & Scope.LEVEL & Scope.BLOCK) {
                            match = types['block'];
                        }
                        else if (query & Scope.LEVEL & Scope.INLINE) {
                            match = types['inline'];
                        }
                    }
                    else if (query instanceof HTMLElement) {
                        var names = (query.getAttribute('class') || '').split(/\s+/);
                        for (var i in names) {
                            match = classes[names[i]];
                            if (match)
                                break;
                        }
                        match = match || tags[query.tagName];
                    }
                    if (match == null)
                        return null;
                    if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope)
                        return match;
                    return null;
                }
                exports.query = query;
                function register() {
                    var Definitions = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        Definitions[_i] = arguments[_i];
                    }
                    if (Definitions.length > 1) {
                        return Definitions.map(function (d) {
                            return register(d);
                        });
                    }
                    var Definition = Definitions[0];
                    if (typeof Definition.blotName !== 'string' && typeof Definition.attrName !== 'string') {
                        throw new ParchmentError('Invalid definition');
                    }
                    else if (Definition.blotName === 'abstract') {
                        throw new ParchmentError('Cannot register abstract class');
                    }
                    types[Definition.blotName || Definition.attrName] = Definition;
                    if (typeof Definition.keyName === 'string') {
                        attributes[Definition.keyName] = Definition;
                    }
                    else {
                        if (Definition.className != null) {
                            classes[Definition.className] = Definition;
                        }
                        if (Definition.tagName != null) {
                            if (Array.isArray(Definition.tagName)) {
                                Definition.tagName = Definition.tagName.map(function (tagName) {
                                    return tagName.toUpperCase();
                                });
                            }
                            else {
                                Definition.tagName = Definition.tagName.toUpperCase();
                            }
                            var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];
                            tagNames.forEach(function (tag) {
                                if (tags[tag] == null || Definition.className == null) {
                                    tags[tag] = Definition;
                                }
                            });
                        }
                    }
                    return Definition;
                }
                exports.register = register;
            }),
            (function (module, exports, __webpack_require__) {
                var diff = __webpack_require__(51);
                var equal = __webpack_require__(11);
                var extend = __webpack_require__(3);
                var op = __webpack_require__(20);
                var NULL_CHARACTER = String.fromCharCode(0);
                var Delta = function (ops) {
                    if (Array.isArray(ops)) {
                        this.ops = ops;
                    }
                    else if (ops != null && Array.isArray(ops.ops)) {
                        this.ops = ops.ops;
                    }
                    else {
                        this.ops = [];
                    }
                };
                Delta.prototype.insert = function (text, attributes) {
                    var newOp = {};
                    if (text.length === 0)
                        return this;
                    newOp.insert = text;
                    if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
                        newOp.attributes = attributes;
                    }
                    return this.push(newOp);
                };
                Delta.prototype['delete'] = function (length) {
                    if (length <= 0)
                        return this;
                    return this.push({ 'delete': length });
                };
                Delta.prototype.retain = function (length, attributes) {
                    if (length <= 0)
                        return this;
                    var newOp = { retain: length };
                    if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
                        newOp.attributes = attributes;
                    }
                    return this.push(newOp);
                };
                Delta.prototype.push = function (newOp) {
                    var index = this.ops.length;
                    var lastOp = this.ops[index - 1];
                    newOp = extend(true, {}, newOp);
                    if (typeof lastOp === 'object') {
                        if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {
                            this.ops[index - 1] = { 'delete': lastOp['delete'] + newOp['delete'] };
                            return this;
                        }
                        if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {
                            index -= 1;
                            lastOp = this.ops[index - 1];
                            if (typeof lastOp !== 'object') {
                                this.ops.unshift(newOp);
                                return this;
                            }
                        }
                        if (equal(newOp.attributes, lastOp.attributes)) {
                            if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
                                this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
                                if (typeof newOp.attributes === 'object')
                                    this.ops[index - 1].attributes = newOp.attributes;
                                return this;
                            }
                            else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
                                this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
                                if (typeof newOp.attributes === 'object')
                                    this.ops[index - 1].attributes = newOp.attributes;
                                return this;
                            }
                        }
                    }
                    if (index === this.ops.length) {
                        this.ops.push(newOp);
                    }
                    else {
                        this.ops.splice(index, 0, newOp);
                    }
                    return this;
                };
                Delta.prototype.chop = function () {
                    var lastOp = this.ops[this.ops.length - 1];
                    if (lastOp && lastOp.retain && !lastOp.attributes) {
                        this.ops.pop();
                    }
                    return this;
                };
                Delta.prototype.filter = function (predicate) {
                    return this.ops.filter(predicate);
                };
                Delta.prototype.forEach = function (predicate) {
                    this.ops.forEach(predicate);
                };
                Delta.prototype.map = function (predicate) {
                    return this.ops.map(predicate);
                };
                Delta.prototype.partition = function (predicate) {
                    var passed = [], failed = [];
                    this.forEach(function (op) {
                        var target = predicate(op) ? passed : failed;
                        target.push(op);
                    });
                    return [passed, failed];
                };
                Delta.prototype.reduce = function (predicate, initial) {
                    return this.ops.reduce(predicate, initial);
                };
                Delta.prototype.changeLength = function () {
                    return this.reduce(function (length, elem) {
                        if (elem.insert) {
                            return length + op.length(elem);
                        }
                        else if (elem.delete) {
                            return length - elem.delete;
                        }
                        return length;
                    }, 0);
                };
                Delta.prototype.length = function () {
                    return this.reduce(function (length, elem) {
                        return length + op.length(elem);
                    }, 0);
                };
                Delta.prototype.slice = function (start, end) {
                    start = start || 0;
                    if (typeof end !== 'number')
                        end = Infinity;
                    var ops = [];
                    var iter = op.iterator(this.ops);
                    var index = 0;
                    while (index < end && iter.hasNext()) {
                        var nextOp;
                        if (index < start) {
                            nextOp = iter.next(start - index);
                        }
                        else {
                            nextOp = iter.next(end - index);
                            ops.push(nextOp);
                        }
                        index += op.length(nextOp);
                    }
                    return new Delta(ops);
                };
                Delta.prototype.compose = function (other) {
                    var thisIter = op.iterator(this.ops);
                    var otherIter = op.iterator(other.ops);
                    var ops = [];
                    var firstOther = otherIter.peek();
                    if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {
                        var firstLeft = firstOther.retain;
                        while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {
                            firstLeft -= thisIter.peekLength();
                            ops.push(thisIter.next());
                        }
                        if (firstOther.retain - firstLeft > 0) {
                            otherIter.next(firstOther.retain - firstLeft);
                        }
                    }
                    var delta = new Delta(ops);
                    while (thisIter.hasNext() || otherIter.hasNext()) {
                        if (otherIter.peekType() === 'insert') {
                            delta.push(otherIter.next());
                        }
                        else if (thisIter.peekType() === 'delete') {
                            delta.push(thisIter.next());
                        }
                        else {
                            var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                            var thisOp = thisIter.next(length);
                            var otherOp = otherIter.next(length);
                            if (typeof otherOp.retain === 'number') {
                                var newOp = {};
                                if (typeof thisOp.retain === 'number') {
                                    newOp.retain = length;
                                }
                                else {
                                    newOp.insert = thisOp.insert;
                                }
                                var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
                                if (attributes)
                                    newOp.attributes = attributes;
                                delta.push(newOp);
                                if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {
                                    var rest = new Delta(thisIter.rest());
                                    return delta.concat(rest).chop();
                                }
                            }
                            else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {
                                delta.push(otherOp);
                            }
                        }
                    }
                    return delta.chop();
                };
                Delta.prototype.concat = function (other) {
                    var delta = new Delta(this.ops.slice());
                    if (other.ops.length > 0) {
                        delta.push(other.ops[0]);
                        delta.ops = delta.ops.concat(other.ops.slice(1));
                    }
                    return delta;
                };
                Delta.prototype.diff = function (other, index) {
                    if (this.ops === other.ops) {
                        return new Delta();
                    }
                    var strings = [this, other].map(function (delta) {
                        return delta.map(function (op) {
                            if (op.insert != null) {
                                return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;
                            }
                            var prep = (delta === other) ? 'on' : 'with';
                            throw new Error('diff() called ' + prep + ' non-document');
                        }).join('');
                    });
                    var delta = new Delta();
                    var diffResult = diff(strings[0], strings[1], index);
                    var thisIter = op.iterator(this.ops);
                    var otherIter = op.iterator(other.ops);
                    diffResult.forEach(function (component) {
                        var length = component[1].length;
                        while (length > 0) {
                            var opLength = 0;
                            switch (component[0]) {
                                case diff.INSERT:
                                    opLength = Math.min(otherIter.peekLength(), length);
                                    delta.push(otherIter.next(opLength));
                                    break;
                                case diff.DELETE:
                                    opLength = Math.min(length, thisIter.peekLength());
                                    thisIter.next(opLength);
                                    delta['delete'](opLength);
                                    break;
                                case diff.EQUAL:
                                    opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                                    var thisOp = thisIter.next(opLength);
                                    var otherOp = otherIter.next(opLength);
                                    if (equal(thisOp.insert, otherOp.insert)) {
                                        delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
                                    }
                                    else {
                                        delta.push(otherOp)['delete'](opLength);
                                    }
                                    break;
                            }
                            length -= opLength;
                        }
                    });
                    return delta.chop();
                };
                Delta.prototype.eachLine = function (predicate, newline) {
                    newline = newline || '\n';
                    var iter = op.iterator(this.ops);
                    var line = new Delta();
                    var i = 0;
                    while (iter.hasNext()) {
                        if (iter.peekType() !== 'insert')
                            return;
                        var thisOp = iter.peek();
                        var start = op.length(thisOp) - iter.peekLength();
                        var index = typeof thisOp.insert === 'string' ?
                            thisOp.insert.indexOf(newline, start) - start : -1;
                        if (index < 0) {
                            line.push(iter.next());
                        }
                        else if (index > 0) {
                            line.push(iter.next(index));
                        }
                        else {
                            if (predicate(line, iter.next(1).attributes || {}, i) === false) {
                                return;
                            }
                            i += 1;
                            line = new Delta();
                        }
                    }
                    if (line.length() > 0) {
                        predicate(line, {}, i);
                    }
                };
                Delta.prototype.transform = function (other, priority) {
                    priority = !!priority;
                    if (typeof other === 'number') {
                        return this.transformPosition(other, priority);
                    }
                    var thisIter = op.iterator(this.ops);
                    var otherIter = op.iterator(other.ops);
                    var delta = new Delta();
                    while (thisIter.hasNext() || otherIter.hasNext()) {
                        if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
                            delta.retain(op.length(thisIter.next()));
                        }
                        else if (otherIter.peekType() === 'insert') {
                            delta.push(otherIter.next());
                        }
                        else {
                            var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                            var thisOp = thisIter.next(length);
                            var otherOp = otherIter.next(length);
                            if (thisOp['delete']) {
                                continue;
                            }
                            else if (otherOp['delete']) {
                                delta.push(otherOp);
                            }
                            else {
                                delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
                            }
                        }
                    }
                    return delta.chop();
                };
                Delta.prototype.transformPosition = function (index, priority) {
                    priority = !!priority;
                    var thisIter = op.iterator(this.ops);
                    var offset = 0;
                    while (thisIter.hasNext() && offset <= index) {
                        var length = thisIter.peekLength();
                        var nextType = thisIter.peekType();
                        thisIter.next();
                        if (nextType === 'delete') {
                            index -= Math.min(length, index - offset);
                            continue;
                        }
                        else if (nextType === 'insert' && (offset < index || !priority)) {
                            index += length;
                        }
                        offset += length;
                    }
                    return index;
                };
                module.exports = Delta;
            }),
            (function (module, exports) {
                var hasOwn = Object.prototype.hasOwnProperty;
                var toStr = Object.prototype.toString;
                var defineProperty = Object.defineProperty;
                var gOPD = Object.getOwnPropertyDescriptor;
                var isArray = function isArray(arr) {
                    if (typeof Array.isArray === 'function') {
                        return Array.isArray(arr);
                    }
                    return toStr.call(arr) === '[object Array]';
                };
                var isPlainObject = function isPlainObject(obj) {
                    if (!obj || toStr.call(obj) !== '[object Object]') {
                        return false;
                    }
                    var hasOwnConstructor = hasOwn.call(obj, 'constructor');
                    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
                    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
                        return false;
                    }
                    var key;
                    for (key in obj) { }
                    return typeof key === 'undefined' || hasOwn.call(obj, key);
                };
                var setProperty = function setProperty(target, options) {
                    if (defineProperty && options.name === '__proto__') {
                        defineProperty(target, options.name, {
                            enumerable: true,
                            configurable: true,
                            value: options.newValue,
                            writable: true
                        });
                    }
                    else {
                        target[options.name] = options.newValue;
                    }
                };
                var getProperty = function getProperty(obj, name) {
                    if (name === '__proto__') {
                        if (!hasOwn.call(obj, name)) {
                            return void 0;
                        }
                        else if (gOPD) {
                            return gOPD(obj, name).value;
                        }
                    }
                    return obj[name];
                };
                module.exports = function extend() {
                    var options, name, src, copy, copyIsArray, clone;
                    var target = arguments[0];
                    var i = 1;
                    var length = arguments.length;
                    var deep = false;
                    if (typeof target === 'boolean') {
                        deep = target;
                        target = arguments[1] || {};
                        i = 2;
                    }
                    if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
                        target = {};
                    }
                    for (; i < length; ++i) {
                        options = arguments[i];
                        if (options != null) {
                            for (name in options) {
                                src = getProperty(target, name);
                                copy = getProperty(options, name);
                                if (target !== copy) {
                                    if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                                        if (copyIsArray) {
                                            copyIsArray = false;
                                            clone = src && isArray(src) ? src : [];
                                        }
                                        else {
                                            clone = src && isPlainObject(src) ? src : {};
                                        }
                                        setProperty(target, { name: name, newValue: extend(deep, clone, copy) });
                                    }
                                    else if (typeof copy !== 'undefined') {
                                        setProperty(target, { name: name, newValue: copy });
                                    }
                                }
                            }
                        }
                    }
                    return target;
                };
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = exports.BlockEmbed = exports.bubbleFormats = undefined;
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _break = __webpack_require__(16);
                var _break2 = _interopRequireDefault(_break);
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                var _text = __webpack_require__(7);
                var _text2 = _interopRequireDefault(_text);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var NEWLINE_LENGTH = 1;
                var BlockEmbed = function (_Parchment$Embed) {
                    _inherits(BlockEmbed, _Parchment$Embed);
                    function BlockEmbed() {
                        _classCallCheck(this, BlockEmbed);
                        return _possibleConstructorReturn(this, (BlockEmbed.__proto__ || Object.getPrototypeOf(BlockEmbed)).apply(this, arguments));
                    }
                    _createClass(BlockEmbed, [{
                            key: 'attach',
                            value: function attach() {
                                _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'attach', this).call(this);
                                this.attributes = new _parchment2.default.Attributor.Store(this.domNode);
                            }
                        }, {
                            key: 'delta',
                            value: function delta() {
                                return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));
                            }
                        }, {
                            key: 'format',
                            value: function format(name, value) {
                                var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);
                                if (attribute != null) {
                                    this.attributes.attribute(attribute, value);
                                }
                            }
                        }, {
                            key: 'formatAt',
                            value: function formatAt(index, length, name, value) {
                                this.format(name, value);
                            }
                        }, {
                            key: 'insertAt',
                            value: function insertAt(index, value, def) {
                                if (typeof value === 'string' && value.endsWith('\n')) {
                                    var block = _parchment2.default.create(Block.blotName);
                                    this.parent.insertBefore(block, index === 0 ? this : this.next);
                                    block.insertAt(0, value.slice(0, -1));
                                }
                                else {
                                    _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'insertAt', this).call(this, index, value, def);
                                }
                            }
                        }]);
                    return BlockEmbed;
                }(_parchment2.default.Embed);
                BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;
                var Block = function (_Parchment$Block) {
                    _inherits(Block, _Parchment$Block);
                    function Block(domNode) {
                        _classCallCheck(this, Block);
                        var _this2 = _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).call(this, domNode));
                        _this2.cache = {};
                        return _this2;
                    }
                    _createClass(Block, [{
                            key: 'delta',
                            value: function delta() {
                                if (this.cache.delta == null) {
                                    this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function (delta, leaf) {
                                        if (leaf.length() === 0) {
                                            return delta;
                                        }
                                        else {
                                            return delta.insert(leaf.value(), bubbleFormats(leaf));
                                        }
                                    }, new _quillDelta2.default()).insert('\n', bubbleFormats(this));
                                }
                                return this.cache.delta;
                            }
                        }, {
                            key: 'deleteAt',
                            value: function deleteAt(index, length) {
                                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'deleteAt', this).call(this, index, length);
                                this.cache = {};
                            }
                        }, {
                            key: 'formatAt',
                            value: function formatAt(index, length, name, value) {
                                if (length <= 0)
                                    return;
                                if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                                    if (index + length === this.length()) {
                                        this.format(name, value);
                                    }
                                }
                                else {
                                    _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'formatAt', this).call(this, index, Math.min(length, this.length() - index - 1), name, value);
                                }
                                this.cache = {};
                            }
                        }, {
                            key: 'insertAt',
                            value: function insertAt(index, value, def) {
                                if (def != null)
                                    return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, index, value, def);
                                if (value.length === 0)
                                    return;
                                var lines = value.split('\n');
                                var text = lines.shift();
                                if (text.length > 0) {
                                    if (index < this.length() - 1 || this.children.tail == null) {
                                        _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, Math.min(index, this.length() - 1), text);
                                    }
                                    else {
                                        this.children.tail.insertAt(this.children.tail.length(), text);
                                    }
                                    this.cache = {};
                                }
                                var block = this;
                                lines.reduce(function (index, line) {
                                    block = block.split(index, true);
                                    block.insertAt(0, line);
                                    return line.length;
                                }, index + text.length);
                            }
                        }, {
                            key: 'insertBefore',
                            value: function insertBefore(blot, ref) {
                                var head = this.children.head;
                                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertBefore', this).call(this, blot, ref);
                                if (head instanceof _break2.default) {
                                    head.remove();
                                }
                                this.cache = {};
                            }
                        }, {
                            key: 'length',
                            value: function length() {
                                if (this.cache.length == null) {
                                    this.cache.length = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'length', this).call(this) + NEWLINE_LENGTH;
                                }
                                return this.cache.length;
                            }
                        }, {
                            key: 'moveChildren',
                            value: function moveChildren(target, ref) {
                                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'moveChildren', this).call(this, target, ref);
                                this.cache = {};
                            }
                        }, {
                            key: 'optimize',
                            value: function optimize(context) {
                                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'optimize', this).call(this, context);
                                this.cache = {};
                            }
                        }, {
                            key: 'path',
                            value: function path(index) {
                                return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'path', this).call(this, index, true);
                            }
                        }, {
                            key: 'removeChild',
                            value: function removeChild(child) {
                                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'removeChild', this).call(this, child);
                                this.cache = {};
                            }
                        }, {
                            key: 'split',
                            value: function split(index) {
                                var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                                if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {
                                    var clone = this.clone();
                                    if (index === 0) {
                                        this.parent.insertBefore(clone, this);
                                        return this;
                                    }
                                    else {
                                        this.parent.insertBefore(clone, this.next);
                                        return clone;
                                    }
                                }
                                else {
                                    var next = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'split', this).call(this, index, force);
                                    this.cache = {};
                                    return next;
                                }
                            }
                        }]);
                    return Block;
                }(_parchment2.default.Block);
                Block.blotName = 'block';
                Block.tagName = 'P';
                Block.defaultChild = 'break';
                Block.allowedChildren = [_inline2.default, _parchment2.default.Embed, _text2.default];
                function bubbleFormats(blot) {
                    var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    if (blot == null)
                        return formats;
                    if (typeof blot.formats === 'function') {
                        formats = (0, _extend2.default)(formats, blot.formats());
                    }
                    if (blot.parent == null || blot.parent.blotName == 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {
                        return formats;
                    }
                    return bubbleFormats(blot.parent, formats);
                }
                exports.bubbleFormats = bubbleFormats;
                exports.BlockEmbed = BlockEmbed;
                exports.default = Block;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = exports.overload = exports.expandConfig = undefined;
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
                var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i)
                            break;
                    }
                }
                catch (err) {
                    _d = true;
                    _e = err;
                }
                finally {
                    try {
                        if (!_n && _i["return"])
                            _i["return"]();
                    }
                    finally {
                        if (_d)
                            throw _e;
                    }
                } return _arr; } return function (arr, i) { if (Array.isArray(arr)) {
                    return arr;
                }
                else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                }
                else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                } }; }();
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                __webpack_require__(50);
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _editor = __webpack_require__(14);
                var _editor2 = _interopRequireDefault(_editor);
                var _emitter3 = __webpack_require__(8);
                var _emitter4 = _interopRequireDefault(_emitter3);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _selection = __webpack_require__(15);
                var _selection2 = _interopRequireDefault(_selection);
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                var _logger = __webpack_require__(10);
                var _logger2 = _interopRequireDefault(_logger);
                var _theme = __webpack_require__(34);
                var _theme2 = _interopRequireDefault(_theme);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _defineProperty(obj, key, value) { if (key in obj) {
                    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
                }
                else {
                    obj[key] = value;
                } return obj; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                var debug = (0, _logger2.default)('quill');
                var Quill = function () {
                    _createClass(Quill, null, [{
                            key: 'debug',
                            value: function debug(limit) {
                                if (limit === true) {
                                    limit = 'log';
                                }
                                _logger2.default.level(limit);
                            }
                        }, {
                            key: 'find',
                            value: function find(node) {
                                return node.__quill || _parchment2.default.find(node);
                            }
                        }, {
                            key: 'import',
                            value: function _import(name) {
                                if (this.imports[name] == null) {
                                    debug.error('Cannot import ' + name + '. Are you sure it was registered?');
                                }
                                return this.imports[name];
                            }
                        }, {
                            key: 'register',
                            value: function register(path, target) {
                                var _this = this;
                                var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                                if (typeof path !== 'string') {
                                    var name = path.attrName || path.blotName;
                                    if (typeof name === 'string') {
                                        this.register('formats/' + name, path, target);
                                    }
                                    else {
                                        Object.keys(path).forEach(function (key) {
                                            _this.register(key, path[key], target);
                                        });
                                    }
                                }
                                else {
                                    if (this.imports[path] != null && !overwrite) {
                                        debug.warn('Overwriting ' + path + ' with', target);
                                    }
                                    this.imports[path] = target;
                                    if ((path.startsWith('blots/') || path.startsWith('formats/')) && target.blotName !== 'abstract') {
                                        _parchment2.default.register(target);
                                    }
                                    else if (path.startsWith('modules') && typeof target.register === 'function') {
                                        target.register();
                                    }
                                }
                            }
                        }]);
                    function Quill(container) {
                        var _this2 = this;
                        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                        _classCallCheck(this, Quill);
                        this.options = expandConfig(container, options);
                        this.container = this.options.container;
                        if (this.container == null) {
                            return debug.error('Invalid Quill container', container);
                        }
                        if (this.options.debug) {
                            Quill.debug(this.options.debug);
                        }
                        var html = this.container.innerHTML.trim();
                        this.container.classList.add('ql-container');
                        this.container.innerHTML = '';
                        this.container.__quill = this;
                        this.root = this.addContainer('ql-editor');
                        this.root.classList.add('ql-blank');
                        this.root.setAttribute('data-gramm', false);
                        this.scrollingContainer = this.options.scrollingContainer || this.root;
                        this.emitter = new _emitter4.default();
                        this.scroll = _parchment2.default.create(this.root, {
                            emitter: this.emitter,
                            whitelist: this.options.formats
                        });
                        this.editor = new _editor2.default(this.scroll);
                        this.selection = new _selection2.default(this.scroll, this.emitter);
                        this.theme = new this.options.theme(this, this.options);
                        this.keyboard = this.theme.addModule('keyboard');
                        this.clipboard = this.theme.addModule('clipboard');
                        this.history = this.theme.addModule('history');
                        this.theme.init();
                        this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type) {
                            if (type === _emitter4.default.events.TEXT_CHANGE) {
                                _this2.root.classList.toggle('ql-blank', _this2.editor.isBlank());
                            }
                        });
                        this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function (source, mutations) {
                            var range = _this2.selection.lastRange;
                            var index = range && range.length === 0 ? range.index : undefined;
                            modify.call(_this2, function () {
                                return _this2.editor.update(null, mutations, index);
                            }, source);
                        });
                        var contents = this.clipboard.convert('<div class=\'ql-editor\' style="white-space: normal;">' + html + '<p><br></p></div>');
                        this.setContents(contents);
                        this.history.clear();
                        if (this.options.placeholder) {
                            this.root.setAttribute('data-placeholder', this.options.placeholder);
                        }
                        if (this.options.readOnly) {
                            this.disable();
                        }
                    }
                    _createClass(Quill, [{
                            key: 'addContainer',
                            value: function addContainer(container) {
                                var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                                if (typeof container === 'string') {
                                    var className = container;
                                    container = document.createElement('div');
                                    container.classList.add(className);
                                }
                                this.container.insertBefore(container, refNode);
                                return container;
                            }
                        }, {
                            key: 'blur',
                            value: function blur() {
                                this.selection.setRange(null);
                            }
                        }, {
                            key: 'deleteText',
                            value: function deleteText(index, length, source) {
                                var _this3 = this;
                                var _overload = overload(index, length, source);
                                var _overload2 = _slicedToArray(_overload, 4);
                                index = _overload2[0];
                                length = _overload2[1];
                                source = _overload2[3];
                                return modify.call(this, function () {
                                    return _this3.editor.deleteText(index, length);
                                }, source, index, -1 * length);
                            }
                        }, {
                            key: 'disable',
                            value: function disable() {
                                this.enable(false);
                            }
                        }, {
                            key: 'enable',
                            value: function enable() {
                                var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                                this.scroll.enable(enabled);
                                this.container.classList.toggle('ql-disabled', !enabled);
                            }
                        }, {
                            key: 'focus',
                            value: function focus() {
                                var scrollTop = this.scrollingContainer.scrollTop;
                                this.selection.focus();
                                this.scrollingContainer.scrollTop = scrollTop;
                                this.scrollIntoView();
                            }
                        }, {
                            key: 'format',
                            value: function format(name, value) {
                                var _this4 = this;
                                var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;
                                return modify.call(this, function () {
                                    var range = _this4.getSelection(true);
                                    var change = new _quillDelta2.default();
                                    if (range == null) {
                                        return change;
                                    }
                                    else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                                        change = _this4.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));
                                    }
                                    else if (range.length === 0) {
                                        _this4.selection.format(name, value);
                                        return change;
                                    }
                                    else {
                                        change = _this4.editor.formatText(range.index, range.length, _defineProperty({}, name, value));
                                    }
                                    _this4.setSelection(range, _emitter4.default.sources.SILENT);
                                    return change;
                                }, source);
                            }
                        }, {
                            key: 'formatLine',
                            value: function formatLine(index, length, name, value, source) {
                                var _this5 = this;
                                var formats = void 0;
                                var _overload3 = overload(index, length, name, value, source);
                                var _overload4 = _slicedToArray(_overload3, 4);
                                index = _overload4[0];
                                length = _overload4[1];
                                formats = _overload4[2];
                                source = _overload4[3];
                                return modify.call(this, function () {
                                    return _this5.editor.formatLine(index, length, formats);
                                }, source, index, 0);
                            }
                        }, {
                            key: 'formatText',
                            value: function formatText(index, length, name, value, source) {
                                var _this6 = this;
                                var formats = void 0;
                                var _overload5 = overload(index, length, name, value, source);
                                var _overload6 = _slicedToArray(_overload5, 4);
                                index = _overload6[0];
                                length = _overload6[1];
                                formats = _overload6[2];
                                source = _overload6[3];
                                return modify.call(this, function () {
                                    return _this6.editor.formatText(index, length, formats);
                                }, source, index, 0);
                            }
                        }, {
                            key: 'getBounds',
                            value: function getBounds(index) {
                                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                                var bounds = void 0;
                                if (typeof index === 'number') {
                                    bounds = this.selection.getBounds(index, length);
                                }
                                else {
                                    bounds = this.selection.getBounds(index.index, index.length);
                                }
                                var containerBounds = this.container.getBoundingClientRect();
                                return {
                                    bottom: bounds.bottom - containerBounds.top,
                                    height: bounds.height,
                                    left: bounds.left - containerBounds.left,
                                    right: bounds.right - containerBounds.left,
                                    top: bounds.top - containerBounds.top,
                                    width: bounds.width
                                };
                            }
                        }, {
                            key: 'getContents',
                            value: function getContents() {
                                var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;
                                var _overload7 = overload(index, length);
                                var _overload8 = _slicedToArray(_overload7, 2);
                                index = _overload8[0];
                                length = _overload8[1];
                                return this.editor.getContents(index, length);
                            }
                        }, {
                            key: 'getFormat',
                            value: function getFormat() {
                                var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);
                                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                                if (typeof index === 'number') {
                                    return this.editor.getFormat(index, length);
                                }
                                else {
                                    return this.editor.getFormat(index.index, index.length);
                                }
                            }
                        }, {
                            key: 'getIndex',
                            value: function getIndex(blot) {
                                return blot.offset(this.scroll);
                            }
                        }, {
                            key: 'getLength',
                            value: function getLength() {
                                return this.scroll.length();
                            }
                        }, {
                            key: 'getLeaf',
                            value: function getLeaf(index) {
                                return this.scroll.leaf(index);
                            }
                        }, {
                            key: 'getLine',
                            value: function getLine(index) {
                                return this.scroll.line(index);
                            }
                        }, {
                            key: 'getLines',
                            value: function getLines() {
                                var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;
                                if (typeof index !== 'number') {
                                    return this.scroll.lines(index.index, index.length);
                                }
                                else {
                                    return this.scroll.lines(index, length);
                                }
                            }
                        }, {
                            key: 'getModule',
                            value: function getModule(name) {
                                return this.theme.modules[name];
                            }
                        }, {
                            key: 'getSelection',
                            value: function getSelection() {
                                var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                                if (focus)
                                    this.focus();
                                this.update();
                                return this.selection.getRange()[0];
                            }
                        }, {
                            key: 'getText',
                            value: function getText() {
                                var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;
                                var _overload9 = overload(index, length);
                                var _overload10 = _slicedToArray(_overload9, 2);
                                index = _overload10[0];
                                length = _overload10[1];
                                return this.editor.getText(index, length);
                            }
                        }, {
                            key: 'hasFocus',
                            value: function hasFocus() {
                                return this.selection.hasFocus();
                            }
                        }, {
                            key: 'insertEmbed',
                            value: function insertEmbed(index, embed, value) {
                                var _this7 = this;
                                var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;
                                return modify.call(this, function () {
                                    return _this7.editor.insertEmbed(index, embed, value);
                                }, source, index);
                            }
                        }, {
                            key: 'insertText',
                            value: function insertText(index, text, name, value, source) {
                                var _this8 = this;
                                var formats = void 0;
                                var _overload11 = overload(index, 0, name, value, source);
                                var _overload12 = _slicedToArray(_overload11, 4);
                                index = _overload12[0];
                                formats = _overload12[2];
                                source = _overload12[3];
                                return modify.call(this, function () {
                                    return _this8.editor.insertText(index, text, formats);
                                }, source, index, text.length);
                            }
                        }, {
                            key: 'isEnabled',
                            value: function isEnabled() {
                                return !this.container.classList.contains('ql-disabled');
                            }
                        }, {
                            key: 'off',
                            value: function off() {
                                return this.emitter.off.apply(this.emitter, arguments);
                            }
                        }, {
                            key: 'on',
                            value: function on() {
                                return this.emitter.on.apply(this.emitter, arguments);
                            }
                        }, {
                            key: 'once',
                            value: function once() {
                                return this.emitter.once.apply(this.emitter, arguments);
                            }
                        }, {
                            key: 'pasteHTML',
                            value: function pasteHTML(index, html, source) {
                                this.clipboard.dangerouslyPasteHTML(index, html, source);
                            }
                        }, {
                            key: 'removeFormat',
                            value: function removeFormat(index, length, source) {
                                var _this9 = this;
                                var _overload13 = overload(index, length, source);
                                var _overload14 = _slicedToArray(_overload13, 4);
                                index = _overload14[0];
                                length = _overload14[1];
                                source = _overload14[3];
                                return modify.call(this, function () {
                                    return _this9.editor.removeFormat(index, length);
                                }, source, index);
                            }
                        }, {
                            key: 'scrollIntoView',
                            value: function scrollIntoView() {
                                this.selection.scrollIntoView(this.scrollingContainer);
                            }
                        }, {
                            key: 'setContents',
                            value: function setContents(delta) {
                                var _this10 = this;
                                var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;
                                return modify.call(this, function () {
                                    delta = new _quillDelta2.default(delta);
                                    var length = _this10.getLength();
                                    var deleted = _this10.editor.deleteText(0, length);
                                    var applied = _this10.editor.applyDelta(delta);
                                    var lastOp = applied.ops[applied.ops.length - 1];
                                    if (lastOp != null && typeof lastOp.insert === 'string' && lastOp.insert[lastOp.insert.length - 1] === '\n') {
                                        _this10.editor.deleteText(_this10.getLength() - 1, 1);
                                        applied.delete(1);
                                    }
                                    var ret = deleted.compose(applied);
                                    return ret;
                                }, source);
                            }
                        }, {
                            key: 'setSelection',
                            value: function setSelection(index, length, source) {
                                if (index == null) {
                                    this.selection.setRange(null, length || Quill.sources.API);
                                }
                                else {
                                    var _overload15 = overload(index, length, source);
                                    var _overload16 = _slicedToArray(_overload15, 4);
                                    index = _overload16[0];
                                    length = _overload16[1];
                                    source = _overload16[3];
                                    this.selection.setRange(new _selection.Range(index, length), source);
                                    if (source !== _emitter4.default.sources.SILENT) {
                                        this.selection.scrollIntoView(this.scrollingContainer);
                                    }
                                }
                            }
                        }, {
                            key: 'setText',
                            value: function setText(text) {
                                var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;
                                var delta = new _quillDelta2.default().insert(text);
                                return this.setContents(delta, source);
                            }
                        }, {
                            key: 'update',
                            value: function update() {
                                var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;
                                var change = this.scroll.update(source);
                                this.selection.update(source);
                                return change;
                            }
                        }, {
                            key: 'updateContents',
                            value: function updateContents(delta) {
                                var _this11 = this;
                                var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;
                                return modify.call(this, function () {
                                    delta = new _quillDelta2.default(delta);
                                    return _this11.editor.applyDelta(delta, source);
                                }, source, true);
                            }
                        }]);
                    return Quill;
                }();
                Quill.DEFAULTS = {
                    bounds: null,
                    formats: null,
                    modules: {},
                    placeholder: '',
                    readOnly: false,
                    scrollingContainer: null,
                    strict: true,
                    theme: 'default'
                };
                Quill.events = _emitter4.default.events;
                Quill.sources = _emitter4.default.sources;
                Quill.version = "1.3.7";
                Quill.imports = {
                    'delta': _quillDelta2.default,
                    'parchment': _parchment2.default,
                    'core/module': _module2.default,
                    'core/theme': _theme2.default
                };
                function expandConfig(container, userConfig) {
                    userConfig = (0, _extend2.default)(true, {
                        container: container,
                        modules: {
                            clipboard: true,
                            keyboard: true,
                            history: true
                        }
                    }, userConfig);
                    if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {
                        userConfig.theme = _theme2.default;
                    }
                    else {
                        userConfig.theme = Quill.import('themes/' + userConfig.theme);
                        if (userConfig.theme == null) {
                            throw new Error('Invalid theme ' + userConfig.theme + '. Did you register it?');
                        }
                    }
                    var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);
                    [themeConfig, userConfig].forEach(function (config) {
                        config.modules = config.modules || {};
                        Object.keys(config.modules).forEach(function (module) {
                            if (config.modules[module] === true) {
                                config.modules[module] = {};
                            }
                        });
                    });
                    var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));
                    var moduleConfig = moduleNames.reduce(function (config, name) {
                        var moduleClass = Quill.import('modules/' + name);
                        if (moduleClass == null) {
                            debug.error('Cannot load ' + name + ' module. Are you sure you registered it?');
                        }
                        else {
                            config[name] = moduleClass.DEFAULTS || {};
                        }
                        return config;
                    }, {});
                    if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {
                        userConfig.modules.toolbar = {
                            container: userConfig.modules.toolbar
                        };
                    }
                    userConfig = (0, _extend2.default)(true, {}, Quill.DEFAULTS, { modules: moduleConfig }, themeConfig, userConfig);
                    ['bounds', 'container', 'scrollingContainer'].forEach(function (key) {
                        if (typeof userConfig[key] === 'string') {
                            userConfig[key] = document.querySelector(userConfig[key]);
                        }
                    });
                    userConfig.modules = Object.keys(userConfig.modules).reduce(function (config, name) {
                        if (userConfig.modules[name]) {
                            config[name] = userConfig.modules[name];
                        }
                        return config;
                    }, {});
                    return userConfig;
                }
                function modify(modifier, source, index, shift) {
                    if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {
                        return new _quillDelta2.default();
                    }
                    var range = index == null ? null : this.getSelection();
                    var oldDelta = this.editor.delta;
                    var change = modifier();
                    if (range != null) {
                        if (index === true)
                            index = range.index;
                        if (shift == null) {
                            range = shiftRange(range, change, source);
                        }
                        else if (shift !== 0) {
                            range = shiftRange(range, index, shift, source);
                        }
                        this.setSelection(range, _emitter4.default.sources.SILENT);
                    }
                    if (change.length() > 0) {
                        var _emitter;
                        var args = [_emitter4.default.events.TEXT_CHANGE, change, oldDelta, source];
                        (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
                        if (source !== _emitter4.default.sources.SILENT) {
                            var _emitter2;
                            (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                        }
                    }
                    return change;
                }
                function overload(index, length, name, value, source) {
                    var formats = {};
                    if (typeof index.index === 'number' && typeof index.length === 'number') {
                        if (typeof length !== 'number') {
                            source = value, value = name, name = length, length = index.length, index = index.index;
                        }
                        else {
                            length = index.length, index = index.index;
                        }
                    }
                    else if (typeof length !== 'number') {
                        source = value, value = name, name = length, length = 0;
                    }
                    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
                        formats = name;
                        source = value;
                    }
                    else if (typeof name === 'string') {
                        if (value != null) {
                            formats[name] = value;
                        }
                        else {
                            source = name;
                        }
                    }
                    source = source || _emitter4.default.sources.API;
                    return [index, length, formats, source];
                }
                function shiftRange(range, index, length, source) {
                    if (range == null)
                        return null;
                    var start = void 0, end = void 0;
                    if (index instanceof _quillDelta2.default) {
                        var _map = [range.index, range.index + range.length].map(function (pos) {
                            return index.transformPosition(pos, source !== _emitter4.default.sources.USER);
                        });
                        var _map2 = _slicedToArray(_map, 2);
                        start = _map2[0];
                        end = _map2[1];
                    }
                    else {
                        var _map3 = [range.index, range.index + range.length].map(function (pos) {
                            if (pos < index || pos === index && source === _emitter4.default.sources.USER)
                                return pos;
                            if (length >= 0) {
                                return pos + length;
                            }
                            else {
                                return Math.max(index, pos + length);
                            }
                        });
                        var _map4 = _slicedToArray(_map3, 2);
                        start = _map4[0];
                        end = _map4[1];
                    }
                    return new _selection.Range(start, end - start);
                }
                exports.expandConfig = expandConfig;
                exports.overload = overload;
                exports.default = Quill;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _text = __webpack_require__(7);
                var _text2 = _interopRequireDefault(_text);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Inline = function (_Parchment$Inline) {
                    _inherits(Inline, _Parchment$Inline);
                    function Inline() {
                        _classCallCheck(this, Inline);
                        return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));
                    }
                    _createClass(Inline, [{
                            key: 'formatAt',
                            value: function formatAt(index, length, name, value) {
                                if (Inline.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {
                                    var blot = this.isolate(index, length);
                                    if (value) {
                                        blot.wrap(name, value);
                                    }
                                }
                                else {
                                    _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'formatAt', this).call(this, index, length, name, value);
                                }
                            }
                        }, {
                            key: 'optimize',
                            value: function optimize(context) {
                                _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'optimize', this).call(this, context);
                                if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                                    var parent = this.parent.isolate(this.offset(), this.length());
                                    this.moveChildren(parent);
                                    parent.wrap(this);
                                }
                            }
                        }], [{
                            key: 'compare',
                            value: function compare(self, other) {
                                var selfIndex = Inline.order.indexOf(self);
                                var otherIndex = Inline.order.indexOf(other);
                                if (selfIndex >= 0 || otherIndex >= 0) {
                                    return selfIndex - otherIndex;
                                }
                                else if (self === other) {
                                    return 0;
                                }
                                else if (self < other) {
                                    return -1;
                                }
                                else {
                                    return 1;
                                }
                            }
                        }]);
                    return Inline;
                }(_parchment2.default.Inline);
                Inline.allowedChildren = [Inline, _parchment2.default.Embed, _text2.default];
                Inline.order = ['cursor', 'inline',
                    'underline', 'strike', 'italic', 'bold', 'script', 'link', 'code'
                ];
                exports.default = Inline;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var TextBlot = function (_Parchment$Text) {
                    _inherits(TextBlot, _Parchment$Text);
                    function TextBlot() {
                        _classCallCheck(this, TextBlot);
                        return _possibleConstructorReturn(this, (TextBlot.__proto__ || Object.getPrototypeOf(TextBlot)).apply(this, arguments));
                    }
                    return TextBlot;
                }(_parchment2.default.Text);
                exports.default = TextBlot;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _eventemitter = __webpack_require__(54);
                var _eventemitter2 = _interopRequireDefault(_eventemitter);
                var _logger = __webpack_require__(10);
                var _logger2 = _interopRequireDefault(_logger);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var debug = (0, _logger2.default)('quill:events');
                var EVENTS = ['selectionchange', 'mousedown', 'mouseup', 'click'];
                EVENTS.forEach(function (eventName) {
                    document.addEventListener(eventName, function () {
                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                            args[_key] = arguments[_key];
                        }
                        [].slice.call(document.querySelectorAll('.ql-container')).forEach(function (node) {
                            if (node.__quill && node.__quill.emitter) {
                                var _node$__quill$emitter;
                                (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);
                            }
                        });
                    });
                });
                var Emitter = function (_EventEmitter) {
                    _inherits(Emitter, _EventEmitter);
                    function Emitter() {
                        _classCallCheck(this, Emitter);
                        var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));
                        _this.listeners = {};
                        _this.on('error', debug.error);
                        return _this;
                    }
                    _createClass(Emitter, [{
                            key: 'emit',
                            value: function emit() {
                                debug.log.apply(debug, arguments);
                                _get(Emitter.prototype.__proto__ || Object.getPrototypeOf(Emitter.prototype), 'emit', this).apply(this, arguments);
                            }
                        }, {
                            key: 'handleDOM',
                            value: function handleDOM(event) {
                                for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                                    args[_key2 - 1] = arguments[_key2];
                                }
                                (this.listeners[event.type] || []).forEach(function (_ref) {
                                    var node = _ref.node, handler = _ref.handler;
                                    if (event.target === node || node.contains(event.target)) {
                                        handler.apply(undefined, [event].concat(args));
                                    }
                                });
                            }
                        }, {
                            key: 'listenDOM',
                            value: function listenDOM(eventName, node, handler) {
                                if (!this.listeners[eventName]) {
                                    this.listeners[eventName] = [];
                                }
                                this.listeners[eventName].push({ node: node, handler: handler });
                            }
                        }]);
                    return Emitter;
                }(_eventemitter2.default);
                Emitter.events = {
                    EDITOR_CHANGE: 'editor-change',
                    SCROLL_BEFORE_UPDATE: 'scroll-before-update',
                    SCROLL_OPTIMIZE: 'scroll-optimize',
                    SCROLL_UPDATE: 'scroll-update',
                    SELECTION_CHANGE: 'selection-change',
                    TEXT_CHANGE: 'text-change'
                };
                Emitter.sources = {
                    API: 'api',
                    SILENT: 'silent',
                    USER: 'user'
                };
                exports.default = Emitter;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                var Module = function Module(quill) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    _classCallCheck(this, Module);
                    this.quill = quill;
                    this.options = options;
                };
                Module.DEFAULTS = {};
                exports.default = Module;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var levels = ['error', 'warn', 'log', 'info'];
                var level = 'warn';
                function debug(method) {
                    if (levels.indexOf(method) <= levels.indexOf(level)) {
                        var _console;
                        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                            args[_key - 1] = arguments[_key];
                        }
                        (_console = console)[method].apply(_console, args);
                    }
                }
                function namespace(ns) {
                    return levels.reduce(function (logger, method) {
                        logger[method] = debug.bind(console, method, ns);
                        return logger;
                    }, {});
                }
                debug.level = namespace.level = function (newLevel) {
                    level = newLevel;
                };
                exports.default = namespace;
            }),
            (function (module, exports, __webpack_require__) {
                var pSlice = Array.prototype.slice;
                var objectKeys = __webpack_require__(52);
                var isArguments = __webpack_require__(53);
                var deepEqual = module.exports = function (actual, expected, opts) {
                    if (!opts)
                        opts = {};
                    if (actual === expected) {
                        return true;
                    }
                    else if (actual instanceof Date && expected instanceof Date) {
                        return actual.getTime() === expected.getTime();
                    }
                    else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
                        return opts.strict ? actual === expected : actual == expected;
                    }
                    else {
                        return objEquiv(actual, expected, opts);
                    }
                };
                function isUndefinedOrNull(value) {
                    return value === null || value === undefined;
                }
                function isBuffer(x) {
                    if (!x || typeof x !== 'object' || typeof x.length !== 'number')
                        return false;
                    if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
                        return false;
                    }
                    if (x.length > 0 && typeof x[0] !== 'number')
                        return false;
                    return true;
                }
                function objEquiv(a, b, opts) {
                    var i, key;
                    if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
                        return false;
                    if (a.prototype !== b.prototype)
                        return false;
                    if (isArguments(a)) {
                        if (!isArguments(b)) {
                            return false;
                        }
                        a = pSlice.call(a);
                        b = pSlice.call(b);
                        return deepEqual(a, b, opts);
                    }
                    if (isBuffer(a)) {
                        if (!isBuffer(b)) {
                            return false;
                        }
                        if (a.length !== b.length)
                            return false;
                        for (i = 0; i < a.length; i++) {
                            if (a[i] !== b[i])
                                return false;
                        }
                        return true;
                    }
                    try {
                        var ka = objectKeys(a), kb = objectKeys(b);
                    }
                    catch (e) {
                        return false;
                    }
                    if (ka.length != kb.length)
                        return false;
                    ka.sort();
                    kb.sort();
                    for (i = ka.length - 1; i >= 0; i--) {
                        if (ka[i] != kb[i])
                            return false;
                    }
                    for (i = ka.length - 1; i >= 0; i--) {
                        key = ka[i];
                        if (!deepEqual(a[key], b[key], opts))
                            return false;
                    }
                    return typeof a === typeof b;
                }
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", { value: true });
                var Registry = __webpack_require__(1);
                var Attributor = (function () {
                    function Attributor(attrName, keyName, options) {
                        if (options === void 0) {
                            options = {};
                        }
                        this.attrName = attrName;
                        this.keyName = keyName;
                        var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;
                        if (options.scope != null) {
                            this.scope = (options.scope & Registry.Scope.LEVEL) | attributeBit;
                        }
                        else {
                            this.scope = Registry.Scope.ATTRIBUTE;
                        }
                        if (options.whitelist != null)
                            this.whitelist = options.whitelist;
                    }
                    Attributor.keys = function (node) {
                        return [].map.call(node.attributes, function (item) {
                            return item.name;
                        });
                    };
                    Attributor.prototype.add = function (node, value) {
                        if (!this.canAdd(node, value))
                            return false;
                        node.setAttribute(this.keyName, value);
                        return true;
                    };
                    Attributor.prototype.canAdd = function (node, value) {
                        var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));
                        if (match == null)
                            return false;
                        if (this.whitelist == null)
                            return true;
                        if (typeof value === 'string') {
                            return this.whitelist.indexOf(value.replace(/["']/g, '')) > -1;
                        }
                        else {
                            return this.whitelist.indexOf(value) > -1;
                        }
                    };
                    Attributor.prototype.remove = function (node) {
                        node.removeAttribute(this.keyName);
                    };
                    Attributor.prototype.value = function (node) {
                        var value = node.getAttribute(this.keyName);
                        if (this.canAdd(node, value) && value) {
                            return value;
                        }
                        return '';
                    };
                    return Attributor;
                }());
                exports.default = Attributor;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = exports.Code = undefined;
                var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i)
                            break;
                    }
                }
                catch (err) {
                    _d = true;
                    _e = err;
                }
                finally {
                    try {
                        if (!_n && _i["return"])
                            _i["return"]();
                    }
                    finally {
                        if (_d)
                            throw _e;
                    }
                } return _arr; } return function (arr, i) { if (Array.isArray(arr)) {
                    return arr;
                }
                else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                }
                else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                } }; }();
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                var _text = __webpack_require__(7);
                var _text2 = _interopRequireDefault(_text);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Code = function (_Inline) {
                    _inherits(Code, _Inline);
                    function Code() {
                        _classCallCheck(this, Code);
                        return _possibleConstructorReturn(this, (Code.__proto__ || Object.getPrototypeOf(Code)).apply(this, arguments));
                    }
                    return Code;
                }(_inline2.default);
                Code.blotName = 'code';
                Code.tagName = 'CODE';
                var CodeBlock = function (_Block) {
                    _inherits(CodeBlock, _Block);
                    function CodeBlock() {
                        _classCallCheck(this, CodeBlock);
                        return _possibleConstructorReturn(this, (CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock)).apply(this, arguments));
                    }
                    _createClass(CodeBlock, [{
                            key: 'delta',
                            value: function delta() {
                                var _this3 = this;
                                var text = this.domNode.textContent;
                                if (text.endsWith('\n')) {
                                    text = text.slice(0, -1);
                                }
                                return text.split('\n').reduce(function (delta, frag) {
                                    return delta.insert(frag).insert('\n', _this3.formats());
                                }, new _quillDelta2.default());
                            }
                        }, {
                            key: 'format',
                            value: function format(name, value) {
                                if (name === this.statics.blotName && value)
                                    return;
                                var _descendant = this.descendant(_text2.default, this.length() - 1), _descendant2 = _slicedToArray(_descendant, 1), text = _descendant2[0];
                                if (text != null) {
                                    text.deleteAt(text.length() - 1, 1);
                                }
                                _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'format', this).call(this, name, value);
                            }
                        }, {
                            key: 'formatAt',
                            value: function formatAt(index, length, name, value) {
                                if (length === 0)
                                    return;
                                if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {
                                    return;
                                }
                                var nextNewline = this.newlineIndex(index);
                                if (nextNewline < 0 || nextNewline >= index + length)
                                    return;
                                var prevNewline = this.newlineIndex(index, true) + 1;
                                var isolateLength = nextNewline - prevNewline + 1;
                                var blot = this.isolate(prevNewline, isolateLength);
                                var next = blot.next;
                                blot.format(name, value);
                                if (next instanceof CodeBlock) {
                                    next.formatAt(0, index - prevNewline + length - isolateLength, name, value);
                                }
                            }
                        }, {
                            key: 'insertAt',
                            value: function insertAt(index, value, def) {
                                if (def != null)
                                    return;
                                var _descendant3 = this.descendant(_text2.default, index), _descendant4 = _slicedToArray(_descendant3, 2), text = _descendant4[0], offset = _descendant4[1];
                                text.insertAt(offset, value);
                            }
                        }, {
                            key: 'length',
                            value: function length() {
                                var length = this.domNode.textContent.length;
                                if (!this.domNode.textContent.endsWith('\n')) {
                                    return length + 1;
                                }
                                return length;
                            }
                        }, {
                            key: 'newlineIndex',
                            value: function newlineIndex(searchIndex) {
                                var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                                if (!reverse) {
                                    var offset = this.domNode.textContent.slice(searchIndex).indexOf('\n');
                                    return offset > -1 ? searchIndex + offset : -1;
                                }
                                else {
                                    return this.domNode.textContent.slice(0, searchIndex).lastIndexOf('\n');
                                }
                            }
                        }, {
                            key: 'optimize',
                            value: function optimize(context) {
                                if (!this.domNode.textContent.endsWith('\n')) {
                                    this.appendChild(_parchment2.default.create('text', '\n'));
                                }
                                _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'optimize', this).call(this, context);
                                var next = this.next;
                                if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {
                                    next.optimize(context);
                                    next.moveChildren(this);
                                    next.remove();
                                }
                            }
                        }, {
                            key: 'replace',
                            value: function replace(target) {
                                _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'replace', this).call(this, target);
                                [].slice.call(this.domNode.querySelectorAll('*')).forEach(function (node) {
                                    var blot = _parchment2.default.find(node);
                                    if (blot == null) {
                                        node.parentNode.removeChild(node);
                                    }
                                    else if (blot instanceof _parchment2.default.Embed) {
                                        blot.remove();
                                    }
                                    else {
                                        blot.unwrap();
                                    }
                                });
                            }
                        }], [{
                            key: 'create',
                            value: function create(value) {
                                var domNode = _get(CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock), 'create', this).call(this, value);
                                domNode.setAttribute('spellcheck', false);
                                return domNode;
                            }
                        }, {
                            key: 'formats',
                            value: function formats() {
                                return true;
                            }
                        }]);
                    return CodeBlock;
                }(_block2.default);
                CodeBlock.blotName = 'code-block';
                CodeBlock.tagName = 'PRE';
                CodeBlock.TAB = '  ';
                exports.Code = Code;
                exports.default = CodeBlock;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
                var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i)
                            break;
                    }
                }
                catch (err) {
                    _d = true;
                    _e = err;
                }
                finally {
                    try {
                        if (!_n && _i["return"])
                            _i["return"]();
                    }
                    finally {
                        if (_d)
                            throw _e;
                    }
                } return _arr; } return function (arr, i) { if (Array.isArray(arr)) {
                    return arr;
                }
                else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                }
                else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                } }; }();
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _op = __webpack_require__(20);
                var _op2 = _interopRequireDefault(_op);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _code = __webpack_require__(13);
                var _code2 = _interopRequireDefault(_code);
                var _cursor = __webpack_require__(24);
                var _cursor2 = _interopRequireDefault(_cursor);
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                var _break = __webpack_require__(16);
                var _break2 = _interopRequireDefault(_break);
                var _clone = __webpack_require__(21);
                var _clone2 = _interopRequireDefault(_clone);
                var _deepEqual = __webpack_require__(11);
                var _deepEqual2 = _interopRequireDefault(_deepEqual);
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _defineProperty(obj, key, value) { if (key in obj) {
                    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
                }
                else {
                    obj[key] = value;
                } return obj; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                var ASCII = /^[ -~]*$/;
                var Editor = function () {
                    function Editor(scroll) {
                        _classCallCheck(this, Editor);
                        this.scroll = scroll;
                        this.delta = this.getDelta();
                    }
                    _createClass(Editor, [{
                            key: 'applyDelta',
                            value: function applyDelta(delta) {
                                var _this = this;
                                var consumeNextNewline = false;
                                this.scroll.update();
                                var scrollLength = this.scroll.length();
                                this.scroll.batchStart();
                                delta = normalizeDelta(delta);
                                delta.reduce(function (index, op) {
                                    var length = op.retain || op.delete || op.insert.length || 1;
                                    var attributes = op.attributes || {};
                                    if (op.insert != null) {
                                        if (typeof op.insert === 'string') {
                                            var text = op.insert;
                                            if (text.endsWith('\n') && consumeNextNewline) {
                                                consumeNextNewline = false;
                                                text = text.slice(0, -1);
                                            }
                                            if (index >= scrollLength && !text.endsWith('\n')) {
                                                consumeNextNewline = true;
                                            }
                                            _this.scroll.insertAt(index, text);
                                            var _scroll$line = _this.scroll.line(index), _scroll$line2 = _slicedToArray(_scroll$line, 2), line = _scroll$line2[0], offset = _scroll$line2[1];
                                            var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));
                                            if (line instanceof _block2.default) {
                                                var _line$descendant = line.descendant(_parchment2.default.Leaf, offset), _line$descendant2 = _slicedToArray(_line$descendant, 1), leaf = _line$descendant2[0];
                                                formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));
                                            }
                                            attributes = _op2.default.attributes.diff(formats, attributes) || {};
                                        }
                                        else if (_typeof(op.insert) === 'object') {
                                            var key = Object.keys(op.insert)[0];
                                            if (key == null)
                                                return index;
                                            _this.scroll.insertAt(index, key, op.insert[key]);
                                        }
                                        scrollLength += length;
                                    }
                                    Object.keys(attributes).forEach(function (name) {
                                        _this.scroll.formatAt(index, length, name, attributes[name]);
                                    });
                                    return index + length;
                                }, 0);
                                delta.reduce(function (index, op) {
                                    if (typeof op.delete === 'number') {
                                        _this.scroll.deleteAt(index, op.delete);
                                        return index;
                                    }
                                    return index + (op.retain || op.insert.length || 1);
                                }, 0);
                                this.scroll.batchEnd();
                                return this.update(delta);
                            }
                        }, {
                            key: 'deleteText',
                            value: function deleteText(index, length) {
                                this.scroll.deleteAt(index, length);
                                return this.update(new _quillDelta2.default().retain(index).delete(length));
                            }
                        }, {
                            key: 'formatLine',
                            value: function formatLine(index, length) {
                                var _this2 = this;
                                var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                                this.scroll.update();
                                Object.keys(formats).forEach(function (format) {
                                    if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format])
                                        return;
                                    var lines = _this2.scroll.lines(index, Math.max(length, 1));
                                    var lengthRemaining = length;
                                    lines.forEach(function (line) {
                                        var lineLength = line.length();
                                        if (!(line instanceof _code2.default)) {
                                            line.format(format, formats[format]);
                                        }
                                        else {
                                            var codeIndex = index - line.offset(_this2.scroll);
                                            var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;
                                            line.formatAt(codeIndex, codeLength, format, formats[format]);
                                        }
                                        lengthRemaining -= lineLength;
                                    });
                                });
                                this.scroll.optimize();
                                return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
                            }
                        }, {
                            key: 'formatText',
                            value: function formatText(index, length) {
                                var _this3 = this;
                                var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                                Object.keys(formats).forEach(function (format) {
                                    _this3.scroll.formatAt(index, length, format, formats[format]);
                                });
                                return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
                            }
                        }, {
                            key: 'getContents',
                            value: function getContents(index, length) {
                                return this.delta.slice(index, index + length);
                            }
                        }, {
                            key: 'getDelta',
                            value: function getDelta() {
                                return this.scroll.lines().reduce(function (delta, line) {
                                    return delta.concat(line.delta());
                                }, new _quillDelta2.default());
                            }
                        }, {
                            key: 'getFormat',
                            value: function getFormat(index) {
                                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                                var lines = [], leaves = [];
                                if (length === 0) {
                                    this.scroll.path(index).forEach(function (path) {
                                        var _path = _slicedToArray(path, 1), blot = _path[0];
                                        if (blot instanceof _block2.default) {
                                            lines.push(blot);
                                        }
                                        else if (blot instanceof _parchment2.default.Leaf) {
                                            leaves.push(blot);
                                        }
                                    });
                                }
                                else {
                                    lines = this.scroll.lines(index, length);
                                    leaves = this.scroll.descendants(_parchment2.default.Leaf, index, length);
                                }
                                var formatsArr = [lines, leaves].map(function (blots) {
                                    if (blots.length === 0)
                                        return {};
                                    var formats = (0, _block.bubbleFormats)(blots.shift());
                                    while (Object.keys(formats).length > 0) {
                                        var blot = blots.shift();
                                        if (blot == null)
                                            return formats;
                                        formats = combineFormats((0, _block.bubbleFormats)(blot), formats);
                                    }
                                    return formats;
                                });
                                return _extend2.default.apply(_extend2.default, formatsArr);
                            }
                        }, {
                            key: 'getText',
                            value: function getText(index, length) {
                                return this.getContents(index, length).filter(function (op) {
                                    return typeof op.insert === 'string';
                                }).map(function (op) {
                                    return op.insert;
                                }).join('');
                            }
                        }, {
                            key: 'insertEmbed',
                            value: function insertEmbed(index, embed, value) {
                                this.scroll.insertAt(index, embed, value);
                                return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({}, embed, value)));
                            }
                        }, {
                            key: 'insertText',
                            value: function insertText(index, text) {
                                var _this4 = this;
                                var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                                text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                                this.scroll.insertAt(index, text);
                                Object.keys(formats).forEach(function (format) {
                                    _this4.scroll.formatAt(index, text.length, format, formats[format]);
                                });
                                return this.update(new _quillDelta2.default().retain(index).insert(text, (0, _clone2.default)(formats)));
                            }
                        }, {
                            key: 'isBlank',
                            value: function isBlank() {
                                if (this.scroll.children.length == 0)
                                    return true;
                                if (this.scroll.children.length > 1)
                                    return false;
                                var block = this.scroll.children.head;
                                if (block.statics.blotName !== _block2.default.blotName)
                                    return false;
                                if (block.children.length > 1)
                                    return false;
                                return block.children.head instanceof _break2.default;
                            }
                        }, {
                            key: 'removeFormat',
                            value: function removeFormat(index, length) {
                                var text = this.getText(index, length);
                                var _scroll$line3 = this.scroll.line(index + length), _scroll$line4 = _slicedToArray(_scroll$line3, 2), line = _scroll$line4[0], offset = _scroll$line4[1];
                                var suffixLength = 0, suffix = new _quillDelta2.default();
                                if (line != null) {
                                    if (!(line instanceof _code2.default)) {
                                        suffixLength = line.length() - offset;
                                    }
                                    else {
                                        suffixLength = line.newlineIndex(offset) - offset + 1;
                                    }
                                    suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\n');
                                }
                                var contents = this.getContents(index, length + suffixLength);
                                var diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));
                                var delta = new _quillDelta2.default().retain(index).concat(diff);
                                return this.applyDelta(delta);
                            }
                        }, {
                            key: 'update',
                            value: function update(change) {
                                var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
                                var cursorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
                                var oldDelta = this.delta;
                                if (mutations.length === 1 && mutations[0].type === 'characterData' && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {
                                    var textBlot = _parchment2.default.find(mutations[0].target);
                                    var formats = (0, _block.bubbleFormats)(textBlot);
                                    var index = textBlot.offset(this.scroll);
                                    var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, '');
                                    var oldText = new _quillDelta2.default().insert(oldValue);
                                    var newText = new _quillDelta2.default().insert(textBlot.value());
                                    var diffDelta = new _quillDelta2.default().retain(index).concat(oldText.diff(newText, cursorIndex));
                                    change = diffDelta.reduce(function (delta, op) {
                                        if (op.insert) {
                                            return delta.insert(op.insert, formats);
                                        }
                                        else {
                                            return delta.push(op);
                                        }
                                    }, new _quillDelta2.default());
                                    this.delta = oldDelta.compose(change);
                                }
                                else {
                                    this.delta = this.getDelta();
                                    if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {
                                        change = oldDelta.diff(this.delta, cursorIndex);
                                    }
                                }
                                return change;
                            }
                        }]);
                    return Editor;
                }();
                function combineFormats(formats, combined) {
                    return Object.keys(combined).reduce(function (merged, name) {
                        if (formats[name] == null)
                            return merged;
                        if (combined[name] === formats[name]) {
                            merged[name] = combined[name];
                        }
                        else if (Array.isArray(combined[name])) {
                            if (combined[name].indexOf(formats[name]) < 0) {
                                merged[name] = combined[name].concat([formats[name]]);
                            }
                        }
                        else {
                            merged[name] = [combined[name], formats[name]];
                        }
                        return merged;
                    }, {});
                }
                function normalizeDelta(delta) {
                    return delta.reduce(function (delta, op) {
                        if (op.insert === 1) {
                            var attributes = (0, _clone2.default)(op.attributes);
                            delete attributes['image'];
                            return delta.insert({ image: op.attributes.image }, attributes);
                        }
                        if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {
                            op = (0, _clone2.default)(op);
                            if (op.attributes.list) {
                                op.attributes.list = 'ordered';
                            }
                            else {
                                op.attributes.list = 'bullet';
                                delete op.attributes.bullet;
                            }
                        }
                        if (typeof op.insert === 'string') {
                            var text = op.insert.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                            return delta.insert(text, op.attributes);
                        }
                        return delta.push(op);
                    }, new _quillDelta2.default());
                }
                exports.default = Editor;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = exports.Range = undefined;
                var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i)
                            break;
                    }
                }
                catch (err) {
                    _d = true;
                    _e = err;
                }
                finally {
                    try {
                        if (!_n && _i["return"])
                            _i["return"]();
                    }
                    finally {
                        if (_d)
                            throw _e;
                    }
                } return _arr; } return function (arr, i) { if (Array.isArray(arr)) {
                    return arr;
                }
                else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                }
                else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                } }; }();
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _clone = __webpack_require__(21);
                var _clone2 = _interopRequireDefault(_clone);
                var _deepEqual = __webpack_require__(11);
                var _deepEqual2 = _interopRequireDefault(_deepEqual);
                var _emitter3 = __webpack_require__(8);
                var _emitter4 = _interopRequireDefault(_emitter3);
                var _logger = __webpack_require__(10);
                var _logger2 = _interopRequireDefault(_logger);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _toConsumableArray(arr) { if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                        arr2[i] = arr[i];
                    }
                    return arr2;
                }
                else {
                    return Array.from(arr);
                } }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                var debug = (0, _logger2.default)('quill:selection');
                var Range = function Range(index) {
                    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    _classCallCheck(this, Range);
                    this.index = index;
                    this.length = length;
                };
                var Selection = function () {
                    function Selection(scroll, emitter) {
                        var _this = this;
                        _classCallCheck(this, Selection);
                        this.emitter = emitter;
                        this.scroll = scroll;
                        this.composing = false;
                        this.mouseDown = false;
                        this.root = this.scroll.domNode;
                        this.cursor = _parchment2.default.create('cursor', this);
                        this.lastRange = this.savedRange = new Range(0, 0);
                        this.handleComposition();
                        this.handleDragging();
                        this.emitter.listenDOM('selectionchange', document, function () {
                            if (!_this.mouseDown) {
                                setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);
                            }
                        });
                        this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type, delta) {
                            if (type === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {
                                _this.update(_emitter4.default.sources.SILENT);
                            }
                        });
                        this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function () {
                            if (!_this.hasFocus())
                                return;
                            var native = _this.getNativeRange();
                            if (native == null)
                                return;
                            if (native.start.node === _this.cursor.textNode)
                                return;
                            _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function () {
                                try {
                                    _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
                                }
                                catch (ignored) { }
                            });
                        });
                        this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function (mutations, context) {
                            if (context.range) {
                                var _context$range = context.range, startNode = _context$range.startNode, startOffset = _context$range.startOffset, endNode = _context$range.endNode, endOffset = _context$range.endOffset;
                                _this.setNativeRange(startNode, startOffset, endNode, endOffset);
                            }
                        });
                        this.update(_emitter4.default.sources.SILENT);
                    }
                    _createClass(Selection, [{
                            key: 'handleComposition',
                            value: function handleComposition() {
                                var _this2 = this;
                                this.root.addEventListener('compositionstart', function () {
                                    _this2.composing = true;
                                });
                                this.root.addEventListener('compositionend', function () {
                                    _this2.composing = false;
                                    if (_this2.cursor.parent) {
                                        var range = _this2.cursor.restore();
                                        if (!range)
                                            return;
                                        setTimeout(function () {
                                            _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
                                        }, 1);
                                    }
                                });
                            }
                        }, {
                            key: 'handleDragging',
                            value: function handleDragging() {
                                var _this3 = this;
                                this.emitter.listenDOM('mousedown', document.body, function () {
                                    _this3.mouseDown = true;
                                });
                                this.emitter.listenDOM('mouseup', document.body, function () {
                                    _this3.mouseDown = false;
                                    _this3.update(_emitter4.default.sources.USER);
                                });
                            }
                        }, {
                            key: 'focus',
                            value: function focus() {
                                if (this.hasFocus())
                                    return;
                                this.root.focus();
                                this.setRange(this.savedRange);
                            }
                        }, {
                            key: 'format',
                            value: function format(_format, value) {
                                if (this.scroll.whitelist != null && !this.scroll.whitelist[_format])
                                    return;
                                this.scroll.update();
                                var nativeRange = this.getNativeRange();
                                if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK))
                                    return;
                                if (nativeRange.start.node !== this.cursor.textNode) {
                                    var blot = _parchment2.default.find(nativeRange.start.node, false);
                                    if (blot == null)
                                        return;
                                    if (blot instanceof _parchment2.default.Leaf) {
                                        var after = blot.split(nativeRange.start.offset);
                                        blot.parent.insertBefore(this.cursor, after);
                                    }
                                    else {
                                        blot.insertBefore(this.cursor, nativeRange.start.node);
                                    }
                                    this.cursor.attach();
                                }
                                this.cursor.format(_format, value);
                                this.scroll.optimize();
                                this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
                                this.update();
                            }
                        }, {
                            key: 'getBounds',
                            value: function getBounds(index) {
                                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                                var scrollLength = this.scroll.length();
                                index = Math.min(index, scrollLength - 1);
                                length = Math.min(index + length, scrollLength - 1) - index;
                                var node = void 0, _scroll$leaf = this.scroll.leaf(index), _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2), leaf = _scroll$leaf2[0], offset = _scroll$leaf2[1];
                                if (leaf == null)
                                    return null;
                                var _leaf$position = leaf.position(offset, true);
                                var _leaf$position2 = _slicedToArray(_leaf$position, 2);
                                node = _leaf$position2[0];
                                offset = _leaf$position2[1];
                                var range = document.createRange();
                                if (length > 0) {
                                    range.setStart(node, offset);
                                    var _scroll$leaf3 = this.scroll.leaf(index + length);
                                    var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);
                                    leaf = _scroll$leaf4[0];
                                    offset = _scroll$leaf4[1];
                                    if (leaf == null)
                                        return null;
                                    var _leaf$position3 = leaf.position(offset, true);
                                    var _leaf$position4 = _slicedToArray(_leaf$position3, 2);
                                    node = _leaf$position4[0];
                                    offset = _leaf$position4[1];
                                    range.setEnd(node, offset);
                                    return range.getBoundingClientRect();
                                }
                                else {
                                    var side = 'left';
                                    var rect = void 0;
                                    if (node instanceof Text) {
                                        if (offset < node.data.length) {
                                            range.setStart(node, offset);
                                            range.setEnd(node, offset + 1);
                                        }
                                        else {
                                            range.setStart(node, offset - 1);
                                            range.setEnd(node, offset);
                                            side = 'right';
                                        }
                                        rect = range.getBoundingClientRect();
                                    }
                                    else {
                                        rect = leaf.domNode.getBoundingClientRect();
                                        if (offset > 0)
                                            side = 'right';
                                    }
                                    return {
                                        bottom: rect.top + rect.height,
                                        height: rect.height,
                                        left: rect[side],
                                        right: rect[side],
                                        top: rect.top,
                                        width: 0
                                    };
                                }
                            }
                        }, {
                            key: 'getNativeRange',
                            value: function getNativeRange() {
                                var selection = document.getSelection();
                                if (selection == null || selection.rangeCount <= 0)
                                    return null;
                                var nativeRange = selection.getRangeAt(0);
                                if (nativeRange == null)
                                    return null;
                                var range = this.normalizeNative(nativeRange);
                                debug.info('getNativeRange', range);
                                return range;
                            }
                        }, {
                            key: 'getRange',
                            value: function getRange() {
                                var normalized = this.getNativeRange();
                                if (normalized == null)
                                    return [null, null];
                                var range = this.normalizedToRange(normalized);
                                return [range, normalized];
                            }
                        }, {
                            key: 'hasFocus',
                            value: function hasFocus() {
                                return document.activeElement === this.root;
                            }
                        }, {
                            key: 'normalizedToRange',
                            value: function normalizedToRange(range) {
                                var _this4 = this;
                                var positions = [[range.start.node, range.start.offset]];
                                if (!range.native.collapsed) {
                                    positions.push([range.end.node, range.end.offset]);
                                }
                                var indexes = positions.map(function (position) {
                                    var _position = _slicedToArray(position, 2), node = _position[0], offset = _position[1];
                                    var blot = _parchment2.default.find(node, true);
                                    var index = blot.offset(_this4.scroll);
                                    if (offset === 0) {
                                        return index;
                                    }
                                    else if (blot instanceof _parchment2.default.Container) {
                                        return index + blot.length();
                                    }
                                    else {
                                        return index + blot.index(node, offset);
                                    }
                                });
                                var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);
                                var start = Math.min.apply(Math, [end].concat(_toConsumableArray(indexes)));
                                return new Range(start, end - start);
                            }
                        }, {
                            key: 'normalizeNative',
                            value: function normalizeNative(nativeRange) {
                                if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
                                    return null;
                                }
                                var range = {
                                    start: { node: nativeRange.startContainer, offset: nativeRange.startOffset },
                                    end: { node: nativeRange.endContainer, offset: nativeRange.endOffset },
                                    native: nativeRange
                                };
                                [range.start, range.end].forEach(function (position) {
                                    var node = position.node, offset = position.offset;
                                    while (!(node instanceof Text) && node.childNodes.length > 0) {
                                        if (node.childNodes.length > offset) {
                                            node = node.childNodes[offset];
                                            offset = 0;
                                        }
                                        else if (node.childNodes.length === offset) {
                                            node = node.lastChild;
                                            offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                    position.node = node, position.offset = offset;
                                });
                                return range;
                            }
                        }, {
                            key: 'rangeToNative',
                            value: function rangeToNative(range) {
                                var _this5 = this;
                                var indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];
                                var args = [];
                                var scrollLength = this.scroll.length();
                                indexes.forEach(function (index, i) {
                                    index = Math.min(scrollLength - 1, index);
                                    var node = void 0, _scroll$leaf5 = _this5.scroll.leaf(index), _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2), leaf = _scroll$leaf6[0], offset = _scroll$leaf6[1];
                                    var _leaf$position5 = leaf.position(offset, i !== 0);
                                    var _leaf$position6 = _slicedToArray(_leaf$position5, 2);
                                    node = _leaf$position6[0];
                                    offset = _leaf$position6[1];
                                    args.push(node, offset);
                                });
                                if (args.length < 2) {
                                    args = args.concat(args);
                                }
                                return args;
                            }
                        }, {
                            key: 'scrollIntoView',
                            value: function scrollIntoView(scrollingContainer) {
                                var range = this.lastRange;
                                if (range == null)
                                    return;
                                var bounds = this.getBounds(range.index, range.length);
                                if (bounds == null)
                                    return;
                                var limit = this.scroll.length() - 1;
                                var _scroll$line = this.scroll.line(Math.min(range.index, limit)), _scroll$line2 = _slicedToArray(_scroll$line, 1), first = _scroll$line2[0];
                                var last = first;
                                if (range.length > 0) {
                                    var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));
                                    var _scroll$line4 = _slicedToArray(_scroll$line3, 1);
                                    last = _scroll$line4[0];
                                }
                                if (first == null || last == null)
                                    return;
                                var scrollBounds = scrollingContainer.getBoundingClientRect();
                                if (bounds.top < scrollBounds.top) {
                                    scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;
                                }
                                else if (bounds.bottom > scrollBounds.bottom) {
                                    scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;
                                }
                            }
                        }, {
                            key: 'setNativeRange',
                            value: function setNativeRange(startNode, startOffset) {
                                var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;
                                var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;
                                var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
                                debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);
                                if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {
                                    return;
                                }
                                var selection = document.getSelection();
                                if (selection == null)
                                    return;
                                if (startNode != null) {
                                    if (!this.hasFocus())
                                        this.root.focus();
                                    var native = (this.getNativeRange() || {}).native;
                                    if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {
                                        if (startNode.tagName == "BR") {
                                            startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);
                                            startNode = startNode.parentNode;
                                        }
                                        if (endNode.tagName == "BR") {
                                            endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);
                                            endNode = endNode.parentNode;
                                        }
                                        var range = document.createRange();
                                        range.setStart(startNode, startOffset);
                                        range.setEnd(endNode, endOffset);
                                        selection.removeAllRanges();
                                        selection.addRange(range);
                                    }
                                }
                                else {
                                    selection.removeAllRanges();
                                    this.root.blur();
                                    document.body.focus();
                                }
                            }
                        }, {
                            key: 'setRange',
                            value: function setRange(range) {
                                var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                                var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;
                                if (typeof force === 'string') {
                                    source = force;
                                    force = false;
                                }
                                debug.info('setRange', range);
                                if (range != null) {
                                    var args = this.rangeToNative(range);
                                    this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));
                                }
                                else {
                                    this.setNativeRange(null);
                                }
                                this.update(source);
                            }
                        }, {
                            key: 'update',
                            value: function update() {
                                var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;
                                var oldRange = this.lastRange;
                                var _getRange = this.getRange(), _getRange2 = _slicedToArray(_getRange, 2), lastRange = _getRange2[0], nativeRange = _getRange2[1];
                                this.lastRange = lastRange;
                                if (this.lastRange != null) {
                                    this.savedRange = this.lastRange;
                                }
                                if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {
                                    var _emitter;
                                    if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
                                        this.cursor.restore();
                                    }
                                    var args = [_emitter4.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];
                                    (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
                                    if (source !== _emitter4.default.sources.SILENT) {
                                        var _emitter2;
                                        (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                                    }
                                }
                            }
                        }]);
                    return Selection;
                }();
                function contains(parent, descendant) {
                    try {
                        descendant.parentNode;
                    }
                    catch (e) {
                        return false;
                    }
                    if (descendant instanceof Text) {
                        descendant = descendant.parentNode;
                    }
                    return parent.contains(descendant);
                }
                exports.Range = Range;
                exports.default = Selection;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Break = function (_Parchment$Embed) {
                    _inherits(Break, _Parchment$Embed);
                    function Break() {
                        _classCallCheck(this, Break);
                        return _possibleConstructorReturn(this, (Break.__proto__ || Object.getPrototypeOf(Break)).apply(this, arguments));
                    }
                    _createClass(Break, [{
                            key: 'insertInto',
                            value: function insertInto(parent, ref) {
                                if (parent.children.length === 0) {
                                    _get(Break.prototype.__proto__ || Object.getPrototypeOf(Break.prototype), 'insertInto', this).call(this, parent, ref);
                                }
                                else {
                                    this.remove();
                                }
                            }
                        }, {
                            key: 'length',
                            value: function length() {
                                return 0;
                            }
                        }, {
                            key: 'value',
                            value: function value() {
                                return '';
                            }
                        }], [{
                            key: 'value',
                            value: function value() {
                                return undefined;
                            }
                        }]);
                    return Break;
                }(_parchment2.default.Embed);
                Break.blotName = 'break';
                Break.tagName = 'BR';
                exports.default = Break;
            }),
            (function (module, exports, __webpack_require__) {
                var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b)
                            if (b.hasOwnProperty(p))
                                d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                Object.defineProperty(exports, "__esModule", { value: true });
                var linked_list_1 = __webpack_require__(44);
                var shadow_1 = __webpack_require__(30);
                var Registry = __webpack_require__(1);
                var ContainerBlot = (function (_super) {
                    __extends(ContainerBlot, _super);
                    function ContainerBlot(domNode) {
                        var _this = _super.call(this, domNode) || this;
                        _this.build();
                        return _this;
                    }
                    ContainerBlot.prototype.appendChild = function (other) {
                        this.insertBefore(other);
                    };
                    ContainerBlot.prototype.attach = function () {
                        _super.prototype.attach.call(this);
                        this.children.forEach(function (child) {
                            child.attach();
                        });
                    };
                    ContainerBlot.prototype.build = function () {
                        var _this = this;
                        this.children = new linked_list_1.default();
                        [].slice
                            .call(this.domNode.childNodes)
                            .reverse()
                            .forEach(function (node) {
                            try {
                                var child = makeBlot(node);
                                _this.insertBefore(child, _this.children.head || undefined);
                            }
                            catch (err) {
                                if (err instanceof Registry.ParchmentError)
                                    return;
                                else
                                    throw err;
                            }
                        });
                    };
                    ContainerBlot.prototype.deleteAt = function (index, length) {
                        if (index === 0 && length === this.length()) {
                            return this.remove();
                        }
                        this.children.forEachAt(index, length, function (child, offset, length) {
                            child.deleteAt(offset, length);
                        });
                    };
                    ContainerBlot.prototype.descendant = function (criteria, index) {
                        var _a = this.children.find(index), child = _a[0], offset = _a[1];
                        if ((criteria.blotName == null && criteria(child)) ||
                            (criteria.blotName != null && child instanceof criteria)) {
                            return [child, offset];
                        }
                        else if (child instanceof ContainerBlot) {
                            return child.descendant(criteria, offset);
                        }
                        else {
                            return [null, -1];
                        }
                    };
                    ContainerBlot.prototype.descendants = function (criteria, index, length) {
                        if (index === void 0) {
                            index = 0;
                        }
                        if (length === void 0) {
                            length = Number.MAX_VALUE;
                        }
                        var descendants = [];
                        var lengthLeft = length;
                        this.children.forEachAt(index, length, function (child, index, length) {
                            if ((criteria.blotName == null && criteria(child)) ||
                                (criteria.blotName != null && child instanceof criteria)) {
                                descendants.push(child);
                            }
                            if (child instanceof ContainerBlot) {
                                descendants = descendants.concat(child.descendants(criteria, index, lengthLeft));
                            }
                            lengthLeft -= length;
                        });
                        return descendants;
                    };
                    ContainerBlot.prototype.detach = function () {
                        this.children.forEach(function (child) {
                            child.detach();
                        });
                        _super.prototype.detach.call(this);
                    };
                    ContainerBlot.prototype.formatAt = function (index, length, name, value) {
                        this.children.forEachAt(index, length, function (child, offset, length) {
                            child.formatAt(offset, length, name, value);
                        });
                    };
                    ContainerBlot.prototype.insertAt = function (index, value, def) {
                        var _a = this.children.find(index), child = _a[0], offset = _a[1];
                        if (child) {
                            child.insertAt(offset, value, def);
                        }
                        else {
                            var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
                            this.appendChild(blot);
                        }
                    };
                    ContainerBlot.prototype.insertBefore = function (childBlot, refBlot) {
                        if (this.statics.allowedChildren != null &&
                            !this.statics.allowedChildren.some(function (child) {
                                return childBlot instanceof child;
                            })) {
                            throw new Registry.ParchmentError("Cannot insert " + childBlot.statics.blotName + " into " + this.statics.blotName);
                        }
                        childBlot.insertInto(this, refBlot);
                    };
                    ContainerBlot.prototype.length = function () {
                        return this.children.reduce(function (memo, child) {
                            return memo + child.length();
                        }, 0);
                    };
                    ContainerBlot.prototype.moveChildren = function (targetParent, refNode) {
                        this.children.forEach(function (child) {
                            targetParent.insertBefore(child, refNode);
                        });
                    };
                    ContainerBlot.prototype.optimize = function (context) {
                        _super.prototype.optimize.call(this, context);
                        if (this.children.length === 0) {
                            if (this.statics.defaultChild != null) {
                                var child = Registry.create(this.statics.defaultChild);
                                this.appendChild(child);
                                child.optimize(context);
                            }
                            else {
                                this.remove();
                            }
                        }
                    };
                    ContainerBlot.prototype.path = function (index, inclusive) {
                        if (inclusive === void 0) {
                            inclusive = false;
                        }
                        var _a = this.children.find(index, inclusive), child = _a[0], offset = _a[1];
                        var position = [[this, index]];
                        if (child instanceof ContainerBlot) {
                            return position.concat(child.path(offset, inclusive));
                        }
                        else if (child != null) {
                            position.push([child, offset]);
                        }
                        return position;
                    };
                    ContainerBlot.prototype.removeChild = function (child) {
                        this.children.remove(child);
                    };
                    ContainerBlot.prototype.replace = function (target) {
                        if (target instanceof ContainerBlot) {
                            target.moveChildren(this);
                        }
                        _super.prototype.replace.call(this, target);
                    };
                    ContainerBlot.prototype.split = function (index, force) {
                        if (force === void 0) {
                            force = false;
                        }
                        if (!force) {
                            if (index === 0)
                                return this;
                            if (index === this.length())
                                return this.next;
                        }
                        var after = this.clone();
                        this.parent.insertBefore(after, this.next);
                        this.children.forEachAt(index, this.length(), function (child, offset, length) {
                            child = child.split(offset, force);
                            after.appendChild(child);
                        });
                        return after;
                    };
                    ContainerBlot.prototype.unwrap = function () {
                        this.moveChildren(this.parent, this.next);
                        this.remove();
                    };
                    ContainerBlot.prototype.update = function (mutations, context) {
                        var _this = this;
                        var addedNodes = [];
                        var removedNodes = [];
                        mutations.forEach(function (mutation) {
                            if (mutation.target === _this.domNode && mutation.type === 'childList') {
                                addedNodes.push.apply(addedNodes, mutation.addedNodes);
                                removedNodes.push.apply(removedNodes, mutation.removedNodes);
                            }
                        });
                        removedNodes.forEach(function (node) {
                            if (node.parentNode != null &&
                                node.tagName !== 'IFRAME' &&
                                document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                                return;
                            }
                            var blot = Registry.find(node);
                            if (blot == null)
                                return;
                            if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {
                                blot.detach();
                            }
                        });
                        addedNodes
                            .filter(function (node) {
                            return node.parentNode == _this.domNode;
                        })
                            .sort(function (a, b) {
                            if (a === b)
                                return 0;
                            if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {
                                return 1;
                            }
                            return -1;
                        })
                            .forEach(function (node) {
                            var refBlot = null;
                            if (node.nextSibling != null) {
                                refBlot = Registry.find(node.nextSibling);
                            }
                            var blot = makeBlot(node);
                            if (blot.next != refBlot || blot.next == null) {
                                if (blot.parent != null) {
                                    blot.parent.removeChild(_this);
                                }
                                _this.insertBefore(blot, refBlot || undefined);
                            }
                        });
                    };
                    return ContainerBlot;
                }(shadow_1.default));
                function makeBlot(node) {
                    var blot = Registry.find(node);
                    if (blot == null) {
                        try {
                            blot = Registry.create(node);
                        }
                        catch (e) {
                            blot = Registry.create(Registry.Scope.INLINE);
                            [].slice.call(node.childNodes).forEach(function (child) {
                                blot.domNode.appendChild(child);
                            });
                            if (node.parentNode) {
                                node.parentNode.replaceChild(blot.domNode, node);
                            }
                            blot.attach();
                        }
                    }
                    return blot;
                }
                exports.default = ContainerBlot;
            }),
            (function (module, exports, __webpack_require__) {
                var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b)
                            if (b.hasOwnProperty(p))
                                d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                Object.defineProperty(exports, "__esModule", { value: true });
                var attributor_1 = __webpack_require__(12);
                var store_1 = __webpack_require__(31);
                var container_1 = __webpack_require__(17);
                var Registry = __webpack_require__(1);
                var FormatBlot = (function (_super) {
                    __extends(FormatBlot, _super);
                    function FormatBlot(domNode) {
                        var _this = _super.call(this, domNode) || this;
                        _this.attributes = new store_1.default(_this.domNode);
                        return _this;
                    }
                    FormatBlot.formats = function (domNode) {
                        if (typeof this.tagName === 'string') {
                            return true;
                        }
                        else if (Array.isArray(this.tagName)) {
                            return domNode.tagName.toLowerCase();
                        }
                        return undefined;
                    };
                    FormatBlot.prototype.format = function (name, value) {
                        var format = Registry.query(name);
                        if (format instanceof attributor_1.default) {
                            this.attributes.attribute(format, value);
                        }
                        else if (value) {
                            if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {
                                this.replaceWith(name, value);
                            }
                        }
                    };
                    FormatBlot.prototype.formats = function () {
                        var formats = this.attributes.values();
                        var format = this.statics.formats(this.domNode);
                        if (format != null) {
                            formats[this.statics.blotName] = format;
                        }
                        return formats;
                    };
                    FormatBlot.prototype.replaceWith = function (name, value) {
                        var replacement = _super.prototype.replaceWith.call(this, name, value);
                        this.attributes.copy(replacement);
                        return replacement;
                    };
                    FormatBlot.prototype.update = function (mutations, context) {
                        var _this = this;
                        _super.prototype.update.call(this, mutations, context);
                        if (mutations.some(function (mutation) {
                            return mutation.target === _this.domNode && mutation.type === 'attributes';
                        })) {
                            this.attributes.build();
                        }
                    };
                    FormatBlot.prototype.wrap = function (name, value) {
                        var wrapper = _super.prototype.wrap.call(this, name, value);
                        if (wrapper instanceof FormatBlot && wrapper.statics.scope === this.statics.scope) {
                            this.attributes.move(wrapper);
                        }
                        return wrapper;
                    };
                    return FormatBlot;
                }(container_1.default));
                exports.default = FormatBlot;
            }),
            (function (module, exports, __webpack_require__) {
                var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b)
                            if (b.hasOwnProperty(p))
                                d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                Object.defineProperty(exports, "__esModule", { value: true });
                var shadow_1 = __webpack_require__(30);
                var Registry = __webpack_require__(1);
                var LeafBlot = (function (_super) {
                    __extends(LeafBlot, _super);
                    function LeafBlot() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    LeafBlot.value = function (domNode) {
                        return true;
                    };
                    LeafBlot.prototype.index = function (node, offset) {
                        if (this.domNode === node ||
                            this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                            return Math.min(offset, 1);
                        }
                        return -1;
                    };
                    LeafBlot.prototype.position = function (index, inclusive) {
                        var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
                        if (index > 0)
                            offset += 1;
                        return [this.parent.domNode, offset];
                    };
                    LeafBlot.prototype.value = function () {
                        var _a;
                        return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;
                    };
                    LeafBlot.scope = Registry.Scope.INLINE_BLOT;
                    return LeafBlot;
                }(shadow_1.default));
                exports.default = LeafBlot;
            }),
            (function (module, exports, __webpack_require__) {
                var equal = __webpack_require__(11);
                var extend = __webpack_require__(3);
                var lib = {
                    attributes: {
                        compose: function (a, b, keepNull) {
                            if (typeof a !== 'object')
                                a = {};
                            if (typeof b !== 'object')
                                b = {};
                            var attributes = extend(true, {}, b);
                            if (!keepNull) {
                                attributes = Object.keys(attributes).reduce(function (copy, key) {
                                    if (attributes[key] != null) {
                                        copy[key] = attributes[key];
                                    }
                                    return copy;
                                }, {});
                            }
                            for (var key in a) {
                                if (a[key] !== undefined && b[key] === undefined) {
                                    attributes[key] = a[key];
                                }
                            }
                            return Object.keys(attributes).length > 0 ? attributes : undefined;
                        },
                        diff: function (a, b) {
                            if (typeof a !== 'object')
                                a = {};
                            if (typeof b !== 'object')
                                b = {};
                            var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function (attributes, key) {
                                if (!equal(a[key], b[key])) {
                                    attributes[key] = b[key] === undefined ? null : b[key];
                                }
                                return attributes;
                            }, {});
                            return Object.keys(attributes).length > 0 ? attributes : undefined;
                        },
                        transform: function (a, b, priority) {
                            if (typeof a !== 'object')
                                return b;
                            if (typeof b !== 'object')
                                return undefined;
                            if (!priority)
                                return b;
                            var attributes = Object.keys(b).reduce(function (attributes, key) {
                                if (a[key] === undefined)
                                    attributes[key] = b[key];
                                return attributes;
                            }, {});
                            return Object.keys(attributes).length > 0 ? attributes : undefined;
                        }
                    },
                    iterator: function (ops) {
                        return new Iterator(ops);
                    },
                    length: function (op) {
                        if (typeof op['delete'] === 'number') {
                            return op['delete'];
                        }
                        else if (typeof op.retain === 'number') {
                            return op.retain;
                        }
                        else {
                            return typeof op.insert === 'string' ? op.insert.length : 1;
                        }
                    }
                };
                function Iterator(ops) {
                    this.ops = ops;
                    this.index = 0;
                    this.offset = 0;
                }
                Iterator.prototype.hasNext = function () {
                    return this.peekLength() < Infinity;
                };
                Iterator.prototype.next = function (length) {
                    if (!length)
                        length = Infinity;
                    var nextOp = this.ops[this.index];
                    if (nextOp) {
                        var offset = this.offset;
                        var opLength = lib.length(nextOp);
                        if (length >= opLength - offset) {
                            length = opLength - offset;
                            this.index += 1;
                            this.offset = 0;
                        }
                        else {
                            this.offset += length;
                        }
                        if (typeof nextOp['delete'] === 'number') {
                            return { 'delete': length };
                        }
                        else {
                            var retOp = {};
                            if (nextOp.attributes) {
                                retOp.attributes = nextOp.attributes;
                            }
                            if (typeof nextOp.retain === 'number') {
                                retOp.retain = length;
                            }
                            else if (typeof nextOp.insert === 'string') {
                                retOp.insert = nextOp.insert.substr(offset, length);
                            }
                            else {
                                retOp.insert = nextOp.insert;
                            }
                            return retOp;
                        }
                    }
                    else {
                        return { retain: Infinity };
                    }
                };
                Iterator.prototype.peek = function () {
                    return this.ops[this.index];
                };
                Iterator.prototype.peekLength = function () {
                    if (this.ops[this.index]) {
                        return lib.length(this.ops[this.index]) - this.offset;
                    }
                    else {
                        return Infinity;
                    }
                };
                Iterator.prototype.peekType = function () {
                    if (this.ops[this.index]) {
                        if (typeof this.ops[this.index]['delete'] === 'number') {
                            return 'delete';
                        }
                        else if (typeof this.ops[this.index].retain === 'number') {
                            return 'retain';
                        }
                        else {
                            return 'insert';
                        }
                    }
                    return 'retain';
                };
                Iterator.prototype.rest = function () {
                    if (!this.hasNext()) {
                        return [];
                    }
                    else if (this.offset === 0) {
                        return this.ops.slice(this.index);
                    }
                    else {
                        var offset = this.offset;
                        var index = this.index;
                        var next = this.next();
                        var rest = this.ops.slice(this.index);
                        this.offset = offset;
                        this.index = index;
                        return [next].concat(rest);
                    }
                };
                module.exports = lib;
            }),
            (function (module, exports) {
                var clone = (function () {
                    function _instanceof(obj, type) {
                        return type != null && obj instanceof type;
                    }
                    var nativeMap;
                    try {
                        nativeMap = Map;
                    }
                    catch (_) {
                        nativeMap = function () { };
                    }
                    var nativeSet;
                    try {
                        nativeSet = Set;
                    }
                    catch (_) {
                        nativeSet = function () { };
                    }
                    var nativePromise;
                    try {
                        nativePromise = Promise;
                    }
                    catch (_) {
                        nativePromise = function () { };
                    }
                    function clone(parent, circular, depth, prototype, includeNonEnumerable) {
                        if (typeof circular === 'object') {
                            depth = circular.depth;
                            prototype = circular.prototype;
                            includeNonEnumerable = circular.includeNonEnumerable;
                            circular = circular.circular;
                        }
                        var allParents = [];
                        var allChildren = [];
                        var useBuffer = typeof Buffer != 'undefined';
                        if (typeof circular == 'undefined')
                            circular = true;
                        if (typeof depth == 'undefined')
                            depth = Infinity;
                        function _clone(parent, depth) {
                            if (parent === null)
                                return null;
                            if (depth === 0)
                                return parent;
                            var child;
                            var proto;
                            if (typeof parent != 'object') {
                                return parent;
                            }
                            if (_instanceof(parent, nativeMap)) {
                                child = new nativeMap();
                            }
                            else if (_instanceof(parent, nativeSet)) {
                                child = new nativeSet();
                            }
                            else if (_instanceof(parent, nativePromise)) {
                                child = new nativePromise(function (resolve, reject) {
                                    parent.then(function (value) {
                                        resolve(_clone(value, depth - 1));
                                    }, function (err) {
                                        reject(_clone(err, depth - 1));
                                    });
                                });
                            }
                            else if (clone.__isArray(parent)) {
                                child = [];
                            }
                            else if (clone.__isRegExp(parent)) {
                                child = new RegExp(parent.source, __getRegExpFlags(parent));
                                if (parent.lastIndex)
                                    child.lastIndex = parent.lastIndex;
                            }
                            else if (clone.__isDate(parent)) {
                                child = new Date(parent.getTime());
                            }
                            else if (useBuffer && Buffer.isBuffer(parent)) {
                                if (Buffer.allocUnsafe) {
                                    child = Buffer.allocUnsafe(parent.length);
                                }
                                else {
                                    child = new Buffer(parent.length);
                                }
                                parent.copy(child);
                                return child;
                            }
                            else if (_instanceof(parent, Error)) {
                                child = Object.create(parent);
                            }
                            else {
                                if (typeof prototype == 'undefined') {
                                    proto = Object.getPrototypeOf(parent);
                                    child = Object.create(proto);
                                }
                                else {
                                    child = Object.create(prototype);
                                    proto = prototype;
                                }
                            }
                            if (circular) {
                                var index = allParents.indexOf(parent);
                                if (index != -1) {
                                    return allChildren[index];
                                }
                                allParents.push(parent);
                                allChildren.push(child);
                            }
                            if (_instanceof(parent, nativeMap)) {
                                parent.forEach(function (value, key) {
                                    var keyChild = _clone(key, depth - 1);
                                    var valueChild = _clone(value, depth - 1);
                                    child.set(keyChild, valueChild);
                                });
                            }
                            if (_instanceof(parent, nativeSet)) {
                                parent.forEach(function (value) {
                                    var entryChild = _clone(value, depth - 1);
                                    child.add(entryChild);
                                });
                            }
                            for (var i in parent) {
                                var attrs;
                                if (proto) {
                                    attrs = Object.getOwnPropertyDescriptor(proto, i);
                                }
                                if (attrs && attrs.set == null) {
                                    continue;
                                }
                                child[i] = _clone(parent[i], depth - 1);
                            }
                            if (Object.getOwnPropertySymbols) {
                                var symbols = Object.getOwnPropertySymbols(parent);
                                for (var i = 0; i < symbols.length; i++) {
                                    var symbol = symbols[i];
                                    var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
                                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                                        continue;
                                    }
                                    child[symbol] = _clone(parent[symbol], depth - 1);
                                    if (!descriptor.enumerable) {
                                        Object.defineProperty(child, symbol, {
                                            enumerable: false
                                        });
                                    }
                                }
                            }
                            if (includeNonEnumerable) {
                                var allPropertyNames = Object.getOwnPropertyNames(parent);
                                for (var i = 0; i < allPropertyNames.length; i++) {
                                    var propertyName = allPropertyNames[i];
                                    var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
                                    if (descriptor && descriptor.enumerable) {
                                        continue;
                                    }
                                    child[propertyName] = _clone(parent[propertyName], depth - 1);
                                    Object.defineProperty(child, propertyName, {
                                        enumerable: false
                                    });
                                }
                            }
                            return child;
                        }
                        return _clone(parent, depth);
                    }
                    clone.clonePrototype = function clonePrototype(parent) {
                        if (parent === null)
                            return null;
                        var c = function () { };
                        c.prototype = parent;
                        return new c();
                    };
                    function __objToStr(o) {
                        return Object.prototype.toString.call(o);
                    }
                    clone.__objToStr = __objToStr;
                    function __isDate(o) {
                        return typeof o === 'object' && __objToStr(o) === '[object Date]';
                    }
                    clone.__isDate = __isDate;
                    function __isArray(o) {
                        return typeof o === 'object' && __objToStr(o) === '[object Array]';
                    }
                    clone.__isArray = __isArray;
                    function __isRegExp(o) {
                        return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
                    }
                    clone.__isRegExp = __isRegExp;
                    function __getRegExpFlags(re) {
                        var flags = '';
                        if (re.global)
                            flags += 'g';
                        if (re.ignoreCase)
                            flags += 'i';
                        if (re.multiline)
                            flags += 'm';
                        return flags;
                    }
                    clone.__getRegExpFlags = __getRegExpFlags;
                    return clone;
                })();
                if (typeof module === 'object' && module.exports) {
                    module.exports = clone;
                }
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i)
                            break;
                    }
                }
                catch (err) {
                    _d = true;
                    _e = err;
                }
                finally {
                    try {
                        if (!_n && _i["return"])
                            _i["return"]();
                    }
                    finally {
                        if (_d)
                            throw _e;
                    }
                } return _arr; } return function (arr, i) { if (Array.isArray(arr)) {
                    return arr;
                }
                else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                }
                else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                } }; }();
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _emitter = __webpack_require__(8);
                var _emitter2 = _interopRequireDefault(_emitter);
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                var _break = __webpack_require__(16);
                var _break2 = _interopRequireDefault(_break);
                var _code = __webpack_require__(13);
                var _code2 = _interopRequireDefault(_code);
                var _container = __webpack_require__(25);
                var _container2 = _interopRequireDefault(_container);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                function isLine(blot) {
                    return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;
                }
                var Scroll = function (_Parchment$Scroll) {
                    _inherits(Scroll, _Parchment$Scroll);
                    function Scroll(domNode, config) {
                        _classCallCheck(this, Scroll);
                        var _this = _possibleConstructorReturn(this, (Scroll.__proto__ || Object.getPrototypeOf(Scroll)).call(this, domNode));
                        _this.emitter = config.emitter;
                        if (Array.isArray(config.whitelist)) {
                            _this.whitelist = config.whitelist.reduce(function (whitelist, format) {
                                whitelist[format] = true;
                                return whitelist;
                            }, {});
                        }
                        _this.domNode.addEventListener('DOMNodeInserted', function () { });
                        _this.optimize();
                        _this.enable();
                        return _this;
                    }
                    _createClass(Scroll, [{
                            key: 'batchStart',
                            value: function batchStart() {
                                this.batch = true;
                            }
                        }, {
                            key: 'batchEnd',
                            value: function batchEnd() {
                                this.batch = false;
                                this.optimize();
                            }
                        }, {
                            key: 'deleteAt',
                            value: function deleteAt(index, length) {
                                var _line = this.line(index), _line2 = _slicedToArray(_line, 2), first = _line2[0], offset = _line2[1];
                                var _line3 = this.line(index + length), _line4 = _slicedToArray(_line3, 1), last = _line4[0];
                                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'deleteAt', this).call(this, index, length);
                                if (last != null && first !== last && offset > 0) {
                                    if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {
                                        this.optimize();
                                        return;
                                    }
                                    if (first instanceof _code2.default) {
                                        var newlineIndex = first.newlineIndex(first.length(), true);
                                        if (newlineIndex > -1) {
                                            first = first.split(newlineIndex + 1);
                                            if (first === last) {
                                                this.optimize();
                                                return;
                                            }
                                        }
                                    }
                                    else if (last instanceof _code2.default) {
                                        var _newlineIndex = last.newlineIndex(0);
                                        if (_newlineIndex > -1) {
                                            last.split(_newlineIndex + 1);
                                        }
                                    }
                                    var ref = last.children.head instanceof _break2.default ? null : last.children.head;
                                    first.moveChildren(last, ref);
                                    first.remove();
                                }
                                this.optimize();
                            }
                        }, {
                            key: 'enable',
                            value: function enable() {
                                var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                                this.domNode.setAttribute('contenteditable', enabled);
                            }
                        }, {
                            key: 'formatAt',
                            value: function formatAt(index, length, format, value) {
                                if (this.whitelist != null && !this.whitelist[format])
                                    return;
                                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'formatAt', this).call(this, index, length, format, value);
                                this.optimize();
                            }
                        }, {
                            key: 'insertAt',
                            value: function insertAt(index, value, def) {
                                if (def != null && this.whitelist != null && !this.whitelist[value])
                                    return;
                                if (index >= this.length()) {
                                    if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {
                                        var blot = _parchment2.default.create(this.statics.defaultChild);
                                        this.appendChild(blot);
                                        if (def == null && value.endsWith('\n')) {
                                            value = value.slice(0, -1);
                                        }
                                        blot.insertAt(0, value, def);
                                    }
                                    else {
                                        var embed = _parchment2.default.create(value, def);
                                        this.appendChild(embed);
                                    }
                                }
                                else {
                                    _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertAt', this).call(this, index, value, def);
                                }
                                this.optimize();
                            }
                        }, {
                            key: 'insertBefore',
                            value: function insertBefore(blot, ref) {
                                if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {
                                    var wrapper = _parchment2.default.create(this.statics.defaultChild);
                                    wrapper.appendChild(blot);
                                    blot = wrapper;
                                }
                                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertBefore', this).call(this, blot, ref);
                            }
                        }, {
                            key: 'leaf',
                            value: function leaf(index) {
                                return this.path(index).pop() || [null, -1];
                            }
                        }, {
                            key: 'line',
                            value: function line(index) {
                                if (index === this.length()) {
                                    return this.line(index - 1);
                                }
                                return this.descendant(isLine, index);
                            }
                        }, {
                            key: 'lines',
                            value: function lines() {
                                var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;
                                var getLines = function getLines(blot, index, length) {
                                    var lines = [], lengthLeft = length;
                                    blot.children.forEachAt(index, length, function (child, index, length) {
                                        if (isLine(child)) {
                                            lines.push(child);
                                        }
                                        else if (child instanceof _parchment2.default.Container) {
                                            lines = lines.concat(getLines(child, index, lengthLeft));
                                        }
                                        lengthLeft -= length;
                                    });
                                    return lines;
                                };
                                return getLines(this, index, length);
                            }
                        }, {
                            key: 'optimize',
                            value: function optimize() {
                                var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                                var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                                if (this.batch === true)
                                    return;
                                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'optimize', this).call(this, mutations, context);
                                if (mutations.length > 0) {
                                    this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);
                                }
                            }
                        }, {
                            key: 'path',
                            value: function path(index) {
                                return _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'path', this).call(this, index).slice(1);
                            }
                        }, {
                            key: 'update',
                            value: function update(mutations) {
                                if (this.batch === true)
                                    return;
                                var source = _emitter2.default.sources.USER;
                                if (typeof mutations === 'string') {
                                    source = mutations;
                                }
                                if (!Array.isArray(mutations)) {
                                    mutations = this.observer.takeRecords();
                                }
                                if (mutations.length > 0) {
                                    this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);
                                }
                                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'update', this).call(this, mutations.concat([]));
                                if (mutations.length > 0) {
                                    this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);
                                }
                            }
                        }]);
                    return Scroll;
                }(_parchment2.default.Scroll);
                Scroll.blotName = 'scroll';
                Scroll.className = 'ql-editor';
                Scroll.tagName = 'DIV';
                Scroll.defaultChild = 'block';
                Scroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];
                exports.default = Scroll;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.SHORTKEY = exports.default = undefined;
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
                var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i)
                            break;
                    }
                }
                catch (err) {
                    _d = true;
                    _e = err;
                }
                finally {
                    try {
                        if (!_n && _i["return"])
                            _i["return"]();
                    }
                    finally {
                        if (_d)
                            throw _e;
                    }
                } return _arr; } return function (arr, i) { if (Array.isArray(arr)) {
                    return arr;
                }
                else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                }
                else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                } }; }();
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _clone = __webpack_require__(21);
                var _clone2 = _interopRequireDefault(_clone);
                var _deepEqual = __webpack_require__(11);
                var _deepEqual2 = _interopRequireDefault(_deepEqual);
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _op = __webpack_require__(20);
                var _op2 = _interopRequireDefault(_op);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _logger = __webpack_require__(10);
                var _logger2 = _interopRequireDefault(_logger);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _defineProperty(obj, key, value) { if (key in obj) {
                    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
                }
                else {
                    obj[key] = value;
                } return obj; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var debug = (0, _logger2.default)('quill:keyboard');
                var SHORTKEY = /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';
                var Keyboard = function (_Module) {
                    _inherits(Keyboard, _Module);
                    _createClass(Keyboard, null, [{
                            key: 'match',
                            value: function match(evt, binding) {
                                binding = normalize(binding);
                                if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(function (key) {
                                    return !!binding[key] !== evt[key] && binding[key] !== null;
                                })) {
                                    return false;
                                }
                                return binding.key === (evt.which || evt.keyCode);
                            }
                        }]);
                    function Keyboard(quill, options) {
                        _classCallCheck(this, Keyboard);
                        var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this, quill, options));
                        _this.bindings = {};
                        Object.keys(_this.options.bindings).forEach(function (name) {
                            if (name === 'list autofill' && quill.scroll.whitelist != null && !quill.scroll.whitelist['list']) {
                                return;
                            }
                            if (_this.options.bindings[name]) {
                                _this.addBinding(_this.options.bindings[name]);
                            }
                        });
                        _this.addBinding({ key: Keyboard.keys.ENTER, shiftKey: null }, handleEnter);
                        _this.addBinding({ key: Keyboard.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null }, function () { });
                        if (/Firefox/i.test(navigator.userAgent)) {
                            _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: true }, handleBackspace);
                            _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: true }, handleDelete);
                        }
                        else {
                            _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: true, prefix: /^.?$/ }, handleBackspace);
                            _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: true, suffix: /^.?$/ }, handleDelete);
                        }
                        _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: false }, handleDeleteRange);
                        _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: false }, handleDeleteRange);
                        _this.addBinding({ key: Keyboard.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, handleBackspace);
                        _this.listen();
                        return _this;
                    }
                    _createClass(Keyboard, [{
                            key: 'addBinding',
                            value: function addBinding(key) {
                                var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                                var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                                var binding = normalize(key);
                                if (binding == null || binding.key == null) {
                                    return debug.warn('Attempted to add invalid keyboard binding', binding);
                                }
                                if (typeof context === 'function') {
                                    context = { handler: context };
                                }
                                if (typeof handler === 'function') {
                                    handler = { handler: handler };
                                }
                                binding = (0, _extend2.default)(binding, context, handler);
                                this.bindings[binding.key] = this.bindings[binding.key] || [];
                                this.bindings[binding.key].push(binding);
                            }
                        }, {
                            key: 'listen',
                            value: function listen() {
                                var _this2 = this;
                                this.quill.root.addEventListener('keydown', function (evt) {
                                    if (evt.defaultPrevented)
                                        return;
                                    var which = evt.which || evt.keyCode;
                                    var bindings = (_this2.bindings[which] || []).filter(function (binding) {
                                        return Keyboard.match(evt, binding);
                                    });
                                    if (bindings.length === 0)
                                        return;
                                    var range = _this2.quill.getSelection();
                                    if (range == null || !_this2.quill.hasFocus())
                                        return;
                                    var _quill$getLine = _this2.quill.getLine(range.index), _quill$getLine2 = _slicedToArray(_quill$getLine, 2), line = _quill$getLine2[0], offset = _quill$getLine2[1];
                                    var _quill$getLeaf = _this2.quill.getLeaf(range.index), _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2), leafStart = _quill$getLeaf2[0], offsetStart = _quill$getLeaf2[1];
                                    var _ref = range.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range.index + range.length), _ref2 = _slicedToArray(_ref, 2), leafEnd = _ref2[0], offsetEnd = _ref2[1];
                                    var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : '';
                                    var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : '';
                                    var curContext = {
                                        collapsed: range.length === 0,
                                        empty: range.length === 0 && line.length() <= 1,
                                        format: _this2.quill.getFormat(range),
                                        offset: offset,
                                        prefix: prefixText,
                                        suffix: suffixText
                                    };
                                    var prevented = bindings.some(function (binding) {
                                        if (binding.collapsed != null && binding.collapsed !== curContext.collapsed)
                                            return false;
                                        if (binding.empty != null && binding.empty !== curContext.empty)
                                            return false;
                                        if (binding.offset != null && binding.offset !== curContext.offset)
                                            return false;
                                        if (Array.isArray(binding.format)) {
                                            if (binding.format.every(function (name) {
                                                return curContext.format[name] == null;
                                            })) {
                                                return false;
                                            }
                                        }
                                        else if (_typeof(binding.format) === 'object') {
                                            if (!Object.keys(binding.format).every(function (name) {
                                                if (binding.format[name] === true)
                                                    return curContext.format[name] != null;
                                                if (binding.format[name] === false)
                                                    return curContext.format[name] == null;
                                                return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);
                                            })) {
                                                return false;
                                            }
                                        }
                                        if (binding.prefix != null && !binding.prefix.test(curContext.prefix))
                                            return false;
                                        if (binding.suffix != null && !binding.suffix.test(curContext.suffix))
                                            return false;
                                        return binding.handler.call(_this2, range, curContext) !== true;
                                    });
                                    if (prevented) {
                                        evt.preventDefault();
                                    }
                                });
                            }
                        }]);
                    return Keyboard;
                }(_module2.default);
                Keyboard.keys = {
                    BACKSPACE: 8,
                    TAB: 9,
                    ENTER: 13,
                    ESCAPE: 27,
                    LEFT: 37,
                    UP: 38,
                    RIGHT: 39,
                    DOWN: 40,
                    DELETE: 46
                };
                Keyboard.DEFAULTS = {
                    bindings: {
                        'bold': makeFormatHandler('bold'),
                        'italic': makeFormatHandler('italic'),
                        'underline': makeFormatHandler('underline'),
                        'indent': {
                            key: Keyboard.keys.TAB,
                            format: ['blockquote', 'indent', 'list'],
                            handler: function handler(range, context) {
                                if (context.collapsed && context.offset !== 0)
                                    return true;
                                this.quill.format('indent', '+1', _quill2.default.sources.USER);
                            }
                        },
                        'outdent': {
                            key: Keyboard.keys.TAB,
                            shiftKey: true,
                            format: ['blockquote', 'indent', 'list'],
                            handler: function handler(range, context) {
                                if (context.collapsed && context.offset !== 0)
                                    return true;
                                this.quill.format('indent', '-1', _quill2.default.sources.USER);
                            }
                        },
                        'outdent backspace': {
                            key: Keyboard.keys.BACKSPACE,
                            collapsed: true,
                            shiftKey: null,
                            metaKey: null,
                            ctrlKey: null,
                            altKey: null,
                            format: ['indent', 'list'],
                            offset: 0,
                            handler: function handler(range, context) {
                                if (context.format.indent != null) {
                                    this.quill.format('indent', '-1', _quill2.default.sources.USER);
                                }
                                else if (context.format.list != null) {
                                    this.quill.format('list', false, _quill2.default.sources.USER);
                                }
                            }
                        },
                        'indent code-block': makeCodeBlockHandler(true),
                        'outdent code-block': makeCodeBlockHandler(false),
                        'remove tab': {
                            key: Keyboard.keys.TAB,
                            shiftKey: true,
                            collapsed: true,
                            prefix: /\t$/,
                            handler: function handler(range) {
                                this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);
                            }
                        },
                        'tab': {
                            key: Keyboard.keys.TAB,
                            handler: function handler(range) {
                                this.quill.history.cutoff();
                                var delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert('\t');
                                this.quill.updateContents(delta, _quill2.default.sources.USER);
                                this.quill.history.cutoff();
                                this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                            }
                        },
                        'list empty enter': {
                            key: Keyboard.keys.ENTER,
                            collapsed: true,
                            format: ['list'],
                            empty: true,
                            handler: function handler(range, context) {
                                this.quill.format('list', false, _quill2.default.sources.USER);
                                if (context.format.indent) {
                                    this.quill.format('indent', false, _quill2.default.sources.USER);
                                }
                            }
                        },
                        'checklist enter': {
                            key: Keyboard.keys.ENTER,
                            collapsed: true,
                            format: { list: 'checked' },
                            handler: function handler(range) {
                                var _quill$getLine3 = this.quill.getLine(range.index), _quill$getLine4 = _slicedToArray(_quill$getLine3, 2), line = _quill$getLine4[0], offset = _quill$getLine4[1];
                                var formats = (0, _extend2.default)({}, line.formats(), { list: 'checked' });
                                var delta = new _quillDelta2.default().retain(range.index).insert('\n', formats).retain(line.length() - offset - 1).retain(1, { list: 'unchecked' });
                                this.quill.updateContents(delta, _quill2.default.sources.USER);
                                this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                                this.quill.scrollIntoView();
                            }
                        },
                        'header enter': {
                            key: Keyboard.keys.ENTER,
                            collapsed: true,
                            format: ['header'],
                            suffix: /^$/,
                            handler: function handler(range, context) {
                                var _quill$getLine5 = this.quill.getLine(range.index), _quill$getLine6 = _slicedToArray(_quill$getLine5, 2), line = _quill$getLine6[0], offset = _quill$getLine6[1];
                                var delta = new _quillDelta2.default().retain(range.index).insert('\n', context.format).retain(line.length() - offset - 1).retain(1, { header: null });
                                this.quill.updateContents(delta, _quill2.default.sources.USER);
                                this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                                this.quill.scrollIntoView();
                            }
                        },
                        'list autofill': {
                            key: ' ',
                            collapsed: true,
                            format: { list: false },
                            prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
                            handler: function handler(range, context) {
                                var length = context.prefix.length;
                                var _quill$getLine7 = this.quill.getLine(range.index), _quill$getLine8 = _slicedToArray(_quill$getLine7, 2), line = _quill$getLine8[0], offset = _quill$getLine8[1];
                                if (offset > length)
                                    return true;
                                var value = void 0;
                                switch (context.prefix.trim()) {
                                    case '[]':
                                    case '[ ]':
                                        value = 'unchecked';
                                        break;
                                    case '[x]':
                                        value = 'checked';
                                        break;
                                    case '-':
                                    case '*':
                                        value = 'bullet';
                                        break;
                                    default:
                                        value = 'ordered';
                                }
                                this.quill.insertText(range.index, ' ', _quill2.default.sources.USER);
                                this.quill.history.cutoff();
                                var delta = new _quillDelta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, { list: value });
                                this.quill.updateContents(delta, _quill2.default.sources.USER);
                                this.quill.history.cutoff();
                                this.quill.setSelection(range.index - length, _quill2.default.sources.SILENT);
                            }
                        },
                        'code exit': {
                            key: Keyboard.keys.ENTER,
                            collapsed: true,
                            format: ['code-block'],
                            prefix: /\n\n$/,
                            suffix: /^\s+$/,
                            handler: function handler(range) {
                                var _quill$getLine9 = this.quill.getLine(range.index), _quill$getLine10 = _slicedToArray(_quill$getLine9, 2), line = _quill$getLine10[0], offset = _quill$getLine10[1];
                                var delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, { 'code-block': null }).delete(1);
                                this.quill.updateContents(delta, _quill2.default.sources.USER);
                            }
                        },
                        'embed left': makeEmbedArrowHandler(Keyboard.keys.LEFT, false),
                        'embed left shift': makeEmbedArrowHandler(Keyboard.keys.LEFT, true),
                        'embed right': makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),
                        'embed right shift': makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)
                    }
                };
                function makeEmbedArrowHandler(key, shiftKey) {
                    var _ref3;
                    var where = key === Keyboard.keys.LEFT ? 'prefix' : 'suffix';
                    return _ref3 = {
                        key: key,
                        shiftKey: shiftKey,
                        altKey: null
                    }, _defineProperty(_ref3, where, /^$/), _defineProperty(_ref3, 'handler', function handler(range) {
                        var index = range.index;
                        if (key === Keyboard.keys.RIGHT) {
                            index += range.length + 1;
                        }
                        var _quill$getLeaf3 = this.quill.getLeaf(index), _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1), leaf = _quill$getLeaf4[0];
                        if (!(leaf instanceof _parchment2.default.Embed))
                            return true;
                        if (key === Keyboard.keys.LEFT) {
                            if (shiftKey) {
                                this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);
                            }
                            else {
                                this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);
                            }
                        }
                        else {
                            if (shiftKey) {
                                this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);
                            }
                            else {
                                this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);
                            }
                        }
                        return false;
                    }), _ref3;
                }
                function handleBackspace(range, context) {
                    if (range.index === 0 || this.quill.getLength() <= 1)
                        return;
                    var _quill$getLine11 = this.quill.getLine(range.index), _quill$getLine12 = _slicedToArray(_quill$getLine11, 1), line = _quill$getLine12[0];
                    var formats = {};
                    if (context.offset === 0) {
                        var _quill$getLine13 = this.quill.getLine(range.index - 1), _quill$getLine14 = _slicedToArray(_quill$getLine13, 1), prev = _quill$getLine14[0];
                        if (prev != null && prev.length() > 1) {
                            var curFormats = line.formats();
                            var prevFormats = this.quill.getFormat(range.index - 1, 1);
                            formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};
                        }
                    }
                    var length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
                    this.quill.deleteText(range.index - length, length, _quill2.default.sources.USER);
                    if (Object.keys(formats).length > 0) {
                        this.quill.formatLine(range.index - length, length, formats, _quill2.default.sources.USER);
                    }
                    this.quill.focus();
                }
                function handleDelete(range, context) {
                    var length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
                    if (range.index >= this.quill.getLength() - length)
                        return;
                    var formats = {}, nextLength = 0;
                    var _quill$getLine15 = this.quill.getLine(range.index), _quill$getLine16 = _slicedToArray(_quill$getLine15, 1), line = _quill$getLine16[0];
                    if (context.offset >= line.length() - 1) {
                        var _quill$getLine17 = this.quill.getLine(range.index + 1), _quill$getLine18 = _slicedToArray(_quill$getLine17, 1), next = _quill$getLine18[0];
                        if (next) {
                            var curFormats = line.formats();
                            var nextFormats = this.quill.getFormat(range.index, 1);
                            formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};
                            nextLength = next.length();
                        }
                    }
                    this.quill.deleteText(range.index, length, _quill2.default.sources.USER);
                    if (Object.keys(formats).length > 0) {
                        this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2.default.sources.USER);
                    }
                }
                function handleDeleteRange(range) {
                    var lines = this.quill.getLines(range);
                    var formats = {};
                    if (lines.length > 1) {
                        var firstFormats = lines[0].formats();
                        var lastFormats = lines[lines.length - 1].formats();
                        formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};
                    }
                    this.quill.deleteText(range, _quill2.default.sources.USER);
                    if (Object.keys(formats).length > 0) {
                        this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);
                    }
                    this.quill.setSelection(range.index, _quill2.default.sources.SILENT);
                    this.quill.focus();
                }
                function handleEnter(range, context) {
                    var _this3 = this;
                    if (range.length > 0) {
                        this.quill.scroll.deleteAt(range.index, range.length);
                    }
                    var lineFormats = Object.keys(context.format).reduce(function (lineFormats, format) {
                        if (_parchment2.default.query(format, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format])) {
                            lineFormats[format] = context.format[format];
                        }
                        return lineFormats;
                    }, {});
                    this.quill.insertText(range.index, '\n', lineFormats, _quill2.default.sources.USER);
                    this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                    this.quill.focus();
                    Object.keys(context.format).forEach(function (name) {
                        if (lineFormats[name] != null)
                            return;
                        if (Array.isArray(context.format[name]))
                            return;
                        if (name === 'link')
                            return;
                        _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);
                    });
                }
                function makeCodeBlockHandler(indent) {
                    return {
                        key: Keyboard.keys.TAB,
                        shiftKey: !indent,
                        format: { 'code-block': true },
                        handler: function handler(range) {
                            var CodeBlock = _parchment2.default.query('code-block');
                            var index = range.index, length = range.length;
                            var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index), _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2), block = _quill$scroll$descend2[0], offset = _quill$scroll$descend2[1];
                            if (block == null)
                                return;
                            var scrollIndex = this.quill.getIndex(block);
                            var start = block.newlineIndex(offset, true) + 1;
                            var end = block.newlineIndex(scrollIndex + offset + length);
                            var lines = block.domNode.textContent.slice(start, end).split('\n');
                            offset = 0;
                            lines.forEach(function (line, i) {
                                if (indent) {
                                    block.insertAt(start + offset, CodeBlock.TAB);
                                    offset += CodeBlock.TAB.length;
                                    if (i === 0) {
                                        index += CodeBlock.TAB.length;
                                    }
                                    else {
                                        length += CodeBlock.TAB.length;
                                    }
                                }
                                else if (line.startsWith(CodeBlock.TAB)) {
                                    block.deleteAt(start + offset, CodeBlock.TAB.length);
                                    offset -= CodeBlock.TAB.length;
                                    if (i === 0) {
                                        index -= CodeBlock.TAB.length;
                                    }
                                    else {
                                        length -= CodeBlock.TAB.length;
                                    }
                                }
                                offset += line.length + 1;
                            });
                            this.quill.update(_quill2.default.sources.USER);
                            this.quill.setSelection(index, length, _quill2.default.sources.SILENT);
                        }
                    };
                }
                function makeFormatHandler(format) {
                    return {
                        key: format[0].toUpperCase(),
                        shortKey: true,
                        handler: function handler(range, context) {
                            this.quill.format(format, !context.format[format], _quill2.default.sources.USER);
                        }
                    };
                }
                function normalize(binding) {
                    if (typeof binding === 'string' || typeof binding === 'number') {
                        return normalize({ key: binding });
                    }
                    if ((typeof binding === 'undefined' ? 'undefined' : _typeof(binding)) === 'object') {
                        binding = (0, _clone2.default)(binding, false);
                    }
                    if (typeof binding.key === 'string') {
                        if (Keyboard.keys[binding.key.toUpperCase()] != null) {
                            binding.key = Keyboard.keys[binding.key.toUpperCase()];
                        }
                        else if (binding.key.length === 1) {
                            binding.key = binding.key.toUpperCase().charCodeAt(0);
                        }
                        else {
                            return null;
                        }
                    }
                    if (binding.shortKey) {
                        binding[SHORTKEY] = binding.shortKey;
                        delete binding.shortKey;
                    }
                    return binding;
                }
                exports.default = Keyboard;
                exports.SHORTKEY = SHORTKEY;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i)
                            break;
                    }
                }
                catch (err) {
                    _d = true;
                    _e = err;
                }
                finally {
                    try {
                        if (!_n && _i["return"])
                            _i["return"]();
                    }
                    finally {
                        if (_d)
                            throw _e;
                    }
                } return _arr; } return function (arr, i) { if (Array.isArray(arr)) {
                    return arr;
                }
                else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                }
                else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                } }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _text = __webpack_require__(7);
                var _text2 = _interopRequireDefault(_text);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Cursor = function (_Parchment$Embed) {
                    _inherits(Cursor, _Parchment$Embed);
                    _createClass(Cursor, null, [{
                            key: 'value',
                            value: function value() {
                                return undefined;
                            }
                        }]);
                    function Cursor(domNode, selection) {
                        _classCallCheck(this, Cursor);
                        var _this = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, domNode));
                        _this.selection = selection;
                        _this.textNode = document.createTextNode(Cursor.CONTENTS);
                        _this.domNode.appendChild(_this.textNode);
                        _this._length = 0;
                        return _this;
                    }
                    _createClass(Cursor, [{
                            key: 'detach',
                            value: function detach() {
                                if (this.parent != null)
                                    this.parent.removeChild(this);
                            }
                        }, {
                            key: 'format',
                            value: function format(name, value) {
                                if (this._length !== 0) {
                                    return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'format', this).call(this, name, value);
                                }
                                var target = this, index = 0;
                                while (target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT) {
                                    index += target.offset(target.parent);
                                    target = target.parent;
                                }
                                if (target != null) {
                                    this._length = Cursor.CONTENTS.length;
                                    target.optimize();
                                    target.formatAt(index, Cursor.CONTENTS.length, name, value);
                                    this._length = 0;
                                }
                            }
                        }, {
                            key: 'index',
                            value: function index(node, offset) {
                                if (node === this.textNode)
                                    return 0;
                                return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'index', this).call(this, node, offset);
                            }
                        }, {
                            key: 'length',
                            value: function length() {
                                return this._length;
                            }
                        }, {
                            key: 'position',
                            value: function position() {
                                return [this.textNode, this.textNode.data.length];
                            }
                        }, {
                            key: 'remove',
                            value: function remove() {
                                _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'remove', this).call(this);
                                this.parent = null;
                            }
                        }, {
                            key: 'restore',
                            value: function restore() {
                                if (this.selection.composing || this.parent == null)
                                    return;
                                var textNode = this.textNode;
                                var range = this.selection.getNativeRange();
                                var restoreText = void 0, start = void 0, end = void 0;
                                if (range != null && range.start.node === textNode && range.end.node === textNode) {
                                    var _ref = [textNode, range.start.offset, range.end.offset];
                                    restoreText = _ref[0];
                                    start = _ref[1];
                                    end = _ref[2];
                                }
                                while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
                                    this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
                                }
                                if (this.textNode.data !== Cursor.CONTENTS) {
                                    var text = this.textNode.data.split(Cursor.CONTENTS).join('');
                                    if (this.next instanceof _text2.default) {
                                        restoreText = this.next.domNode;
                                        this.next.insertAt(0, text);
                                        this.textNode.data = Cursor.CONTENTS;
                                    }
                                    else {
                                        this.textNode.data = text;
                                        this.parent.insertBefore(_parchment2.default.create(this.textNode), this);
                                        this.textNode = document.createTextNode(Cursor.CONTENTS);
                                        this.domNode.appendChild(this.textNode);
                                    }
                                }
                                this.remove();
                                if (start != null) {
                                    var _map = [start, end].map(function (offset) {
                                        return Math.max(0, Math.min(restoreText.data.length, offset - 1));
                                    });
                                    var _map2 = _slicedToArray(_map, 2);
                                    start = _map2[0];
                                    end = _map2[1];
                                    return {
                                        startNode: restoreText,
                                        startOffset: start,
                                        endNode: restoreText,
                                        endOffset: end
                                    };
                                }
                            }
                        }, {
                            key: 'update',
                            value: function update(mutations, context) {
                                var _this2 = this;
                                if (mutations.some(function (mutation) {
                                    return mutation.type === 'characterData' && mutation.target === _this2.textNode;
                                })) {
                                    var range = this.restore();
                                    if (range)
                                        context.range = range;
                                }
                            }
                        }, {
                            key: 'value',
                            value: function value() {
                                return '';
                            }
                        }]);
                    return Cursor;
                }(_parchment2.default.Embed);
                Cursor.blotName = 'cursor';
                Cursor.className = 'ql-cursor';
                Cursor.tagName = 'span';
                Cursor.CONTENTS = '\uFEFF';
                exports.default = Cursor;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Container = function (_Parchment$Container) {
                    _inherits(Container, _Parchment$Container);
                    function Container() {
                        _classCallCheck(this, Container);
                        return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));
                    }
                    return Container;
                }(_parchment2.default.Container);
                Container.allowedChildren = [_block2.default, _block.BlockEmbed, Container];
                exports.default = Container;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.ColorStyle = exports.ColorClass = exports.ColorAttributor = undefined;
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var ColorAttributor = function (_Parchment$Attributor) {
                    _inherits(ColorAttributor, _Parchment$Attributor);
                    function ColorAttributor() {
                        _classCallCheck(this, ColorAttributor);
                        return _possibleConstructorReturn(this, (ColorAttributor.__proto__ || Object.getPrototypeOf(ColorAttributor)).apply(this, arguments));
                    }
                    _createClass(ColorAttributor, [{
                            key: 'value',
                            value: function value(domNode) {
                                var value = _get(ColorAttributor.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor.prototype), 'value', this).call(this, domNode);
                                if (!value.startsWith('rgb('))
                                    return value;
                                value = value.replace(/^[^\d]+/, '').replace(/[^\d]+$/, '');
                                return '#' + value.split(',').map(function (component) {
                                    return ('00' + parseInt(component).toString(16)).slice(-2);
                                }).join('');
                            }
                        }]);
                    return ColorAttributor;
                }(_parchment2.default.Attributor.Style);
                var ColorClass = new _parchment2.default.Attributor.Class('color', 'ql-color', {
                    scope: _parchment2.default.Scope.INLINE
                });
                var ColorStyle = new ColorAttributor('color', 'color', {
                    scope: _parchment2.default.Scope.INLINE
                });
                exports.ColorAttributor = ColorAttributor;
                exports.ColorClass = ColorClass;
                exports.ColorStyle = ColorStyle;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.sanitize = exports.default = undefined;
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Link = function (_Inline) {
                    _inherits(Link, _Inline);
                    function Link() {
                        _classCallCheck(this, Link);
                        return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));
                    }
                    _createClass(Link, [{
                            key: 'format',
                            value: function format(name, value) {
                                if (name !== this.statics.blotName || !value)
                                    return _get(Link.prototype.__proto__ || Object.getPrototypeOf(Link.prototype), 'format', this).call(this, name, value);
                                value = this.constructor.sanitize(value);
                                this.domNode.setAttribute('href', value);
                            }
                        }], [{
                            key: 'create',
                            value: function create(value) {
                                var node = _get(Link.__proto__ || Object.getPrototypeOf(Link), 'create', this).call(this, value);
                                value = this.sanitize(value);
                                node.setAttribute('href', value);
                                node.setAttribute('rel', 'noopener noreferrer');
                                node.setAttribute('target', '_blank');
                                return node;
                            }
                        }, {
                            key: 'formats',
                            value: function formats(domNode) {
                                return domNode.getAttribute('href');
                            }
                        }, {
                            key: 'sanitize',
                            value: function sanitize(url) {
                                return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
                            }
                        }]);
                    return Link;
                }(_inline2.default);
                Link.blotName = 'link';
                Link.tagName = 'A';
                Link.SANITIZED_URL = 'about:blank';
                Link.PROTOCOL_WHITELIST = ['http', 'https', 'mailto', 'tel'];
                function _sanitize(url, protocols) {
                    var anchor = document.createElement('a');
                    anchor.href = url;
                    var protocol = anchor.href.slice(0, anchor.href.indexOf(':'));
                    return protocols.indexOf(protocol) > -1;
                }
                exports.default = Link;
                exports.sanitize = _sanitize;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _keyboard = __webpack_require__(23);
                var _keyboard2 = _interopRequireDefault(_keyboard);
                var _dropdown = __webpack_require__(107);
                var _dropdown2 = _interopRequireDefault(_dropdown);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                var optionsCounter = 0;
                function toggleAriaAttribute(element, attribute) {
                    element.setAttribute(attribute, !(element.getAttribute(attribute) === 'true'));
                }
                var Picker = function () {
                    function Picker(select) {
                        var _this = this;
                        _classCallCheck(this, Picker);
                        this.select = select;
                        this.container = document.createElement('span');
                        this.buildPicker();
                        this.select.style.display = 'none';
                        this.select.parentNode.insertBefore(this.container, this.select);
                        this.label.addEventListener('mousedown', function () {
                            _this.togglePicker();
                        });
                        this.label.addEventListener('keydown', function (event) {
                            switch (event.keyCode) {
                                case _keyboard2.default.keys.ENTER:
                                    _this.togglePicker();
                                    break;
                                case _keyboard2.default.keys.ESCAPE:
                                    _this.escape();
                                    event.preventDefault();
                                    break;
                            }
                        });
                        this.select.addEventListener('change', this.update.bind(this));
                    }
                    _createClass(Picker, [{
                            key: 'togglePicker',
                            value: function togglePicker() {
                                this.container.classList.toggle('ql-expanded');
                                toggleAriaAttribute(this.label, 'aria-expanded');
                                toggleAriaAttribute(this.options, 'aria-hidden');
                            }
                        }, {
                            key: 'buildItem',
                            value: function buildItem(option) {
                                var _this2 = this;
                                var item = document.createElement('span');
                                item.tabIndex = '0';
                                item.setAttribute('role', 'button');
                                item.classList.add('ql-picker-item');
                                if (option.hasAttribute('value')) {
                                    item.setAttribute('data-value', option.getAttribute('value'));
                                }
                                if (option.textContent) {
                                    item.setAttribute('data-label', option.textContent);
                                }
                                item.addEventListener('click', function () {
                                    _this2.selectItem(item, true);
                                });
                                item.addEventListener('keydown', function (event) {
                                    switch (event.keyCode) {
                                        case _keyboard2.default.keys.ENTER:
                                            _this2.selectItem(item, true);
                                            event.preventDefault();
                                            break;
                                        case _keyboard2.default.keys.ESCAPE:
                                            _this2.escape();
                                            event.preventDefault();
                                            break;
                                    }
                                });
                                return item;
                            }
                        }, {
                            key: 'buildLabel',
                            value: function buildLabel() {
                                var label = document.createElement('span');
                                label.classList.add('ql-picker-label');
                                label.innerHTML = _dropdown2.default;
                                label.tabIndex = '0';
                                label.setAttribute('role', 'button');
                                label.setAttribute('aria-expanded', 'false');
                                this.container.appendChild(label);
                                return label;
                            }
                        }, {
                            key: 'buildOptions',
                            value: function buildOptions() {
                                var _this3 = this;
                                var options = document.createElement('span');
                                options.classList.add('ql-picker-options');
                                options.setAttribute('aria-hidden', 'true');
                                options.tabIndex = '-1';
                                options.id = 'ql-picker-options-' + optionsCounter;
                                optionsCounter += 1;
                                this.label.setAttribute('aria-controls', options.id);
                                this.options = options;
                                [].slice.call(this.select.options).forEach(function (option) {
                                    var item = _this3.buildItem(option);
                                    options.appendChild(item);
                                    if (option.selected === true) {
                                        _this3.selectItem(item);
                                    }
                                });
                                this.container.appendChild(options);
                            }
                        }, {
                            key: 'buildPicker',
                            value: function buildPicker() {
                                var _this4 = this;
                                [].slice.call(this.select.attributes).forEach(function (item) {
                                    _this4.container.setAttribute(item.name, item.value);
                                });
                                this.container.classList.add('ql-picker');
                                this.label = this.buildLabel();
                                this.buildOptions();
                            }
                        }, {
                            key: 'escape',
                            value: function escape() {
                                var _this5 = this;
                                this.close();
                                setTimeout(function () {
                                    return _this5.label.focus();
                                }, 1);
                            }
                        }, {
                            key: 'close',
                            value: function close() {
                                this.container.classList.remove('ql-expanded');
                                this.label.setAttribute('aria-expanded', 'false');
                                this.options.setAttribute('aria-hidden', 'true');
                            }
                        }, {
                            key: 'selectItem',
                            value: function selectItem(item) {
                                var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                                var selected = this.container.querySelector('.ql-selected');
                                if (item === selected)
                                    return;
                                if (selected != null) {
                                    selected.classList.remove('ql-selected');
                                }
                                if (item == null)
                                    return;
                                item.classList.add('ql-selected');
                                this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);
                                if (item.hasAttribute('data-value')) {
                                    this.label.setAttribute('data-value', item.getAttribute('data-value'));
                                }
                                else {
                                    this.label.removeAttribute('data-value');
                                }
                                if (item.hasAttribute('data-label')) {
                                    this.label.setAttribute('data-label', item.getAttribute('data-label'));
                                }
                                else {
                                    this.label.removeAttribute('data-label');
                                }
                                if (trigger) {
                                    if (typeof Event === 'function') {
                                        this.select.dispatchEvent(new Event('change'));
                                    }
                                    else if ((typeof Event === 'undefined' ? 'undefined' : _typeof(Event)) === 'object') {
                                        var event = document.createEvent('Event');
                                        event.initEvent('change', true, true);
                                        this.select.dispatchEvent(event);
                                    }
                                    this.close();
                                }
                            }
                        }, {
                            key: 'update',
                            value: function update() {
                                var option = void 0;
                                if (this.select.selectedIndex > -1) {
                                    var item = this.container.querySelector('.ql-picker-options').children[this.select.selectedIndex];
                                    option = this.select.options[this.select.selectedIndex];
                                    this.selectItem(item);
                                }
                                else {
                                    this.selectItem(null);
                                }
                                var isActive = option != null && option !== this.select.querySelector('option[selected]');
                                this.label.classList.toggle('ql-active', isActive);
                            }
                        }]);
                    return Picker;
                }();
                exports.default = Picker;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                var _break = __webpack_require__(16);
                var _break2 = _interopRequireDefault(_break);
                var _container = __webpack_require__(25);
                var _container2 = _interopRequireDefault(_container);
                var _cursor = __webpack_require__(24);
                var _cursor2 = _interopRequireDefault(_cursor);
                var _embed = __webpack_require__(35);
                var _embed2 = _interopRequireDefault(_embed);
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                var _scroll = __webpack_require__(22);
                var _scroll2 = _interopRequireDefault(_scroll);
                var _text = __webpack_require__(7);
                var _text2 = _interopRequireDefault(_text);
                var _clipboard = __webpack_require__(55);
                var _clipboard2 = _interopRequireDefault(_clipboard);
                var _history = __webpack_require__(42);
                var _history2 = _interopRequireDefault(_history);
                var _keyboard = __webpack_require__(23);
                var _keyboard2 = _interopRequireDefault(_keyboard);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                _quill2.default.register({
                    'blots/block': _block2.default,
                    'blots/block/embed': _block.BlockEmbed,
                    'blots/break': _break2.default,
                    'blots/container': _container2.default,
                    'blots/cursor': _cursor2.default,
                    'blots/embed': _embed2.default,
                    'blots/inline': _inline2.default,
                    'blots/scroll': _scroll2.default,
                    'blots/text': _text2.default,
                    'modules/clipboard': _clipboard2.default,
                    'modules/history': _history2.default,
                    'modules/keyboard': _keyboard2.default
                });
                _parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);
                exports.default = _quill2.default;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", { value: true });
                var Registry = __webpack_require__(1);
                var ShadowBlot = (function () {
                    function ShadowBlot(domNode) {
                        this.domNode = domNode;
                        this.domNode[Registry.DATA_KEY] = { blot: this };
                    }
                    Object.defineProperty(ShadowBlot.prototype, "statics", {
                        get: function () {
                            return this.constructor;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ShadowBlot.create = function (value) {
                        if (this.tagName == null) {
                            throw new Registry.ParchmentError('Blot definition missing tagName');
                        }
                        var node;
                        if (Array.isArray(this.tagName)) {
                            if (typeof value === 'string') {
                                value = value.toUpperCase();
                                if (parseInt(value).toString() === value) {
                                    value = parseInt(value);
                                }
                            }
                            if (typeof value === 'number') {
                                node = document.createElement(this.tagName[value - 1]);
                            }
                            else if (this.tagName.indexOf(value) > -1) {
                                node = document.createElement(value);
                            }
                            else {
                                node = document.createElement(this.tagName[0]);
                            }
                        }
                        else {
                            node = document.createElement(this.tagName);
                        }
                        if (this.className) {
                            node.classList.add(this.className);
                        }
                        return node;
                    };
                    ShadowBlot.prototype.attach = function () {
                        if (this.parent != null) {
                            this.scroll = this.parent.scroll;
                        }
                    };
                    ShadowBlot.prototype.clone = function () {
                        var domNode = this.domNode.cloneNode(false);
                        return Registry.create(domNode);
                    };
                    ShadowBlot.prototype.detach = function () {
                        if (this.parent != null)
                            this.parent.removeChild(this);
                        delete this.domNode[Registry.DATA_KEY];
                    };
                    ShadowBlot.prototype.deleteAt = function (index, length) {
                        var blot = this.isolate(index, length);
                        blot.remove();
                    };
                    ShadowBlot.prototype.formatAt = function (index, length, name, value) {
                        var blot = this.isolate(index, length);
                        if (Registry.query(name, Registry.Scope.BLOT) != null && value) {
                            blot.wrap(name, value);
                        }
                        else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {
                            var parent = Registry.create(this.statics.scope);
                            blot.wrap(parent);
                            parent.format(name, value);
                        }
                    };
                    ShadowBlot.prototype.insertAt = function (index, value, def) {
                        var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
                        var ref = this.split(index);
                        this.parent.insertBefore(blot, ref);
                    };
                    ShadowBlot.prototype.insertInto = function (parentBlot, refBlot) {
                        if (refBlot === void 0) {
                            refBlot = null;
                        }
                        if (this.parent != null) {
                            this.parent.children.remove(this);
                        }
                        var refDomNode = null;
                        parentBlot.children.insertBefore(this, refBlot);
                        if (refBlot != null) {
                            refDomNode = refBlot.domNode;
                        }
                        if (this.domNode.parentNode != parentBlot.domNode ||
                            this.domNode.nextSibling != refDomNode) {
                            parentBlot.domNode.insertBefore(this.domNode, refDomNode);
                        }
                        this.parent = parentBlot;
                        this.attach();
                    };
                    ShadowBlot.prototype.isolate = function (index, length) {
                        var target = this.split(index);
                        target.split(length);
                        return target;
                    };
                    ShadowBlot.prototype.length = function () {
                        return 1;
                    };
                    ShadowBlot.prototype.offset = function (root) {
                        if (root === void 0) {
                            root = this.parent;
                        }
                        if (this.parent == null || this == root)
                            return 0;
                        return this.parent.children.offset(this) + this.parent.offset(root);
                    };
                    ShadowBlot.prototype.optimize = function (context) {
                        if (this.domNode[Registry.DATA_KEY] != null) {
                            delete this.domNode[Registry.DATA_KEY].mutations;
                        }
                    };
                    ShadowBlot.prototype.remove = function () {
                        if (this.domNode.parentNode != null) {
                            this.domNode.parentNode.removeChild(this.domNode);
                        }
                        this.detach();
                    };
                    ShadowBlot.prototype.replace = function (target) {
                        if (target.parent == null)
                            return;
                        target.parent.insertBefore(this, target.next);
                        target.remove();
                    };
                    ShadowBlot.prototype.replaceWith = function (name, value) {
                        var replacement = typeof name === 'string' ? Registry.create(name, value) : name;
                        replacement.replace(this);
                        return replacement;
                    };
                    ShadowBlot.prototype.split = function (index, force) {
                        return index === 0 ? this : this.next;
                    };
                    ShadowBlot.prototype.update = function (mutations, context) {
                    };
                    ShadowBlot.prototype.wrap = function (name, value) {
                        var wrapper = typeof name === 'string' ? Registry.create(name, value) : name;
                        if (this.parent != null) {
                            this.parent.insertBefore(wrapper, this.next);
                        }
                        wrapper.appendChild(this);
                        return wrapper;
                    };
                    ShadowBlot.blotName = 'abstract';
                    return ShadowBlot;
                }());
                exports.default = ShadowBlot;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", { value: true });
                var attributor_1 = __webpack_require__(12);
                var class_1 = __webpack_require__(32);
                var style_1 = __webpack_require__(33);
                var Registry = __webpack_require__(1);
                var AttributorStore = (function () {
                    function AttributorStore(domNode) {
                        this.attributes = {};
                        this.domNode = domNode;
                        this.build();
                    }
                    AttributorStore.prototype.attribute = function (attribute, value) {
                        if (value) {
                            if (attribute.add(this.domNode, value)) {
                                if (attribute.value(this.domNode) != null) {
                                    this.attributes[attribute.attrName] = attribute;
                                }
                                else {
                                    delete this.attributes[attribute.attrName];
                                }
                            }
                        }
                        else {
                            attribute.remove(this.domNode);
                            delete this.attributes[attribute.attrName];
                        }
                    };
                    AttributorStore.prototype.build = function () {
                        var _this = this;
                        this.attributes = {};
                        var attributes = attributor_1.default.keys(this.domNode);
                        var classes = class_1.default.keys(this.domNode);
                        var styles = style_1.default.keys(this.domNode);
                        attributes
                            .concat(classes)
                            .concat(styles)
                            .forEach(function (name) {
                            var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);
                            if (attr instanceof attributor_1.default) {
                                _this.attributes[attr.attrName] = attr;
                            }
                        });
                    };
                    AttributorStore.prototype.copy = function (target) {
                        var _this = this;
                        Object.keys(this.attributes).forEach(function (key) {
                            var value = _this.attributes[key].value(_this.domNode);
                            target.format(key, value);
                        });
                    };
                    AttributorStore.prototype.move = function (target) {
                        var _this = this;
                        this.copy(target);
                        Object.keys(this.attributes).forEach(function (key) {
                            _this.attributes[key].remove(_this.domNode);
                        });
                        this.attributes = {};
                    };
                    AttributorStore.prototype.values = function () {
                        var _this = this;
                        return Object.keys(this.attributes).reduce(function (attributes, name) {
                            attributes[name] = _this.attributes[name].value(_this.domNode);
                            return attributes;
                        }, {});
                    };
                    return AttributorStore;
                }());
                exports.default = AttributorStore;
            }),
            (function (module, exports, __webpack_require__) {
                var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b)
                            if (b.hasOwnProperty(p))
                                d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                Object.defineProperty(exports, "__esModule", { value: true });
                var attributor_1 = __webpack_require__(12);
                function match(node, prefix) {
                    var className = node.getAttribute('class') || '';
                    return className.split(/\s+/).filter(function (name) {
                        return name.indexOf(prefix + "-") === 0;
                    });
                }
                var ClassAttributor = (function (_super) {
                    __extends(ClassAttributor, _super);
                    function ClassAttributor() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    ClassAttributor.keys = function (node) {
                        return (node.getAttribute('class') || '').split(/\s+/).map(function (name) {
                            return name
                                .split('-')
                                .slice(0, -1)
                                .join('-');
                        });
                    };
                    ClassAttributor.prototype.add = function (node, value) {
                        if (!this.canAdd(node, value))
                            return false;
                        this.remove(node);
                        node.classList.add(this.keyName + "-" + value);
                        return true;
                    };
                    ClassAttributor.prototype.remove = function (node) {
                        var matches = match(node, this.keyName);
                        matches.forEach(function (name) {
                            node.classList.remove(name);
                        });
                        if (node.classList.length === 0) {
                            node.removeAttribute('class');
                        }
                    };
                    ClassAttributor.prototype.value = function (node) {
                        var result = match(node, this.keyName)[0] || '';
                        var value = result.slice(this.keyName.length + 1);
                        return this.canAdd(node, value) ? value : '';
                    };
                    return ClassAttributor;
                }(attributor_1.default));
                exports.default = ClassAttributor;
            }),
            (function (module, exports, __webpack_require__) {
                var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b)
                            if (b.hasOwnProperty(p))
                                d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                Object.defineProperty(exports, "__esModule", { value: true });
                var attributor_1 = __webpack_require__(12);
                function camelize(name) {
                    var parts = name.split('-');
                    var rest = parts
                        .slice(1)
                        .map(function (part) {
                        return part[0].toUpperCase() + part.slice(1);
                    })
                        .join('');
                    return parts[0] + rest;
                }
                var StyleAttributor = (function (_super) {
                    __extends(StyleAttributor, _super);
                    function StyleAttributor() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    StyleAttributor.keys = function (node) {
                        return (node.getAttribute('style') || '').split(';').map(function (value) {
                            var arr = value.split(':');
                            return arr[0].trim();
                        });
                    };
                    StyleAttributor.prototype.add = function (node, value) {
                        if (!this.canAdd(node, value))
                            return false;
                        node.style[camelize(this.keyName)] = value;
                        return true;
                    };
                    StyleAttributor.prototype.remove = function (node) {
                        node.style[camelize(this.keyName)] = '';
                        if (!node.getAttribute('style')) {
                            node.removeAttribute('style');
                        }
                    };
                    StyleAttributor.prototype.value = function (node) {
                        var value = node.style[camelize(this.keyName)];
                        return this.canAdd(node, value) ? value : '';
                    };
                    return StyleAttributor;
                }(attributor_1.default));
                exports.default = StyleAttributor;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                var Theme = function () {
                    function Theme(quill, options) {
                        _classCallCheck(this, Theme);
                        this.quill = quill;
                        this.options = options;
                        this.modules = {};
                    }
                    _createClass(Theme, [{
                            key: 'init',
                            value: function init() {
                                var _this = this;
                                Object.keys(this.options.modules).forEach(function (name) {
                                    if (_this.modules[name] == null) {
                                        _this.addModule(name);
                                    }
                                });
                            }
                        }, {
                            key: 'addModule',
                            value: function addModule(name) {
                                var moduleClass = this.quill.constructor.import('modules/' + name);
                                this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});
                                return this.modules[name];
                            }
                        }]);
                    return Theme;
                }();
                Theme.DEFAULTS = {
                    modules: {}
                };
                Theme.themes = {
                    'default': Theme
                };
                exports.default = Theme;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _text = __webpack_require__(7);
                var _text2 = _interopRequireDefault(_text);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var GUARD_TEXT = '\uFEFF';
                var Embed = function (_Parchment$Embed) {
                    _inherits(Embed, _Parchment$Embed);
                    function Embed(node) {
                        _classCallCheck(this, Embed);
                        var _this = _possibleConstructorReturn(this, (Embed.__proto__ || Object.getPrototypeOf(Embed)).call(this, node));
                        _this.contentNode = document.createElement('span');
                        _this.contentNode.setAttribute('contenteditable', false);
                        [].slice.call(_this.domNode.childNodes).forEach(function (childNode) {
                            _this.contentNode.appendChild(childNode);
                        });
                        _this.leftGuard = document.createTextNode(GUARD_TEXT);
                        _this.rightGuard = document.createTextNode(GUARD_TEXT);
                        _this.domNode.appendChild(_this.leftGuard);
                        _this.domNode.appendChild(_this.contentNode);
                        _this.domNode.appendChild(_this.rightGuard);
                        return _this;
                    }
                    _createClass(Embed, [{
                            key: 'index',
                            value: function index(node, offset) {
                                if (node === this.leftGuard)
                                    return 0;
                                if (node === this.rightGuard)
                                    return 1;
                                return _get(Embed.prototype.__proto__ || Object.getPrototypeOf(Embed.prototype), 'index', this).call(this, node, offset);
                            }
                        }, {
                            key: 'restore',
                            value: function restore(node) {
                                var range = void 0, textNode = void 0;
                                var text = node.data.split(GUARD_TEXT).join('');
                                if (node === this.leftGuard) {
                                    if (this.prev instanceof _text2.default) {
                                        var prevLength = this.prev.length();
                                        this.prev.insertAt(prevLength, text);
                                        range = {
                                            startNode: this.prev.domNode,
                                            startOffset: prevLength + text.length
                                        };
                                    }
                                    else {
                                        textNode = document.createTextNode(text);
                                        this.parent.insertBefore(_parchment2.default.create(textNode), this);
                                        range = {
                                            startNode: textNode,
                                            startOffset: text.length
                                        };
                                    }
                                }
                                else if (node === this.rightGuard) {
                                    if (this.next instanceof _text2.default) {
                                        this.next.insertAt(0, text);
                                        range = {
                                            startNode: this.next.domNode,
                                            startOffset: text.length
                                        };
                                    }
                                    else {
                                        textNode = document.createTextNode(text);
                                        this.parent.insertBefore(_parchment2.default.create(textNode), this.next);
                                        range = {
                                            startNode: textNode,
                                            startOffset: text.length
                                        };
                                    }
                                }
                                node.data = GUARD_TEXT;
                                return range;
                            }
                        }, {
                            key: 'update',
                            value: function update(mutations, context) {
                                var _this2 = this;
                                mutations.forEach(function (mutation) {
                                    if (mutation.type === 'characterData' && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {
                                        var range = _this2.restore(mutation.target);
                                        if (range)
                                            context.range = range;
                                    }
                                });
                            }
                        }]);
                    return Embed;
                }(_parchment2.default.Embed);
                exports.default = Embed;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.AlignStyle = exports.AlignClass = exports.AlignAttribute = undefined;
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                var config = {
                    scope: _parchment2.default.Scope.BLOCK,
                    whitelist: ['right', 'center', 'justify']
                };
                var AlignAttribute = new _parchment2.default.Attributor.Attribute('align', 'align', config);
                var AlignClass = new _parchment2.default.Attributor.Class('align', 'ql-align', config);
                var AlignStyle = new _parchment2.default.Attributor.Style('align', 'text-align', config);
                exports.AlignAttribute = AlignAttribute;
                exports.AlignClass = AlignClass;
                exports.AlignStyle = AlignStyle;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.BackgroundStyle = exports.BackgroundClass = undefined;
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _color = __webpack_require__(26);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                var BackgroundClass = new _parchment2.default.Attributor.Class('background', 'ql-bg', {
                    scope: _parchment2.default.Scope.INLINE
                });
                var BackgroundStyle = new _color.ColorAttributor('background', 'background-color', {
                    scope: _parchment2.default.Scope.INLINE
                });
                exports.BackgroundClass = BackgroundClass;
                exports.BackgroundStyle = BackgroundStyle;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.DirectionStyle = exports.DirectionClass = exports.DirectionAttribute = undefined;
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                var config = {
                    scope: _parchment2.default.Scope.BLOCK,
                    whitelist: ['rtl']
                };
                var DirectionAttribute = new _parchment2.default.Attributor.Attribute('direction', 'dir', config);
                var DirectionClass = new _parchment2.default.Attributor.Class('direction', 'ql-direction', config);
                var DirectionStyle = new _parchment2.default.Attributor.Style('direction', 'direction', config);
                exports.DirectionAttribute = DirectionAttribute;
                exports.DirectionClass = DirectionClass;
                exports.DirectionStyle = DirectionStyle;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.FontClass = exports.FontStyle = undefined;
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var config = {
                    scope: _parchment2.default.Scope.INLINE,
                    whitelist: ['serif', 'monospace']
                };
                var FontClass = new _parchment2.default.Attributor.Class('font', 'ql-font', config);
                var FontStyleAttributor = function (_Parchment$Attributor) {
                    _inherits(FontStyleAttributor, _Parchment$Attributor);
                    function FontStyleAttributor() {
                        _classCallCheck(this, FontStyleAttributor);
                        return _possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));
                    }
                    _createClass(FontStyleAttributor, [{
                            key: 'value',
                            value: function value(node) {
                                return _get(FontStyleAttributor.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor.prototype), 'value', this).call(this, node).replace(/["']/g, '');
                            }
                        }]);
                    return FontStyleAttributor;
                }(_parchment2.default.Attributor.Style);
                var FontStyle = new FontStyleAttributor('font', 'font-family', config);
                exports.FontStyle = FontStyle;
                exports.FontClass = FontClass;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.SizeStyle = exports.SizeClass = undefined;
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                var SizeClass = new _parchment2.default.Attributor.Class('size', 'ql-size', {
                    scope: _parchment2.default.Scope.INLINE,
                    whitelist: ['small', 'large', 'huge']
                });
                var SizeStyle = new _parchment2.default.Attributor.Style('size', 'font-size', {
                    scope: _parchment2.default.Scope.INLINE,
                    whitelist: ['10px', '18px', '32px']
                });
                exports.SizeClass = SizeClass;
                exports.SizeStyle = SizeStyle;
            }),
            (function (module, exports, __webpack_require__) {
                module.exports = {
                    'align': {
                        '': __webpack_require__(76),
                        'center': __webpack_require__(77),
                        'right': __webpack_require__(78),
                        'justify': __webpack_require__(79)
                    },
                    'background': __webpack_require__(80),
                    'blockquote': __webpack_require__(81),
                    'bold': __webpack_require__(82),
                    'clean': __webpack_require__(83),
                    'code': __webpack_require__(58),
                    'code-block': __webpack_require__(58),
                    'color': __webpack_require__(84),
                    'direction': {
                        '': __webpack_require__(85),
                        'rtl': __webpack_require__(86)
                    },
                    'float': {
                        'center': __webpack_require__(87),
                        'full': __webpack_require__(88),
                        'left': __webpack_require__(89),
                        'right': __webpack_require__(90)
                    },
                    'formula': __webpack_require__(91),
                    'header': {
                        '1': __webpack_require__(92),
                        '2': __webpack_require__(93)
                    },
                    'italic': __webpack_require__(94),
                    'image': __webpack_require__(95),
                    'indent': {
                        '+1': __webpack_require__(96),
                        '-1': __webpack_require__(97)
                    },
                    'link': __webpack_require__(98),
                    'list': {
                        'ordered': __webpack_require__(99),
                        'bullet': __webpack_require__(100),
                        'check': __webpack_require__(101)
                    },
                    'script': {
                        'sub': __webpack_require__(102),
                        'super': __webpack_require__(103)
                    },
                    'strike': __webpack_require__(104),
                    'underline': __webpack_require__(105),
                    'video': __webpack_require__(106)
                };
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.getLastChangeIndex = exports.default = undefined;
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var History = function (_Module) {
                    _inherits(History, _Module);
                    function History(quill, options) {
                        _classCallCheck(this, History);
                        var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, quill, options));
                        _this.lastRecorded = 0;
                        _this.ignoreChange = false;
                        _this.clear();
                        _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (eventName, delta, oldDelta, source) {
                            if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange)
                                return;
                            if (!_this.options.userOnly || source === _quill2.default.sources.USER) {
                                _this.record(delta, oldDelta);
                            }
                            else {
                                _this.transform(delta);
                            }
                        });
                        _this.quill.keyboard.addBinding({ key: 'Z', shortKey: true }, _this.undo.bind(_this));
                        _this.quill.keyboard.addBinding({ key: 'Z', shortKey: true, shiftKey: true }, _this.redo.bind(_this));
                        if (/Win/i.test(navigator.platform)) {
                            _this.quill.keyboard.addBinding({ key: 'Y', shortKey: true }, _this.redo.bind(_this));
                        }
                        return _this;
                    }
                    _createClass(History, [{
                            key: 'change',
                            value: function change(source, dest) {
                                if (this.stack[source].length === 0)
                                    return;
                                var delta = this.stack[source].pop();
                                this.stack[dest].push(delta);
                                this.lastRecorded = 0;
                                this.ignoreChange = true;
                                this.quill.updateContents(delta[source], _quill2.default.sources.USER);
                                this.ignoreChange = false;
                                var index = getLastChangeIndex(delta[source]);
                                this.quill.setSelection(index);
                            }
                        }, {
                            key: 'clear',
                            value: function clear() {
                                this.stack = { undo: [], redo: [] };
                            }
                        }, {
                            key: 'cutoff',
                            value: function cutoff() {
                                this.lastRecorded = 0;
                            }
                        }, {
                            key: 'record',
                            value: function record(changeDelta, oldDelta) {
                                if (changeDelta.ops.length === 0)
                                    return;
                                this.stack.redo = [];
                                var undoDelta = this.quill.getContents().diff(oldDelta);
                                var timestamp = Date.now();
                                if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
                                    var delta = this.stack.undo.pop();
                                    undoDelta = undoDelta.compose(delta.undo);
                                    changeDelta = delta.redo.compose(changeDelta);
                                }
                                else {
                                    this.lastRecorded = timestamp;
                                }
                                this.stack.undo.push({
                                    redo: changeDelta,
                                    undo: undoDelta
                                });
                                if (this.stack.undo.length > this.options.maxStack) {
                                    this.stack.undo.shift();
                                }
                            }
                        }, {
                            key: 'redo',
                            value: function redo() {
                                this.change('redo', 'undo');
                            }
                        }, {
                            key: 'transform',
                            value: function transform(delta) {
                                this.stack.undo.forEach(function (change) {
                                    change.undo = delta.transform(change.undo, true);
                                    change.redo = delta.transform(change.redo, true);
                                });
                                this.stack.redo.forEach(function (change) {
                                    change.undo = delta.transform(change.undo, true);
                                    change.redo = delta.transform(change.redo, true);
                                });
                            }
                        }, {
                            key: 'undo',
                            value: function undo() {
                                this.change('undo', 'redo');
                            }
                        }]);
                    return History;
                }(_module2.default);
                History.DEFAULTS = {
                    delay: 1000,
                    maxStack: 100,
                    userOnly: false
                };
                function endsWithNewlineChange(delta) {
                    var lastOp = delta.ops[delta.ops.length - 1];
                    if (lastOp == null)
                        return false;
                    if (lastOp.insert != null) {
                        return typeof lastOp.insert === 'string' && lastOp.insert.endsWith('\n');
                    }
                    if (lastOp.attributes != null) {
                        return Object.keys(lastOp.attributes).some(function (attr) {
                            return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;
                        });
                    }
                    return false;
                }
                function getLastChangeIndex(delta) {
                    var deleteLength = delta.reduce(function (length, op) {
                        length += op.delete || 0;
                        return length;
                    }, 0);
                    var changeIndex = delta.length() - deleteLength;
                    if (endsWithNewlineChange(delta)) {
                        changeIndex -= 1;
                    }
                    return changeIndex;
                }
                exports.default = History;
                exports.getLastChangeIndex = getLastChangeIndex;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = exports.BaseTooltip = undefined;
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _emitter = __webpack_require__(8);
                var _emitter2 = _interopRequireDefault(_emitter);
                var _keyboard = __webpack_require__(23);
                var _keyboard2 = _interopRequireDefault(_keyboard);
                var _theme = __webpack_require__(34);
                var _theme2 = _interopRequireDefault(_theme);
                var _colorPicker = __webpack_require__(59);
                var _colorPicker2 = _interopRequireDefault(_colorPicker);
                var _iconPicker = __webpack_require__(60);
                var _iconPicker2 = _interopRequireDefault(_iconPicker);
                var _picker = __webpack_require__(28);
                var _picker2 = _interopRequireDefault(_picker);
                var _tooltip = __webpack_require__(61);
                var _tooltip2 = _interopRequireDefault(_tooltip);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var ALIGNS = [false, 'center', 'right', 'justify'];
                var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
                var FONTS = [false, 'serif', 'monospace'];
                var HEADERS = ['1', '2', '3', false];
                var SIZES = ['small', false, 'large', 'huge'];
                var BaseTheme = function (_Theme) {
                    _inherits(BaseTheme, _Theme);
                    function BaseTheme(quill, options) {
                        _classCallCheck(this, BaseTheme);
                        var _this = _possibleConstructorReturn(this, (BaseTheme.__proto__ || Object.getPrototypeOf(BaseTheme)).call(this, quill, options));
                        var listener = function listener(e) {
                            if (!document.body.contains(quill.root)) {
                                return document.body.removeEventListener('click', listener);
                            }
                            if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {
                                _this.tooltip.hide();
                            }
                            if (_this.pickers != null) {
                                _this.pickers.forEach(function (picker) {
                                    if (!picker.container.contains(e.target)) {
                                        picker.close();
                                    }
                                });
                            }
                        };
                        quill.emitter.listenDOM('click', document.body, listener);
                        return _this;
                    }
                    _createClass(BaseTheme, [{
                            key: 'addModule',
                            value: function addModule(name) {
                                var module = _get(BaseTheme.prototype.__proto__ || Object.getPrototypeOf(BaseTheme.prototype), 'addModule', this).call(this, name);
                                if (name === 'toolbar') {
                                    this.extendToolbar(module);
                                }
                                return module;
                            }
                        }, {
                            key: 'buildButtons',
                            value: function buildButtons(buttons, icons) {
                                buttons.forEach(function (button) {
                                    var className = button.getAttribute('class') || '';
                                    className.split(/\s+/).forEach(function (name) {
                                        if (!name.startsWith('ql-'))
                                            return;
                                        name = name.slice('ql-'.length);
                                        if (icons[name] == null)
                                            return;
                                        if (name === 'direction') {
                                            button.innerHTML = icons[name][''] + icons[name]['rtl'];
                                        }
                                        else if (typeof icons[name] === 'string') {
                                            button.innerHTML = icons[name];
                                        }
                                        else {
                                            var value = button.value || '';
                                            if (value != null && icons[name][value]) {
                                                button.innerHTML = icons[name][value];
                                            }
                                        }
                                    });
                                });
                            }
                        }, {
                            key: 'buildPickers',
                            value: function buildPickers(selects, icons) {
                                var _this2 = this;
                                this.pickers = selects.map(function (select) {
                                    if (select.classList.contains('ql-align')) {
                                        if (select.querySelector('option') == null) {
                                            fillSelect(select, ALIGNS);
                                        }
                                        return new _iconPicker2.default(select, icons.align);
                                    }
                                    else if (select.classList.contains('ql-background') || select.classList.contains('ql-color')) {
                                        var format = select.classList.contains('ql-background') ? 'background' : 'color';
                                        if (select.querySelector('option') == null) {
                                            fillSelect(select, COLORS, format === 'background' ? '#ffffff' : '#000000');
                                        }
                                        return new _colorPicker2.default(select, icons[format]);
                                    }
                                    else {
                                        if (select.querySelector('option') == null) {
                                            if (select.classList.contains('ql-font')) {
                                                fillSelect(select, FONTS);
                                            }
                                            else if (select.classList.contains('ql-header')) {
                                                fillSelect(select, HEADERS);
                                            }
                                            else if (select.classList.contains('ql-size')) {
                                                fillSelect(select, SIZES);
                                            }
                                        }
                                        return new _picker2.default(select);
                                    }
                                });
                                var update = function update() {
                                    _this2.pickers.forEach(function (picker) {
                                        picker.update();
                                    });
                                };
                                this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);
                            }
                        }]);
                    return BaseTheme;
                }(_theme2.default);
                BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {
                    modules: {
                        toolbar: {
                            handlers: {
                                formula: function formula() {
                                    this.quill.theme.tooltip.edit('formula');
                                },
                                image: function image() {
                                    var _this3 = this;
                                    var fileInput = this.container.querySelector('input.ql-image[type=file]');
                                    if (fileInput == null) {
                                        fileInput = document.createElement('input');
                                        fileInput.setAttribute('type', 'file');
                                        fileInput.setAttribute('accept', 'image/png, image/gif, image/jpeg, image/bmp, image/x-icon');
                                        fileInput.classList.add('ql-image');
                                        fileInput.addEventListener('change', function () {
                                            if (fileInput.files != null && fileInput.files[0] != null) {
                                                var reader = new FileReader();
                                                reader.onload = function (e) {
                                                    var range = _this3.quill.getSelection(true);
                                                    _this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({ image: e.target.result }), _emitter2.default.sources.USER);
                                                    _this3.quill.setSelection(range.index + 1, _emitter2.default.sources.SILENT);
                                                    fileInput.value = "";
                                                };
                                                reader.readAsDataURL(fileInput.files[0]);
                                            }
                                        });
                                        this.container.appendChild(fileInput);
                                    }
                                    fileInput.click();
                                },
                                video: function video() {
                                    this.quill.theme.tooltip.edit('video');
                                }
                            }
                        }
                    }
                });
                var BaseTooltip = function (_Tooltip) {
                    _inherits(BaseTooltip, _Tooltip);
                    function BaseTooltip(quill, boundsContainer) {
                        _classCallCheck(this, BaseTooltip);
                        var _this4 = _possibleConstructorReturn(this, (BaseTooltip.__proto__ || Object.getPrototypeOf(BaseTooltip)).call(this, quill, boundsContainer));
                        _this4.textbox = _this4.root.querySelector('input[type="text"]');
                        _this4.listen();
                        return _this4;
                    }
                    _createClass(BaseTooltip, [{
                            key: 'listen',
                            value: function listen() {
                                var _this5 = this;
                                this.textbox.addEventListener('keydown', function (event) {
                                    if (_keyboard2.default.match(event, 'enter')) {
                                        _this5.save();
                                        event.preventDefault();
                                    }
                                    else if (_keyboard2.default.match(event, 'escape')) {
                                        _this5.cancel();
                                        event.preventDefault();
                                    }
                                });
                            }
                        }, {
                            key: 'cancel',
                            value: function cancel() {
                                this.hide();
                            }
                        }, {
                            key: 'edit',
                            value: function edit() {
                                var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'link';
                                var preview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                                this.root.classList.remove('ql-hidden');
                                this.root.classList.add('ql-editing');
                                if (preview != null) {
                                    this.textbox.value = preview;
                                }
                                else if (mode !== this.root.getAttribute('data-mode')) {
                                    this.textbox.value = '';
                                }
                                this.position(this.quill.getBounds(this.quill.selection.savedRange));
                                this.textbox.select();
                                this.textbox.setAttribute('placeholder', this.textbox.getAttribute('data-' + mode) || '');
                                this.root.setAttribute('data-mode', mode);
                            }
                        }, {
                            key: 'restoreFocus',
                            value: function restoreFocus() {
                                var scrollTop = this.quill.scrollingContainer.scrollTop;
                                this.quill.focus();
                                this.quill.scrollingContainer.scrollTop = scrollTop;
                            }
                        }, {
                            key: 'save',
                            value: function save() {
                                var value = this.textbox.value;
                                switch (this.root.getAttribute('data-mode')) {
                                    case 'link':
                                        {
                                            var scrollTop = this.quill.root.scrollTop;
                                            if (this.linkRange) {
                                                this.quill.formatText(this.linkRange, 'link', value, _emitter2.default.sources.USER);
                                                delete this.linkRange;
                                            }
                                            else {
                                                this.restoreFocus();
                                                this.quill.format('link', value, _emitter2.default.sources.USER);
                                            }
                                            this.quill.root.scrollTop = scrollTop;
                                            break;
                                        }
                                    case 'video':
                                        {
                                            value = extractVideoUrl(value);
                                        }
                                    case 'formula':
                                        {
                                            if (!value)
                                                break;
                                            var range = this.quill.getSelection(true);
                                            if (range != null) {
                                                var index = range.index + range.length;
                                                this.quill.insertEmbed(index, this.root.getAttribute('data-mode'), value, _emitter2.default.sources.USER);
                                                if (this.root.getAttribute('data-mode') === 'formula') {
                                                    this.quill.insertText(index + 1, ' ', _emitter2.default.sources.USER);
                                                }
                                                this.quill.setSelection(index + 2, _emitter2.default.sources.USER);
                                            }
                                            break;
                                        }
                                }
                                this.textbox.value = '';
                                this.hide();
                            }
                        }]);
                    return BaseTooltip;
                }(_tooltip2.default);
                function extractVideoUrl(url) {
                    var match = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
                    if (match) {
                        return (match[1] || 'https') + '://www.youtube.com/embed/' + match[2] + '?showinfo=0';
                    }
                    if (match = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
                        return (match[1] || 'https') + '://player.vimeo.com/video/' + match[2] + '/';
                    }
                    return url;
                }
                function fillSelect(select, values) {
                    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                    values.forEach(function (value) {
                        var option = document.createElement('option');
                        if (value === defaultValue) {
                            option.setAttribute('selected', 'selected');
                        }
                        else {
                            option.setAttribute('value', value);
                        }
                        select.appendChild(option);
                    });
                }
                exports.BaseTooltip = BaseTooltip;
                exports.default = BaseTheme;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", { value: true });
                var LinkedList = (function () {
                    function LinkedList() {
                        this.head = this.tail = null;
                        this.length = 0;
                    }
                    LinkedList.prototype.append = function () {
                        var nodes = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            nodes[_i] = arguments[_i];
                        }
                        this.insertBefore(nodes[0], null);
                        if (nodes.length > 1) {
                            this.append.apply(this, nodes.slice(1));
                        }
                    };
                    LinkedList.prototype.contains = function (node) {
                        var cur, next = this.iterator();
                        while ((cur = next())) {
                            if (cur === node)
                                return true;
                        }
                        return false;
                    };
                    LinkedList.prototype.insertBefore = function (node, refNode) {
                        if (!node)
                            return;
                        node.next = refNode;
                        if (refNode != null) {
                            node.prev = refNode.prev;
                            if (refNode.prev != null) {
                                refNode.prev.next = node;
                            }
                            refNode.prev = node;
                            if (refNode === this.head) {
                                this.head = node;
                            }
                        }
                        else if (this.tail != null) {
                            this.tail.next = node;
                            node.prev = this.tail;
                            this.tail = node;
                        }
                        else {
                            node.prev = null;
                            this.head = this.tail = node;
                        }
                        this.length += 1;
                    };
                    LinkedList.prototype.offset = function (target) {
                        var index = 0, cur = this.head;
                        while (cur != null) {
                            if (cur === target)
                                return index;
                            index += cur.length();
                            cur = cur.next;
                        }
                        return -1;
                    };
                    LinkedList.prototype.remove = function (node) {
                        if (!this.contains(node))
                            return;
                        if (node.prev != null)
                            node.prev.next = node.next;
                        if (node.next != null)
                            node.next.prev = node.prev;
                        if (node === this.head)
                            this.head = node.next;
                        if (node === this.tail)
                            this.tail = node.prev;
                        this.length -= 1;
                    };
                    LinkedList.prototype.iterator = function (curNode) {
                        if (curNode === void 0) {
                            curNode = this.head;
                        }
                        return function () {
                            var ret = curNode;
                            if (curNode != null)
                                curNode = curNode.next;
                            return ret;
                        };
                    };
                    LinkedList.prototype.find = function (index, inclusive) {
                        if (inclusive === void 0) {
                            inclusive = false;
                        }
                        var cur, next = this.iterator();
                        while ((cur = next())) {
                            var length = cur.length();
                            if (index < length ||
                                (inclusive && index === length && (cur.next == null || cur.next.length() !== 0))) {
                                return [cur, index];
                            }
                            index -= length;
                        }
                        return [null, 0];
                    };
                    LinkedList.prototype.forEach = function (callback) {
                        var cur, next = this.iterator();
                        while ((cur = next())) {
                            callback(cur);
                        }
                    };
                    LinkedList.prototype.forEachAt = function (index, length, callback) {
                        if (length <= 0)
                            return;
                        var _a = this.find(index), startNode = _a[0], offset = _a[1];
                        var cur, curIndex = index - offset, next = this.iterator(startNode);
                        while ((cur = next()) && curIndex < index + length) {
                            var curLength = cur.length();
                            if (index > curIndex) {
                                callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));
                            }
                            else {
                                callback(cur, 0, Math.min(curLength, index + length - curIndex));
                            }
                            curIndex += curLength;
                        }
                    };
                    LinkedList.prototype.map = function (callback) {
                        return this.reduce(function (memo, cur) {
                            memo.push(callback(cur));
                            return memo;
                        }, []);
                    };
                    LinkedList.prototype.reduce = function (callback, memo) {
                        var cur, next = this.iterator();
                        while ((cur = next())) {
                            memo = callback(memo, cur);
                        }
                        return memo;
                    };
                    return LinkedList;
                }());
                exports.default = LinkedList;
            }),
            (function (module, exports, __webpack_require__) {
                var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b)
                            if (b.hasOwnProperty(p))
                                d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                Object.defineProperty(exports, "__esModule", { value: true });
                var container_1 = __webpack_require__(17);
                var Registry = __webpack_require__(1);
                var OBSERVER_CONFIG = {
                    attributes: true,
                    characterData: true,
                    characterDataOldValue: true,
                    childList: true,
                    subtree: true,
                };
                var MAX_OPTIMIZE_ITERATIONS = 100;
                var ScrollBlot = (function (_super) {
                    __extends(ScrollBlot, _super);
                    function ScrollBlot(node) {
                        var _this = _super.call(this, node) || this;
                        _this.scroll = _this;
                        _this.observer = new MutationObserver(function (mutations) {
                            _this.update(mutations);
                        });
                        _this.observer.observe(_this.domNode, OBSERVER_CONFIG);
                        _this.attach();
                        return _this;
                    }
                    ScrollBlot.prototype.detach = function () {
                        _super.prototype.detach.call(this);
                        this.observer.disconnect();
                    };
                    ScrollBlot.prototype.deleteAt = function (index, length) {
                        this.update();
                        if (index === 0 && length === this.length()) {
                            this.children.forEach(function (child) {
                                child.remove();
                            });
                        }
                        else {
                            _super.prototype.deleteAt.call(this, index, length);
                        }
                    };
                    ScrollBlot.prototype.formatAt = function (index, length, name, value) {
                        this.update();
                        _super.prototype.formatAt.call(this, index, length, name, value);
                    };
                    ScrollBlot.prototype.insertAt = function (index, value, def) {
                        this.update();
                        _super.prototype.insertAt.call(this, index, value, def);
                    };
                    ScrollBlot.prototype.optimize = function (mutations, context) {
                        var _this = this;
                        if (mutations === void 0) {
                            mutations = [];
                        }
                        if (context === void 0) {
                            context = {};
                        }
                        _super.prototype.optimize.call(this, context);
                        var records = [].slice.call(this.observer.takeRecords());
                        while (records.length > 0)
                            mutations.push(records.pop());
                        var mark = function (blot, markParent) {
                            if (markParent === void 0) {
                                markParent = true;
                            }
                            if (blot == null || blot === _this)
                                return;
                            if (blot.domNode.parentNode == null)
                                return;
                            if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                                blot.domNode[Registry.DATA_KEY].mutations = [];
                            }
                            if (markParent)
                                mark(blot.parent);
                        };
                        var optimize = function (blot) {
                            if (blot.domNode[Registry.DATA_KEY] == null ||
                                blot.domNode[Registry.DATA_KEY].mutations == null) {
                                return;
                            }
                            if (blot instanceof container_1.default) {
                                blot.children.forEach(optimize);
                            }
                            blot.optimize(context);
                        };
                        var remaining = mutations;
                        for (var i = 0; remaining.length > 0; i += 1) {
                            if (i >= MAX_OPTIMIZE_ITERATIONS) {
                                throw new Error('[Parchment] Maximum optimize iterations reached');
                            }
                            remaining.forEach(function (mutation) {
                                var blot = Registry.find(mutation.target, true);
                                if (blot == null)
                                    return;
                                if (blot.domNode === mutation.target) {
                                    if (mutation.type === 'childList') {
                                        mark(Registry.find(mutation.previousSibling, false));
                                        [].forEach.call(mutation.addedNodes, function (node) {
                                            var child = Registry.find(node, false);
                                            mark(child, false);
                                            if (child instanceof container_1.default) {
                                                child.children.forEach(function (grandChild) {
                                                    mark(grandChild, false);
                                                });
                                            }
                                        });
                                    }
                                    else if (mutation.type === 'attributes') {
                                        mark(blot.prev);
                                    }
                                }
                                mark(blot);
                            });
                            this.children.forEach(optimize);
                            remaining = [].slice.call(this.observer.takeRecords());
                            records = remaining.slice();
                            while (records.length > 0)
                                mutations.push(records.pop());
                        }
                    };
                    ScrollBlot.prototype.update = function (mutations, context) {
                        var _this = this;
                        if (context === void 0) {
                            context = {};
                        }
                        mutations = mutations || this.observer.takeRecords();
                        mutations
                            .map(function (mutation) {
                            var blot = Registry.find(mutation.target, true);
                            if (blot == null)
                                return null;
                            if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                                blot.domNode[Registry.DATA_KEY].mutations = [mutation];
                                return blot;
                            }
                            else {
                                blot.domNode[Registry.DATA_KEY].mutations.push(mutation);
                                return null;
                            }
                        })
                            .forEach(function (blot) {
                            if (blot == null ||
                                blot === _this ||
                                blot.domNode[Registry.DATA_KEY] == null)
                                return;
                            blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);
                        });
                        if (this.domNode[Registry.DATA_KEY].mutations != null) {
                            _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);
                        }
                        this.optimize(mutations, context);
                    };
                    ScrollBlot.blotName = 'scroll';
                    ScrollBlot.defaultChild = 'block';
                    ScrollBlot.scope = Registry.Scope.BLOCK_BLOT;
                    ScrollBlot.tagName = 'DIV';
                    return ScrollBlot;
                }(container_1.default));
                exports.default = ScrollBlot;
            }),
            (function (module, exports, __webpack_require__) {
                var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b)
                            if (b.hasOwnProperty(p))
                                d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                Object.defineProperty(exports, "__esModule", { value: true });
                var format_1 = __webpack_require__(18);
                var Registry = __webpack_require__(1);
                function isEqual(obj1, obj2) {
                    if (Object.keys(obj1).length !== Object.keys(obj2).length)
                        return false;
                    for (var prop in obj1) {
                        if (obj1[prop] !== obj2[prop])
                            return false;
                    }
                    return true;
                }
                var InlineBlot = (function (_super) {
                    __extends(InlineBlot, _super);
                    function InlineBlot() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    InlineBlot.formats = function (domNode) {
                        if (domNode.tagName === InlineBlot.tagName)
                            return undefined;
                        return _super.formats.call(this, domNode);
                    };
                    InlineBlot.prototype.format = function (name, value) {
                        var _this = this;
                        if (name === this.statics.blotName && !value) {
                            this.children.forEach(function (child) {
                                if (!(child instanceof format_1.default)) {
                                    child = child.wrap(InlineBlot.blotName, true);
                                }
                                _this.attributes.copy(child);
                            });
                            this.unwrap();
                        }
                        else {
                            _super.prototype.format.call(this, name, value);
                        }
                    };
                    InlineBlot.prototype.formatAt = function (index, length, name, value) {
                        if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {
                            var blot = this.isolate(index, length);
                            blot.format(name, value);
                        }
                        else {
                            _super.prototype.formatAt.call(this, index, length, name, value);
                        }
                    };
                    InlineBlot.prototype.optimize = function (context) {
                        _super.prototype.optimize.call(this, context);
                        var formats = this.formats();
                        if (Object.keys(formats).length === 0) {
                            return this.unwrap();
                        }
                        var next = this.next;
                        if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {
                            next.moveChildren(this);
                            next.remove();
                        }
                    };
                    InlineBlot.blotName = 'inline';
                    InlineBlot.scope = Registry.Scope.INLINE_BLOT;
                    InlineBlot.tagName = 'SPAN';
                    return InlineBlot;
                }(format_1.default));
                exports.default = InlineBlot;
            }),
            (function (module, exports, __webpack_require__) {
                var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b)
                            if (b.hasOwnProperty(p))
                                d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                Object.defineProperty(exports, "__esModule", { value: true });
                var format_1 = __webpack_require__(18);
                var Registry = __webpack_require__(1);
                var BlockBlot = (function (_super) {
                    __extends(BlockBlot, _super);
                    function BlockBlot() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    BlockBlot.formats = function (domNode) {
                        var tagName = Registry.query(BlockBlot.blotName).tagName;
                        if (domNode.tagName === tagName)
                            return undefined;
                        return _super.formats.call(this, domNode);
                    };
                    BlockBlot.prototype.format = function (name, value) {
                        if (Registry.query(name, Registry.Scope.BLOCK) == null) {
                            return;
                        }
                        else if (name === this.statics.blotName && !value) {
                            this.replaceWith(BlockBlot.blotName);
                        }
                        else {
                            _super.prototype.format.call(this, name, value);
                        }
                    };
                    BlockBlot.prototype.formatAt = function (index, length, name, value) {
                        if (Registry.query(name, Registry.Scope.BLOCK) != null) {
                            this.format(name, value);
                        }
                        else {
                            _super.prototype.formatAt.call(this, index, length, name, value);
                        }
                    };
                    BlockBlot.prototype.insertAt = function (index, value, def) {
                        if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {
                            _super.prototype.insertAt.call(this, index, value, def);
                        }
                        else {
                            var after = this.split(index);
                            var blot = Registry.create(value, def);
                            after.parent.insertBefore(blot, after);
                        }
                    };
                    BlockBlot.prototype.update = function (mutations, context) {
                        if (navigator.userAgent.match(/Trident/)) {
                            this.build();
                        }
                        else {
                            _super.prototype.update.call(this, mutations, context);
                        }
                    };
                    BlockBlot.blotName = 'block';
                    BlockBlot.scope = Registry.Scope.BLOCK_BLOT;
                    BlockBlot.tagName = 'P';
                    return BlockBlot;
                }(format_1.default));
                exports.default = BlockBlot;
            }),
            (function (module, exports, __webpack_require__) {
                var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b)
                            if (b.hasOwnProperty(p))
                                d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                Object.defineProperty(exports, "__esModule", { value: true });
                var leaf_1 = __webpack_require__(19);
                var EmbedBlot = (function (_super) {
                    __extends(EmbedBlot, _super);
                    function EmbedBlot() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    EmbedBlot.formats = function (domNode) {
                        return undefined;
                    };
                    EmbedBlot.prototype.format = function (name, value) {
                        _super.prototype.formatAt.call(this, 0, this.length(), name, value);
                    };
                    EmbedBlot.prototype.formatAt = function (index, length, name, value) {
                        if (index === 0 && length === this.length()) {
                            this.format(name, value);
                        }
                        else {
                            _super.prototype.formatAt.call(this, index, length, name, value);
                        }
                    };
                    EmbedBlot.prototype.formats = function () {
                        return this.statics.formats(this.domNode);
                    };
                    return EmbedBlot;
                }(leaf_1.default));
                exports.default = EmbedBlot;
            }),
            (function (module, exports, __webpack_require__) {
                var __extends = (this && this.__extends) || (function () {
                    var extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b)
                            if (b.hasOwnProperty(p))
                                d[p] = b[p]; };
                    return function (d, b) {
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                Object.defineProperty(exports, "__esModule", { value: true });
                var leaf_1 = __webpack_require__(19);
                var Registry = __webpack_require__(1);
                var TextBlot = (function (_super) {
                    __extends(TextBlot, _super);
                    function TextBlot(node) {
                        var _this = _super.call(this, node) || this;
                        _this.text = _this.statics.value(_this.domNode);
                        return _this;
                    }
                    TextBlot.create = function (value) {
                        return document.createTextNode(value);
                    };
                    TextBlot.value = function (domNode) {
                        var text = domNode.data;
                        if (text['normalize'])
                            text = text['normalize']();
                        return text;
                    };
                    TextBlot.prototype.deleteAt = function (index, length) {
                        this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);
                    };
                    TextBlot.prototype.index = function (node, offset) {
                        if (this.domNode === node) {
                            return offset;
                        }
                        return -1;
                    };
                    TextBlot.prototype.insertAt = function (index, value, def) {
                        if (def == null) {
                            this.text = this.text.slice(0, index) + value + this.text.slice(index);
                            this.domNode.data = this.text;
                        }
                        else {
                            _super.prototype.insertAt.call(this, index, value, def);
                        }
                    };
                    TextBlot.prototype.length = function () {
                        return this.text.length;
                    };
                    TextBlot.prototype.optimize = function (context) {
                        _super.prototype.optimize.call(this, context);
                        this.text = this.statics.value(this.domNode);
                        if (this.text.length === 0) {
                            this.remove();
                        }
                        else if (this.next instanceof TextBlot && this.next.prev === this) {
                            this.insertAt(this.length(), this.next.value());
                            this.next.remove();
                        }
                    };
                    TextBlot.prototype.position = function (index, inclusive) {
                        return [this.domNode, index];
                    };
                    TextBlot.prototype.split = function (index, force) {
                        if (force === void 0) {
                            force = false;
                        }
                        if (!force) {
                            if (index === 0)
                                return this;
                            if (index === this.length())
                                return this.next;
                        }
                        var after = Registry.create(this.domNode.splitText(index));
                        this.parent.insertBefore(after, this.next);
                        this.text = this.statics.value(this.domNode);
                        return after;
                    };
                    TextBlot.prototype.update = function (mutations, context) {
                        var _this = this;
                        if (mutations.some(function (mutation) {
                            return mutation.type === 'characterData' && mutation.target === _this.domNode;
                        })) {
                            this.text = this.statics.value(this.domNode);
                        }
                    };
                    TextBlot.prototype.value = function () {
                        return this.text;
                    };
                    TextBlot.blotName = 'text';
                    TextBlot.scope = Registry.Scope.INLINE_BLOT;
                    return TextBlot;
                }(leaf_1.default));
                exports.default = TextBlot;
            }),
            (function (module, exports, __webpack_require__) {
                var elem = document.createElement('div');
                elem.classList.toggle('test-class', false);
                if (elem.classList.contains('test-class')) {
                    var _toggle = DOMTokenList.prototype.toggle;
                    DOMTokenList.prototype.toggle = function (token, force) {
                        if (arguments.length > 1 && !this.contains(token) === !force) {
                            return force;
                        }
                        else {
                            return _toggle.call(this, token);
                        }
                    };
                }
                if (!String.prototype.startsWith) {
                    String.prototype.startsWith = function (searchString, position) {
                        position = position || 0;
                        return this.substr(position, searchString.length) === searchString;
                    };
                }
                if (!String.prototype.endsWith) {
                    String.prototype.endsWith = function (searchString, position) {
                        var subjectString = this.toString();
                        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
                            position = subjectString.length;
                        }
                        position -= searchString.length;
                        var lastIndex = subjectString.indexOf(searchString, position);
                        return lastIndex !== -1 && lastIndex === position;
                    };
                }
                if (!Array.prototype.find) {
                    Object.defineProperty(Array.prototype, "find", {
                        value: function value(predicate) {
                            if (this === null) {
                                throw new TypeError('Array.prototype.find called on null or undefined');
                            }
                            if (typeof predicate !== 'function') {
                                throw new TypeError('predicate must be a function');
                            }
                            var list = Object(this);
                            var length = list.length >>> 0;
                            var thisArg = arguments[1];
                            var value;
                            for (var i = 0; i < length; i++) {
                                value = list[i];
                                if (predicate.call(thisArg, value, i, list)) {
                                    return value;
                                }
                            }
                            return undefined;
                        }
                    });
                }
                document.addEventListener("DOMContentLoaded", function () {
                    document.execCommand("enableObjectResizing", false, false);
                    document.execCommand("autoUrlDetect", false, false);
                });
            }),
            (function (module, exports) {
                var DIFF_DELETE = -1;
                var DIFF_INSERT = 1;
                var DIFF_EQUAL = 0;
                function diff_main(text1, text2, cursor_pos) {
                    if (text1 == text2) {
                        if (text1) {
                            return [[DIFF_EQUAL, text1]];
                        }
                        return [];
                    }
                    if (cursor_pos < 0 || text1.length < cursor_pos) {
                        cursor_pos = null;
                    }
                    var commonlength = diff_commonPrefix(text1, text2);
                    var commonprefix = text1.substring(0, commonlength);
                    text1 = text1.substring(commonlength);
                    text2 = text2.substring(commonlength);
                    commonlength = diff_commonSuffix(text1, text2);
                    var commonsuffix = text1.substring(text1.length - commonlength);
                    text1 = text1.substring(0, text1.length - commonlength);
                    text2 = text2.substring(0, text2.length - commonlength);
                    var diffs = diff_compute_(text1, text2);
                    if (commonprefix) {
                        diffs.unshift([DIFF_EQUAL, commonprefix]);
                    }
                    if (commonsuffix) {
                        diffs.push([DIFF_EQUAL, commonsuffix]);
                    }
                    diff_cleanupMerge(diffs);
                    if (cursor_pos != null) {
                        diffs = fix_cursor(diffs, cursor_pos);
                    }
                    diffs = fix_emoji(diffs);
                    return diffs;
                }
                function diff_compute_(text1, text2) {
                    var diffs;
                    if (!text1) {
                        return [[DIFF_INSERT, text2]];
                    }
                    if (!text2) {
                        return [[DIFF_DELETE, text1]];
                    }
                    var longtext = text1.length > text2.length ? text1 : text2;
                    var shorttext = text1.length > text2.length ? text2 : text1;
                    var i = longtext.indexOf(shorttext);
                    if (i != -1) {
                        diffs = [[DIFF_INSERT, longtext.substring(0, i)],
                            [DIFF_EQUAL, shorttext],
                            [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
                        if (text1.length > text2.length) {
                            diffs[0][0] = diffs[2][0] = DIFF_DELETE;
                        }
                        return diffs;
                    }
                    if (shorttext.length == 1) {
                        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
                    }
                    var hm = diff_halfMatch_(text1, text2);
                    if (hm) {
                        var text1_a = hm[0];
                        var text1_b = hm[1];
                        var text2_a = hm[2];
                        var text2_b = hm[3];
                        var mid_common = hm[4];
                        var diffs_a = diff_main(text1_a, text2_a);
                        var diffs_b = diff_main(text1_b, text2_b);
                        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
                    }
                    return diff_bisect_(text1, text2);
                }
                function diff_bisect_(text1, text2) {
                    var text1_length = text1.length;
                    var text2_length = text2.length;
                    var max_d = Math.ceil((text1_length + text2_length) / 2);
                    var v_offset = max_d;
                    var v_length = 2 * max_d;
                    var v1 = new Array(v_length);
                    var v2 = new Array(v_length);
                    for (var x = 0; x < v_length; x++) {
                        v1[x] = -1;
                        v2[x] = -1;
                    }
                    v1[v_offset + 1] = 0;
                    v2[v_offset + 1] = 0;
                    var delta = text1_length - text2_length;
                    var front = (delta % 2 != 0);
                    var k1start = 0;
                    var k1end = 0;
                    var k2start = 0;
                    var k2end = 0;
                    for (var d = 0; d < max_d; d++) {
                        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                            var k1_offset = v_offset + k1;
                            var x1;
                            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
                                x1 = v1[k1_offset + 1];
                            }
                            else {
                                x1 = v1[k1_offset - 1] + 1;
                            }
                            var y1 = x1 - k1;
                            while (x1 < text1_length && y1 < text2_length &&
                                text1.charAt(x1) == text2.charAt(y1)) {
                                x1++;
                                y1++;
                            }
                            v1[k1_offset] = x1;
                            if (x1 > text1_length) {
                                k1end += 2;
                            }
                            else if (y1 > text2_length) {
                                k1start += 2;
                            }
                            else if (front) {
                                var k2_offset = v_offset + delta - k1;
                                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                                    var x2 = text1_length - v2[k2_offset];
                                    if (x1 >= x2) {
                                        return diff_bisectSplit_(text1, text2, x1, y1);
                                    }
                                }
                            }
                        }
                        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                            var k2_offset = v_offset + k2;
                            var x2;
                            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
                                x2 = v2[k2_offset + 1];
                            }
                            else {
                                x2 = v2[k2_offset - 1] + 1;
                            }
                            var y2 = x2 - k2;
                            while (x2 < text1_length && y2 < text2_length &&
                                text1.charAt(text1_length - x2 - 1) ==
                                    text2.charAt(text2_length - y2 - 1)) {
                                x2++;
                                y2++;
                            }
                            v2[k2_offset] = x2;
                            if (x2 > text1_length) {
                                k2end += 2;
                            }
                            else if (y2 > text2_length) {
                                k2start += 2;
                            }
                            else if (!front) {
                                var k1_offset = v_offset + delta - k2;
                                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                                    var x1 = v1[k1_offset];
                                    var y1 = v_offset + x1 - k1_offset;
                                    x2 = text1_length - x2;
                                    if (x1 >= x2) {
                                        return diff_bisectSplit_(text1, text2, x1, y1);
                                    }
                                }
                            }
                        }
                    }
                    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
                }
                function diff_bisectSplit_(text1, text2, x, y) {
                    var text1a = text1.substring(0, x);
                    var text2a = text2.substring(0, y);
                    var text1b = text1.substring(x);
                    var text2b = text2.substring(y);
                    var diffs = diff_main(text1a, text2a);
                    var diffsb = diff_main(text1b, text2b);
                    return diffs.concat(diffsb);
                }
                function diff_commonPrefix(text1, text2) {
                    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
                        return 0;
                    }
                    var pointermin = 0;
                    var pointermax = Math.min(text1.length, text2.length);
                    var pointermid = pointermax;
                    var pointerstart = 0;
                    while (pointermin < pointermid) {
                        if (text1.substring(pointerstart, pointermid) ==
                            text2.substring(pointerstart, pointermid)) {
                            pointermin = pointermid;
                            pointerstart = pointermin;
                        }
                        else {
                            pointermax = pointermid;
                        }
                        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
                    }
                    return pointermid;
                }
                function diff_commonSuffix(text1, text2) {
                    if (!text1 || !text2 ||
                        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
                        return 0;
                    }
                    var pointermin = 0;
                    var pointermax = Math.min(text1.length, text2.length);
                    var pointermid = pointermax;
                    var pointerend = 0;
                    while (pointermin < pointermid) {
                        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
                            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                            pointermin = pointermid;
                            pointerend = pointermin;
                        }
                        else {
                            pointermax = pointermid;
                        }
                        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
                    }
                    return pointermid;
                }
                function diff_halfMatch_(text1, text2) {
                    var longtext = text1.length > text2.length ? text1 : text2;
                    var shorttext = text1.length > text2.length ? text2 : text1;
                    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
                        return null;
                    }
                    function diff_halfMatchI_(longtext, shorttext, i) {
                        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
                        var j = -1;
                        var best_common = '';
                        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
                        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
                            var prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));
                            var suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
                            if (best_common.length < suffixLength + prefixLength) {
                                best_common = shorttext.substring(j - suffixLength, j) +
                                    shorttext.substring(j, j + prefixLength);
                                best_longtext_a = longtext.substring(0, i - suffixLength);
                                best_longtext_b = longtext.substring(i + prefixLength);
                                best_shorttext_a = shorttext.substring(0, j - suffixLength);
                                best_shorttext_b = shorttext.substring(j + prefixLength);
                            }
                        }
                        if (best_common.length * 2 >= longtext.length) {
                            return [best_longtext_a, best_longtext_b,
                                best_shorttext_a, best_shorttext_b, best_common];
                        }
                        else {
                            return null;
                        }
                    }
                    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
                    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
                    var hm;
                    if (!hm1 && !hm2) {
                        return null;
                    }
                    else if (!hm2) {
                        hm = hm1;
                    }
                    else if (!hm1) {
                        hm = hm2;
                    }
                    else {
                        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
                    }
                    var text1_a, text1_b, text2_a, text2_b;
                    if (text1.length > text2.length) {
                        text1_a = hm[0];
                        text1_b = hm[1];
                        text2_a = hm[2];
                        text2_b = hm[3];
                    }
                    else {
                        text2_a = hm[0];
                        text2_b = hm[1];
                        text1_a = hm[2];
                        text1_b = hm[3];
                    }
                    var mid_common = hm[4];
                    return [text1_a, text1_b, text2_a, text2_b, mid_common];
                }
                function diff_cleanupMerge(diffs) {
                    diffs.push([DIFF_EQUAL, '']);
                    var pointer = 0;
                    var count_delete = 0;
                    var count_insert = 0;
                    var text_delete = '';
                    var text_insert = '';
                    var commonlength;
                    while (pointer < diffs.length) {
                        switch (diffs[pointer][0]) {
                            case DIFF_INSERT:
                                count_insert++;
                                text_insert += diffs[pointer][1];
                                pointer++;
                                break;
                            case DIFF_DELETE:
                                count_delete++;
                                text_delete += diffs[pointer][1];
                                pointer++;
                                break;
                            case DIFF_EQUAL:
                                if (count_delete + count_insert > 1) {
                                    if (count_delete !== 0 && count_insert !== 0) {
                                        commonlength = diff_commonPrefix(text_insert, text_delete);
                                        if (commonlength !== 0) {
                                            if ((pointer - count_delete - count_insert) > 0 &&
                                                diffs[pointer - count_delete - count_insert - 1][0] ==
                                                    DIFF_EQUAL) {
                                                diffs[pointer - count_delete - count_insert - 1][1] +=
                                                    text_insert.substring(0, commonlength);
                                            }
                                            else {
                                                diffs.splice(0, 0, [DIFF_EQUAL,
                                                    text_insert.substring(0, commonlength)]);
                                                pointer++;
                                            }
                                            text_insert = text_insert.substring(commonlength);
                                            text_delete = text_delete.substring(commonlength);
                                        }
                                        commonlength = diff_commonSuffix(text_insert, text_delete);
                                        if (commonlength !== 0) {
                                            diffs[pointer][1] = text_insert.substring(text_insert.length -
                                                commonlength) + diffs[pointer][1];
                                            text_insert = text_insert.substring(0, text_insert.length -
                                                commonlength);
                                            text_delete = text_delete.substring(0, text_delete.length -
                                                commonlength);
                                        }
                                    }
                                    if (count_delete === 0) {
                                        diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT, text_insert]);
                                    }
                                    else if (count_insert === 0) {
                                        diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE, text_delete]);
                                    }
                                    else {
                                        diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                                    }
                                    pointer = pointer - count_delete - count_insert +
                                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                                }
                                else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                                    diffs[pointer - 1][1] += diffs[pointer][1];
                                    diffs.splice(pointer, 1);
                                }
                                else {
                                    pointer++;
                                }
                                count_insert = 0;
                                count_delete = 0;
                                text_delete = '';
                                text_insert = '';
                                break;
                        }
                    }
                    if (diffs[diffs.length - 1][1] === '') {
                        diffs.pop();
                    }
                    var changes = false;
                    pointer = 1;
                    while (pointer < diffs.length - 1) {
                        if (diffs[pointer - 1][0] == DIFF_EQUAL &&
                            diffs[pointer + 1][0] == DIFF_EQUAL) {
                            if (diffs[pointer][1].substring(diffs[pointer][1].length -
                                diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                                diffs[pointer][1] = diffs[pointer - 1][1] +
                                    diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
                                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                                diffs.splice(pointer - 1, 1);
                                changes = true;
                            }
                            else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
                                diffs[pointer + 1][1]) {
                                diffs[pointer - 1][1] += diffs[pointer + 1][1];
                                diffs[pointer][1] =
                                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
                                        diffs[pointer + 1][1];
                                diffs.splice(pointer + 1, 1);
                                changes = true;
                            }
                        }
                        pointer++;
                    }
                    if (changes) {
                        diff_cleanupMerge(diffs);
                    }
                }
                var diff = diff_main;
                diff.INSERT = DIFF_INSERT;
                diff.DELETE = DIFF_DELETE;
                diff.EQUAL = DIFF_EQUAL;
                module.exports = diff;
                function cursor_normalize_diff(diffs, cursor_pos) {
                    if (cursor_pos === 0) {
                        return [DIFF_EQUAL, diffs];
                    }
                    for (var current_pos = 0, i = 0; i < diffs.length; i++) {
                        var d = diffs[i];
                        if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
                            var next_pos = current_pos + d[1].length;
                            if (cursor_pos === next_pos) {
                                return [i + 1, diffs];
                            }
                            else if (cursor_pos < next_pos) {
                                diffs = diffs.slice();
                                var split_pos = cursor_pos - current_pos;
                                var d_left = [d[0], d[1].slice(0, split_pos)];
                                var d_right = [d[0], d[1].slice(split_pos)];
                                diffs.splice(i, 1, d_left, d_right);
                                return [i + 1, diffs];
                            }
                            else {
                                current_pos = next_pos;
                            }
                        }
                    }
                    throw new Error('cursor_pos is out of bounds!');
                }
                function fix_cursor(diffs, cursor_pos) {
                    var norm = cursor_normalize_diff(diffs, cursor_pos);
                    var ndiffs = norm[1];
                    var cursor_pointer = norm[0];
                    var d = ndiffs[cursor_pointer];
                    var d_next = ndiffs[cursor_pointer + 1];
                    if (d == null) {
                        return diffs;
                    }
                    else if (d[0] !== DIFF_EQUAL) {
                        return diffs;
                    }
                    else {
                        if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
                            ndiffs.splice(cursor_pointer, 2, d_next, d);
                            return merge_tuples(ndiffs, cursor_pointer, 2);
                        }
                        else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
                            ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
                            var suffix = d_next[1].slice(d[1].length);
                            if (suffix.length > 0) {
                                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
                            }
                            return merge_tuples(ndiffs, cursor_pointer, 3);
                        }
                        else {
                            return diffs;
                        }
                    }
                }
                function fix_emoji(diffs) {
                    var compact = false;
                    var starts_with_pair_end = function (str) {
                        return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
                    };
                    var ends_with_pair_start = function (str) {
                        return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
                    };
                    for (var i = 2; i < diffs.length; i += 1) {
                        if (diffs[i - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i - 2][1]) &&
                            diffs[i - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i - 1][1]) &&
                            diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {
                            compact = true;
                            diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
                            diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
                            diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
                        }
                    }
                    if (!compact) {
                        return diffs;
                    }
                    var fixed_diffs = [];
                    for (var i = 0; i < diffs.length; i += 1) {
                        if (diffs[i][1].length > 0) {
                            fixed_diffs.push(diffs[i]);
                        }
                    }
                    return fixed_diffs;
                }
                function merge_tuples(diffs, start, length) {
                    for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
                        if (i + 1 < diffs.length) {
                            var left_d = diffs[i];
                            var right_d = diffs[i + 1];
                            if (left_d[0] === right_d[1]) {
                                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
                            }
                        }
                    }
                    return diffs;
                }
            }),
            (function (module, exports) {
                exports = module.exports = typeof Object.keys === 'function'
                    ? Object.keys : shim;
                exports.shim = shim;
                function shim(obj) {
                    var keys = [];
                    for (var key in obj)
                        keys.push(key);
                    return keys;
                }
            }),
            (function (module, exports) {
                var supportsArgumentsClass = (function () {
                    return Object.prototype.toString.call(arguments);
                })() == '[object Arguments]';
                exports = module.exports = supportsArgumentsClass ? supported : unsupported;
                exports.supported = supported;
                function supported(object) {
                    return Object.prototype.toString.call(object) == '[object Arguments]';
                }
                exports.unsupported = unsupported;
                function unsupported(object) {
                    return object &&
                        typeof object == 'object' &&
                        typeof object.length == 'number' &&
                        Object.prototype.hasOwnProperty.call(object, 'callee') &&
                        !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
                        false;
                }
            }),
            (function (module, exports) {
                var has = Object.prototype.hasOwnProperty, prefix = '~';
                function Events() { }
                if (Object.create) {
                    Events.prototype = Object.create(null);
                    if (!new Events().__proto__)
                        prefix = false;
                }
                function EE(fn, context, once) {
                    this.fn = fn;
                    this.context = context;
                    this.once = once || false;
                }
                function EventEmitter() {
                    this._events = new Events();
                    this._eventsCount = 0;
                }
                EventEmitter.prototype.eventNames = function eventNames() {
                    var names = [], events, name;
                    if (this._eventsCount === 0)
                        return names;
                    for (name in (events = this._events)) {
                        if (has.call(events, name))
                            names.push(prefix ? name.slice(1) : name);
                    }
                    if (Object.getOwnPropertySymbols) {
                        return names.concat(Object.getOwnPropertySymbols(events));
                    }
                    return names;
                };
                EventEmitter.prototype.listeners = function listeners(event, exists) {
                    var evt = prefix ? prefix + event : event, available = this._events[evt];
                    if (exists)
                        return !!available;
                    if (!available)
                        return [];
                    if (available.fn)
                        return [available.fn];
                    for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
                        ee[i] = available[i].fn;
                    }
                    return ee;
                };
                EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
                    var evt = prefix ? prefix + event : event;
                    if (!this._events[evt])
                        return false;
                    var listeners = this._events[evt], len = arguments.length, args, i;
                    if (listeners.fn) {
                        if (listeners.once)
                            this.removeListener(event, listeners.fn, undefined, true);
                        switch (len) {
                            case 1: return listeners.fn.call(listeners.context), true;
                            case 2: return listeners.fn.call(listeners.context, a1), true;
                            case 3: return listeners.fn.call(listeners.context, a1, a2), true;
                            case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
                            case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                            case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
                        }
                        for (i = 1, args = new Array(len - 1); i < len; i++) {
                            args[i - 1] = arguments[i];
                        }
                        listeners.fn.apply(listeners.context, args);
                    }
                    else {
                        var length = listeners.length, j;
                        for (i = 0; i < length; i++) {
                            if (listeners[i].once)
                                this.removeListener(event, listeners[i].fn, undefined, true);
                            switch (len) {
                                case 1:
                                    listeners[i].fn.call(listeners[i].context);
                                    break;
                                case 2:
                                    listeners[i].fn.call(listeners[i].context, a1);
                                    break;
                                case 3:
                                    listeners[i].fn.call(listeners[i].context, a1, a2);
                                    break;
                                case 4:
                                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                                    break;
                                default:
                                    if (!args)
                                        for (j = 1, args = new Array(len - 1); j < len; j++) {
                                            args[j - 1] = arguments[j];
                                        }
                                    listeners[i].fn.apply(listeners[i].context, args);
                            }
                        }
                    }
                    return true;
                };
                EventEmitter.prototype.on = function on(event, fn, context) {
                    var listener = new EE(fn, context || this), evt = prefix ? prefix + event : event;
                    if (!this._events[evt])
                        this._events[evt] = listener, this._eventsCount++;
                    else if (!this._events[evt].fn)
                        this._events[evt].push(listener);
                    else
                        this._events[evt] = [this._events[evt], listener];
                    return this;
                };
                EventEmitter.prototype.once = function once(event, fn, context) {
                    var listener = new EE(fn, context || this, true), evt = prefix ? prefix + event : event;
                    if (!this._events[evt])
                        this._events[evt] = listener, this._eventsCount++;
                    else if (!this._events[evt].fn)
                        this._events[evt].push(listener);
                    else
                        this._events[evt] = [this._events[evt], listener];
                    return this;
                };
                EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
                    var evt = prefix ? prefix + event : event;
                    if (!this._events[evt])
                        return this;
                    if (!fn) {
                        if (--this._eventsCount === 0)
                            this._events = new Events();
                        else
                            delete this._events[evt];
                        return this;
                    }
                    var listeners = this._events[evt];
                    if (listeners.fn) {
                        if (listeners.fn === fn
                            && (!once || listeners.once)
                            && (!context || listeners.context === context)) {
                            if (--this._eventsCount === 0)
                                this._events = new Events();
                            else
                                delete this._events[evt];
                        }
                    }
                    else {
                        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                            if (listeners[i].fn !== fn
                                || (once && !listeners[i].once)
                                || (context && listeners[i].context !== context)) {
                                events.push(listeners[i]);
                            }
                        }
                        if (events.length)
                            this._events[evt] = events.length === 1 ? events[0] : events;
                        else if (--this._eventsCount === 0)
                            this._events = new Events();
                        else
                            delete this._events[evt];
                    }
                    return this;
                };
                EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
                    var evt;
                    if (event) {
                        evt = prefix ? prefix + event : event;
                        if (this._events[evt]) {
                            if (--this._eventsCount === 0)
                                this._events = new Events();
                            else
                                delete this._events[evt];
                        }
                    }
                    else {
                        this._events = new Events();
                        this._eventsCount = 0;
                    }
                    return this;
                };
                EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
                EventEmitter.prototype.addListener = EventEmitter.prototype.on;
                EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
                    return this;
                };
                EventEmitter.prefixed = prefix;
                EventEmitter.EventEmitter = EventEmitter;
                if ('undefined' !== typeof module) {
                    module.exports = EventEmitter;
                }
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.matchText = exports.matchSpacing = exports.matchNewline = exports.matchBlot = exports.matchAttributor = exports.default = undefined;
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
                var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i)
                            break;
                    }
                }
                catch (err) {
                    _d = true;
                    _e = err;
                }
                finally {
                    try {
                        if (!_n && _i["return"])
                            _i["return"]();
                    }
                    finally {
                        if (_d)
                            throw _e;
                    }
                } return _arr; } return function (arr, i) { if (Array.isArray(arr)) {
                    return arr;
                }
                else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                }
                else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                } }; }();
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _extend2 = __webpack_require__(3);
                var _extend3 = _interopRequireDefault(_extend2);
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _logger = __webpack_require__(10);
                var _logger2 = _interopRequireDefault(_logger);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                var _align = __webpack_require__(36);
                var _background = __webpack_require__(37);
                var _code = __webpack_require__(13);
                var _code2 = _interopRequireDefault(_code);
                var _color = __webpack_require__(26);
                var _direction = __webpack_require__(38);
                var _font = __webpack_require__(39);
                var _size = __webpack_require__(40);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _defineProperty(obj, key, value) { if (key in obj) {
                    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
                }
                else {
                    obj[key] = value;
                } return obj; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var debug = (0, _logger2.default)('quill:clipboard');
                var DOM_KEY = '__ql-matcher';
                var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ['br', matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ['li', matchIndent], ['b', matchAlias.bind(matchAlias, 'bold')], ['i', matchAlias.bind(matchAlias, 'italic')], ['style', matchIgnore]];
                var ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function (memo, attr) {
                    memo[attr.keyName] = attr;
                    return memo;
                }, {});
                var STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function (memo, attr) {
                    memo[attr.keyName] = attr;
                    return memo;
                }, {});
                var Clipboard = function (_Module) {
                    _inherits(Clipboard, _Module);
                    function Clipboard(quill, options) {
                        _classCallCheck(this, Clipboard);
                        var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this, quill, options));
                        _this.quill.root.addEventListener('paste', _this.onPaste.bind(_this));
                        _this.container = _this.quill.addContainer('ql-clipboard');
                        _this.container.setAttribute('contenteditable', true);
                        _this.container.setAttribute('tabindex', -1);
                        _this.matchers = [];
                        CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function (_ref) {
                            var _ref2 = _slicedToArray(_ref, 2), selector = _ref2[0], matcher = _ref2[1];
                            if (!options.matchVisual && matcher === matchSpacing)
                                return;
                            _this.addMatcher(selector, matcher);
                        });
                        return _this;
                    }
                    _createClass(Clipboard, [{
                            key: 'addMatcher',
                            value: function addMatcher(selector, matcher) {
                                this.matchers.push([selector, matcher]);
                            }
                        }, {
                            key: 'convert',
                            value: function convert(html) {
                                if (typeof html === 'string') {
                                    this.container.innerHTML = html.replace(/\>\r?\n +\</g, '><');
                                    return this.convert();
                                }
                                var formats = this.quill.getFormat(this.quill.selection.savedRange.index);
                                if (formats[_code2.default.blotName]) {
                                    var text = this.container.innerText;
                                    this.container.innerHTML = '';
                                    return new _quillDelta2.default().insert(text, _defineProperty({}, _code2.default.blotName, formats[_code2.default.blotName]));
                                }
                                var _prepareMatching = this.prepareMatching(), _prepareMatching2 = _slicedToArray(_prepareMatching, 2), elementMatchers = _prepareMatching2[0], textMatchers = _prepareMatching2[1];
                                var delta = traverse(this.container, elementMatchers, textMatchers);
                                if (deltaEndsWith(delta, '\n') && delta.ops[delta.ops.length - 1].attributes == null) {
                                    delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));
                                }
                                debug.log('convert', this.container.innerHTML, delta);
                                this.container.innerHTML = '';
                                return delta;
                            }
                        }, {
                            key: 'dangerouslyPasteHTML',
                            value: function dangerouslyPasteHTML(index, html) {
                                var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _quill2.default.sources.API;
                                if (typeof index === 'string') {
                                    this.quill.setContents(this.convert(index), html);
                                    this.quill.setSelection(0, _quill2.default.sources.SILENT);
                                }
                                else {
                                    var paste = this.convert(html);
                                    this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste), source);
                                    this.quill.setSelection(index + paste.length(), _quill2.default.sources.SILENT);
                                }
                            }
                        }, {
                            key: 'onPaste',
                            value: function onPaste(e) {
                                var _this2 = this;
                                if (e.defaultPrevented || !this.quill.isEnabled())
                                    return;
                                var range = this.quill.getSelection();
                                var delta = new _quillDelta2.default().retain(range.index);
                                var scrollTop = this.quill.scrollingContainer.scrollTop;
                                this.container.focus();
                                this.quill.selection.update(_quill2.default.sources.SILENT);
                                setTimeout(function () {
                                    delta = delta.concat(_this2.convert()).delete(range.length);
                                    _this2.quill.updateContents(delta, _quill2.default.sources.USER);
                                    _this2.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);
                                    _this2.quill.scrollingContainer.scrollTop = scrollTop;
                                    _this2.quill.focus();
                                }, 1);
                            }
                        }, {
                            key: 'prepareMatching',
                            value: function prepareMatching() {
                                var _this3 = this;
                                var elementMatchers = [], textMatchers = [];
                                this.matchers.forEach(function (pair) {
                                    var _pair = _slicedToArray(pair, 2), selector = _pair[0], matcher = _pair[1];
                                    switch (selector) {
                                        case Node.TEXT_NODE:
                                            textMatchers.push(matcher);
                                            break;
                                        case Node.ELEMENT_NODE:
                                            elementMatchers.push(matcher);
                                            break;
                                        default:
                                            [].forEach.call(_this3.container.querySelectorAll(selector), function (node) {
                                                node[DOM_KEY] = node[DOM_KEY] || [];
                                                node[DOM_KEY].push(matcher);
                                            });
                                            break;
                                    }
                                });
                                return [elementMatchers, textMatchers];
                            }
                        }]);
                    return Clipboard;
                }(_module2.default);
                Clipboard.DEFAULTS = {
                    matchers: [],
                    matchVisual: true
                };
                function applyFormat(delta, format, value) {
                    if ((typeof format === 'undefined' ? 'undefined' : _typeof(format)) === 'object') {
                        return Object.keys(format).reduce(function (delta, key) {
                            return applyFormat(delta, key, format[key]);
                        }, delta);
                    }
                    else {
                        return delta.reduce(function (delta, op) {
                            if (op.attributes && op.attributes[format]) {
                                return delta.push(op);
                            }
                            else {
                                return delta.insert(op.insert, (0, _extend3.default)({}, _defineProperty({}, format, value), op.attributes));
                            }
                        }, new _quillDelta2.default());
                    }
                }
                function computeStyle(node) {
                    if (node.nodeType !== Node.ELEMENT_NODE)
                        return {};
                    var DOM_KEY = '__ql-computed-style';
                    return node[DOM_KEY] || (node[DOM_KEY] = window.getComputedStyle(node));
                }
                function deltaEndsWith(delta, text) {
                    var endText = "";
                    for (var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {
                        var op = delta.ops[i];
                        if (typeof op.insert !== 'string')
                            break;
                        endText = op.insert + endText;
                    }
                    return endText.slice(-1 * text.length) === text;
                }
                function isLine(node) {
                    if (node.childNodes.length === 0)
                        return false;
                    var style = computeStyle(node);
                    return ['block', 'list-item'].indexOf(style.display) > -1;
                }
                function traverse(node, elementMatchers, textMatchers) {
                    if (node.nodeType === node.TEXT_NODE) {
                        return textMatchers.reduce(function (delta, matcher) {
                            return matcher(node, delta);
                        }, new _quillDelta2.default());
                    }
                    else if (node.nodeType === node.ELEMENT_NODE) {
                        return [].reduce.call(node.childNodes || [], function (delta, childNode) {
                            var childrenDelta = traverse(childNode, elementMatchers, textMatchers);
                            if (childNode.nodeType === node.ELEMENT_NODE) {
                                childrenDelta = elementMatchers.reduce(function (childrenDelta, matcher) {
                                    return matcher(childNode, childrenDelta);
                                }, childrenDelta);
                                childrenDelta = (childNode[DOM_KEY] || []).reduce(function (childrenDelta, matcher) {
                                    return matcher(childNode, childrenDelta);
                                }, childrenDelta);
                            }
                            return delta.concat(childrenDelta);
                        }, new _quillDelta2.default());
                    }
                    else {
                        return new _quillDelta2.default();
                    }
                }
                function matchAlias(format, node, delta) {
                    return applyFormat(delta, format, true);
                }
                function matchAttributor(node, delta) {
                    var attributes = _parchment2.default.Attributor.Attribute.keys(node);
                    var classes = _parchment2.default.Attributor.Class.keys(node);
                    var styles = _parchment2.default.Attributor.Style.keys(node);
                    var formats = {};
                    attributes.concat(classes).concat(styles).forEach(function (name) {
                        var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);
                        if (attr != null) {
                            formats[attr.attrName] = attr.value(node);
                            if (formats[attr.attrName])
                                return;
                        }
                        attr = ATTRIBUTE_ATTRIBUTORS[name];
                        if (attr != null && (attr.attrName === name || attr.keyName === name)) {
                            formats[attr.attrName] = attr.value(node) || undefined;
                        }
                        attr = STYLE_ATTRIBUTORS[name];
                        if (attr != null && (attr.attrName === name || attr.keyName === name)) {
                            attr = STYLE_ATTRIBUTORS[name];
                            formats[attr.attrName] = attr.value(node) || undefined;
                        }
                    });
                    if (Object.keys(formats).length > 0) {
                        delta = applyFormat(delta, formats);
                    }
                    return delta;
                }
                function matchBlot(node, delta) {
                    var match = _parchment2.default.query(node);
                    if (match == null)
                        return delta;
                    if (match.prototype instanceof _parchment2.default.Embed) {
                        var embed = {};
                        var value = match.value(node);
                        if (value != null) {
                            embed[match.blotName] = value;
                            delta = new _quillDelta2.default().insert(embed, match.formats(node));
                        }
                    }
                    else if (typeof match.formats === 'function') {
                        delta = applyFormat(delta, match.blotName, match.formats(node));
                    }
                    return delta;
                }
                function matchBreak(node, delta) {
                    if (!deltaEndsWith(delta, '\n')) {
                        delta.insert('\n');
                    }
                    return delta;
                }
                function matchIgnore() {
                    return new _quillDelta2.default();
                }
                function matchIndent(node, delta) {
                    var match = _parchment2.default.query(node);
                    if (match == null || match.blotName !== 'list-item' || !deltaEndsWith(delta, '\n')) {
                        return delta;
                    }
                    var indent = -1, parent = node.parentNode;
                    while (!parent.classList.contains('ql-clipboard')) {
                        if ((_parchment2.default.query(parent) || {}).blotName === 'list') {
                            indent += 1;
                        }
                        parent = parent.parentNode;
                    }
                    if (indent <= 0)
                        return delta;
                    return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, { indent: indent }));
                }
                function matchNewline(node, delta) {
                    if (!deltaEndsWith(delta, '\n')) {
                        if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {
                            delta.insert('\n');
                        }
                    }
                    return delta;
                }
                function matchSpacing(node, delta) {
                    if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, '\n\n')) {
                        var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);
                        if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {
                            delta.insert('\n');
                        }
                    }
                    return delta;
                }
                function matchStyles(node, delta) {
                    var formats = {};
                    var style = node.style || {};
                    if (style.fontStyle && computeStyle(node).fontStyle === 'italic') {
                        formats.italic = true;
                    }
                    if (style.fontWeight && (computeStyle(node).fontWeight.startsWith('bold') || parseInt(computeStyle(node).fontWeight) >= 700)) {
                        formats.bold = true;
                    }
                    if (Object.keys(formats).length > 0) {
                        delta = applyFormat(delta, formats);
                    }
                    if (parseFloat(style.textIndent || 0) > 0) {
                        delta = new _quillDelta2.default().insert('\t').concat(delta);
                    }
                    return delta;
                }
                function matchText(node, delta) {
                    var text = node.data;
                    if (node.parentNode.tagName === 'O:P') {
                        return delta.insert(text.trim());
                    }
                    if (text.trim().length === 0 && node.parentNode.classList.contains('ql-clipboard')) {
                        return delta;
                    }
                    if (!computeStyle(node.parentNode).whiteSpace.startsWith('pre')) {
                        var replacer = function replacer(collapse, match) {
                            match = match.replace(/[^\u00a0]/g, '');
                            return match.length < 1 && collapse ? ' ' : match;
                        };
                        text = text.replace(/\r\n/g, ' ').replace(/\n/g, ' ');
                        text = text.replace(/\s\s+/g, replacer.bind(replacer, true));
                        if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {
                            text = text.replace(/^\s+/, replacer.bind(replacer, false));
                        }
                        if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {
                            text = text.replace(/\s+$/, replacer.bind(replacer, false));
                        }
                    }
                    return delta.insert(text);
                }
                exports.default = Clipboard;
                exports.matchAttributor = matchAttributor;
                exports.matchBlot = matchBlot;
                exports.matchNewline = matchNewline;
                exports.matchSpacing = matchSpacing;
                exports.matchText = matchText;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Bold = function (_Inline) {
                    _inherits(Bold, _Inline);
                    function Bold() {
                        _classCallCheck(this, Bold);
                        return _possibleConstructorReturn(this, (Bold.__proto__ || Object.getPrototypeOf(Bold)).apply(this, arguments));
                    }
                    _createClass(Bold, [{
                            key: 'optimize',
                            value: function optimize(context) {
                                _get(Bold.prototype.__proto__ || Object.getPrototypeOf(Bold.prototype), 'optimize', this).call(this, context);
                                if (this.domNode.tagName !== this.statics.tagName[0]) {
                                    this.replaceWith(this.statics.blotName);
                                }
                            }
                        }], [{
                            key: 'create',
                            value: function create() {
                                return _get(Bold.__proto__ || Object.getPrototypeOf(Bold), 'create', this).call(this);
                            }
                        }, {
                            key: 'formats',
                            value: function formats() {
                                return true;
                            }
                        }]);
                    return Bold;
                }(_inline2.default);
                Bold.blotName = 'bold';
                Bold.tagName = ['STRONG', 'B'];
                exports.default = Bold;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.addControls = exports.default = undefined;
                var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i)
                            break;
                    }
                }
                catch (err) {
                    _d = true;
                    _e = err;
                }
                finally {
                    try {
                        if (!_n && _i["return"])
                            _i["return"]();
                    }
                    finally {
                        if (_d)
                            throw _e;
                    }
                } return _arr; } return function (arr, i) { if (Array.isArray(arr)) {
                    return arr;
                }
                else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                }
                else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                } }; }();
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _quillDelta = __webpack_require__(2);
                var _quillDelta2 = _interopRequireDefault(_quillDelta);
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _logger = __webpack_require__(10);
                var _logger2 = _interopRequireDefault(_logger);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _defineProperty(obj, key, value) { if (key in obj) {
                    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
                }
                else {
                    obj[key] = value;
                } return obj; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var debug = (0, _logger2.default)('quill:toolbar');
                var Toolbar = function (_Module) {
                    _inherits(Toolbar, _Module);
                    function Toolbar(quill, options) {
                        _classCallCheck(this, Toolbar);
                        var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, quill, options));
                        if (Array.isArray(_this.options.container)) {
                            var container = document.createElement('div');
                            addControls(container, _this.options.container);
                            quill.container.parentNode.insertBefore(container, quill.container);
                            _this.container = container;
                        }
                        else if (typeof _this.options.container === 'string') {
                            _this.container = document.querySelector(_this.options.container);
                        }
                        else {
                            _this.container = _this.options.container;
                        }
                        if (!(_this.container instanceof HTMLElement)) {
                            var _ret;
                            return _ret = debug.error('Container required for toolbar', _this.options), _possibleConstructorReturn(_this, _ret);
                        }
                        _this.container.classList.add('ql-toolbar');
                        _this.controls = [];
                        _this.handlers = {};
                        Object.keys(_this.options.handlers).forEach(function (format) {
                            _this.addHandler(format, _this.options.handlers[format]);
                        });
                        [].forEach.call(_this.container.querySelectorAll('button, select'), function (input) {
                            _this.attach(input);
                        });
                        _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (type, range) {
                            if (type === _quill2.default.events.SELECTION_CHANGE) {
                                _this.update(range);
                            }
                        });
                        _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
                            var _this$quill$selection = _this.quill.selection.getRange(), _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1), range = _this$quill$selection2[0];
                            _this.update(range);
                        });
                        return _this;
                    }
                    _createClass(Toolbar, [{
                            key: 'addHandler',
                            value: function addHandler(format, handler) {
                                this.handlers[format] = handler;
                            }
                        }, {
                            key: 'attach',
                            value: function attach(input) {
                                var _this2 = this;
                                var format = [].find.call(input.classList, function (className) {
                                    return className.indexOf('ql-') === 0;
                                });
                                if (!format)
                                    return;
                                format = format.slice('ql-'.length);
                                if (input.tagName === 'BUTTON') {
                                    input.setAttribute('type', 'button');
                                }
                                if (this.handlers[format] == null) {
                                    if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {
                                        debug.warn('ignoring attaching to disabled format', format, input);
                                        return;
                                    }
                                    if (_parchment2.default.query(format) == null) {
                                        debug.warn('ignoring attaching to nonexistent format', format, input);
                                        return;
                                    }
                                }
                                var eventName = input.tagName === 'SELECT' ? 'change' : 'click';
                                input.addEventListener(eventName, function (e) {
                                    var value = void 0;
                                    if (input.tagName === 'SELECT') {
                                        if (input.selectedIndex < 0)
                                            return;
                                        var selected = input.options[input.selectedIndex];
                                        if (selected.hasAttribute('selected')) {
                                            value = false;
                                        }
                                        else {
                                            value = selected.value || false;
                                        }
                                    }
                                    else {
                                        if (input.classList.contains('ql-active')) {
                                            value = false;
                                        }
                                        else {
                                            value = input.value || !input.hasAttribute('value');
                                        }
                                        e.preventDefault();
                                    }
                                    _this2.quill.focus();
                                    var _quill$selection$getR = _this2.quill.selection.getRange(), _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1), range = _quill$selection$getR2[0];
                                    if (_this2.handlers[format] != null) {
                                        _this2.handlers[format].call(_this2, value);
                                    }
                                    else if (_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed) {
                                        value = prompt('Enter ' + format);
                                        if (!value)
                                            return;
                                        _this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({}, format, value)), _quill2.default.sources.USER);
                                    }
                                    else {
                                        _this2.quill.format(format, value, _quill2.default.sources.USER);
                                    }
                                    _this2.update(range);
                                });
                                this.controls.push([format, input]);
                            }
                        }, {
                            key: 'update',
                            value: function update(range) {
                                var formats = range == null ? {} : this.quill.getFormat(range);
                                this.controls.forEach(function (pair) {
                                    var _pair = _slicedToArray(pair, 2), format = _pair[0], input = _pair[1];
                                    if (input.tagName === 'SELECT') {
                                        var option = void 0;
                                        if (range == null) {
                                            option = null;
                                        }
                                        else if (formats[format] == null) {
                                            option = input.querySelector('option[selected]');
                                        }
                                        else if (!Array.isArray(formats[format])) {
                                            var value = formats[format];
                                            if (typeof value === 'string') {
                                                value = value.replace(/\"/g, '\\"');
                                            }
                                            option = input.querySelector('option[value="' + value + '"]');
                                        }
                                        if (option == null) {
                                            input.value = '';
                                            input.selectedIndex = -1;
                                        }
                                        else {
                                            option.selected = true;
                                        }
                                    }
                                    else {
                                        if (range == null) {
                                            input.classList.remove('ql-active');
                                        }
                                        else if (input.hasAttribute('value')) {
                                            var isActive = formats[format] === input.getAttribute('value') || formats[format] != null && formats[format].toString() === input.getAttribute('value') || formats[format] == null && !input.getAttribute('value');
                                            input.classList.toggle('ql-active', isActive);
                                        }
                                        else {
                                            input.classList.toggle('ql-active', formats[format] != null);
                                        }
                                    }
                                });
                            }
                        }]);
                    return Toolbar;
                }(_module2.default);
                Toolbar.DEFAULTS = {};
                function addButton(container, format, value) {
                    var input = document.createElement('button');
                    input.setAttribute('type', 'button');
                    input.classList.add('ql-' + format);
                    if (value != null) {
                        input.value = value;
                    }
                    container.appendChild(input);
                }
                function addControls(container, groups) {
                    if (!Array.isArray(groups[0])) {
                        groups = [groups];
                    }
                    groups.forEach(function (controls) {
                        var group = document.createElement('span');
                        group.classList.add('ql-formats');
                        controls.forEach(function (control) {
                            if (typeof control === 'string') {
                                addButton(group, control);
                            }
                            else {
                                var format = Object.keys(control)[0];
                                var value = control[format];
                                if (Array.isArray(value)) {
                                    addSelect(group, format, value);
                                }
                                else {
                                    addButton(group, format, value);
                                }
                            }
                        });
                        container.appendChild(group);
                    });
                }
                function addSelect(container, format, values) {
                    var input = document.createElement('select');
                    input.classList.add('ql-' + format);
                    values.forEach(function (value) {
                        var option = document.createElement('option');
                        if (value !== false) {
                            option.setAttribute('value', value);
                        }
                        else {
                            option.setAttribute('selected', 'selected');
                        }
                        input.appendChild(option);
                    });
                    container.appendChild(input);
                }
                Toolbar.DEFAULTS = {
                    container: null,
                    handlers: {
                        clean: function clean() {
                            var _this3 = this;
                            var range = this.quill.getSelection();
                            if (range == null)
                                return;
                            if (range.length == 0) {
                                var formats = this.quill.getFormat();
                                Object.keys(formats).forEach(function (name) {
                                    if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {
                                        _this3.quill.format(name, false);
                                    }
                                });
                            }
                            else {
                                this.quill.removeFormat(range, _quill2.default.sources.USER);
                            }
                        },
                        direction: function direction(value) {
                            var align = this.quill.getFormat()['align'];
                            if (value === 'rtl' && align == null) {
                                this.quill.format('align', 'right', _quill2.default.sources.USER);
                            }
                            else if (!value && align === 'right') {
                                this.quill.format('align', false, _quill2.default.sources.USER);
                            }
                            this.quill.format('direction', value, _quill2.default.sources.USER);
                        },
                        indent: function indent(value) {
                            var range = this.quill.getSelection();
                            var formats = this.quill.getFormat(range);
                            var indent = parseInt(formats.indent || 0);
                            if (value === '+1' || value === '-1') {
                                var modifier = value === '+1' ? 1 : -1;
                                if (formats.direction === 'rtl')
                                    modifier *= -1;
                                this.quill.format('indent', indent + modifier, _quill2.default.sources.USER);
                            }
                        },
                        link: function link(value) {
                            if (value === true) {
                                value = prompt('Enter link URL:');
                            }
                            this.quill.format('link', value, _quill2.default.sources.USER);
                        },
                        list: function list(value) {
                            var range = this.quill.getSelection();
                            var formats = this.quill.getFormat(range);
                            if (value === 'check') {
                                if (formats['list'] === 'checked' || formats['list'] === 'unchecked') {
                                    this.quill.format('list', false, _quill2.default.sources.USER);
                                }
                                else {
                                    this.quill.format('list', 'unchecked', _quill2.default.sources.USER);
                                }
                            }
                            else {
                                this.quill.format('list', value, _quill2.default.sources.USER);
                            }
                        }
                    }
                };
                exports.default = Toolbar;
                exports.addControls = addControls;
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>";
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _picker = __webpack_require__(28);
                var _picker2 = _interopRequireDefault(_picker);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var ColorPicker = function (_Picker) {
                    _inherits(ColorPicker, _Picker);
                    function ColorPicker(select, label) {
                        _classCallCheck(this, ColorPicker);
                        var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, select));
                        _this.label.innerHTML = label;
                        _this.container.classList.add('ql-color-picker');
                        [].slice.call(_this.container.querySelectorAll('.ql-picker-item'), 0, 7).forEach(function (item) {
                            item.classList.add('ql-primary');
                        });
                        return _this;
                    }
                    _createClass(ColorPicker, [{
                            key: 'buildItem',
                            value: function buildItem(option) {
                                var item = _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'buildItem', this).call(this, option);
                                item.style.backgroundColor = option.getAttribute('value') || '';
                                return item;
                            }
                        }, {
                            key: 'selectItem',
                            value: function selectItem(item, trigger) {
                                _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'selectItem', this).call(this, item, trigger);
                                var colorLabel = this.label.querySelector('.ql-color-label');
                                var value = item ? item.getAttribute('data-value') || '' : '';
                                if (colorLabel) {
                                    if (colorLabel.tagName === 'line') {
                                        colorLabel.style.stroke = value;
                                    }
                                    else {
                                        colorLabel.style.fill = value;
                                    }
                                }
                            }
                        }]);
                    return ColorPicker;
                }(_picker2.default);
                exports.default = ColorPicker;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _picker = __webpack_require__(28);
                var _picker2 = _interopRequireDefault(_picker);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var IconPicker = function (_Picker) {
                    _inherits(IconPicker, _Picker);
                    function IconPicker(select, icons) {
                        _classCallCheck(this, IconPicker);
                        var _this = _possibleConstructorReturn(this, (IconPicker.__proto__ || Object.getPrototypeOf(IconPicker)).call(this, select));
                        _this.container.classList.add('ql-icon-picker');
                        [].forEach.call(_this.container.querySelectorAll('.ql-picker-item'), function (item) {
                            item.innerHTML = icons[item.getAttribute('data-value') || ''];
                        });
                        _this.defaultItem = _this.container.querySelector('.ql-selected');
                        _this.selectItem(_this.defaultItem);
                        return _this;
                    }
                    _createClass(IconPicker, [{
                            key: 'selectItem',
                            value: function selectItem(item, trigger) {
                                _get(IconPicker.prototype.__proto__ || Object.getPrototypeOf(IconPicker.prototype), 'selectItem', this).call(this, item, trigger);
                                item = item || this.defaultItem;
                                this.label.innerHTML = item.innerHTML;
                            }
                        }]);
                    return IconPicker;
                }(_picker2.default);
                exports.default = IconPicker;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                var Tooltip = function () {
                    function Tooltip(quill, boundsContainer) {
                        var _this = this;
                        _classCallCheck(this, Tooltip);
                        this.quill = quill;
                        this.boundsContainer = boundsContainer || document.body;
                        this.root = quill.addContainer('ql-tooltip');
                        this.root.innerHTML = this.constructor.TEMPLATE;
                        if (this.quill.root === this.quill.scrollingContainer) {
                            this.quill.root.addEventListener('scroll', function () {
                                _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + 'px';
                            });
                        }
                        this.hide();
                    }
                    _createClass(Tooltip, [{
                            key: 'hide',
                            value: function hide() {
                                this.root.classList.add('ql-hidden');
                            }
                        }, {
                            key: 'position',
                            value: function position(reference) {
                                var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
                                var top = reference.bottom + this.quill.root.scrollTop;
                                this.root.style.left = left + 'px';
                                this.root.style.top = top + 'px';
                                this.root.classList.remove('ql-flip');
                                var containerBounds = this.boundsContainer.getBoundingClientRect();
                                var rootBounds = this.root.getBoundingClientRect();
                                var shift = 0;
                                if (rootBounds.right > containerBounds.right) {
                                    shift = containerBounds.right - rootBounds.right;
                                    this.root.style.left = left + shift + 'px';
                                }
                                if (rootBounds.left < containerBounds.left) {
                                    shift = containerBounds.left - rootBounds.left;
                                    this.root.style.left = left + shift + 'px';
                                }
                                if (rootBounds.bottom > containerBounds.bottom) {
                                    var height = rootBounds.bottom - rootBounds.top;
                                    var verticalShift = reference.bottom - reference.top + height;
                                    this.root.style.top = top - verticalShift + 'px';
                                    this.root.classList.add('ql-flip');
                                }
                                return shift;
                            }
                        }, {
                            key: 'show',
                            value: function show() {
                                this.root.classList.remove('ql-editing');
                                this.root.classList.remove('ql-hidden');
                            }
                        }]);
                    return Tooltip;
                }();
                exports.default = Tooltip;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i)
                            break;
                    }
                }
                catch (err) {
                    _d = true;
                    _e = err;
                }
                finally {
                    try {
                        if (!_n && _i["return"])
                            _i["return"]();
                    }
                    finally {
                        if (_d)
                            throw _e;
                    }
                } return _arr; } return function (arr, i) { if (Array.isArray(arr)) {
                    return arr;
                }
                else if (Symbol.iterator in Object(arr)) {
                    return sliceIterator(arr, i);
                }
                else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                } }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                var _emitter = __webpack_require__(8);
                var _emitter2 = _interopRequireDefault(_emitter);
                var _base = __webpack_require__(43);
                var _base2 = _interopRequireDefault(_base);
                var _link = __webpack_require__(27);
                var _link2 = _interopRequireDefault(_link);
                var _selection = __webpack_require__(15);
                var _icons = __webpack_require__(41);
                var _icons2 = _interopRequireDefault(_icons);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var TOOLBAR_CONFIG = [[{ header: ['1', '2', '3', false] }], ['bold', 'italic', 'underline', 'link'], [{ list: 'ordered' }, { list: 'bullet' }], ['clean']];
                var SnowTheme = function (_BaseTheme) {
                    _inherits(SnowTheme, _BaseTheme);
                    function SnowTheme(quill, options) {
                        _classCallCheck(this, SnowTheme);
                        if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                            options.modules.toolbar.container = TOOLBAR_CONFIG;
                        }
                        var _this = _possibleConstructorReturn(this, (SnowTheme.__proto__ || Object.getPrototypeOf(SnowTheme)).call(this, quill, options));
                        _this.quill.container.classList.add('ql-snow');
                        return _this;
                    }
                    _createClass(SnowTheme, [{
                            key: 'extendToolbar',
                            value: function extendToolbar(toolbar) {
                                toolbar.container.classList.add('ql-snow');
                                this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
                                this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
                                this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
                                if (toolbar.container.querySelector('.ql-link')) {
                                    this.quill.keyboard.addBinding({ key: 'K', shortKey: true }, function (range, context) {
                                        toolbar.handlers['link'].call(toolbar, !context.format.link);
                                    });
                                }
                            }
                        }]);
                    return SnowTheme;
                }(_base2.default);
                SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
                    modules: {
                        toolbar: {
                            handlers: {
                                link: function link(value) {
                                    if (value) {
                                        var range = this.quill.getSelection();
                                        if (range == null || range.length == 0)
                                            return;
                                        var preview = this.quill.getText(range);
                                        if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf('mailto:') !== 0) {
                                            preview = 'mailto:' + preview;
                                        }
                                        var tooltip = this.quill.theme.tooltip;
                                        tooltip.edit('link', preview);
                                    }
                                    else {
                                        this.quill.format('link', false);
                                    }
                                }
                            }
                        }
                    }
                });
                var SnowTooltip = function (_BaseTooltip) {
                    _inherits(SnowTooltip, _BaseTooltip);
                    function SnowTooltip(quill, bounds) {
                        _classCallCheck(this, SnowTooltip);
                        var _this2 = _possibleConstructorReturn(this, (SnowTooltip.__proto__ || Object.getPrototypeOf(SnowTooltip)).call(this, quill, bounds));
                        _this2.preview = _this2.root.querySelector('a.ql-preview');
                        return _this2;
                    }
                    _createClass(SnowTooltip, [{
                            key: 'listen',
                            value: function listen() {
                                var _this3 = this;
                                _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'listen', this).call(this);
                                this.root.querySelector('a.ql-action').addEventListener('click', function (event) {
                                    if (_this3.root.classList.contains('ql-editing')) {
                                        _this3.save();
                                    }
                                    else {
                                        _this3.edit('link', _this3.preview.textContent);
                                    }
                                    event.preventDefault();
                                });
                                this.root.querySelector('a.ql-remove').addEventListener('click', function (event) {
                                    if (_this3.linkRange != null) {
                                        var range = _this3.linkRange;
                                        _this3.restoreFocus();
                                        _this3.quill.formatText(range, 'link', false, _emitter2.default.sources.USER);
                                        delete _this3.linkRange;
                                    }
                                    event.preventDefault();
                                    _this3.hide();
                                });
                                this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function (range, oldRange, source) {
                                    if (range == null)
                                        return;
                                    if (range.length === 0 && source === _emitter2.default.sources.USER) {
                                        var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range.index), _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2), link = _quill$scroll$descend2[0], offset = _quill$scroll$descend2[1];
                                        if (link != null) {
                                            _this3.linkRange = new _selection.Range(range.index - offset, link.length());
                                            var preview = _link2.default.formats(link.domNode);
                                            _this3.preview.textContent = preview;
                                            _this3.preview.setAttribute('href', preview);
                                            _this3.show();
                                            _this3.position(_this3.quill.getBounds(_this3.linkRange));
                                            return;
                                        }
                                    }
                                    else {
                                        delete _this3.linkRange;
                                    }
                                    _this3.hide();
                                });
                            }
                        }, {
                            key: 'show',
                            value: function show() {
                                _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'show', this).call(this);
                                this.root.removeAttribute('data-mode');
                            }
                        }]);
                    return SnowTooltip;
                }(_base.BaseTooltip);
                SnowTooltip.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join('');
                exports.default = SnowTheme;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _core = __webpack_require__(29);
                var _core2 = _interopRequireDefault(_core);
                var _align = __webpack_require__(36);
                var _direction = __webpack_require__(38);
                var _indent = __webpack_require__(64);
                var _blockquote = __webpack_require__(65);
                var _blockquote2 = _interopRequireDefault(_blockquote);
                var _header = __webpack_require__(66);
                var _header2 = _interopRequireDefault(_header);
                var _list = __webpack_require__(67);
                var _list2 = _interopRequireDefault(_list);
                var _background = __webpack_require__(37);
                var _color = __webpack_require__(26);
                var _font = __webpack_require__(39);
                var _size = __webpack_require__(40);
                var _bold = __webpack_require__(56);
                var _bold2 = _interopRequireDefault(_bold);
                var _italic = __webpack_require__(68);
                var _italic2 = _interopRequireDefault(_italic);
                var _link = __webpack_require__(27);
                var _link2 = _interopRequireDefault(_link);
                var _script = __webpack_require__(69);
                var _script2 = _interopRequireDefault(_script);
                var _strike = __webpack_require__(70);
                var _strike2 = _interopRequireDefault(_strike);
                var _underline = __webpack_require__(71);
                var _underline2 = _interopRequireDefault(_underline);
                var _image = __webpack_require__(72);
                var _image2 = _interopRequireDefault(_image);
                var _video = __webpack_require__(73);
                var _video2 = _interopRequireDefault(_video);
                var _code = __webpack_require__(13);
                var _code2 = _interopRequireDefault(_code);
                var _formula = __webpack_require__(74);
                var _formula2 = _interopRequireDefault(_formula);
                var _syntax = __webpack_require__(75);
                var _syntax2 = _interopRequireDefault(_syntax);
                var _toolbar = __webpack_require__(57);
                var _toolbar2 = _interopRequireDefault(_toolbar);
                var _icons = __webpack_require__(41);
                var _icons2 = _interopRequireDefault(_icons);
                var _picker = __webpack_require__(28);
                var _picker2 = _interopRequireDefault(_picker);
                var _colorPicker = __webpack_require__(59);
                var _colorPicker2 = _interopRequireDefault(_colorPicker);
                var _iconPicker = __webpack_require__(60);
                var _iconPicker2 = _interopRequireDefault(_iconPicker);
                var _tooltip = __webpack_require__(61);
                var _tooltip2 = _interopRequireDefault(_tooltip);
                var _bubble = __webpack_require__(108);
                var _bubble2 = _interopRequireDefault(_bubble);
                var _snow = __webpack_require__(62);
                var _snow2 = _interopRequireDefault(_snow);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                _core2.default.register({
                    'attributors/attribute/direction': _direction.DirectionAttribute,
                    'attributors/class/align': _align.AlignClass,
                    'attributors/class/background': _background.BackgroundClass,
                    'attributors/class/color': _color.ColorClass,
                    'attributors/class/direction': _direction.DirectionClass,
                    'attributors/class/font': _font.FontClass,
                    'attributors/class/size': _size.SizeClass,
                    'attributors/style/align': _align.AlignStyle,
                    'attributors/style/background': _background.BackgroundStyle,
                    'attributors/style/color': _color.ColorStyle,
                    'attributors/style/direction': _direction.DirectionStyle,
                    'attributors/style/font': _font.FontStyle,
                    'attributors/style/size': _size.SizeStyle
                }, true);
                _core2.default.register({
                    'formats/align': _align.AlignClass,
                    'formats/direction': _direction.DirectionClass,
                    'formats/indent': _indent.IndentClass,
                    'formats/background': _background.BackgroundStyle,
                    'formats/color': _color.ColorStyle,
                    'formats/font': _font.FontClass,
                    'formats/size': _size.SizeClass,
                    'formats/blockquote': _blockquote2.default,
                    'formats/code-block': _code2.default,
                    'formats/header': _header2.default,
                    'formats/list': _list2.default,
                    'formats/bold': _bold2.default,
                    'formats/code': _code.Code,
                    'formats/italic': _italic2.default,
                    'formats/link': _link2.default,
                    'formats/script': _script2.default,
                    'formats/strike': _strike2.default,
                    'formats/underline': _underline2.default,
                    'formats/image': _image2.default,
                    'formats/video': _video2.default,
                    'formats/list/item': _list.ListItem,
                    'modules/formula': _formula2.default,
                    'modules/syntax': _syntax2.default,
                    'modules/toolbar': _toolbar2.default,
                    'themes/bubble': _bubble2.default,
                    'themes/snow': _snow2.default,
                    'ui/icons': _icons2.default,
                    'ui/picker': _picker2.default,
                    'ui/icon-picker': _iconPicker2.default,
                    'ui/color-picker': _colorPicker2.default,
                    'ui/tooltip': _tooltip2.default
                }, true);
                exports.default = _core2.default;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.IndentClass = undefined;
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var IdentAttributor = function (_Parchment$Attributor) {
                    _inherits(IdentAttributor, _Parchment$Attributor);
                    function IdentAttributor() {
                        _classCallCheck(this, IdentAttributor);
                        return _possibleConstructorReturn(this, (IdentAttributor.__proto__ || Object.getPrototypeOf(IdentAttributor)).apply(this, arguments));
                    }
                    _createClass(IdentAttributor, [{
                            key: 'add',
                            value: function add(node, value) {
                                if (value === '+1' || value === '-1') {
                                    var indent = this.value(node) || 0;
                                    value = value === '+1' ? indent + 1 : indent - 1;
                                }
                                if (value === 0) {
                                    this.remove(node);
                                    return true;
                                }
                                else {
                                    return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'add', this).call(this, node, value);
                                }
                            }
                        }, {
                            key: 'canAdd',
                            value: function canAdd(node, value) {
                                return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, value) || _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, parseInt(value));
                            }
                        }, {
                            key: 'value',
                            value: function value(node) {
                                return parseInt(_get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'value', this).call(this, node)) || undefined;
                            }
                        }]);
                    return IdentAttributor;
                }(_parchment2.default.Attributor.Class);
                var IndentClass = new IdentAttributor('indent', 'ql-indent', {
                    scope: _parchment2.default.Scope.BLOCK,
                    whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
                });
                exports.IndentClass = IndentClass;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Blockquote = function (_Block) {
                    _inherits(Blockquote, _Block);
                    function Blockquote() {
                        _classCallCheck(this, Blockquote);
                        return _possibleConstructorReturn(this, (Blockquote.__proto__ || Object.getPrototypeOf(Blockquote)).apply(this, arguments));
                    }
                    return Blockquote;
                }(_block2.default);
                Blockquote.blotName = 'blockquote';
                Blockquote.tagName = 'blockquote';
                exports.default = Blockquote;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Header = function (_Block) {
                    _inherits(Header, _Block);
                    function Header() {
                        _classCallCheck(this, Header);
                        return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));
                    }
                    _createClass(Header, null, [{
                            key: 'formats',
                            value: function formats(domNode) {
                                return this.tagName.indexOf(domNode.tagName) + 1;
                            }
                        }]);
                    return Header;
                }(_block2.default);
                Header.blotName = 'header';
                Header.tagName = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];
                exports.default = Header;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = exports.ListItem = undefined;
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _block = __webpack_require__(4);
                var _block2 = _interopRequireDefault(_block);
                var _container = __webpack_require__(25);
                var _container2 = _interopRequireDefault(_container);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _defineProperty(obj, key, value) { if (key in obj) {
                    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
                }
                else {
                    obj[key] = value;
                } return obj; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var ListItem = function (_Block) {
                    _inherits(ListItem, _Block);
                    function ListItem() {
                        _classCallCheck(this, ListItem);
                        return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).apply(this, arguments));
                    }
                    _createClass(ListItem, [{
                            key: 'format',
                            value: function format(name, value) {
                                if (name === List.blotName && !value) {
                                    this.replaceWith(_parchment2.default.create(this.statics.scope));
                                }
                                else {
                                    _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'format', this).call(this, name, value);
                                }
                            }
                        }, {
                            key: 'remove',
                            value: function remove() {
                                if (this.prev == null && this.next == null) {
                                    this.parent.remove();
                                }
                                else {
                                    _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'remove', this).call(this);
                                }
                            }
                        }, {
                            key: 'replaceWith',
                            value: function replaceWith(name, value) {
                                this.parent.isolate(this.offset(this.parent), this.length());
                                if (name === this.parent.statics.blotName) {
                                    this.parent.replaceWith(name, value);
                                    return this;
                                }
                                else {
                                    this.parent.unwrap();
                                    return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'replaceWith', this).call(this, name, value);
                                }
                            }
                        }], [{
                            key: 'formats',
                            value: function formats(domNode) {
                                return domNode.tagName === this.tagName ? undefined : _get(ListItem.__proto__ || Object.getPrototypeOf(ListItem), 'formats', this).call(this, domNode);
                            }
                        }]);
                    return ListItem;
                }(_block2.default);
                ListItem.blotName = 'list-item';
                ListItem.tagName = 'LI';
                var List = function (_Container) {
                    _inherits(List, _Container);
                    _createClass(List, null, [{
                            key: 'create',
                            value: function create(value) {
                                var tagName = value === 'ordered' ? 'OL' : 'UL';
                                var node = _get(List.__proto__ || Object.getPrototypeOf(List), 'create', this).call(this, tagName);
                                if (value === 'checked' || value === 'unchecked') {
                                    node.setAttribute('data-checked', value === 'checked');
                                }
                                return node;
                            }
                        }, {
                            key: 'formats',
                            value: function formats(domNode) {
                                if (domNode.tagName === 'OL')
                                    return 'ordered';
                                if (domNode.tagName === 'UL') {
                                    if (domNode.hasAttribute('data-checked')) {
                                        return domNode.getAttribute('data-checked') === 'true' ? 'checked' : 'unchecked';
                                    }
                                    else {
                                        return 'bullet';
                                    }
                                }
                                return undefined;
                            }
                        }]);
                    function List(domNode) {
                        _classCallCheck(this, List);
                        var _this2 = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, domNode));
                        var listEventHandler = function listEventHandler(e) {
                            if (e.target.parentNode !== domNode)
                                return;
                            var format = _this2.statics.formats(domNode);
                            var blot = _parchment2.default.find(e.target);
                            if (format === 'checked') {
                                blot.format('list', 'unchecked');
                            }
                            else if (format === 'unchecked') {
                                blot.format('list', 'checked');
                            }
                        };
                        domNode.addEventListener('touchstart', listEventHandler);
                        domNode.addEventListener('mousedown', listEventHandler);
                        return _this2;
                    }
                    _createClass(List, [{
                            key: 'format',
                            value: function format(name, value) {
                                if (this.children.length > 0) {
                                    this.children.tail.format(name, value);
                                }
                            }
                        }, {
                            key: 'formats',
                            value: function formats() {
                                return _defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));
                            }
                        }, {
                            key: 'insertBefore',
                            value: function insertBefore(blot, ref) {
                                if (blot instanceof ListItem) {
                                    _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'insertBefore', this).call(this, blot, ref);
                                }
                                else {
                                    var index = ref == null ? this.length() : ref.offset(this);
                                    var after = this.split(index);
                                    after.parent.insertBefore(blot, after);
                                }
                            }
                        }, {
                            key: 'optimize',
                            value: function optimize(context) {
                                _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'optimize', this).call(this, context);
                                var next = this.next;
                                if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute('data-checked') === this.domNode.getAttribute('data-checked')) {
                                    next.moveChildren(this);
                                    next.remove();
                                }
                            }
                        }, {
                            key: 'replace',
                            value: function replace(target) {
                                if (target.statics.blotName !== this.statics.blotName) {
                                    var item = _parchment2.default.create(this.statics.defaultChild);
                                    target.moveChildren(item);
                                    this.appendChild(item);
                                }
                                _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'replace', this).call(this, target);
                            }
                        }]);
                    return List;
                }(_container2.default);
                List.blotName = 'list';
                List.scope = _parchment2.default.Scope.BLOCK_BLOT;
                List.tagName = ['OL', 'UL'];
                List.defaultChild = 'list-item';
                List.allowedChildren = [ListItem];
                exports.ListItem = ListItem;
                exports.default = List;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _bold = __webpack_require__(56);
                var _bold2 = _interopRequireDefault(_bold);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Italic = function (_Bold) {
                    _inherits(Italic, _Bold);
                    function Italic() {
                        _classCallCheck(this, Italic);
                        return _possibleConstructorReturn(this, (Italic.__proto__ || Object.getPrototypeOf(Italic)).apply(this, arguments));
                    }
                    return Italic;
                }(_bold2.default);
                Italic.blotName = 'italic';
                Italic.tagName = ['EM', 'I'];
                exports.default = Italic;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Script = function (_Inline) {
                    _inherits(Script, _Inline);
                    function Script() {
                        _classCallCheck(this, Script);
                        return _possibleConstructorReturn(this, (Script.__proto__ || Object.getPrototypeOf(Script)).apply(this, arguments));
                    }
                    _createClass(Script, null, [{
                            key: 'create',
                            value: function create(value) {
                                if (value === 'super') {
                                    return document.createElement('sup');
                                }
                                else if (value === 'sub') {
                                    return document.createElement('sub');
                                }
                                else {
                                    return _get(Script.__proto__ || Object.getPrototypeOf(Script), 'create', this).call(this, value);
                                }
                            }
                        }, {
                            key: 'formats',
                            value: function formats(domNode) {
                                if (domNode.tagName === 'SUB')
                                    return 'sub';
                                if (domNode.tagName === 'SUP')
                                    return 'super';
                                return undefined;
                            }
                        }]);
                    return Script;
                }(_inline2.default);
                Script.blotName = 'script';
                Script.tagName = ['SUB', 'SUP'];
                exports.default = Script;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Strike = function (_Inline) {
                    _inherits(Strike, _Inline);
                    function Strike() {
                        _classCallCheck(this, Strike);
                        return _possibleConstructorReturn(this, (Strike.__proto__ || Object.getPrototypeOf(Strike)).apply(this, arguments));
                    }
                    return Strike;
                }(_inline2.default);
                Strike.blotName = 'strike';
                Strike.tagName = 'S';
                exports.default = Strike;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _inline = __webpack_require__(6);
                var _inline2 = _interopRequireDefault(_inline);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var Underline = function (_Inline) {
                    _inherits(Underline, _Inline);
                    function Underline() {
                        _classCallCheck(this, Underline);
                        return _possibleConstructorReturn(this, (Underline.__proto__ || Object.getPrototypeOf(Underline)).apply(this, arguments));
                    }
                    return Underline;
                }(_inline2.default);
                Underline.blotName = 'underline';
                Underline.tagName = 'U';
                exports.default = Underline;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _link = __webpack_require__(27);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var ATTRIBUTES = ['alt', 'height', 'width'];
                var Image = function (_Parchment$Embed) {
                    _inherits(Image, _Parchment$Embed);
                    function Image() {
                        _classCallCheck(this, Image);
                        return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));
                    }
                    _createClass(Image, [{
                            key: 'format',
                            value: function format(name, value) {
                                if (ATTRIBUTES.indexOf(name) > -1) {
                                    if (value) {
                                        this.domNode.setAttribute(name, value);
                                    }
                                    else {
                                        this.domNode.removeAttribute(name);
                                    }
                                }
                                else {
                                    _get(Image.prototype.__proto__ || Object.getPrototypeOf(Image.prototype), 'format', this).call(this, name, value);
                                }
                            }
                        }], [{
                            key: 'create',
                            value: function create(value) {
                                var node = _get(Image.__proto__ || Object.getPrototypeOf(Image), 'create', this).call(this, value);
                                if (typeof value === 'string') {
                                    node.setAttribute('src', this.sanitize(value));
                                }
                                return node;
                            }
                        }, {
                            key: 'formats',
                            value: function formats(domNode) {
                                return ATTRIBUTES.reduce(function (formats, attribute) {
                                    if (domNode.hasAttribute(attribute)) {
                                        formats[attribute] = domNode.getAttribute(attribute);
                                    }
                                    return formats;
                                }, {});
                            }
                        }, {
                            key: 'match',
                            value: function match(url) {
                                return (/\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url));
                            }
                        }, {
                            key: 'sanitize',
                            value: function sanitize(url) {
                                return (0, _link.sanitize)(url, ['http', 'https', 'data']) ? url : '//:0';
                            }
                        }, {
                            key: 'value',
                            value: function value(domNode) {
                                return domNode.getAttribute('src');
                            }
                        }]);
                    return Image;
                }(_parchment2.default.Embed);
                Image.blotName = 'image';
                Image.tagName = 'IMG';
                exports.default = Image;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _block = __webpack_require__(4);
                var _link = __webpack_require__(27);
                var _link2 = _interopRequireDefault(_link);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var ATTRIBUTES = ['height', 'width'];
                var Video = function (_BlockEmbed) {
                    _inherits(Video, _BlockEmbed);
                    function Video() {
                        _classCallCheck(this, Video);
                        return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));
                    }
                    _createClass(Video, [{
                            key: 'format',
                            value: function format(name, value) {
                                if (ATTRIBUTES.indexOf(name) > -1) {
                                    if (value) {
                                        this.domNode.setAttribute(name, value);
                                    }
                                    else {
                                        this.domNode.removeAttribute(name);
                                    }
                                }
                                else {
                                    _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), 'format', this).call(this, name, value);
                                }
                            }
                        }], [{
                            key: 'create',
                            value: function create(value) {
                                var node = _get(Video.__proto__ || Object.getPrototypeOf(Video), 'create', this).call(this, value);
                                node.setAttribute('frameborder', '0');
                                node.setAttribute('allowfullscreen', true);
                                node.setAttribute('src', this.sanitize(value));
                                return node;
                            }
                        }, {
                            key: 'formats',
                            value: function formats(domNode) {
                                return ATTRIBUTES.reduce(function (formats, attribute) {
                                    if (domNode.hasAttribute(attribute)) {
                                        formats[attribute] = domNode.getAttribute(attribute);
                                    }
                                    return formats;
                                }, {});
                            }
                        }, {
                            key: 'sanitize',
                            value: function sanitize(url) {
                                return _link2.default.sanitize(url);
                            }
                        }, {
                            key: 'value',
                            value: function value(domNode) {
                                return domNode.getAttribute('src');
                            }
                        }]);
                    return Video;
                }(_block.BlockEmbed);
                Video.blotName = 'video';
                Video.className = 'ql-video';
                Video.tagName = 'IFRAME';
                exports.default = Video;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = exports.FormulaBlot = undefined;
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _embed = __webpack_require__(35);
                var _embed2 = _interopRequireDefault(_embed);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var FormulaBlot = function (_Embed) {
                    _inherits(FormulaBlot, _Embed);
                    function FormulaBlot() {
                        _classCallCheck(this, FormulaBlot);
                        return _possibleConstructorReturn(this, (FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot)).apply(this, arguments));
                    }
                    _createClass(FormulaBlot, null, [{
                            key: 'create',
                            value: function create(value) {
                                var node = _get(FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot), 'create', this).call(this, value);
                                if (typeof value === 'string') {
                                    window.katex.render(value, node, {
                                        throwOnError: false,
                                        errorColor: '#f00'
                                    });
                                    node.setAttribute('data-value', value);
                                }
                                return node;
                            }
                        }, {
                            key: 'value',
                            value: function value(domNode) {
                                return domNode.getAttribute('data-value');
                            }
                        }]);
                    return FormulaBlot;
                }(_embed2.default);
                FormulaBlot.blotName = 'formula';
                FormulaBlot.className = 'ql-formula';
                FormulaBlot.tagName = 'SPAN';
                var Formula = function (_Module) {
                    _inherits(Formula, _Module);
                    _createClass(Formula, null, [{
                            key: 'register',
                            value: function register() {
                                _quill2.default.register(FormulaBlot, true);
                            }
                        }]);
                    function Formula() {
                        _classCallCheck(this, Formula);
                        var _this2 = _possibleConstructorReturn(this, (Formula.__proto__ || Object.getPrototypeOf(Formula)).call(this));
                        if (window.katex == null) {
                            throw new Error('Formula module requires KaTeX.');
                        }
                        return _this2;
                    }
                    return Formula;
                }(_module2.default);
                exports.FormulaBlot = FormulaBlot;
                exports.default = Formula;
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = exports.CodeToken = exports.CodeBlock = undefined;
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _parchment = __webpack_require__(0);
                var _parchment2 = _interopRequireDefault(_parchment);
                var _quill = __webpack_require__(5);
                var _quill2 = _interopRequireDefault(_quill);
                var _module = __webpack_require__(9);
                var _module2 = _interopRequireDefault(_module);
                var _code = __webpack_require__(13);
                var _code2 = _interopRequireDefault(_code);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var SyntaxCodeBlock = function (_CodeBlock) {
                    _inherits(SyntaxCodeBlock, _CodeBlock);
                    function SyntaxCodeBlock() {
                        _classCallCheck(this, SyntaxCodeBlock);
                        return _possibleConstructorReturn(this, (SyntaxCodeBlock.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock)).apply(this, arguments));
                    }
                    _createClass(SyntaxCodeBlock, [{
                            key: 'replaceWith',
                            value: function replaceWith(block) {
                                this.domNode.textContent = this.domNode.textContent;
                                this.attach();
                                _get(SyntaxCodeBlock.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock.prototype), 'replaceWith', this).call(this, block);
                            }
                        }, {
                            key: 'highlight',
                            value: function highlight(_highlight) {
                                var text = this.domNode.textContent;
                                if (this.cachedText !== text) {
                                    if (text.trim().length > 0 || this.cachedText == null) {
                                        this.domNode.innerHTML = _highlight(text);
                                        this.domNode.normalize();
                                        this.attach();
                                    }
                                    this.cachedText = text;
                                }
                            }
                        }]);
                    return SyntaxCodeBlock;
                }(_code2.default);
                SyntaxCodeBlock.className = 'ql-syntax';
                var CodeToken = new _parchment2.default.Attributor.Class('token', 'hljs', {
                    scope: _parchment2.default.Scope.INLINE
                });
                var Syntax = function (_Module) {
                    _inherits(Syntax, _Module);
                    _createClass(Syntax, null, [{
                            key: 'register',
                            value: function register() {
                                _quill2.default.register(CodeToken, true);
                                _quill2.default.register(SyntaxCodeBlock, true);
                            }
                        }]);
                    function Syntax(quill, options) {
                        _classCallCheck(this, Syntax);
                        var _this2 = _possibleConstructorReturn(this, (Syntax.__proto__ || Object.getPrototypeOf(Syntax)).call(this, quill, options));
                        if (typeof _this2.options.highlight !== 'function') {
                            throw new Error('Syntax module requires highlight.js. Please include the library on the page before Quill.');
                        }
                        var timer = null;
                        _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
                            clearTimeout(timer);
                            timer = setTimeout(function () {
                                _this2.highlight();
                                timer = null;
                            }, _this2.options.interval);
                        });
                        _this2.highlight();
                        return _this2;
                    }
                    _createClass(Syntax, [{
                            key: 'highlight',
                            value: function highlight() {
                                var _this3 = this;
                                if (this.quill.selection.composing)
                                    return;
                                this.quill.update(_quill2.default.sources.USER);
                                var range = this.quill.getSelection();
                                this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function (code) {
                                    code.highlight(_this3.options.highlight);
                                });
                                this.quill.update(_quill2.default.sources.SILENT);
                                if (range != null) {
                                    this.quill.setSelection(range, _quill2.default.sources.SILENT);
                                }
                            }
                        }]);
                    return Syntax;
                }(_module2.default);
                Syntax.DEFAULTS = {
                    highlight: function () {
                        if (window.hljs == null)
                            return null;
                        return function (text) {
                            var result = window.hljs.highlightAuto(text);
                            return result.value;
                        };
                    }(),
                    interval: 1000
                };
                exports.CodeBlock = SyntaxCodeBlock;
                exports.CodeToken = CodeToken;
                exports.default = Syntax;
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>";
            }),
            (function (module, exports) {
                module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>";
            }),
            (function (module, exports, __webpack_require__) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = exports.BubbleTooltip = undefined;
                var _get = function get(object, property, receiver) { if (object === null)
                    object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) {
                    var parent = Object.getPrototypeOf(object);
                    if (parent === null) {
                        return undefined;
                    }
                    else {
                        return get(parent, property, receiver);
                    }
                }
                else if ("value" in desc) {
                    return desc.value;
                }
                else {
                    var getter = desc.get;
                    if (getter === undefined) {
                        return undefined;
                    }
                    return getter.call(receiver);
                } };
                var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                } } return function (Constructor, protoProps, staticProps) { if (protoProps)
                    defineProperties(Constructor.prototype, protoProps); if (staticProps)
                    defineProperties(Constructor, staticProps); return Constructor; }; }();
                var _extend = __webpack_require__(3);
                var _extend2 = _interopRequireDefault(_extend);
                var _emitter = __webpack_require__(8);
                var _emitter2 = _interopRequireDefault(_emitter);
                var _base = __webpack_require__(43);
                var _base2 = _interopRequireDefault(_base);
                var _selection = __webpack_require__(15);
                var _icons = __webpack_require__(41);
                var _icons2 = _interopRequireDefault(_icons);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                } }
                function _possibleConstructorReturn(self, call) { if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass)
                    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
                var TOOLBAR_CONFIG = [['bold', 'italic', 'link'], [{ header: 1 }, { header: 2 }, 'blockquote']];
                var BubbleTheme = function (_BaseTheme) {
                    _inherits(BubbleTheme, _BaseTheme);
                    function BubbleTheme(quill, options) {
                        _classCallCheck(this, BubbleTheme);
                        if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                            options.modules.toolbar.container = TOOLBAR_CONFIG;
                        }
                        var _this = _possibleConstructorReturn(this, (BubbleTheme.__proto__ || Object.getPrototypeOf(BubbleTheme)).call(this, quill, options));
                        _this.quill.container.classList.add('ql-bubble');
                        return _this;
                    }
                    _createClass(BubbleTheme, [{
                            key: 'extendToolbar',
                            value: function extendToolbar(toolbar) {
                                this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
                                this.tooltip.root.appendChild(toolbar.container);
                                this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
                                this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
                            }
                        }]);
                    return BubbleTheme;
                }(_base2.default);
                BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
                    modules: {
                        toolbar: {
                            handlers: {
                                link: function link(value) {
                                    if (!value) {
                                        this.quill.format('link', false);
                                    }
                                    else {
                                        this.quill.theme.tooltip.edit();
                                    }
                                }
                            }
                        }
                    }
                });
                var BubbleTooltip = function (_BaseTooltip) {
                    _inherits(BubbleTooltip, _BaseTooltip);
                    function BubbleTooltip(quill, bounds) {
                        _classCallCheck(this, BubbleTooltip);
                        var _this2 = _possibleConstructorReturn(this, (BubbleTooltip.__proto__ || Object.getPrototypeOf(BubbleTooltip)).call(this, quill, bounds));
                        _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function (type, range, oldRange, source) {
                            if (type !== _emitter2.default.events.SELECTION_CHANGE)
                                return;
                            if (range != null && range.length > 0 && source === _emitter2.default.sources.USER) {
                                _this2.show();
                                _this2.root.style.left = '0px';
                                _this2.root.style.width = '';
                                _this2.root.style.width = _this2.root.offsetWidth + 'px';
                                var lines = _this2.quill.getLines(range.index, range.length);
                                if (lines.length === 1) {
                                    _this2.position(_this2.quill.getBounds(range));
                                }
                                else {
                                    var lastLine = lines[lines.length - 1];
                                    var index = _this2.quill.getIndex(lastLine);
                                    var length = Math.min(lastLine.length() - 1, range.index + range.length - index);
                                    var _bounds = _this2.quill.getBounds(new _selection.Range(index, length));
                                    _this2.position(_bounds);
                                }
                            }
                            else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {
                                _this2.hide();
                            }
                        });
                        return _this2;
                    }
                    _createClass(BubbleTooltip, [{
                            key: 'listen',
                            value: function listen() {
                                var _this3 = this;
                                _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'listen', this).call(this);
                                this.root.querySelector('.ql-close').addEventListener('click', function () {
                                    _this3.root.classList.remove('ql-editing');
                                });
                                this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function () {
                                    setTimeout(function () {
                                        if (_this3.root.classList.contains('ql-hidden'))
                                            return;
                                        var range = _this3.quill.getSelection();
                                        if (range != null) {
                                            _this3.position(_this3.quill.getBounds(range));
                                        }
                                    }, 1);
                                });
                            }
                        }, {
                            key: 'cancel',
                            value: function cancel() {
                                this.show();
                            }
                        }, {
                            key: 'position',
                            value: function position(reference) {
                                var shift = _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'position', this).call(this, reference);
                                var arrow = this.root.querySelector('.ql-tooltip-arrow');
                                arrow.style.marginLeft = '';
                                if (shift === 0)
                                    return shift;
                                arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + 'px';
                            }
                        }]);
                    return BubbleTooltip;
                }(_base.BaseTooltip);
                BubbleTooltip.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', '</div>'].join('');
                exports.BubbleTooltip = BubbleTooltip;
                exports.default = BubbleTheme;
            }),
            (function (module, exports, __webpack_require__) {
                module.exports = __webpack_require__(63);
            })
        ])["default"];
    });
}(quill));
var Quill = getDefaultExportFromCjs(quill.exports);
const quillEditorHtml$1 = "<div id=\"<%= id %>\"></div>\n";
class Value extends AbstractValue {
    constructor(id, name, subjectEntity, rootSubjectEntity) {
        super(id, name, subjectEntity, rootSubjectEntity);
        var _ytext = null;
        var _value = "";
        let editorId = sanitizeValue("editor-" + rootSubjectEntity.getEntityId());
        editorId = editorId.toLowerCase();
        var _$node = $(lodash.template(quillEditorHtml$1)({ id: editorId }));
        var _$editorRef;
        this.setValue = function (value) {
            _value = value;
            _$node.val(value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        this.getYText = function () {
            return _ytext;
        };
        this.registerYType = function (ytext) {
            _ytext = ytext;
            const domElem = _$node.get(0);
            _$editorRef = new Quill(domElem, {
                theme: "snow",
                modules: {
                    toolbar: false,
                },
                cursors: false,
                placeholder: name,
            });
            if (!_ytext) {
                throw new Error("YText not found");
            }
            new QuillBinding(_ytext, _$editorRef);
            _ytext?.observe(function () {
                _value = _ytext.toString();
            });
            window.syncmetaLog.initializedYTexts += 1;
            if (window.syncmetaLog.hasOwnProperty(this.getEntityId()))
                window.syncmetaLog.objects[this.getEntityId()] += 1;
            else
                window.syncmetaLog.objects[this.getEntityId()] = 0;
        };
    }
}
function sanitizeValue(value) {
    return value
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/ /g, "-")
        .replace("[", "(")
        .replace("]", ")");
}
const singleQuizAttributeHtml = "<div class=\"attribute_single_quiz_attribute\">\n  <span class=\"attribute_name\" for=\"<%= id %>-value\"></span>\n  <div class=\"value\" id=\"<%= id %>-value\"></div>\n  <table id=\"table\" style=\"float: left; visibility: hidden\">\n    <tr>\n      <th>Assessment Name :</th>\n      <th><input class=\"form-control\" id=\"topic\" /></th>\n    </tr>\n    <tr>\n      <td>Nr</td>\n      <td>Question</td>\n      <td>Correct Intent</td>\n      <td>Optional Hint</td>\n    </tr>\n  </table>\n  <button\n    id=\"b\"\n    style=\"margin-left: 3px; float: left; width: 50%; visibility: hidden\"\n  >\n    +\n  </button>\n  <button\n    id=\"c\"\n    style=\"margin-left: 3px; float: left; width: 50%; visibility: hidden\"\n  >\n    -\n  </button>\n  <button\n    id=\"submit\"\n    style=\"margin-left: 3px; float: left; width: 50%; visibility: hidden\"\n  >\n    Submit\n  </button>\n  <button\n    id=\"display\"\n    style=\"margin-left: 3px; float: left; width: 50%; visibility: hidden\"\n  >\n    Display\n  </button>\n</div>\n";
class QuizAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity) {
        super(id, name, subjectEntity);
        var _value = new Value(id, name, this, this.getRootSubjectEntity());
        var _$node = $(lodash.template(singleQuizAttributeHtml)({ id: id }));
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".attribute_name").text(this.getName());
        _$node.find(".attribute_value").append(_value.get$node());
        function addRow() {
            var table = _$node.find("#table")[0];
            var rows = table.rows.length;
            var row = table.insertRow(table.rows.length);
            var cell0 = row.insertCell(0);
            var cell1 = row.insertCell(1);
            var cell2 = row.insertCell(2);
            var cell3 = row.insertCell(3);
            var input0 = document.createElement("input");
            var input1 = document.createElement("input");
            var input2 = document.createElement("input");
            var input3 = document.createElement("input");
            input0.id = rows + "0";
            input1.id = rows + "1";
            input2.id = rows + "2";
            input3.id = rows + "3";
            input1.type = "text";
            input2.type = "text";
            input3.type = "text";
            cell0.appendChild(input0);
            cell1.appendChild(input1);
            cell2.appendChild(input2);
            cell3.appendChild(input3);
        }
        this.showTable = function () {
            _$node.find("#table")[0].style.visibility = "visible";
            _$node.find("#b")[0].style.visibility = "visible";
            _$node.find("#c")[0].style.visibility = "visible";
            _$node.find("#submit")[0].style.visibility = "visible";
            _$node.find("#display")[0].style.visibility = "visible";
        };
        this.hideTable = function () {
            _$node.find("#table")[0].style.visibility = "hidden";
            _$node.find("#b")[0].style.visibility = "hidden";
            _$node.find("#c")[0].style.visibility = "hidden";
            _$node.find("#submit")[0].style.visibility = "hidden";
            _$node.find("#display")[0].style.visibility = "hidden";
        };
        _$node.find("#b").click(function () {
            addRow();
        });
        _$node.find("#c").click(function () {
            var table = _$node.find("#table")[0];
            var rows = table.rows.length;
            table.deleteRow(rows - 1);
        });
        _$node.find("#submit").click(function () {
            var table = _$node.find("#table")[0];
            var Json = {};
            Json["topic"] = _$node.find("#topic")[0].value;
            var Sequence = [];
            var Questions = [];
            var Intents = [];
            var Hints = [];
            var row = table.rows.length;
            for (var i = 2; i < row; i++) {
                if (_$node.find("#" + i.toString() + "1")[0].value == "" ||
                    _$node.find("#" + i.toString() + "2")[0].value == "") {
                    continue;
                }
                Sequence.push(_$node.find("#" + i.toString() + "0")[0].value);
                Questions.push(_$node.find("#" + i.toString() + "1")[0].value);
                Intents.push(_$node.find("#" + i.toString() + "2")[0].value);
                if (_$node.find("#" + i.toString() + "3")[0].value == "") {
                    Hints.push("No Hint Available for this Question");
                }
                else
                    Hints.push(_$node.find("#" + i.toString() + "3")[0].value);
            }
            Json["Questions"] = Questions;
            Json["Sequence"] = Sequence;
            Json["Intents"] = Intents;
            Json["Hints"] = Hints;
            console.log(JSON.stringify(Json));
            _$node.find(".val")[0].value = JSON.stringify(Json);
            var field = _$node.find(".val")[0];
            field.dispatchEvent(new Event("input"));
        });
        _$node.find("#display").click(function () {
            var table = _$node.find("#table")[0];
            var Json = _$node.find(".val")[0].value;
            console.log(Json);
            var content = JSON.parse(Json);
            _$node.find("#topic")[0].value = content.topic;
            var rowNumb = content.Questions.length;
            console.log(rowNumb);
            var currRows = table.rows.length - 2;
            console.log(currRows);
            if (currRows < rowNumb) {
                for (currRows; currRows < rowNumb; currRows++) {
                    addRow();
                }
            }
            for (var i = 2; i < rowNumb + 2; i++) {
                if (_$node.find("#" + i.toString() + "0")[0].value == null) {
                    break;
                }
                _$node.find("#" + i.toString() + "0")[0].value =
                    content.Sequence[i - 2];
                _$node.find("#" + i.toString() + "1")[0].value =
                    content.Questions[i - 2];
                _$node.find("#" + i.toString() + "2")[0].value = content.Intents[i - 2];
                _$node.find("#" + i.toString() + "3")[0].value = content.Hints[i - 2];
            }
        });
    }
}
const selectionValueHtml = "<select class=\"val form-select mb-3 h-100\">\n  <% _.each(options,function(option,key){ %>\n  <option value=\"<%= key %>\"><%= option %></option>\n  <% }); %>\n</select>\n";
class SelectionValue extends AbstractValue {
    constructor(id, name, subjectEntity, rootSubjectEntity, options) {
        super(id, name, subjectEntity, rootSubjectEntity);
        var that = this;
        var _value = Object.keys(options)[0];
        var _$node = $(lodash.template(selectionValueHtml)({
            name: name,
            options: options,
        }));
        var _iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var processValueChangeOperation = function (operation, fromCallback) {
            that.setValue(operation.getValue());
        };
        this.propagateValueChange = function (type, value, position) {
            var operation = new ValueChangeOperation(that.getEntityId(), value, type, position, _iwc.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
            propagateValueChangeOperation(operation);
        };
        var propagateValueChangeOperation = function (operation) {
            processValueChangeOperation(operation);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(rootSubjectEntity.getEntityId());
            if (ymap) {
                ymap.set(that.getEntityId(), operation.toJSON());
            }
        };
        var valueChangeCallback = function (operation) {
            if (operation instanceof ValueChangeOperation &&
                operation.getEntityId() === that.getEntityId()) {
                processValueChangeOperation(operation);
            }
        };
        var init = function () {
            _$node.off();
            _$node.change(function () {
                that.propagateValueChange(CONFIG$1.OPERATION.TYPE.UPDATE, $(this).val(), 0);
            });
        };
        this.setValue = function (value) {
            if (value === undefined) {
                console.error("value is undefined");
                return;
            }
            if (name == "Content Type") {
                if (value == "Quiz") {
                    Object.values(rootSubjectEntity.getAttributes()).forEach((value) => {
                        if (value instanceof QuizAttribute) {
                            value.showTable();
                        }
                    });
                }
                else
                    Object.values(rootSubjectEntity.getAttributes()).forEach((value) => {
                        if (value instanceof QuizAttribute) {
                            value.hideTable();
                        }
                    });
            }
            _value = value;
            _$node.val(value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.registerCallbacks = function () {
            _iwc.registerOnDataReceivedCallback(valueChangeCallback);
        };
        this.unregisterCallbacks = function () {
            _iwc.unregisterOnDataReceivedCallback(valueChangeCallback);
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        init();
        if (_iwc) {
            that.registerCallbacks();
        }
    }
}
const keySelectionValueAttributeHtml = "<li class=\"attribute_key_value_attribute input-group mb-3\">\n  <div class=\"key flex-fill\"></div>\n  <div class=\"attribute_value\"></div>\n  <button type=\"button\" class=\"btn btn-danger\">\n    <i class=\"bi bi-trash-fill\"></i>\n  </button>\n</li>\n<hr />\n";
class KeySelectionValueAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity, options) {
        super(id, name, subjectEntity);
        var that = this;
        var _options = options;
        var _key = new Value(id + "[key]", "Attribute Name", this, this.getRootSubjectEntity());
        var _value = new SelectionValue(id + "[value]", "Attribute Type", this, this.getRootSubjectEntity(), _options);
        var _$node = $(lodash.template(keySelectionValueAttributeHtml)({ id: id }));
        var _iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var propagateAttributeDeleteOperation = function (operation) {
            _iwc.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.getOTOperation());
            EntityManagerInstance$1.storeDataYjs();
        };
        var processAttributeDeleteOperation = function (operation) {
            subjectEntity.deleteAttribute(operation.getEntityId());
            that.get$node().remove();
        };
        var attributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        this.setKey = function (key) {
            _key = key;
        };
        this.getKey = function () {
            return _key;
        };
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _key.setValueFromJSON(json.key);
            _value.setValueFromJSON(json.value);
        };
        this.registerCallbacks = function () {
            _iwc.registerOnDataReceivedCallback(attributeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            _iwc.unregisterOnDataReceivedCallback(attributeDeleteCallback);
            _value.unregisterCallbacks();
        };
        _$node.find(".key").append(_key.get$node());
        _$node.find(".attribute_value").append(_value.get$node());
        _$node.find(".btn-danger").click(function () {
            var operation = new AttributeDeleteOperation(that.getEntityId(), that.getSubjectEntityId(), that.getRootSubjectEntity().getEntityId(), KeySelectionValueAttribute.TYPE);
            propagateAttributeDeleteOperation(operation, CONFIG$1.WIDGET.NAME.MAIN);
        });
        if (_iwc) {
            that.registerCallbacks();
        }
    }
    static { this.TYPE = "KeySelectionValueAttribute"; }
}
const keySelectionValueListAttributeHtml = "<div class=\"list_attribute\">\n  <div class=\"attribute_name\"></div>\n  <ul class=\"list\"></ul>\n  <button type=\"button\" class=\"btn btn-success\">\n    <i class=\"bi bi-plus-circle-fill\"></i>\n  </button>\n</div>\n";
class KeySelectionValueListAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity, options) {
        super(id, name, subjectEntity);
        var that = this;
        var _options = options;
        var _list = {};
        var _$node = $(lodash.template(keySelectionValueListAttributeHtml)());
        var iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var processAttributeAddOperation = function (operation) {
            var attribute = new KeySelectionValueAttribute(operation.getEntityId(), "Attribute", that, _options);
            const nodesMap = y.getMap("nodes");
            const ymap = nodesMap.get(subjectEntity.getEntityId());
            var ytext = ymap.get(attribute.getKey().getEntityId());
            if (!ytext)
                throw new Error("ytext is undefined");
            attribute.getKey().registerYType(ytext);
            that.addAttribute(attribute);
            if (_$node.find(".list").find("#" + attribute.getEntityId()).length === 0)
                _$node.find(".list").append(attribute.get$node());
        };
        var processAttributeDeleteOperation = function (operation) {
            var attribute = that.getAttribute(operation.getEntityId());
            if (attribute) {
                that.deleteAttribute(attribute.getEntityId());
                attribute.get$node().remove();
            }
        };
        var propagateAttributeAddOperation = function (operation) {
            iwc.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.getOTOperation());
        };
        var attributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeAddOperation(operation);
            }
        };
        var attributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_list.hasOwnProperty(id)) {
                _list[id] = attribute;
            }
        };
        this.getAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                return _list[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                delete _list[id];
            }
        };
        this.getAttributes = function () {
            return _list;
        };
        this.setAttributes = function (list) {
            _list = list;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            lodash.forEach(json.list, function (val, key) {
                var attribute = new KeySelectionValueAttribute(key, key, that, _options);
                attribute.setValueFromJSON(json.list[key]);
                that.addAttribute(attribute);
                _$node.find(".list").append(attribute.get$node());
            });
        };
        this.unregisterCallbacks = function () {
            var attrs = this.getAttributes();
            for (var key in attrs) {
                if (attrs.hasOwnProperty(key)) {
                    attrs[key].unregisterCallbacks();
                }
            }
        };
        _$node.find(".attribute_name").text(this.getName());
        for (var attrId in _list) {
            if (_list.hasOwnProperty(attrId)) {
                _$node.find(".list").append(_list[attrId].get$node());
            }
        }
        _$node.find(".btn-success").click(function () {
            var id = Util.generateRandomId();
            var operation = new AttributeAddOperation(id, that.getEntityId(), that.getRootSubjectEntity().getEntityId(), KeySelectionValueAttribute.TYPE);
            propagateAttributeAddOperation(operation);
        });
        const nodesMap = y.getMap("nodes");
        nodesMap.get(subjectEntity.getEntityId()).observe(function (event) {
            const array = Array.from(event.changes.keys.entries());
            array.forEach(([key, change]) => {
                if (key.indexOf("[key]") === -1)
                    return;
                const type = change.action;
                switch (type) {
                    case "add": {
                        const operation = new AttributeAddOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                        attributeAddCallback(operation);
                        break;
                    }
                    case "delete": {
                        const operation = new AttributeDeleteOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                        attributeDeleteCallback(operation);
                        break;
                    }
                }
            });
        });
    }
}
const keySelectionValueSelectionValueAttributeHtml = "<li class=\"attribute_key_value_attribute input-group mb-3\">\n  <div class=\"attribute_key flex-fill\"></div>\n  <div class=\"attribute_value\"></div>\n  <div class=\"attribute_value2\"></div>\n  <button type=\"button\" class=\"btn btn-danger\">\n    <i class=\"bi bi-trash-fill\"></i>\n  </button>\n</li>\n<hr />\n";
class KeySelectionValueSelectionValueAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity, options, options2) {
        super(id, name, subjectEntity);
        var that = this;
        var _options = options;
        var _options2 = options2;
        var _key = new Value(id + "[key]", "Attribute Name", this, this.getRootSubjectEntity());
        var _value = new SelectionValue(id + "[value]", "Attribute Type", this, this.getRootSubjectEntity(), _options);
        var _value2 = new SelectionValue(id + "[value2]", "Attribute Position", this, this.getRootSubjectEntity(), _options2);
        var _$node = $(lodash.template(keySelectionValueSelectionValueAttributeHtml)({ id: id }));
        var _iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        this.propagateAttributeDeleteOperation = function (operation) {
            _iwc.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.getOTOperation());
        };
        var processAttributeDeleteOperation = function (operation) {
            subjectEntity.deleteAttribute(operation.getEntityId());
            that.get$node().remove();
        };
        var attributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        this.setKey = function (key) {
            _key = key;
        };
        this.getKey = function () {
            return _key;
        };
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.setValue2 = function (value) {
            _value2 = value;
        };
        this.getValue2 = function () {
            return _value2;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _key.setValueFromJSON(json.key);
            _value.setValueFromJSON(json.value);
            _value2.setValueFromJSON(json.value2 || { value: "" });
        };
        this.registerCallbacks = function () {
            _iwc.registerOnDataReceivedCallback(attributeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            _iwc.unregisterOnDataReceivedCallback(attributeDeleteCallback);
        };
        _$node.find(".attribute_key").append(_key.get$node());
        _$node.find(".attribute_value").append(_value.get$node());
        _$node.find(".attribute_value2").append(_value2.get$node());
        _$node.find(".btn-danger").click(function () {
            var operation = new AttributeDeleteOperation(that.getEntityId(), that.getSubjectEntityId(), that.getRootSubjectEntity().getEntityId(), KeySelectionValueSelectionValueAttribute.TYPE);
            that.propagateAttributeDeleteOperation(operation);
        });
        if (_iwc) {
            that.registerCallbacks();
        }
    }
    static { this.TYPE = "KeySelectionValueSelectionValueAttribute"; }
}
const keySelectionValueSelectionValueListAttributeHtml = "<div class=\"list_attribute\">\n  <div class=\"attribute_name\"></div>\n  <ul class=\"list\"></ul>\n  <button type=\"button\" class=\"btn btn-success\">\n    <i class=\"bi bi-plus-circle-fill\"></i>\n  </button>\n</div>\n";
class KeySelectionValueSelectionValueListAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity, options, options2) {
        super(id, name, subjectEntity);
        var that = this;
        var _options = options;
        var _options2 = options2;
        var _list = {};
        var _$node = $(lodash.template(keySelectionValueSelectionValueListAttributeHtml)());
        var iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var processAttributeAddOperation = function (operation) {
            var attribute = new KeySelectionValueSelectionValueAttribute(operation.getEntityId(), "Attribute", that, _options, _options2);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(subjectEntity.getEntityId());
            var ytext = ymap.get(attribute.getKey().getEntityId());
            if (!ytext)
                throw new Error("ytext is undefined");
            attribute.getKey().registerYType(ytext);
            that.addAttribute(attribute);
            if (_$node.find(".list").find("#" + attribute.getEntityId()).length === 0)
                _$node.find(".list").append(attribute.get$node());
        };
        var processAttributeDeleteOperation = function (operation) {
            var attribute = that.getAttribute(operation.getEntityId());
            if (attribute) {
                that.deleteAttribute(attribute.getEntityId());
                attribute.get$node().remove();
            }
        };
        var attributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        this.propagateAttributeAddOperation = function (operation) {
            iwc.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.getOTOperation());
        };
        var attributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeAddOperation(operation);
            }
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_list.hasOwnProperty(id)) {
                _list[id] = attribute;
            }
        };
        this.getAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                return _list[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                delete _list[id];
            }
        };
        this.getAttributes = function () {
            return _list;
        };
        this.setAttributes = function (list) {
            _list = list;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            lodash.forEach(json.list, function (val, key) {
                var attribute = new KeySelectionValueSelectionValueAttribute(key, key, that, _options, _options2);
                attribute.setValueFromJSON(json.list[key]);
                that.addAttribute(attribute);
                _$node.find(".list").append(attribute.get$node());
            });
        };
        this.registerCallbacks = function () {
            iwc.registerOnDataReceivedCallback(attributeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            iwc.unregisterOnDataReceivedCallback(attributeDeleteCallback);
        };
        _$node.find(".attribute_name").text(this.getName());
        for (var attrId in _list) {
            if (_list.hasOwnProperty(attrId)) {
                _$node.find(".list").append(_list[attrId].get$node());
            }
        }
        _$node.find(".btn-success").click(function () {
            var id = Util.generateRandomId();
            var operation = new AttributeAddOperation(id, that.getEntityId(), that.getRootSubjectEntity().getEntityId(), KeySelectionValueSelectionValueAttribute.TYPE);
            that.propagateAttributeAddOperation(operation);
        });
        if (iwc) {
            that.registerCallbacks();
        }
        const nodesMap = y.getMap("nodes");
        nodesMap.get(subjectEntity.getEntityId()).observe(function (event) {
            const array = Array.from(event.changes.keys.entries());
            array.forEach(function (entry) {
                const key = entry[0];
                const action = entry[1].action;
                if (key.indexOf("[key]") != -1) {
                    switch (action) {
                        case "add": {
                            const operation = new AttributeAddOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                            attributeAddCallback(operation);
                            break;
                        }
                        case "delete": {
                            const operation = new AttributeDeleteOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                            attributeDeleteCallback(operation);
                        }
                    }
                }
            });
        });
    }
}
const quillEditorModalHtml = "<div\n  class=\"modal\"\n  tabindex=\"-1\"\n  id=\"editor-modal\"\n  style=\"z-index: 3000000000 !important\"\n>\n  <div class=\"modal-dialog modal-dialog-scrollable\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <h5 class=\"modal-title\"><%= title %></h5>\n        <button\n          type=\"button\"\n          class=\"btn-close\"\n          data-bs-dismiss=\"modal\"\n          aria-label=\"Close\"\n        ></button>\n      </div>\n      <div class=\"modal-body\">\n        <div id=\"<%= id %>\"></div>\n      </div>\n    </div>\n  </div>\n</div>\n";
const codeEditorValueHtml = "<button\n  class=\"btn btn-outline-secondary\"\n  data-bs-toggle=\"modal\"\n  data-bs-target=\"#editor-modal\"\n>\n  Open Code Editor\n</button>\n";
class CodeEditorValue extends AbstractValue {
    constructor(id, name, subjectEntity, rootSubjectEntity) {
        super(id, name, subjectEntity, rootSubjectEntity);
        var that = this;
        var _ytext = null;
        var _value = "";
        var editor = null;
        var init = false;
        var _$node = $(codeEditorValueHtml);
        var bindQuillEditor = function (ytext) {
            if (init) {
                return;
            }
            init = true;
            _ytext = ytext;
            new QuillBinding(_ytext, editor);
            initData(ytext, _value);
        };
        var createYText = function () {
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(rootSubjectEntity.getEntityId());
            if (ymap) {
                var ytext = ymap.get(subjectEntity.getEntityId());
                bindQuillEditor(ytext);
            }
        };
        const tagname = getWidgetTagName(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        const editorId = "editor-" + rootSubjectEntity.getEntityId();
        if (editor) {
            $(editor.container).parent().show();
        }
        else {
            var tpl = $(lodash.template(quillEditorModalHtml)({
                id: editorId,
                title: name,
            }));
            $(tagname).find(".main-wrapper").append(tpl);
            const domElem = tpl.get(0).querySelector("#" + editorId);
            editor = new Quill(domElem, {
                theme: "snow",
                modules: {
                    toolbar: false,
                },
                placeholder: "Paste your SVG code here",
                syntax: true,
            });
        }
        _$node.click(function () {
            createYText();
        });
        IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        this.setValue = function (value) {
            _value = value;
            _$node.val(value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        var initData = function (ytext, data) {
            if (data) {
                if (data !== ytext.toString()) {
                    if (ytext.toString().length > 0)
                        ytext.delete(0, ytext.toString().length);
                    ytext.insert(0, data);
                }
            }
            else {
                if (that.getValue() !== ytext.toString()) {
                    if (ytext.toString().length > 0)
                        ytext.delete(0, ytext.toString().length);
                    ytext.insert(0, that.getValue());
                }
            }
        };
        this.getYText = function () {
            return _ytext;
        };
    }
}
const SingleCodeEditorValueAttributeHtml = "<div class=\"attribute_single_value_attribute form-floating mb-3\">\n  <span class=\"attribute_name\"></span>\n  <div class=\"attribute_value\"></div>\n</div>\n";
class SingleCodeEditorValueAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity) {
        super(id, name, subjectEntity);
        var _value = new CodeEditorValue(id, name, this, this.getRootSubjectEntity());
        var _$node = $(lodash.template(SingleCodeEditorValueAttributeHtml)({ id: id }));
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".attribute_name").text(this.getName());
        _$node.find(".attribute_value").append(_value.get$node());
    }
}
const colorValueHtml = "<input\n  class=\"form-control val color\"\n  type=\"color\"\n  placeholder=\"<%= name %>\"\n/><span class=\"color_preview\"></span>\n";
class ColorValue extends AbstractValue {
    constructor(id, name, subjectEntity, rootSubjectEntity) {
        super(id, name, subjectEntity, rootSubjectEntity);
        var that = this;
        var _ytext = null;
        var _value = "";
        var _$node = $(lodash.template(colorValueHtml)({ name: name }));
        var iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var commitUpdate = function (type, value, position, remote) {
            var selectionStart = _$node[0].selectionStart;
            var selectionEnd = _$node[0].selectionEnd;
            var newSelectionStart, newSelectionEnd;
            if (!_$node.is(":focus")) {
                _$node.val(value);
                return;
            }
            switch (type) {
                case CONFIG$1.OPERATION.TYPE.INSERT:
                    if (remote) {
                        if (position <= selectionStart) {
                            newSelectionStart = selectionStart + 1;
                            newSelectionEnd = selectionEnd + 1;
                        }
                        else if (position < selectionEnd) {
                            newSelectionStart = selectionStart;
                            newSelectionEnd = selectionEnd + 1;
                        }
                        else {
                            newSelectionStart = selectionStart;
                            newSelectionEnd = selectionEnd;
                        }
                    }
                    else {
                        newSelectionStart = position + 1;
                        newSelectionEnd = position + 1;
                    }
                    break;
                case CONFIG$1.OPERATION.TYPE.DELETE:
                    if (remote) {
                        if (position < selectionStart) {
                            newSelectionStart = selectionStart - 1;
                            newSelectionEnd = selectionEnd - 1;
                        }
                        else if (position < selectionEnd) {
                            newSelectionStart = selectionStart;
                            newSelectionEnd = selectionEnd - 1;
                        }
                        else {
                            newSelectionStart = selectionStart;
                            newSelectionEnd = selectionEnd;
                        }
                    }
                    else {
                        newSelectionStart = position;
                        newSelectionEnd = position;
                    }
                    break;
            }
            _$node.val(value);
            _$node[0].selectionStart = newSelectionStart;
            _$node[0].selectionEnd = newSelectionEnd;
            _$node
                .closest(".color_preview")
                .css("backgroundColor", "#FFFFFF")
                .css("backgroundColor", value);
        };
        var processValueChangeOperation = function (operation) {
            if (operation.getType() === CONFIG$1.OPERATION.TYPE.INSERT) {
                _value =
                    _value.substr(0, operation.getPosition()) +
                        operation.getValue() +
                        _value.substring(operation.getPosition());
            }
            else if (operation.getType() === CONFIG$1.OPERATION.TYPE.DELETE) {
                _value =
                    _value.substr(0, operation.getPosition()) +
                        _value.substring(operation.getPosition() + 1);
            }
            commitUpdate(operation.getType(), _value, operation.getPosition(), operation.getRemote());
        };
        var valueChangeCallback = function (operation) {
            if (operation instanceof ValueChangeOperation &&
                operation.getEntityId() === that.getEntityId()) {
                processValueChangeOperation(operation);
            }
        };
        this.setValue = function (value) {
            _value = value;
            _$node.val(value);
            _$node
                .closest(".color_preview")
                .css("backgroundColor", "#FFFFFF")
                .css("backgroundColor", value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        this.registerCallbacks = function () {
            iwc.registerOnDataReceivedCallback(valueChangeCallback);
        };
        this.unregisterCallbacks = function () {
            iwc.unregisterOnDataReceivedCallback(valueChangeCallback);
        };
        var initData = function (ytext, data) {
            if (data) {
                if (data !== ytext.toString()) {
                    if (ytext.toString().length > 0)
                        ytext.delete(0, ytext.toString().length);
                    ytext.insert(0, data);
                }
            }
            else {
                if (that.getValue() !== ytext.toString()) {
                    if (ytext.toString().length > 0)
                        ytext.delete(0, ytext.toString().length);
                    ytext.insert(0, that.getValue());
                }
            }
        };
        this.getYText = function () {
            return _ytext;
        };
        this.registerYType = function (ytext) {
            _ytext = ytext;
            initData(ytext);
        };
    }
}
const singleColorValueAttributeHtml = "<div class=\"attribute_single_value_attribute form-floating mb-3\">\n  <span class=\"attribute_name\"></span>\n  <div class=\"attribute_value\"></div>\n</div>\n";
class SingleColorValueAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity) {
        super(id, name, subjectEntity);
        var _value = new ColorValue(id, name, this, this.getRootSubjectEntity());
        var _$node = $(lodash.template(singleColorValueAttributeHtml)({ id: id }));
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".attribute_name").text(this.getName());
        _$node.find(".attribute_value").append(_value.get$node());
    }
}
const quillEditorHtml = "<div id=\"<%= id %>\"></div>\n";
class MultiLineValue extends AbstractValue {
    constructor(id, name, subjectEntity, rootSubjectEntity) {
        super(id, name, subjectEntity, rootSubjectEntity);
        var that = this;
        var _ytext = null;
        var _value = "";
        let editorId = name.replace(/ /g, "-");
        editorId = editorId.toLowerCase();
        var _$node = $(lodash.template(quillEditorHtml)({ id: editorId }));
        var _$editorRef;
        IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        this.setValue = function (value) {
            _value = value;
            _$node.val(value);
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            this.setValue(json.value);
        };
        var initData = function (ytext, data) {
            if (data) {
                if (data !== ytext.toString()) {
                    if (ytext.toString().length > 0)
                        ytext.delete(0, ytext.toString().length);
                    ytext.insert(0, data);
                }
            }
            else {
                if (that.getValue() !== ytext.toString()) {
                    if (ytext.toString().length > 0)
                        ytext.delete(0, ytext.toString().length);
                    ytext.insert(0, that.getValue());
                }
            }
        };
        this.registerYType = function (ytext) {
            _ytext = ytext;
            const $editor = document.querySelector("#" + editorId);
            if (!$editor) {
                throw new Error("Editor not found " + editorId);
            }
            _$editorRef = new Quill($editor, {
                theme: "snow",
                modules: {
                    toolbar: false,
                },
                placeholder: name,
            });
            if (!_ytext) {
                throw new Error("YText not found");
            }
            new QuillBinding(_ytext, _$editorRef);
            _ytext?.observe(function () {
                _value = _ytext.toString();
            });
            window.syncmetaLog.initializedYTexts += 1;
            if (window.syncmetaLog.hasOwnProperty(this.getEntityId()))
                window.syncmetaLog.objects[this.getEntityId()] += 1;
            else
                window.syncmetaLog.objects[this.getEntityId()] = 0;
            initData(ytext);
        };
        this.getYText = function () {
            return _ytext;
        };
    }
}
const singleMultiLineValueAttributeHtml = "<div class=\"attribute_single_value_attribute form-floating mb-3\">\n  <span class=\"attribute_name\"></span>\n  <div class=\"attribute_value\"></div>\n</div>\n";
class SingleMultiLineValueAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity) {
        super(id, name, subjectEntity);
        var _value = new MultiLineValue(id, name, this, this.getRootSubjectEntity());
        var _$node = $(lodash.template(singleMultiLineValueAttributeHtml)({ id: id }));
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".attribute_name").text(this.getName());
        _$node.find(".attribute_value").append(_value.get$node());
    }
}
const singleSelectionAttributeHtml = "<div class=\"attribute_single_value_attribute\">\n  <div class=\"attribute_name\"></div>\n  <div class=\"attribute_value\"></div>\n</div>\n";
class SingleSelectionAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity, options) {
        super(id, name, subjectEntity);
        var _value = new SelectionValue(id, name, this, this.getRootSubjectEntity(), options);
        var _$node = $(lodash.template(singleSelectionAttributeHtml)());
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.getOptionValue = function () {
            return options.hasOwnProperty(_value.getValue())
                ? options[_value.getValue()]
                : null;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find(".attribute_name").text(this.getName());
        _$node.find(".attribute_value").append(_value.get$node());
        if (window.hasOwnProperty("y")) {
            const widgetConfigMap = y.getMap("widgetConfig");
            if (widgetConfigMap.get("view_only_property_browser")) {
                _$node.find(".val").attr("disabled", "true");
            }
        }
    }
}
const singleValueAttributeHtml = "<div class=\"attribute_single_value_attribute form-floating mb-3\">\n  <span class=\"attribute_name\"></span>\n  <div class=\"attribute_value\"></div>\n</div>\n";
class SingleValueAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity) {
        super(id, name, subjectEntity);
        var _value = new Value(id, name, this, this.getRootSubjectEntity());
        var _$node = $(lodash.template(singleValueAttributeHtml)({ id: id }));
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        _$node.find("attribute_name").text(this.getName());
        _$node.find(".attribute_value").append(_value.get$node());
        if (window.hasOwnProperty("y")) {
            const widgetConfigMap = y.getMap("widgetConfig");
            if (widgetConfigMap.get("view_only_property_browser")) {
                _$node.find(".val").attr("disabled", "true");
            }
        }
    }
}
const listSingleValueAttributeHtml = "<div class=\"attribute_single_value_attribute input-group mb-3\">\n  <div\n    class=\"attribute_name input-group-text overflow-auto\"\n    style=\"max-width: 40%\"\n  ></div>\n  <div class=\"attribute_value flex-fill\"></div>\n  <button type=\"button\" class=\"btn btn-danger\">\n    <i class=\"bi bi-trash-fill\"></i>\n  </button>\n</div>\n";
class ListSingleValueAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity) {
        super(id, name, subjectEntity);
        var that = this;
        var _value = new Value(id, name, this, this.getRootSubjectEntity());
        var _$node = $(lodash.template(listSingleValueAttributeHtml)({ id: id }));
        var _iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE, window.y);
        var propagateAttributeDeleteOperation = function (operation) {
            _iwc.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.getOTOperation());
        };
        var processAttributeDeleteOperation = function (operation) {
            subjectEntity.deleteAttribute(operation.getEntityId());
            that.get$node().remove();
        };
        var attributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _value.setValueFromJSON(json.value);
        };
        this.registerCallbacks = function () {
            _iwc.registerOnDataReceivedCallback(attributeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            _iwc.unregisterOnDataReceivedCallback(attributeDeleteCallback);
        };
        _$node.find(".attribute_name").text(this.getName());
        _$node.find(".attribute_value").append(_value.get$node());
        _$node.find(".btn-danger").click(function () {
            var operation = new AttributeDeleteOperation(that.getEntityId(), that.getSubjectEntityId(), that.getRootSubjectEntity().getEntityId(), ListSingleValueAttribute.TYPE);
            propagateAttributeDeleteOperation(operation, CONFIG$1.WIDGET.NAME.MAIN);
        });
        if (_iwc) {
            that.registerCallbacks();
        }
    }
}
const singleValueListAttributeHtml = "<div class=\"list_attribute\">\n  <div class=\"attribute_name\"></div>\n  <ul class=\"list\"></ul>\n  <button type=\"button\" class=\"btn btn-success\">\n    <i class=\"bi bi-plus-circle-fill\"></i>\n  </button>\n</div>\n";
class SingleValueListAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity) {
        super(id, name, subjectEntity);
        var that = this;
        var _list = {};
        var _$node = $(lodash.template(singleValueListAttributeHtml)());
        var iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE, window.y);
        var processAttributeAddOperation = function (operation) {
            var attribute = new ListSingleValueAttribute(operation.getEntityId() + "[value]", "Attribute", that);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(subjectEntity.getEntityId());
            var ytext = ymap.get(attribute.getValue().getEntityId());
            attribute.getValue().registerYType(ytext);
            that.addAttribute(attribute);
            if (_$node
                .find(".list")
                .find("#" +
                attribute.getEntityId().replace("[", "\\[").replace("]", "\\]")).length === 0)
                _$node.find(".list").append(attribute.get$node());
        };
        var processAttributeDeleteOperation = function (operation) {
            var attribute = that.getAttribute(operation.getEntityId());
            if (attribute) {
                that.deleteAttribute(attribute.getEntityId());
                attribute.get$node().remove();
            }
        };
        var propagateAttributeAddOperation = function (operation) {
            iwc.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.getOTOperation());
        };
        var attributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeAddOperation(operation);
            }
        };
        var attributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_list.hasOwnProperty(id)) {
                _list[id] = attribute;
            }
        };
        this.getAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                return _list[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                delete _list[id];
            }
        };
        this.getAttributes = function () {
            return _list;
        };
        this.setAttributes = function (list) {
            _list = list;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = (json) => {
            lodash.forEach(json.list, function (val, key) {
                var attribute = new ListSingleValueAttribute(key, "Attribute", that);
                attribute.setValueFromJSON(json.list[key]);
                that.addAttribute(attribute);
                _$node.find(".list").append(attribute.get$node());
            });
        };
        _$node.find(".attribute_name").text(this.getName());
        for (var attrId in _list) {
            if (_list.hasOwnProperty(attrId)) {
                _$node.find(".list").append(_list[attrId].get$node());
            }
        }
        _$node.find(".btn-success").click(function () {
            var id = Util.generateRandomId();
            const userMap = y.getMap("users");
            var operation = new AttributeAddOperation(id, that.getEntityId(), that.getRootSubjectEntity().getEntityId(), ListSingleValueAttribute.TYPE, userMap.get(y.clientID));
            propagateAttributeAddOperation(operation);
        });
        const nodesMap = y.getMap("nodes");
        nodesMap.get(subjectEntity.getEntityId()).observe(function (event) {
            const array = Array.from(event.changes.keys.entries());
            array.forEach(([key, change]) => {
                if (key.indexOf("[value]") != -1) {
                    switch (change.action) {
                        case "add": {
                            const jabberId = event.currentTarget.get("jabberId");
                            if (jabberId ===
                                IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE).getUser()[CONFIG$1.NS.PERSON.JABBERID]) {
                                return;
                            }
                            const operation = new AttributeAddOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                            attributeAddCallback(operation);
                            break;
                        }
                        case "delete": {
                            const operation = new AttributeDeleteOperation(key, that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                            attributeDeleteCallback(operation);
                            break;
                        }
                    }
                }
            });
        });
    }
}
function makeViewEdge(attributes, edgeType) {
    function ViewEdge(id, source, target) {
        var viewEdge = new edgeType(id, source, target);
        viewEdge.applyAttributeRenaming(attributes);
        return viewEdge;
    }
    ViewEdge.getAttributes = function () {
        return attributes;
    };
    ViewEdge.getTargetEdgeType = function () {
        return edgeType;
    };
    return ViewEdge;
}
function makeViewNode(type, attributes, nodeType) {
    ViewNode.prototype.constructor = ViewNode;
    function ViewNode(id, left, top, width, height, zIndex) {
        var viewNode = new nodeType(id, left, top, width, height, zIndex);
        viewNode.applyAttributeRenaming(attributes);
        return viewNode;
    }
    ViewNode.getTargetNodeType = function () {
        return nodeType;
    };
    ViewNode.getAttributes = function () {
        return attributes;
    };
    return ViewNode;
}
const condition_predicateHtml = "<li class=\"condition_predicate\">\n  <div class=\"property\"></div>\n  <div class=\"operator\"></div>\n  <div class=\"val\"></div>\n  <div class=\"operator2\" style=\"display: none\"></div>\n  <button type=\"button\" class=\"btn btn-danger\">\n    <i class=\"bi bi-trash-fill\"></i>\n  </button>\n</li>\n";
class ConditionPredicateAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity, options, options2) {
        super(id, name, subjectEntity);
        var that = this;
        var _options = options;
        var _options2 = options2;
        var _key = new Value(id + "[value]", "Attribute Value", this, this.getRootSubjectEntity());
        var _value = new SelectionValue(id + "[property]", "Attribute Name", this, this.getRootSubjectEntity(), _options);
        var _value2 = new SelectionValue(id + "[operator]", "Logical Operator", this, this.getRootSubjectEntity(), _options2);
        var _$node = $(lodash.template(condition_predicateHtml)());
        var _iwc = IWCW.getInstance(CONFIG.WIDGET.NAME.ATTRIBUTE);
        this.propagateAttributeDeleteOperation = function (operation) {
            processAttributeDeleteOperation(operation);
            _iwc.sendLocalOTOperation(CONFIG.WIDGET.NAME.MAIN, operation.getOTOperation());
        };
        var processAttributeDeleteOperation = function (operation) {
            subjectEntity.deleteAttribute(operation.getEntityId());
            that.get$node().remove();
        };
        var attributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        this.setKey = function (key) {
            _key = key;
        };
        this.getKey = function () {
            return _key;
        };
        this.setValue = function (value) {
            _value = value;
        };
        this.getValue = function () {
            return _value;
        };
        this.setValue2 = function (value) {
            _value2 = value;
        };
        this.getValue2 = function () {
            return _value2;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _key.setValueFromJSON(json.val);
            _value.setValueFromJSON(json.property);
            _value2.setValueFromJSON(json.operator || { value: "" });
        };
        this.registerCallbacks = function () {
            _iwc.registerOnDataReceivedCallback(attributeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            _iwc.unregisterOnDataReceivedCallback(attributeDeleteCallback);
        };
        _$node.find(".val").append(_key.get$node());
        _$node.find(".property").append(_value.get$node());
        _$node.find(".operator").append(_value2.get$node());
        _$node.find(".btn-danger").click(function () {
            var operation = new AttributeDeleteOperation(that.getEntityId(), that.getSubjectEntityId(), that.getRootSubjectEntity().getEntityId(), ConditionPredicateAttribute.TYPE);
            that.propagateAttributeDeleteOperation(operation);
        });
        if (_iwc) {
            that.registerCallbacks();
        }
    }
    static { this.TYPE = "ConditionPredicateAttribute"; }
}
const listAttributeHtml$1 = "<div class=\"list_attribute\">\n  <div class=\"attribute_name\"></div>\n  <ul class=\"list\"></ul>\n  <button type=\"button\" class=\"btn btn-success\">\n    <i class=\"bi bi-plus-circle-fill\"></i>\n  </button>\n</div>\n";
class ConditionListAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity, options, options2) {
        super(id, name, subjectEntity);
        var that = this;
        var _options = options;
        var _options2 = options2;
        var _list = {};
        var _$node = $(lodash.template(listAttributeHtml$1)());
        var iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var processAttributeAddOperation = function (operation) {
            var attribute;
            if (!that.getAttributes().hasOwnProperty(operation.getEntityId())) {
                attribute = new ConditionPredicateAttribute(operation.getEntityId(), "Attribute", that, _options, _options2);
                that.addAttribute(attribute);
                _$node.find(".list").append(attribute.get$node());
            }
            else
                attribute = that.getAttribute(operation.getEntityId());
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(subjectEntity.getEntityId());
            var ytext = ymap.get(attribute.getKey().getEntityId());
            if (!ytext)
                throw new Error("ytext is undefined");
            attribute.getKey().registerYType(ytext);
            _$node.find(".list .operator2").show();
            _$node.find(".list").append(attribute.get$node());
        };
        var processAttributeDeleteOperation = function (operation) {
            var attribute = that.getAttribute(operation.getEntityId());
            if (attribute) {
                that.deleteAttribute(attribute.getEntityId());
                attribute.get$node().remove();
            }
        };
        var attributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        var propagateAttributeAddOperation = function (operation) {
            iwc.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.getOTOperation());
        };
        var attributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeAddOperation(operation);
            }
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_list.hasOwnProperty(id)) {
                _list[id] = attribute;
            }
        };
        this.getAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                return _list[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                delete _list[id];
            }
        };
        this.getAttributes = function () {
            return _list;
        };
        this.setAttributes = function (list) {
            _list = list;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setOptions = function (options) {
            _options = options;
        };
        this.setValueFromJSON = function (json) {
            lodash.forEach(json.list, function (val, key) {
                var attribute = new ConditionPredicateAttribute(key, key, that, _options, _options2);
                attribute.setValueFromJSON(json.list[key]);
                that.addAttribute(attribute);
                _$node.find(".list").append(attribute.get$node());
            });
        };
        _$node.find(".attribute_name").text(this.getName());
        for (var attrId in _list) {
            if (_list.hasOwnProperty(attrId)) {
                _$node.find(".list").append(_list[attrId].get$node());
            }
        }
        _$node.find(".btn-success").click(function () {
            var id = Util.generateRandomId();
            var operation = new AttributeAddOperation(id, that.getEntityId(), that.getRootSubjectEntity().getEntityId(), ConditionPredicateAttribute.TYPE);
            propagateAttributeAddOperation(operation);
        });
        const nodesMap = y.getMap("nodes");
        nodesMap.get(subjectEntity.getEntityId()).observe(function (event) {
            const array = Array.from(event.changes.keys.entries());
            array.forEach(([key, change]) => {
                if (key.indexOf("[value]") != -1) {
                    switch (change.action) {
                        case "add": {
                            const operation = new AttributeAddOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                            attributeAddCallback(operation);
                            break;
                        }
                        case "delete": {
                            const operation = new AttributeDeleteOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                            attributeDeleteCallback(operation);
                            break;
                        }
                    }
                }
                else if (key.indexOf("updateConditionOption") != -1) {
                    that.setOptions(event.value);
                }
            });
        });
    }
}
const renamingAttrHTML = "<li class=\"renaming_attr\">\n    <div class=\"val\"></div>\n    <div class=\"ref\" ></div>\n    <div class=\"vis\"></div>\n</li>";
class RenamingAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity, options) {
        super(id, name, subjectEntity);
        var that = this;
        var _options = options;
        var _key = new Value(id + "[val]", "Attribute Name", this, this.getRootSubjectEntity());
        var _ref = new Value(id + "[ref]", "Attribute Reference", this, this.getRootSubjectEntity());
        var _vis = new SelectionValue(id + "[vis]", "Attribute Visibility", this, this.getRootSubjectEntity(), _options);
        var _$node = $(lodash.template(renamingAttrHTML)());
        var _iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        this.propagateAttributeDeleteOperation = function (operation) {
            processAttributeDeleteOperation(operation);
            _iwc.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.getOTOperation());
        };
        var processAttributeDeleteOperation = function (operation) {
            subjectEntity.deleteAttribute(operation.getEntityId());
            that.get$node().remove();
        };
        var attributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        this.setKey = function (key) {
            _key = key;
        };
        this.getKey = function () {
            return _key;
        };
        this.getRef = function () {
            return _ref;
        };
        this.setVisibility = function (value) {
            _vis = value;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setValueFromJSON = function (json) {
            _key.setValueFromJSON(json.val);
            _ref.setValueFromJSON(json.ref);
            _vis.setValueFromJSON(json.vis || { value: "" });
        };
        this.registerCallbacks = function () {
            _iwc.registerOnDataReceivedCallback(attributeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            _iwc.unregisterOnDataReceivedCallback(attributeDeleteCallback);
        };
        _$node.find(".val").append(_key.get$node());
        _$node.find(".ref").append(_ref.get$node());
        _$node.find(".vis").append(_vis.get$node());
        _$node.find(".ref").find("input").prop("disabled", true);
        if (_iwc) {
            that.registerCallbacks();
        }
    }
    static { this.TYPE = "RenamingAttribute"; }
}
const listAttributeHtml = "<div class=\"list_attribute\">\n  <div class=\"attribute_name\"></div>\n  <ul class=\"list\"></ul>\n  <button type=\"button\" class=\"btn btn-success\">\n    <i class=\"bi bi-plus-circle-fill\"></i>\n  </button>\n</div>\n";
class RenamingListAttribute extends AbstractAttribute {
    constructor(id, name, subjectEntity, options) {
        super(id, name, subjectEntity);
        var that = this;
        var _options = options;
        var _list = {};
        var _$node = $(lodash.template(listAttributeHtml)());
        _$node.find(".btn-success").parent().remove();
        var iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var processAttributeAddOperation = function (operation) {
            var attribute;
            if (!that.getAttributes().hasOwnProperty(operation.getEntityId())) {
                attribute = new RenamingAttribute(operation.getEntityId(), "Attribute", that, _options);
                that.addAttribute(attribute);
                _$node.find(".list").append(attribute.get$node());
            }
            else
                attribute = that.getAttribute(operation.getEntityId());
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(subjectEntity.getEntityId());
            var ytext = ymap.get(attribute.getKey().getEntityId());
            if (!ytext)
                throw new Error("ytext is undefined");
            attribute.getKey().registerYType(ytext);
            var ytext2 = ymap.get(attribute.getRef().getEntityId());
            attribute.getRef().registerYType(ytext2);
        };
        var processAttributeDeleteOperation = function (operation) {
            var attribute = that.getAttribute(operation.getEntityId());
            if (attribute) {
                that.deleteAttribute(attribute.getEntityId());
                attribute.get$node().remove();
            }
        };
        var attributeDeleteCallback = function (operation) {
            if (operation instanceof AttributeDeleteOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeDeleteOperation(operation);
            }
        };
        this.propagateAttributeAddOperation = function (operation) {
            iwc.sendLocalOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.getOTOperation());
        };
        var attributeAddCallback = function (operation) {
            if (operation instanceof AttributeAddOperation &&
                operation.getRootSubjectEntityId() ===
                    that.getRootSubjectEntity().getEntityId() &&
                operation.getSubjectEntityId() === that.getEntityId()) {
                processAttributeAddOperation(operation);
                subjectEntity.showAttributes();
            }
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_list.hasOwnProperty(id)) {
                _list[id] = attribute;
            }
        };
        this.getAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                return _list[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (_list.hasOwnProperty(id)) {
                delete _list[id];
            }
        };
        this.getAttributes = function () {
            return _list;
        };
        this.setAttributes = function (list) {
            _list = list;
        };
        this.get$node = function () {
            return _$node;
        };
        this.setOptions = function (options) {
            _options = options;
        };
        this.setValueFromJSON = function (json) {
            lodash.forEach(json.list, function (val, key) {
                var attribute = new RenamingAttribute(key, "Attribute", that, _options);
                attribute.setValueFromJSON(json.list[key]);
                that.addAttribute(attribute);
                _$node.find(".list").append(attribute.get$node());
            });
        };
        _$node.find(".attribute_name").text(this.getName());
        for (var attrId in _list) {
            if (_list.hasOwnProperty(attrId)) {
                _$node.find(".list").append(_list[attrId].get$node());
            }
        }
        const nodesMap = y.getMap("nodes");
        nodesMap.get(subjectEntity.getEntityId()).observe(function (event) {
            const array = Array.from(event.changes.keys.entries());
            array.forEach(function ([key, value]) {
                if (key.indexOf("[val]") != -1) {
                    const action = value.action;
                    switch (action) {
                        case "add": {
                            const operation = new AttributeAddOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                            attributeAddCallback(operation);
                            break;
                        }
                        case "delete": {
                            const operation = new AttributeDeleteOperation(key.replace(/\[\w*\]/g, ""), that.getEntityId(), that.getRootSubjectEntity().getEntityId(), that.constructor.name);
                            attributeDeleteCallback(operation);
                            break;
                        }
                    }
                }
            });
        });
    }
}
const relationshipNodeHtml = "<div class=\"attribute_default_node\">\n  <h4 class=\"attribute_type text-center\"><%=type%></h4>\n  <div class=\"label\"></div>\n  <div class=\"attributes\"></div>\n  <p class=\"show_hint\"><a href=\"#\">Show list of possible connections</a></p>\n  <p class=\"hint\"></p>\n</div>\n";
const relationshipGroupNodeHtml = "<div class=\"attribute_default_node\">\n  <div class=\"attribute_type\">Relation</div>\n  <div class=\"label\"></div>\n  <div class=\"attributes\"></div>\n  <p class=\"show_hint\"><a href=\"#\">Show list of possible connections</a></p>\n  <p class=\"hint\"></p>\n</div>\n";
const objectNodeHtml = "<div class=\"attribute_default_node\">\n  <h4 class=\"attribute_type text-center\"><%=type%></h4>\n  <div class=\"label\"></div>\n  <div class=\"attributes\"></div>\n  <p class=\"show_hint\"><a href=\"#\">Show list of possible connections</a></p>\n  <p class=\"hint\"></p>\n</div>\n";
const nodeShapeNodeHtml = "<div class=\"attribute_default_node\">\n  <h4 class=\"attribute_type text-center\">Node Shape</h4>\n  <div class=\"label\"></div>\n  <div class=\"attributes\"></div>\n  <p class=\"show_hint\"><a href=\"#\">Show list of possible connections</a></p>\n  <p class=\"hint\"></p>\n</div>\n";
const modelAttributesNodeHtml = "<div class=\"attribute_default_node\">\n  <div class=\"attribute_type\">Model Attributes</div>\n  <div class=\"label\"></div>\n  <div class=\"attributes\"></div>\n</div>\n";
const enumNodeHtml = "<div class=\"attribute_default_node\">\n  <div class=\"attribute_type\">Enumeration</div>\n  <div class=\"label\"></div>\n  <div class=\"attributes\"></div>\n  <p class=\"show_hint\"><a href=\"#\">Show list of possible connections</a></p>\n  <p class=\"hint\"></p>\n</div>\n";
const edgeShapeNodeHtml = "<div class=\"attribute_default_node\">\n  <div class=\"attribute_type\">Edge Shape</div>\n  <div class=\"label\"></div>\n  <div class=\"attributes\"></div>\n  <p class=\"show_hint\"><a href=\"#\">Show list of possible connections</a></p>\n  <p class=\"hint\"></p>\n</div>\n";
const abstractEdgeHtml = "<div class=\"abstract-edge\">\n  <div class=\"attribute_default_node\">\n    <h4 class=\"attribute_type text-center\"><%= type %></h4>\n    <div class=\"label\"></div>\n    <div class=\"attributes\"></div>\n  </div>\n</div>\n";
const abstractClassNodeHtml = "<div class=\"default_node\">\n  <div class=\"attribute_attribute_type\">Abstract Class</div>\n  <div class=\"label\"></div>\n  <div class=\"attributes\"></div>\n  <p class=\"show_hint\"><a href=\"#\">Show list of possible connections</a></p>\n  <p class=\"hint\"></p>\n</div>\n";
const abstractNodeHtml = "<div class=\"attribute_abstract-node\"></div>\n";
const nodeHtml = "<div class=\"attribute_default_node\">\n  <h4 class=\"attribute_type text-center\"><%= type %></h4>\n  <div class=\"label\"></div>\n  <div class=\"attributes\"></div>\n  <p class=\"show_hint\"><a href=\"#\">Show list of possible connections</a></p>\n  <p class=\"hint\"></p>\n</div>\n";
let EntityManager$1 = class EntityManager {
    constructor() {
        var metamodel = null;
        var _layer = null;
        var nodeTypes = {};
        var edgeTypes = {};
        var relations = {};
        var _initNodeTypes = function (vls) {
            var nodes = vls.nodes, node;
            var _nodeTypes = {};
            for (var nodeId in nodes) {
                if (nodes.hasOwnProperty(nodeId)) {
                    node = nodes[nodeId];
                    if (node.hasOwnProperty("targetName") &&
                        !$.isEmptyObject(nodeTypes) &&
                        nodeTypes.hasOwnProperty(node.targetName)) {
                        _nodeTypes[node.label] = makeViewNode(node.label, node.attributes, nodeTypes[node.targetName]);
                        nodeTypes[node.targetName].VIEWTYPE = node.label;
                    }
                    else {
                        _nodeTypes[node.label] = makeNode(node.label, node.shape.shape, node.shape.customShape, node.shape.customAnchors, node.shape.color, node.attributes);
                    }
                }
            }
            return _nodeTypes;
        };
        var _initEdgeTypes = function (vls) {
            var edges = vls.edges, edge;
            var _edgeTypes = {}, _relations = {};
            for (var edgeId in edges) {
                if (edges.hasOwnProperty(edgeId)) {
                    edge = edges[edgeId];
                    if (edge.hasOwnProperty("targetName") &&
                        !$.isEmptyObject(edgeTypes) &&
                        edgeTypes.hasOwnProperty(edge.targetName)) {
                        _edgeTypes[edge.label] = makeViewEdge(edge.attributes, edgeTypes[edge.targetName]);
                        edgeTypes[edge.targetName].VIEWTYPE = edge.label;
                    }
                    else {
                        _edgeTypes[edge.label] = makeEdge(edge.label, edge.shape.arrow, edge.shape.shape, edge.shape.color, edge.shape.overlay, edge.shape.overlayPosition, edge.shape.overlayRotate, edge.attributes);
                    }
                    _relations[edge.label] = edge.relations;
                }
            }
            return {
                edgeTypes: _edgeTypes,
                relations: _relations,
            };
        };
        var _nodes = {};
        var viewId = null;
        var viewNodeTypes = {};
        var viewEdgeTypes = {};
        var _edges = {};
        this.createNode = function (type, id, left, top, width, height, containment, json) {
            var node;
            if (viewNodeTypes.hasOwnProperty(type) && viewId) {
                node = viewNodeTypes[type](id, left, top, width, height, json);
            }
            else if (nodeTypes.hasOwnProperty(type)) {
                node = new nodeTypes[type](id, left, top, width, height, json);
            }
            _nodes[id] = node;
            return node;
        };
        this.createModelAttributesNode = function () {
            if (metamodel)
                return new ModelAttributesNode("modelAttributes", metamodel.attributes);
            else
                return new ModelAttributesNode("modelAttributes", null);
        };
        this.findNode = function (id) {
            if (_nodes.hasOwnProperty(id)) {
                return _nodes[id];
            }
            return null;
        };
        this.deleteNode = function (id) {
            if (_nodes.hasOwnProperty(id)) {
                delete _nodes[id];
            }
        };
        this.getNodesByType = function (type) {
            var nodeId, node, nodesByType = {};
            if (typeof type === "string") {
                type = [type];
            }
            for (nodeId in _nodes) {
                if (_nodes.hasOwnProperty(nodeId)) {
                    node = _nodes[nodeId];
                    if (type.indexOf(node.getType()) !== -1) {
                        nodesByType[nodeId] = node;
                    }
                }
            }
            return nodesByType;
        };
        this.getEdgesByType = function (type) {
            var edgeId, edge, edgesByType = {};
            for (edgeId in _edges) {
                if (_edges.hasOwnProperty(edgeId)) {
                    edge = _edges[edgeId];
                    if (edge.getType() === type) {
                        edgesByType[edgeId] = edge;
                    }
                }
            }
            return edgesByType;
        };
        this.createEdge = function (type, id, source, target) {
            if (!source || !target) {
                throw new Error("Source or target node is not defined");
            }
            var edge;
            if (viewId && viewEdgeTypes.hasOwnProperty(type)) {
                edge = viewEdgeTypes[type](id, source, target);
            }
            else if (edgeTypes.hasOwnProperty(type)) {
                edge = new edgeTypes[type](id, source, target);
            }
            source.addOutgoingEdge(edge);
            target.addIngoingEdge(edge);
            _edges[id] = edge;
            return edge;
        };
        this.findEdge = function (id) {
            if (_edges.hasOwnProperty(id)) {
                return _edges[id];
            }
            return null;
        };
        this.deleteEdge = function (id) {
            if (_edges.hasOwnProperty(id)) {
                delete _edges[id];
            }
        };
        this.find = function (id) {
            return this.findNode(id) || this.findEdge(id);
        };
        this.createModelAttributesNodeFromJSON = function (json) {
            var node = this.createModelAttributesNode();
            if (node) {
                node.getLabel().getValue().setValue(json.label.value.value);
                for (var attrId in json.attributes) {
                    if (json.attributes.hasOwnProperty(attrId)) {
                        var attr = node.getAttribute(attrId);
                        if (attr) {
                            attr.setValueFromJSON(json.attributes[attrId]);
                        }
                    }
                }
            }
            return node;
        };
        this.createNodeFromJSON = function (type, id, left, top, width, height, containment, json) {
            var node = this.createNode(type, id, left, top, width, height, containment, json);
            if (!node) {
                console.error("Node could not be created: " + type + " " + id);
                return null;
            }
            node.getLabel().getValue().setValue(json.label.value.value);
            for (var attrId in json.attributes) {
                if (json.attributes.hasOwnProperty(attrId)) {
                    var attr = node.getAttribute(attrId);
                    if (attr) {
                        attr.setValueFromJSON(json.attributes[attrId]);
                    }
                    else {
                        var newId = attrId.replace(/[^\[\]]*/, id);
                        attr = node.getAttribute(newId);
                        if (attr)
                            attr.setValueFromJSON(json.attributes[attrId]);
                        else {
                            var attributeList = node.getAttributes();
                            this.setAttributesByName(attributeList, json.attributes[attrId].name, json.attributes[attrId]);
                        }
                    }
                }
            }
            return node;
        };
        this.createEdgeFromJSON = function (type, id, sourceId, targetId, json) {
            const sourceNode = this.findNode(sourceId);
            const targetNode = this.findNode(targetId);
            var edge = this.createEdge(type, id, sourceNode, targetNode, viewId);
            if (edge) {
                edge.getLabel().getValue().setValue(json.label.value.value);
                for (var attrId in json.attributes) {
                    if (json.attributes.hasOwnProperty(attrId)) {
                        var attr = edge.getAttribute(attrId);
                        if (attr) {
                            attr.setValueFromJSON(json.attributes[attrId]);
                        }
                        else {
                            var attributeList = edge.getAttributes();
                            this.setAttributesByName(attributeList, json.attributes[attrId].name, json.attributes[attrId]);
                        }
                    }
                }
            }
            return edge;
        };
        this.setAttributesByName = (attributeList, name, value) => {
            for (var key in attributeList) {
                if (attributeList.hasOwnProperty(key) &&
                    attributeList[key].getName() === name) {
                    attributeList[key].setValueFromJSON(value);
                    break;
                }
            }
        };
        this.generateConnectToText = (node) => {
            function mapTargetNodeItems(e) {
                return "<i>" + e + "</i>";
            }
            var connectionType, sourceNodeTypes, targetNodeTypes, targetNodeType, connectionItems, targetNodeTypeItems, targetNodeItems, i, numOfRelations, j, numOfTargetTypes, targetNodes, targetNodeId, targetNode;
            connectionItems = [];
            for (connectionType in relations) {
                if (relations.hasOwnProperty(connectionType)) {
                    targetNodeTypeItems = [];
                    for (i = 0, numOfRelations = relations[connectionType].length; i < numOfRelations; i++) {
                        sourceNodeTypes = relations[connectionType][i].sourceTypes;
                        targetNodeTypes = relations[connectionType][i].targetTypes;
                        if (sourceNodeTypes.indexOf(node.getType()) !== -1) {
                            for (j = 0, numOfTargetTypes = targetNodeTypes.length; j < numOfTargetTypes; j++) {
                                targetNodeType = targetNodeTypes[j];
                                targetNodeItems = [];
                                targetNodes = this.getNodesByType(targetNodeType);
                                for (targetNodeId in targetNodes) {
                                    if (targetNodes.hasOwnProperty(targetNodeId)) {
                                        targetNode = targetNodes[targetNodeId];
                                        if (targetNode === node ||
                                            targetNode
                                                .getNeighbors()
                                                .hasOwnProperty(node.getEntityId()))
                                            continue;
                                        targetNodeItems.push(targetNode.getLabel().getValue().getValue() ||
                                            targetNode.getType());
                                    }
                                }
                                targetNodeItems.sort();
                                if (lodash.size(targetNodeItems) > 0) {
                                    targetNodeTypeItems.push(" to <strong>" +
                                        targetNodeType +
                                        "</strong> " +
                                        lodash.map(targetNodeItems, mapTargetNodeItems).join(", "));
                                }
                            }
                        }
                    }
                    if (lodash.size(targetNodeTypeItems) > 0) {
                        connectionItems.push("..with <strong>" +
                            connectionType +
                            "</strong> " +
                            targetNodeTypeItems.join(", "));
                    }
                }
            }
            if (lodash.size(connectionItems) > 0) {
                return ("This node can be connected..<br>" +
                    lodash.map(connectionItems, function (e) {
                        return e + "<br>";
                    }).join(""));
            }
            else {
                return "";
            }
        };
        this.initNodeTypes = (vls) => {
            nodeTypes = _initNodeTypes(vls);
        };
        this.initEdgeTypes = function (vls) {
            var res = _initEdgeTypes(vls);
            edgeTypes = res.edgeTypes;
            relations = res.relations;
        };
        this.initModelTypes = function (vls) {
            this.initNodeTypes(vls);
            this.initEdgeTypes(vls);
        };
        this.getNodeType = function (type) {
            return nodeTypes.hasOwnProperty(type) ? nodeTypes[type] : null;
        };
        this.getEdgeType = function (type) {
            return edgeTypes.hasOwnProperty(type) ? edgeTypes[type] : null;
        };
        this.initViewNodeTypes = function (vvs) {
            for (var nodeTypeName in nodeTypes) {
                if (nodeTypes.hasOwnProperty(nodeTypeName)) {
                    delete nodeTypes[nodeTypeName].VIEWTYPE;
                }
            }
            viewNodeTypes = _initNodeTypes(vvs);
        };
        this.initViewEdgeTypes = function (vvs) {
            for (var edgeTypeName in edgeTypes) {
                if (edgeTypes.hasOwnProperty(edgeTypeName)) {
                    delete edgeTypes[edgeTypeName].VIEWTYPE;
                }
            }
            var res = _initEdgeTypes(vvs);
            viewEdgeTypes = res.edgeTypes;
            relations = res.relations;
        };
        this.initViewTypes = function (vvs) {
            this.setViewId(vvs.id);
            this.initViewNodeTypes(vvs);
            this.initViewEdgeTypes(vvs);
        };
        this.getViewNodeType = function (type) {
            return viewNodeTypes.hasOwnProperty(type) ? viewNodeTypes[type] : null;
        };
        this.getViewEdgeType = function (type) {
            return viewEdgeTypes.hasOwnProperty(type) ? viewEdgeTypes[type] : null;
        };
        this.setViewId = function (id) {
            viewId = id;
        };
        this.getViewId = function () {
            return viewId;
        };
        this.getLayer = function () {
            return _layer;
        };
        this.init = function (mm) {
            console.log("init model types for attribute widget");
            metamodel = mm;
            if (metamodel && metamodel.hasOwnProperty("nodes")) {
                nodeTypes = _initNodeTypes(metamodel);
                _layer = CONFIG$1.LAYER.MODEL;
            }
            else {
                _layer = CONFIG$1.LAYER.META;
                nodeTypes[ObjectNode.TYPE] = ObjectNode;
                nodeTypes[AbstractClassNode.TYPE] = AbstractClassNode;
                nodeTypes[RelationshipNode.TYPE] = RelationshipNode;
                nodeTypes[RelationshipGroupNode.TYPE] = RelationshipGroupNode;
                nodeTypes[EnumNode.TYPE] = EnumNode;
                nodeTypes[NodeShapeNode.TYPE] = NodeShapeNode;
                nodeTypes[EdgeShapeNode.TYPE] = EdgeShapeNode;
                nodeTypes[ViewObjectNode.TYPE] = ViewObjectNode;
                nodeTypes[ViewRelationshipNode.TYPE] = ViewRelationshipNode;
            }
            if (metamodel && metamodel.hasOwnProperty("edges")) {
                var res = _initEdgeTypes(metamodel);
                edgeTypes = res.edgeTypes;
                relations = res.relations;
            }
            else {
                edgeTypes[GeneralisationEdge.TYPE] = GeneralisationEdge;
                edgeTypes[BiDirAssociationEdge.TYPE] = BiDirAssociationEdge;
                edgeTypes[UniDirAssociationEdge.TYPE] = UniDirAssociationEdge;
                relations[BiDirAssociationEdge.TYPE] = BiDirAssociationEdge.RELATIONS;
                relations[UniDirAssociationEdge.TYPE] = UniDirAssociationEdge.RELATIONS;
                relations[GeneralisationEdge.TYPE] = GeneralisationEdge.RELATIONS;
            }
        };
        this.getEdges = function () {
            return _edges;
        };
        this.getNodes = function () {
            return _nodes;
        };
    }
};
const EntityManagerInstance = new EntityManager$1();
function makeNode(type, shapeType, customShape, customAnchors, color, attributes) {
    class Node extends AbstractNode {
        constructor(id, left, top, width, height) {
            super(id, type, left, top, width, height);
            var that = this;
            var $template = $(lodash.template(nodeHtml)({ type: type }));
            var _$node = AbstractNode.prototype.get$node.call(this).append($template);
            var init = function () {
                var attribute, attributeId, attrObj = {};
                for (attributeId in attributes) {
                    if (attributes.hasOwnProperty(attributeId)) {
                        attribute = attributes[attributeId];
                        if (attribute.hasOwnProperty("visibility") &&
                            attribute.visibility === "hide")
                            continue;
                        switch (attribute.value) {
                            case "boolean":
                                attrObj[attributeId] = new BooleanAttribute(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            case "string":
                                attrObj[attributeId] = new SingleValueAttribute(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                if (attribute.key.toLowerCase() === "label" ||
                                    attribute.key.toLowerCase() === "title" ||
                                    attribute.key.toLowerCase() === "name") {
                                    that.setLabel(attrObj[attributeId]);
                                }
                                break;
                            case "integer":
                                attrObj[attributeId] = new IntegerAttribute(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            case "file":
                                attrObj[attributeId] = new FileAttribute(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            case "quiz":
                                attrObj[attributeId] = new QuizAttribute(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                if (attribute.key.toLowerCase() === "label" ||
                                    attribute.key.toLowerCase() === "title" ||
                                    attribute.key.toLowerCase() === "name") {
                                    that.setLabel(attrObj[attributeId]);
                                }
                            default:
                                if (attribute.options) {
                                    attrObj[attributeId] = new SingleSelectionAttribute(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that, attribute.options);
                                }
                        }
                    }
                }
                that.setAttributes(attrObj);
                var $attributeNode = _$node.find(".attributes");
                for (var attributeKey in attrObj) {
                    if (attrObj.hasOwnProperty(attributeKey)) {
                        $attributeNode.append(attrObj[attributeKey].get$node());
                    }
                }
            };
            init();
        }
        static getType() {
            return type;
        }
        static getAttributes() {
            return attributes;
        }
        registerYType() {
            AbstractNode.prototype.registerYType.call(this);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(this.getEntityId());
            var attr = this.getAttributes();
            for (var key in attr) {
                if (attr.hasOwnProperty(key)) {
                    var val = attr[key].getValue();
                    var ytext = ymap.get(val.getEntityId());
                    if (val.hasOwnProperty("registerYType")) {
                        val.registerYType(ytext);
                    }
                }
            }
        }
        applyAttributeRenaming(renamingAttributes) {
            var renAttr, $attr, attributes = this.getAttributes();
            for (var attrKey in attributes) {
                if (attributes.hasOwnProperty(attrKey)) {
                    renAttr = renamingAttributes[attrKey];
                    $attr = attributes[attrKey].get$node();
                    if (renAttr) {
                        if (renAttr.visibility === "hide") {
                            $attr.hide();
                        }
                        else {
                            $attr.find(".attribute_name").text(renAttr.key);
                            if ($attr.is(":hidden")) {
                                $attr.show();
                            }
                        }
                    }
                    else {
                        $attr.hide();
                    }
                }
            }
        }
    }
    return Node;
}
class AbstractNode extends AbstractEntity {
    constructor(id, type, left, top, width, height, containment, viewId) {
        super(id);
        var that = this;
        var _viewId = viewId;
        var _type = type;
        var _containment = containment;
        var _label = new SingleValueAttribute(id + "[label]", "Label", this);
        var appearance = {
            left: left,
            top: top,
            width: width,
            height: height,
        };
        var _wrapper = null;
        var _$node = $(lodash.template(abstractNodeHtml)({ id: id }));
        var _iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var _attributes = {};
        var _ingoingEdges = {};
        var _outgoingEdges = {};
        var _ingoingNeighbors = {};
        var _outgoingNeighbors = {};
        var processNodeDeleteOperation = function (operation) {
            var edges = that.getEdges(), edgeId, edge;
            for (edgeId in edges) {
                if (edges.hasOwnProperty(edgeId)) {
                    edge = edges[edgeId];
                    edge.remove();
                }
            }
            that.remove();
        };
        var entitySelectCallback = function (operation) {
            if (operation instanceof EntitySelectOperation &&
                operation.getSelectedEntityId() === that.getEntityId()) {
                $(".ace-container").hide();
                if (_wrapper.get$node().is(":hidden"))
                    _wrapper.get$node().show();
                _wrapper.select(that);
            }
        };
        var nodeDeleteCallback = function (operation) {
            if (operation instanceof NodeDeleteOperation &&
                operation.getEntityId() === that.getEntityId()) {
                processNodeDeleteOperation();
            }
        };
        var init = function () {
            _$node
                .find(".show_hint a")
                .click(function (e) {
                var $this = $(this), $hint = _$node.find(".hint");
                e.preventDefault();
                if ($hint.is(":visible")) {
                    $hint.hide();
                    $this.text("Show list of possible connections");
                }
                else {
                    $hint.show();
                    $this.text("Hide list of possible connections");
                }
            })
                .text("Show list of possible connections");
            _$node.find(".hint").hide();
        };
        this.addToWrapper = function (wrapper) {
            _wrapper = wrapper;
            _wrapper.get$node().append(_$node.hide());
            init();
        };
        this.removeFromWrapper = function () {
            _wrapper = null;
            _$node.remove();
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_attributes.hasOwnProperty(id)) {
                _attributes[id] = attribute;
            }
        };
        this.getAttribute = function (id) {
            if (_attributes.hasOwnProperty(id)) {
                return _attributes[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (!_attributes.hasOwnProperty(id)) {
                delete _attributes[id];
            }
        };
        this.setAttributes = function (attributes) {
            _attributes = attributes;
        };
        this.getAttributes = function () {
            return _attributes;
        };
        this.setLabel = function (label) {
            _label = label;
        };
        this.getViewId = function () {
            return _viewId;
        };
        this.setViewId = function (viewId) {
            _viewId = viewId;
        };
        this.getLabel = function () {
            return _label;
        };
        this.getType = function () {
            return _type;
        };
        this.getContainment = function () {
            return _containment;
        };
        this._get$node = function () {
            return _$node;
        };
        this.addIngoingEdge = function (edge) {
            var id = edge.getEntityId();
            var source = edge.getSource();
            var sourceEntityId = source.getEntityId();
            if (!_ingoingEdges.hasOwnProperty(id)) {
                _ingoingEdges[id] = edge;
                if (!_ingoingNeighbors.hasOwnProperty(sourceEntityId)) {
                    _ingoingNeighbors[sourceEntityId] = source;
                }
            }
        };
        this.addOutgoingEdge = function (edge) {
            var id = edge.getEntityId();
            var target = edge.getTarget();
            var targetEntityId = target?.getEntityId();
            if (!_outgoingEdges.hasOwnProperty(id)) {
                _outgoingEdges[id] = edge;
                if (!_outgoingNeighbors.hasOwnProperty(targetEntityId)) {
                    _outgoingNeighbors[targetEntityId] = target;
                }
            }
        };
        this.deleteIngoingEdge = function (edge) {
            var id = edge.getEntityId();
            var source = edge.getSource();
            var sourceEntityId = source.getEntityId();
            var isMultiEdge = false;
            if (_ingoingEdges.hasOwnProperty(id)) {
                delete _ingoingEdges[id];
                for (var edgeId in _ingoingEdges) {
                    if (_ingoingEdges.hasOwnProperty(edgeId) &&
                        _ingoingEdges[edgeId].getSource().getEntityId() === sourceEntityId) {
                        isMultiEdge = true;
                    }
                }
                if (!isMultiEdge) {
                    delete _ingoingNeighbors[sourceEntityId];
                }
            }
        };
        this.deleteOutgoingEdge = function (edge) {
            var id = edge.getEntityId();
            var target = edge.getTarget();
            var targetEntityId = target?.getEntityId();
            var isMultiEdge = false;
            if (_outgoingEdges.hasOwnProperty(id)) {
                delete _outgoingEdges[id];
                for (var edgeId in _outgoingEdges) {
                    if (_outgoingEdges.hasOwnProperty(edgeId) &&
                        _outgoingEdges[edgeId].getTarget().getEntityId() === targetEntityId) {
                        isMultiEdge = true;
                    }
                }
                if (!isMultiEdge) {
                    delete _outgoingNeighbors[targetEntityId];
                }
            }
        };
        this.getIngoingEdges = function () {
            return _ingoingEdges;
        };
        this.getOutgoingEdges = function () {
            return _outgoingEdges;
        };
        this.getEdges = function () {
            return Util.union(_ingoingEdges, _outgoingEdges);
        };
        this.getIngoingNeighbors = function () {
            return _ingoingNeighbors;
        };
        this.getOutgoingNeighbors = function () {
            return _outgoingNeighbors;
        };
        this.getNeighbors = function () {
            return Util.union(_ingoingNeighbors, _outgoingNeighbors);
        };
        this.select = function () {
            var connectToText = EntityManagerInstance.generateConnectToText(this);
            _$node.find(".hint").html(connectToText).hide();
            _$node.find(".show_hint").toggle(connectToText !== "");
            this.show();
        };
        this.unselect = function () {
            this.hide();
        };
        this.hide = function () {
            _$node.hide();
        };
        this.show = function () {
            _$node.show();
        };
        this._remove = function () {
            this.removeFromWrapper();
            this.unregisterCallbacks();
            var EntityManager = EntityManagerInstance;
            EntityManager.deleteNode(this.getEntityId());
            this.unregisterCallbacks();
        };
        this.toJSON = function () {
            return {
                id: id,
                label: _label.getValue(),
                appearance: appearance,
            };
        };
        this.registerCallbacks = function () {
            _iwc.registerOnDataReceivedCallback(entitySelectCallback);
            _iwc.registerOnDataReceivedCallback(nodeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            _iwc.unregisterOnDataReceivedCallback(entitySelectCallback);
            _iwc.unregisterOnDataReceivedCallback(nodeDeleteCallback);
        };
        this._registerYType = function () {
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(that.getEntityId());
            if (ymap) {
                var ytext = ymap.get(that.getLabel().getValue().getEntityId());
                that.getLabel().getValue().registerYType(ytext);
            }
        };
        if (_iwc) {
            that.registerCallbacks();
        }
    }
    draw() {
        return this._draw();
    }
    get$node() {
        return this._get$node();
    }
    registerYType() {
        this._registerYType();
    }
    remove() {
        this._remove();
    }
}
class AbstractEdge extends AbstractEntity {
    constructor(type, id, source, target, viewId) {
        super(id);
        var that = this;
        var _type = type;
        var _viewId = viewId;
        var _label = new SingleValueAttribute(id + "[label]", "Label", this);
        var _appearance = {
            source: source,
            target: target,
        };
        var _$node = $(lodash.template(abstractEdgeHtml)({ id: id, type: type }));
        var _wrapper = null;
        var iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var _attributes = {};
        var processEdgeDeleteOperation = function (operation) {
            that.getSource().deleteOutgoingEdge(that);
            that.getTarget().deleteIngoingEdge(that);
            that.remove();
        };
        var entitySelectCallback = function (operation) {
            if (operation instanceof EntitySelectOperation &&
                operation.getSelectedEntityId() === that.getEntityId()) {
                $(".ace-container").hide();
                if (_wrapper.get$node().is(":hidden"))
                    _wrapper.get$node().show();
                _wrapper.select(that);
            }
        };
        var edgeDeleteCallback = function (operation) {
            if (operation instanceof EdgeDeleteOperation &&
                operation.getEntityId() === that.getEntityId()) {
                processEdgeDeleteOperation();
            }
        };
        this.addToWrapper = function (wrapper) {
            _wrapper = wrapper;
            _wrapper.get$node().append(_$node.hide());
        };
        this.removeFromWrapper = function () {
            _wrapper = null;
            _$node.detach();
        };
        this.addAttribute = function (attribute) {
            var id = attribute.getEntityId();
            if (!_attributes.hasOwnProperty(id)) {
                _attributes[id] = attribute;
            }
        };
        this.setAttributes = function (attributes) {
            _attributes = attributes;
        };
        this.getAttributes = function () {
            return _attributes;
        };
        this.getAttribute = function (id) {
            if (_attributes.hasOwnProperty(id)) {
                return _attributes[id];
            }
            return null;
        };
        this.deleteAttribute = function (id) {
            if (!_attributes.hasOwnProperty(id)) {
                delete _attributes[id];
            }
        };
        this.setLabel = function (label) {
            _label = label;
        };
        this.getLabel = function () {
            return _label;
        };
        this.getViewId = function () {
            return _viewId;
        };
        this.setViewId = function (viewId) {
            _viewId = viewId;
        };
        this.getType = function () {
            return _type;
        };
        this.getSource = function () {
            return _appearance.source;
        };
        this.getTarget = function () {
            return _appearance.target;
        };
        this._get$node = function () {
            return _$node;
        };
        this.select = function () {
            this.show();
        };
        this.unselect = function () {
            this.hide();
        };
        this.hide = function () {
            _$node.hide();
        };
        this.show = function () {
            _$node.show();
        };
        this.remove = function () {
            source.deleteOutgoingEdge(this);
            target.deleteIngoingEdge(this);
            this.removeFromWrapper();
            this.unregisterCallbacks();
            var EntityManager = EntityManagerInstance;
            EntityManager.deleteEdge(this.getEntityId());
        };
        this.toJSON = function () {
            return {
                id: id,
                label: _label,
                appearance: _appearance,
            };
        };
        this.registerCallbacks = function () {
            iwc.registerOnDataReceivedCallback(entitySelectCallback);
            iwc.registerOnDataReceivedCallback(edgeDeleteCallback);
        };
        this.unregisterCallbacks = function () {
            iwc.unregisterOnDataReceivedCallback(entitySelectCallback);
            iwc.unregisterOnDataReceivedCallback(edgeDeleteCallback);
        };
        this._registerYType = function () {
            const edgeMap = y.getMap("edges");
            var ymap = edgeMap.get(that.getEntityId());
            if (ymap) {
                var ytext = ymap.get(that.getLabel().getValue().getEntityId());
                that.getLabel().getValue().registerYType(ytext);
            }
        };
        _$node.find(".label").append(this.getLabel().get$node());
        if (iwc) {
            that.registerCallbacks();
        }
    }
    get$node() {
        return this._get$node();
    }
    registerYType() {
        this._registerYType();
    }
}
class AbstractClassNode extends AbstractNode {
    constructor(id, left, top, width, height) {
        super(id, AbstractClassNode.TYPE, left, top, width, height);
        var that = this;
        var _$template = $(lodash.template(abstractClassNodeHtml)());
        var _$node = AbstractNode.prototype.get$node.call(this).append(_$template);
        var _$attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        this.addAttribute(new KeySelectionValueListAttribute("[attributes]", "Attributes", this, {
            string: "String",
            boolean: "Boolean",
            integer: "Integer",
            file: "File",
            quiz: "Questions",
        }));
        _$node.find(".label").append(this.getLabel().get$node());
        this.registerYType = function () {
            AbstractNode.prototype.registerYType.call(this);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(that.getEntityId());
            var attrs = _attributes["[attributes]"].getAttributes();
            for (var attributeKey in attrs) {
                if (attrs.hasOwnProperty(attributeKey)) {
                    var keyVal = attrs[attributeKey].getKey();
                    var ytext = ymap.get(keyVal.getEntityId());
                    keyVal.registerYType(ytext);
                }
            }
        };
        for (var attributeKey in _attributes) {
            if (_attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(_attributes[attributeKey].get$node());
            }
        }
    }
    static { this.TYPE = "Abstract Class"; }
}
function makeEdge(type, arrowType, shapeType, color, overlay, overlayPosition, overlayRotate, attributes) {
    class Edge extends AbstractEdge {
        constructor(id, source, target) {
            super(type, id, source, target);
            var that = this;
            var _$node = AbstractEdge.prototype.get$node.call(this);
            var init = function () {
                var attribute, attributeId, attrObj = {};
                for (attributeId in attributes) {
                    if (attributes.hasOwnProperty(attributeId)) {
                        attribute = attributes[attributeId];
                        if (attribute.hasOwnProperty("position") &&
                            attribute.position === "hide")
                            continue;
                        switch (attribute.value) {
                            case "boolean":
                                attrObj[attributeId] = new BooleanAttribute(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            case "string":
                                attrObj[attributeId] = new SingleValueAttribute(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            case "integer":
                                attrObj[attributeId] = new IntegerAttribute(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            case "file":
                                attrObj[attributeId] = new FileAttribute(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that);
                                break;
                            default:
                                if (attribute.options) {
                                    attrObj[attributeId] = new SingleSelectionAttribute(id + "[" + attribute.key.toLowerCase() + "]", attribute.key, that, attribute.options);
                                }
                        }
                    }
                }
                that.setAttributes(attrObj);
                var $attributeNode = _$node.find(".attributes");
                for (var attributeKey in attrObj) {
                    if (attrObj.hasOwnProperty(attributeKey)) {
                        $attributeNode.append(attrObj[attributeKey].get$node());
                    }
                }
            };
            this.registerYType = function () {
                AbstractEdge.prototype.registerYType.call(this);
                const edgeMap = y.getMap("edges");
                var ymap = edgeMap.get(that.getEntityId());
                var attr = that.getAttributes();
                for (var key in attr) {
                    if (attr.hasOwnProperty(key)) {
                        var val = attr[key].getValue();
                        if (val.hasOwnProperty("registerYType")) {
                            var ytext = ymap.get(val.getEntityId());
                            val.registerYType(ytext);
                        }
                    }
                }
            };
            init();
        }
        static getType() {
            return type;
        }
        static getAttributes() {
            return attributes;
        }
        applyAttributeRenaming(renamingAttributes) {
            var renAttr, $attr, attributes = this.getAttributes();
            for (var attrKey in attributes) {
                if (attributes.hasOwnProperty(attrKey)) {
                    renAttr = renamingAttributes[attrKey];
                    $attr = attributes[attrKey].get$node();
                    if (renAttr) {
                        if (renAttr.position === "hide") {
                            $attr.hide();
                        }
                        else {
                            $attr.find(".attribute_name").text(renAttr.key);
                            if ($attr.is(":hidden")) {
                                $attr.show();
                            }
                        }
                    }
                    else {
                        $attr.hide();
                    }
                }
            }
        }
    }
    return Edge;
}
class EdgeShapeNode extends AbstractNode {
    constructor(id, left, top, width, height) {
        super(id, EdgeShapeNode.TYPE, left, top, width, height);
        var that = this;
        var _$template = $(lodash.template(edgeShapeNodeHtml)());
        var _$node = AbstractNode.prototype.get$node.call(this).append(_$template);
        var $attributeNode = _$node.find(".attributes");
        var attributes = this.getAttributes();
        this.addAttribute(new SingleSelectionAttribute(this.getEntityId() + "[arrow]", "Arrow", this, {
            bidirassociation: "---",
            unidirassociation: "-->",
            generalisation: "--▷",
            diamond: "-◁▷",
        }));
        this.addAttribute(new SingleSelectionAttribute(this.getEntityId() + "[shape]", "Shape", this, { straight: "Straight", curved: "Curved", segmented: "Segmented" }));
        this.addAttribute(new SingleColorValueAttribute(this.getEntityId() + "[color]", "Color", this));
        this.addAttribute(new SingleValueAttribute(this.getEntityId() + "[overlay]", "Overlay Text", this));
        this.addAttribute(new SingleSelectionAttribute(this.getEntityId() + "[overlayPosition]", "Overlay Position", this, { hidden: "Hide", top: "Top", center: "Center", bottom: "Bottom" }));
        this.addAttribute(new BooleanAttribute(this.getEntityId() + "[overlayRotate]", "Autoflip Overlay", this));
        _$node.find(".label").append(this.getLabel().get$node());
        this.registerYType = function () {
            AbstractNode.prototype.registerYType.call(this);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(that.getEntityId());
            var colorVal = that
                .getAttribute(that.getEntityId() + "[color]")
                .getValue();
            var ytextColor = ymap.get(colorVal.getEntityId());
            colorVal.registerYType(ytextColor);
            var customShapeVal = that
                .getAttribute(that.getEntityId() + "[overlay]")
                .getValue();
            var ytextCustomShape = ymap.get(customShapeVal.getEntityId());
            customShapeVal.registerYType(ytextCustomShape);
        };
        for (var attributeKey in attributes) {
            if (attributes.hasOwnProperty(attributeKey)) {
                $attributeNode.append(attributes[attributeKey].get$node());
            }
        }
    }
    static { this.TYPE = "Edge Shape"; }
}
class EnumNode extends AbstractNode {
    constructor(id, left, top, width, height) {
        super(id, EnumNode.TYPE, left, top, width, height);
        var that = this;
        var _$template = $(lodash.template(enumNodeHtml)());
        var _$node = AbstractNode.prototype.get$node.call(this).append(_$template);
        var $attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        this.addAttribute(new SingleValueListAttribute("[attributes]", "Attributes", this));
        _$node.find(".label").append(this.getLabel().get$node());
        this.registerYMap = function () {
            AbstractNode.prototype.registerYType.call(this);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(that.getEntityId());
            var attrs = _attributes["[attributes]"].getAttributes();
            for (var attributeKey in attrs) {
                if (attrs.hasOwnProperty(attributeKey)) {
                    var val = attrs[attributeKey].getValue();
                    var ytext = ymap.get(val.getEntityId());
                    val.registerYType(ytext);
                }
            }
        };
        for (var attributeKey in _attributes) {
            if (_attributes.hasOwnProperty(attributeKey)) {
                $attributeNode.append(_attributes[attributeKey].get$node());
            }
        }
    }
    static { this.TYPE = "Enumeration"; }
}
class ModelAttributesNode extends AbstractNode {
    constructor(id, attr) {
        super(id, ModelAttributesNode.TYPE, 0, 0, 0, 0);
        var _$template = $(lodash.template(modelAttributesNodeHtml)());
        var _$node = AbstractNode.prototype.get$node.call(this).append(_$template);
        var _$attributeNode = _$node.find(".attributes");
        var attributes = this.getAttributes();
        if (attr) {
            if (lodash.size(attr) === 0) {
                _$node.children().hide();
            }
            for (var attrKey in attr) {
                if (attr.hasOwnProperty(attrKey)) {
                    switch (attr[attrKey].value) {
                        case "boolean":
                            this.addAttribute(new BooleanAttribute(this.getEntityId() +
                                "[" +
                                attr[attrKey].key.toLowerCase() +
                                "]", attr[attrKey].key, this));
                            break;
                        case "string":
                            this.addAttribute(new SingleValueAttribute(this.getEntityId() +
                                "[" +
                                attr[attrKey].key.toLowerCase() +
                                "]", attr[attrKey].key, this));
                            break;
                        case "integer":
                            this.addAttribute(new IntegerAttribute(this.getEntityId() +
                                "[" +
                                attr[attrKey].key.toLowerCase() +
                                "]", attr[attrKey].key, this));
                            break;
                        case "file":
                            this.addAttribute(new FileAttribute(this.getEntityId() +
                                "[" +
                                attr[attrKey].key.toLowerCase() +
                                "]", attr[attrKey].key, this));
                            break;
                        default:
                            if (attr[attrKey].options) {
                                this.addAttribute(new SingleSelectionAttribute(this.getEntityId() +
                                    "[" +
                                    attr[attrKey].key.toLowerCase() +
                                    "]", attr[attrKey].key, this, attr[attrKey].options));
                            }
                            break;
                    }
                }
            }
        }
        else {
            this.addAttribute(new SingleValueAttribute(this.getEntityId() + "[name]", "Name", this));
            this.addAttribute(new SingleMultiLineValueAttribute(this.getEntityId() + "[description]", "Description", this));
        }
        this.registerYType = function () {
            var attrs = this.getAttributes();
            for (var key in attrs) {
                if (attrs.hasOwnProperty(key)) {
                    var val = attrs[key].getValue();
                    if (val.constructor.name === "Value" ||
                        val.constructor.name === "MultiLineValue") {
                        const nodesMap = y.getMap("nodes");
                        var ymap = nodesMap.get(this.getEntityId());
                        if (!ymap) {
                            throw new Error("YMap not found");
                        }
                        var ytext = ymap.get(val.getEntityId());
                        val.registerYType(ytext);
                    }
                }
            }
        };
        _$node.find(".label").hide();
        for (var attributeKey in attributes) {
            if (attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(attributes[attributeKey].get$node());
            }
        }
    }
    static { this.TYPE = "ModelAttributesNode"; }
}
class NodeShapeNode extends AbstractNode {
    constructor(id, left, top, width, height, containment) {
        super(id, NodeShapeNode.TYPE, left, top, width, height, containment);
        var that = this;
        var _$template = $(lodash.template(nodeShapeNodeHtml)());
        var _$node = AbstractNode.prototype.get$node.call(this).append(_$template);
        var $attributeNode = _$node.find(".attributes");
        var attributes = this.getAttributes();
        this.addAttribute(new SingleSelectionAttribute(this.getEntityId() + "[shape]", "Shape", this, {
            circle: "Circle",
            diamond: "Diamond",
            rectangle: "Rectangle",
            rounded_rectangle: "Rounded Rectangle",
            triangle: "Triangle",
        }));
        this.addAttribute(new SingleColorValueAttribute(this.getEntityId() + "[color]", "Color", this));
        this.addAttribute(new IntegerAttribute(this.getEntityId() + "[defaultWidth]", "Default Width", this));
        this.addAttribute(new IntegerAttribute(this.getEntityId() + "[defaultHeight]", "Default Height", this));
        this.addAttribute(new BooleanAttribute(this.getEntityId() + "[containment]", "Containment", this));
        this.addAttribute(new SingleCodeEditorValueAttribute(this.getEntityId() + "[customShape]", "Custom Shape", this));
        this.addAttribute(new SingleValueAttribute(this.getEntityId() + "[customAnchors]", "Custom Anchors", this));
        _$node.find(".label").append(this.getLabel().get$node());
        this.registerYType = function () {
            AbstractNode.prototype.registerYType.call(this);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(that.getEntityId());
            var colorVal = that
                .getAttribute(that.getEntityId() + "[color]")
                .getValue();
            var ytextColor = ymap.get(colorVal.getEntityId());
            colorVal.registerYType(ytextColor);
            var customAnchorVal = that
                .getAttribute(that.getEntityId() + "[customAnchors]")
                .getValue();
            var ytextCustomAnchor = ymap.get(customAnchorVal.getEntityId());
            customAnchorVal.registerYType(ytextCustomAnchor);
        };
        for (var attributeKey in attributes) {
            if (attributes.hasOwnProperty(attributeKey)) {
                $attributeNode.append(attributes[attributeKey].get$node());
            }
        }
    }
    static { this.TYPE = "Node Shape"; }
}
class ObjectNode extends AbstractNode {
    constructor(id, left, top, width, height) {
        super(id, ObjectNode.TYPE, left, top, width, height);
        var that = this;
        var _$template = $(lodash.template(objectNodeHtml)({ type: "Object" }));
        var _$node = AbstractNode.prototype.get$node.call(this).append(_$template);
        var _$attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        this.registerYType = function () {
            AbstractNode.prototype.registerYType.call(this);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(that.getEntityId());
            var attrs = _attributes["[attributes]"].getAttributes();
            for (var attributeKey in attrs) {
                if (attrs.hasOwnProperty(attributeKey)) {
                    var keyVal = attrs[attributeKey].getKey();
                    var ytext = ymap.get(keyVal.getEntityId());
                    keyVal.registerYType(ytext);
                }
            }
        };
        this.remove = function () {
            AbstractNode.prototype.remove.call(this);
            this.getAttribute("[attributes]").unregisterCallbacks();
        };
        this.addAttribute(new KeySelectionValueListAttribute("[attributes]", "Attributes", this, {
            string: "String",
            boolean: "Boolean",
            integer: "Integer",
            file: "File",
            quiz: "Questions",
        }));
        _$node.find(".label").append(this.getLabel().get$node());
        for (var attributeKey in _attributes) {
            if (_attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(_attributes[attributeKey].get$node());
            }
        }
    }
    static { this.TYPE = "Object"; }
}
class RelationshipGroupNode extends AbstractNode {
    constructor(id, left, top, width, height) {
        super(id, RelationshipGroupNode.TYPE, left, top, width, height);
        var _$template = $(lodash.template(relationshipGroupNodeHtml)());
        var _$node = AbstractNode.prototype.get$node.call(this).append(_$template);
        var _$attributeNode = _$node.find(".attributes");
        var attributes = this.getAttributes();
        _$node.find(".label").append(this.getLabel().get$node());
        for (var attributeKey in attributes) {
            if (attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(attributes[attributeKey].get$node());
            }
        }
    }
    static { this.TYPE = "Relation"; }
}
class RelationshipNode extends AbstractNode {
    constructor(id, left, top, width, height) {
        super(id, RelationshipNode.TYPE, left, top, width, height);
        var that = this;
        var $template = $(lodash.template(relationshipNodeHtml)({ type: "Relationship" }));
        var _$node = AbstractNode.prototype.get$node.call(this).append($template);
        var _$attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        this.addAttribute(new KeySelectionValueSelectionValueListAttribute("[attributes]", "Attributes", this, {
            string: "String",
            boolean: "Boolean",
            integer: "Integer",
            file: "File",
        }, { hidden: "Hide", top: "Top", center: "Center", bottom: "Bottom" }));
        this.registerYType = function () {
            AbstractNode.prototype.registerYType.call(this);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(that.getEntityId());
            var attrs = _attributes["[attributes]"].getAttributes();
            for (var attributeKey in attrs) {
                if (attrs.hasOwnProperty(attributeKey)) {
                    var keyVal = attrs[attributeKey].getKey();
                    var ytext = ymap.get(keyVal.getEntityId());
                    keyVal.registerYType(ytext);
                }
            }
        };
        _$node.find(".label").append(this.getLabel().get$node());
        for (var attributeKey in _attributes) {
            if (_attributes.hasOwnProperty(attributeKey)) {
                _$attributeNode.append(_attributes[attributeKey].get$node());
            }
        }
    }
    static { this.TYPE = "Relationship"; }
}
class ViewObjectNode extends AbstractNode {
    constructor(id, left, top, width, height, json) {
        super(id, "ViewObject", left, top, width, height, json);
        var that = this;
        var _$template = $(lodash.template(objectNodeHtml)({ type: "ViewObject" }));
        var _$node = AbstractNode.prototype.get$node.call(this).append(_$template);
        var _$attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        var targetAttribute, renamingList, conjSelection, cla;
        this.showAttributes = function () {
            if (renamingList.get$node().is(":hidden"))
                renamingList.get$node().show();
            if (conjSelection.get$node().is(":hidden"))
                conjSelection.get$node().show();
            if (cla.get$node().is(":hidden"))
                cla.get$node().show();
            if (!targetAttribute.get$node().is(":hidden"))
                targetAttribute.get$node().hide();
        };
        this.createConditionListAttribute = function (refAttrs) {
            var targetAttrList = {};
            if (refAttrs && refAttrs.constructor.name === "RenamingListAttribute") {
                var attrs = refAttrs.getAttributes();
                for (var key in attrs) {
                    if (attrs.hasOwnProperty(key)) {
                        targetAttrList[key] = attrs[key].getKey().getValue();
                    }
                }
            }
            else {
                for (var key in refAttrs) {
                    if (refAttrs.hasOwnProperty(key)) {
                        targetAttrList[key] = refAttrs[key].val.value;
                    }
                }
            }
            var conditionListAttr = new ConditionListAttribute("[condition]", "Conditions", that, targetAttrList, LogicalOperator);
            that.addAttribute(conditionListAttr);
            _$attributeNode.append(conditionListAttr.get$node());
            conditionListAttr.get$node().hide();
            return conditionListAttr;
        };
        _$node.find(".label").append(this.getLabel().get$node());
        const dataMap = y.getMap("data");
        var model = dataMap.get("model");
        if (model) {
            var selectionValues = ViewTypesUtil$1.GetAllNodesOfBaseModelAsSelectionList2(model.nodes, [
                "Object",
            ]);
            targetAttribute = new SingleSelectionAttribute(id + "[target]", "Target", that, selectionValues);
            that.addAttribute(targetAttribute);
            _$attributeNode.prepend(targetAttribute.get$node());
            renamingList = new RenamingListAttribute("[attributes]", "Attributes", that, { show: "Visible", hide: "Hidden" });
            that.addAttribute(renamingList);
            _$attributeNode.append(renamingList.get$node());
            renamingList.get$node().hide();
            conjSelection = new SingleSelectionAttribute(id + "[conjunction]", "Conjunction", that, LogicalConjunctions);
            that.addAttribute(conjSelection);
            _$attributeNode.append(conjSelection.get$node());
            conjSelection.get$node().hide();
            if (json) {
                cla = that.createConditionListAttribute(json.attributes["[attributes]"].list);
                that.showAttributes();
                targetAttribute.get$node().hide();
            }
            else
                cla = that.createConditionListAttribute();
        }
        this.registerYType = function () {
            AbstractNode.prototype.registerYType.call(this);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(that.getEntityId());
            var attrs = _attributes["[attributes]"].getAttributes();
            for (var attributeKey in attrs) {
                if (attrs.hasOwnProperty(attributeKey)) {
                    var keyVal = attrs[attributeKey].getKey();
                    var ytext = ymap.get(keyVal.getEntityId());
                    keyVal.registerYType(ytext);
                }
            }
            if (_attributes["[condition]"]) {
                var conditions = _attributes["[condition]"].getAttributes();
                for (var attrKey4 in conditions) {
                    if (conditions.hasOwnProperty(attrKey4)) {
                        var keyVal = attrs[attributeKey].getKey();
                        var ytext = ymap.get(keyVal.getEntityId());
                        keyVal.registerYType(ytext);
                    }
                }
            }
        };
    }
    static { this.TYPE = "ViewObject"; }
}
class ViewRelationshipNode extends AbstractNode {
    constructor(id, left, top, width, height, json) {
        super(id, ViewRelationshipNode.TYPE, left, top, width, height, json);
        var that = this;
        var $template = $(lodash.template(relationshipNodeHtml)({ type: "ViewRelationship" }));
        var _$node = AbstractNode.prototype.get$node.call(this).append($template);
        var _$attributeNode = _$node.find(".attributes");
        var _attributes = this.getAttributes();
        this.showAttributes = function () {
            if (renamingList.get$node().is(":hidden"))
                renamingList.get$node().show();
            if (conjSelection.get$node().is(":hidden"))
                conjSelection.get$node().show();
            if (cla.get$node().is(":hidden"))
                cla.get$node().show();
            if (!targetAttribute.get$node().is(":hidden"))
                targetAttribute.get$node().hide();
        };
        this.createConditionListAttribute = function (refAttrs) {
            var targetAttrList = {};
            if (refAttrs && refAttrs.constructor.name === "RenamingListAttribute") {
                var attrs = refAttrs.getAttributes();
                for (var key in attrs) {
                    if (attrs.hasOwnProperty(key)) {
                        targetAttrList[key] = attrs[key].getKey().getValue();
                    }
                }
            }
            else {
                for (var key in refAttrs) {
                    if (refAttrs.hasOwnProperty(key)) {
                        targetAttrList[key] = refAttrs[key].val.value;
                    }
                }
            }
            var conditionListAttr = new ConditionListAttribute("[condition]", "Conditions", that, targetAttrList, LogicalOperator);
            that.addAttribute(conditionListAttr);
            _$attributeNode.append(conditionListAttr.get$node());
            conditionListAttr.get$node().hide();
            return conditionListAttr;
        };
        var targetAttribute, renamingList, conjSelection, cla;
        _$node.find(".label").append(this.getLabel().get$node());
        const dataMap = y.getMap("data");
        var model = dataMap.get("model");
        if (model) {
            var selectionValues = ViewTypesUtil$1.GetAllNodesOfBaseModelAsSelectionList2(model.nodes, [
                "Relationship",
            ]);
            targetAttribute = new SingleSelectionAttribute(id + "[target]", "Reference", that, selectionValues);
            that.addAttribute(targetAttribute);
            _$attributeNode.prepend(targetAttribute.get$node());
            renamingList = new RenamingListAttribute("[attributes]", "Attributes", that, {
                hidden: "Show",
                top: "Show Top",
                center: "Show Center",
                bottom: "Show Bottom",
                hide: "Hide",
            });
            that.addAttribute(renamingList);
            _$attributeNode.append(renamingList.get$node());
            renamingList.get$node().hide();
            conjSelection = new SingleSelectionAttribute(id + "[conjunction]", "Conjunction", that, LogicalConjunctions);
            that.addAttribute(conjSelection);
            _$attributeNode.append(conjSelection.get$node());
            conjSelection.get$node().hide();
            if (json) {
                cla = that.createConditionListAttribute(json.attributes["[attributes]"].list);
                that.showAttributes();
                targetAttribute.get$node().hide();
            }
            else
                cla = that.createConditionListAttribute();
        }
        this.registerYType = function () {
            AbstractNode.prototype.registerYType.call(this);
            const nodesMap = y.getMap("nodes");
            var ymap = nodesMap.get(that.getEntityId());
            var attrs = _attributes["[attributes]"].getAttributes();
            for (var attributeKey in attrs) {
                if (attrs.hasOwnProperty(attributeKey)) {
                    var keyVal = attrs[attributeKey].getKey();
                    var ytext = ymap.get(keyVal.getEntityId());
                    keyVal.registerYType(ytext);
                }
            }
            if (_attributes["[condition]"]) {
                var conditions = _attributes["[condition]"].getAttributes();
                for (var attrKey4 in conditions) {
                    if (conditions.hasOwnProperty(attrKey4)) {
                        var keyVal = attrs[attributeKey].getKey();
                        var ytext = ymap.get(keyVal.getEntityId());
                        keyVal.registerYType(ytext);
                    }
                }
            }
        };
    }
    static { this.TYPE = "ViewRelationship"; }
}
class UniDirAssociationEdge extends AbstractEdge {
    constructor(id, source, target) {
        super("Uni-Dir-Association", id, source, target);
    }
    static { this.TYPE = "Uni-Dir-Association"; }
    static { this.RELATIONS = [
        {
            sourceTypes: [ObjectNode.TYPE],
            targetTypes: [
                EnumNode.TYPE,
                NodeShapeNode.TYPE,
                RelationshipNode.TYPE,
                RelationshipGroupNode.TYPE,
                ViewRelationshipNode.TYPE,
            ],
        },
        {
            sourceTypes: [RelationshipNode.TYPE],
            targetTypes: [
                EnumNode.TYPE,
                EdgeShapeNode.TYPE,
                ObjectNode.TYPE,
                AbstractClassNode.TYPE,
                ViewObjectNode.TYPE,
            ],
        },
        {
            sourceTypes: [RelationshipGroupNode.TYPE],
            targetTypes: [ObjectNode.TYPE, AbstractClassNode.TYPE],
        },
        {
            sourceTypes: [AbstractClassNode.TYPE],
            targetTypes: [
                EnumNode.TYPE,
                RelationshipNode.TYPE,
                RelationshipGroupNode.TYPE,
            ],
        },
        {
            sourceTypes: [ViewObjectNode.TYPE],
            targetTypes: [
                EnumNode.TYPE,
                NodeShapeNode.TYPE,
                RelationshipNode.TYPE,
                RelationshipGroupNode.TYPE,
                ViewRelationshipNode.TYPE,
            ],
        },
        {
            sourceTypes: [ViewRelationshipNode.TYPE],
            targetTypes: [
                EnumNode.TYPE,
                EdgeShapeNode.TYPE,
                ObjectNode.TYPE,
                AbstractClassNode.TYPE,
                ViewObjectNode.TYPE,
            ],
        },
    ]; }
}
class BiDirAssociationEdge extends AbstractEdge {
    constructor(id, source, target) {
        super(BiDirAssociationEdge.TYPE, id, source, target);
    }
    static { this.TYPE = "Bi-Dir-Association"; }
    static { this.RELATIONS = [
        {
            sourceTypes: [ObjectNode.TYPE],
            targetTypes: [
                EnumNode.TYPE,
                NodeShapeNode.TYPE,
                RelationshipNode.TYPE,
                RelationshipGroupNode.TYPE,
                ViewRelationshipNode.TYPE,
            ],
        },
        {
            sourceTypes: [RelationshipNode.TYPE],
            targetTypes: [
                EnumNode.TYPE,
                EdgeShapeNode.TYPE,
                ObjectNode.TYPE,
                AbstractClassNode.TYPE,
                ViewObjectNode.TYPE,
            ],
        },
        {
            sourceTypes: [RelationshipGroupNode.TYPE],
            targetTypes: [ObjectNode.TYPE, AbstractClassNode.TYPE],
        },
        {
            sourceTypes: [AbstractClassNode.TYPE],
            targetTypes: [
                EnumNode.TYPE,
                RelationshipNode.TYPE,
                RelationshipGroupNode.TYPE,
            ],
        },
        {
            sourceTypes: [EnumNode.TYPE],
            targetTypes: [
                ObjectNode.TYPE,
                RelationshipNode.TYPE,
                AbstractClassNode.TYPE,
            ],
        },
        {
            sourceTypes: [NodeShapeNode.TYPE],
            targetTypes: [ObjectNode.TYPE],
        },
        {
            sourceTypes: [EdgeShapeNode.TYPE],
            targetTypes: [RelationshipNode.TYPE],
        },
        {
            sourceTypes: [ViewObjectNode.TYPE],
            targetTypes: [
                EnumNode.TYPE,
                NodeShapeNode.TYPE,
                RelationshipNode.TYPE,
                RelationshipGroupNode.TYPE,
                ViewRelationshipNode.TYPE,
            ],
        },
        {
            sourceTypes: [ViewRelationshipNode.TYPE],
            targetTypes: [
                EnumNode.TYPE,
                EdgeShapeNode.TYPE,
                ObjectNode.TYPE,
                AbstractClassNode.TYPE,
                ViewObjectNode.TYPE,
            ],
        },
    ]; }
}
class GeneralisationEdge extends AbstractEdge {
    constructor(id, source, target) {
        super("Generalisation", id, source, target);
    }
    static { this.TYPE = "Generalisation"; }
    static { this.RELATIONS = [
        {
            sourceTypes: [ObjectNode.TYPE],
            targetTypes: [ObjectNode.TYPE, AbstractClassNode.TYPE],
        },
        {
            sourceTypes: [RelationshipNode.TYPE],
            targetTypes: [RelationshipNode.TYPE, AbstractClassNode.TYPE],
        },
        {
            sourceTypes: [RelationshipGroupNode.TYPE],
            targetTypes: [RelationshipNode.TYPE],
        },
        {
            sourceTypes: [AbstractClassNode.TYPE],
            targetTypes: [AbstractClassNode.TYPE],
        },
        {
            sourceTypes: [EnumNode.TYPE],
            targetTypes: [EnumNode.TYPE],
        },
    ]; }
}
class AttributeWrapper {
    constructor($node) {
        var that = this;
        var _$node = $node;
        var _selectedEntity = null;
        var _modelAttributesNode = null;
        var iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
        var entitySelectCallback = function (operation) {
            if (operation instanceof EntitySelectOperation &&
                operation.getSelectedEntityId() === null) {
                that.select(_modelAttributesNode);
                if ($node.is(":hidden"))
                    $node.show();
                $(".ace-container").hide();
            }
        };
        var nodeAddCallback = function (operation) {
            if (operation instanceof NodeAddOperation) {
                var node, type, viewType;
                if (operation.getViewId() === EntityManagerInstance.getViewId() ||
                    EntityManagerInstance.getLayer() === CONFIG$1.LAYER.META) {
                    type = operation.getType();
                }
                else {
                    if (!operation.getViewId()) {
                        type = operation.getType();
                    }
                    else {
                        type = operation.getOriginType();
                    }
                    if (EntityManagerInstance.getViewId()) {
                        viewType = EntityManagerInstance.getNodeType(type).VIEWTYPE;
                        if (viewType) {
                            type = viewType;
                        }
                    }
                }
                var json = operation.getJSON();
                if (json) {
                    node = EntityManagerInstance.createNodeFromJSON(type, operation.getEntityId(), operation.getLeft(), operation.getTop(), operation.getWidth(), operation.getHeight(), operation.getContainment(), operation.getJSON());
                }
                else {
                    node = EntityManagerInstance.createNode(type, operation.getEntityId(), operation.getLeft(), operation.getTop(), operation.getWidth(), operation.getHeight(), operation.getContainment());
                }
                node.addToWrapper(that);
            }
        };
        var edgeAddCallback = function (operation) {
            if (operation instanceof EdgeAddOperation) {
                var edge, type, viewType;
                if (operation.getViewId() === EntityManagerInstance.getViewId() ||
                    EntityManagerInstance.getLayer() === CONFIG$1.LAYER.META) {
                    type = operation.getType();
                }
                else {
                    if (!operation.getViewId()) {
                        type = operation.getType();
                    }
                    else {
                        type = operation.getOriginType();
                    }
                    if (EntityManagerInstance.getViewId()) {
                        viewType = EntityManagerInstance.getEdgeType(type).VIEWTYPE;
                        if (viewType) {
                            type = viewType;
                        }
                    }
                }
                var json = operation.getJSON();
                if (json) {
                    edge = EntityManagerInstance.createEdgeFromJSON(type, operation.getEntityId(), operation.getSource(), operation.getTarget(), json);
                }
                else {
                    const source = EntityManagerInstance.findNode(operation.getSource()), target = EntityManagerInstance.findNode(operation.getTarget());
                    if (!source || !target) {
                        throw new Error("Source or target node not found for edge " +
                            operation.getEntityId());
                    }
                    edge = EntityManagerInstance.createEdge(type, operation.getEntityId(), source, target);
                }
                edge.addToWrapper(that);
            }
        };
        this.get$node = function () {
            return _$node;
        };
        this.setModelAttributesNode = function (node) {
            _modelAttributesNode = node;
        };
        this.getModelAttributesNode = function () {
            return _modelAttributesNode;
        };
        this.select = function (entity) {
            if (_selectedEntity != entity) {
                if (_selectedEntity)
                    _selectedEntity.unselect();
                if (entity)
                    entity.select();
                _selectedEntity = entity;
            }
        };
        this.registerCallbacks = function () {
            iwc.registerOnDataReceivedCallback(entitySelectCallback);
        };
        this.unregisterCallbacks = function () {
            iwc.unregisterOnDataReceivedCallback(entitySelectCallback);
        };
        if (iwc) {
            that.registerCallbacks();
        }
        if (y) {
            const nodesMap = y.getMap("nodes");
            nodesMap.observe(function (event) {
                const array = Array.from(event.changes.keys.entries());
                array.forEach(function (entry) {
                    const key = entry[0];
                    const action = entry[1].action;
                    switch (action) {
                        case "add": {
                            nodesMap.get(key).observe(function (nodeEvent) {
                                nodeEvent.keysChanged.forEach(function (nodeKey) {
                                    const map = nodeEvent.currentTarget;
                                    const action = nodeEvent.changes.keys.get(nodeKey).action;
                                    if (action !== "add")
                                        return;
                                    if (nodeKey.search(/\w*\[(\w|\s)*\]/g) == -1)
                                        return;
                                    if (!map.has("jabberId"))
                                        return;
                                    nodeAddCallback(new NodeAddOperation(map.get("id"), map.get("type"), map.get("left"), map.get("top"), map.get("width"), map.get("height"), map.get("zIndex"), map.get("containment"), map.get("json"), null, null, nodeKey));
                                    var node = EntityManagerInstance.findNode(nodeEvent.currentTarget.get("id"));
                                    if (!node) {
                                        throw new Error("node is null");
                                    }
                                    if (node && node.getLabel().getEntityId() === nodeKey)
                                        node
                                            .getLabel()
                                            .getValue()
                                            .registerYType(nodeEvent.currentTarget.get(nodeKey));
                                    else {
                                        var attrs = null;
                                        if (EntityManagerInstance.getLayer() === CONFIG$1.LAYER.META) {
                                            attrs = node.getAttribute("[attributes]");
                                            if (!attrs)
                                                attrs = node.getAttributes();
                                            else
                                                attrs = attrs.getAttributes();
                                            var attrId = nodeKey.replace(/\[\w*\]/g, "");
                                            if (attrs.hasOwnProperty(attrId)) {
                                                var attr = attrs[attrId];
                                                if (attr.hasOwnProperty("getKey")) {
                                                    if (nodeKey.indexOf("ref") != -1)
                                                        attr.getRef().registerYType(nodeEvent.value);
                                                    else if (attr.getKey().hasOwnProperty("registerYType") &&
                                                        nodeKey.indexOf("value") === -1)
                                                        attr
                                                            .getKey()
                                                            .registerYType(nodeEvent.currentTarget.get(nodeKey));
                                                }
                                                else if (attr.hasOwnProperty("getValue")) {
                                                    if (attr.getValue().hasOwnProperty("registerYType"))
                                                        attr
                                                            .getValue()
                                                            .registerYType(nodeEvent.currentTarget.get(nodeKey));
                                                }
                                            }
                                            else if (attrs.hasOwnProperty(nodeKey)) {
                                                var attr = attrs[nodeKey];
                                                if (attr.getValue().hasOwnProperty("registerYType"))
                                                    attr
                                                        .getValue()
                                                        .registerYType(nodeEvent.currentTarget.get(nodeKey));
                                            }
                                        }
                                        else {
                                            attrs = node.getAttributes();
                                            for (var attrKey in attrs) {
                                                if (attrs.hasOwnProperty(attrKey)) {
                                                    var attr = attrs[attrKey];
                                                    if (attr.getEntityId() === nodeKey &&
                                                        attr.getValue().hasOwnProperty("registerYType")) {
                                                        attr
                                                            .getValue()
                                                            .registerYType(nodeEvent.currentTarget.get(nodeKey));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                });
                            });
                            break;
                        }
                    }
                });
            });
            const edgesMap = y.getMap("edges");
            edgesMap.observe(function (event) {
                const array = Array.from(event.changes.keys.entries());
                array.forEach(function (entry) {
                    const key = entry[0];
                    const action = entry[1].action;
                    if (action !== "add")
                        return;
                    const jabberId = edgesMap.get(key).get("jabberId");
                    if (!jabberId)
                        return;
                    const map = event.currentTarget.get(key);
                    edgeAddCallback(new EdgeAddOperation(map.get("id"), map.get("type"), map.get("source"), map.get("target"), null, null, null, jabberId));
                    var edge = EntityManagerInstance.findEdge(map.get("id"));
                    if (!edge) {
                        throw new Error("edge is null");
                    }
                    var attrs = edge.getAttributes();
                    if (edge.getLabel().getEntityId() === key)
                        edge.getLabel().getValue().registerYType(map.get(key));
                    else {
                        var attrs = edge.getAttributes();
                        for (var attrKey in attrs) {
                            if (attrs.hasOwnProperty(attrKey)) {
                                if (attrs[attrKey].getEntityId() === key) {
                                    var attr = attrs[attrKey];
                                    if (attr.getValue().hasOwnProperty("registerYType"))
                                        attr.getValue().registerYType(map.get(key));
                                }
                            }
                        }
                    }
                });
            });
        }
        this.select(_modelAttributesNode);
    }
}
function ViewGenerator() { }
function applyNodeTypeToNode(nodeType, node) {
    node.applyAttributeRenaming(nodeType.getAttributes());
}
function applyNodeTypeToNodes(nodeType, nodes) {
    for (var nodeKey in nodes) {
        if (nodes.hasOwnProperty(nodeKey)) {
            applyNodeTypeToNode(nodeType, nodes[nodeKey]);
        }
    }
}
function applyEdgeTypeToEdge(edgeType, edge) {
    edge.applyAttributeRenaming(edgeType.getAttributes());
}
function applyEdgeTypeToEdges(edgeType, edges) {
    for (var edgeKey in edges) {
        if (edges.hasOwnProperty(edgeKey)) {
            applyEdgeTypeToEdge(edgeType, edges[edgeKey]);
        }
    }
}
ViewGenerator.generate = function (vls, vvs) {
    var _processed = {};
    var viewpointNodes = vvs.nodes;
    for (var vpNodeKey in viewpointNodes) {
        if (viewpointNodes.hasOwnProperty(vpNodeKey)) {
            var nodeViewType = viewpointNodes[vpNodeKey];
            if (nodeViewType.hasOwnProperty("target")) {
                _processed[nodeViewType.target] = true;
                var viewNodeTypeObject = EntityManagerInstance.getViewNodeType(nodeViewType.label);
                applyNodeTypeToNodes(viewNodeTypeObject, EntityManagerInstance.getNodesByType(viewNodeTypeObject.getTargetNodeType().getType()));
            }
        }
    }
    var viewpointEdges = vvs.edges;
    for (var vpEdgeKey in viewpointEdges) {
        if (viewpointEdges.hasOwnProperty(vpEdgeKey)) {
            var edgeViewType = viewpointEdges[vpEdgeKey];
            if (edgeViewType.hasOwnProperty("target")) {
                _processed[edgeViewType.target] = true;
                var viewEdgeTypeObject = EntityManagerInstance.getViewEdgeType(edgeViewType.label);
                applyEdgeTypeToEdges(viewEdgeTypeObject, EntityManagerInstance.getEdgesByType(viewEdgeTypeObject.getTargetEdgeType().getType()));
            }
        }
    }
};
ViewGenerator.reset = function (vls) {
    var typeName;
    var nodes = vls.nodes;
    for (var nodeKey in nodes) {
        if (nodes.hasOwnProperty(nodeKey)) {
            typeName = nodes[nodeKey].label;
            applyNodeTypeToNodes(EntityManagerInstance.getNodeType(typeName), EntityManagerInstance.getNodesByType(typeName));
        }
    }
    var edges = vls.edges;
    for (var edgeKey in edges) {
        if (edges.hasOwnProperty(edgeKey)) {
            typeName = edges[edgeKey].label;
            applyEdgeTypeToEdges(EntityManagerInstance.getEdgeType(typeName), EntityManagerInstance.getEdgesByType(typeName));
        }
    }
};
async function WaitForCanvas(widgetName, doc, maxAttempts = 10, interval = 3000) {
    const iwc = IWCW.getInstance(widgetName, doc);
    var gotResponseFromCanvas = false;
    var canvasResponse = null;
    iwc.registerOnDataReceivedCallback((operation) => {
        if (operation.hasOwnProperty("getType")) {
            if (operation.getType() === "WaitForCanvasOperation") {
                gotResponseFromCanvas = true;
                canvasResponse = operation.getData();
            }
        }
    });
    try {
        await poll({
            interval,
            maxAttempts,
            validate: () => gotResponseFromCanvas,
            action: () => {
                const operation = new NonOTOperation("WaitForCanvasOperation", JSON.stringify({ widget: widgetName }));
                iwc.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation);
            },
        });
        return canvasResponse;
    }
    catch (error) {
        throw error;
    }
}
async function poll({ action, validate, interval, maxAttempts }) {
    let attempts = 0;
    const executePoll = async (resolve, reject) => {
        const result = await action();
        attempts++;
        if (validate(result)) {
            return resolve(result);
        }
        else if (maxAttempts && attempts === maxAttempts) {
            return reject(new Error("Exceeded max attempts"));
        }
        else {
            setTimeout(executePoll, interval, resolve, reject);
        }
    };
    return new Promise(executePoll);
}
let AttributeWidget = class AttributeWidget extends SyncMetaWidget(LitElement, getWidgetTagName(CONFIG$1.WIDGET.NAME.ATTRIBUTE)) {
    constructor() {
        super(...arguments);
        this.widgetName = getWidgetTagName(CONFIG$1.WIDGET.NAME.ATTRIBUTE);
    }
    firstUpdated(e) {
        super.firstUpdated(e);
        const guidancemodel = getGuidanceModeling();
        try {
            yjsSync()
                .then((y) => {
                WaitForCanvas(CONFIG$1.WIDGET.NAME.ATTRIBUTE, y)
                    .then((user) => {
                    var iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ATTRIBUTE, y);
                    iwc.setSpace(user);
                    if (!window.y)
                        window.y = y;
                    window.syncmetaLog = {
                        widget: "Attribute",
                        initializedYTexts: 0,
                        objects: {},
                        errors: {},
                        firstAttemptFail: {},
                    };
                    console.info("ATTRIBUTE: Yjs successfully initialized in room " +
                        undefined +
                        " with y-user-id: " +
                        y.clientID);
                    const userMap = y.getMap("users");
                    userMap.set(y.clientID, iwc.getUser()[CONFIG$1.NS.PERSON.JABBERID]);
                    const dataMap = y.getMap("data");
                    var model = dataMap.get("model");
                    if (model)
                        console.info("ATTRIBUTE: Found model in yjs room with " +
                            Object.keys(model.nodes).length +
                            " nodes and " +
                            Object.keys(model.edges).length +
                            " edges.");
                    if (guidancemodel.isGuidanceEditor()) {
                        const dataMap = y.getMap("data");
                        EntityManagerInstance.init(dataMap.get("guidancemetamodel"));
                        model = dataMap.get("guidancemodel");
                    }
                    else {
                        EntityManagerInstance.init(dataMap.get("metamodel"));
                    }
                    var attributeWrapper = new AttributeWrapper($("#wrapper"));
                    if (model) {
                        JSONToGraph(model, attributeWrapper);
                    }
                    console.info("ATTRIBUTE: Initialization of model completed", window.syncmetaLog);
                    iwc.registerOnDataReceivedCallback(function (operation) {
                        var modelAttributesNode;
                        if (operation instanceof SetModelAttributeNodeOperation) {
                            modelAttributesNode =
                                attributeWrapper.getModelAttributesNode();
                            if (modelAttributesNode === null) {
                                modelAttributesNode =
                                    EntityManagerInstance.createModelAttributesNode();
                                attributeWrapper.setModelAttributesNode(modelAttributesNode);
                                modelAttributesNode.registerYType();
                                modelAttributesNode.addToWrapper(attributeWrapper);
                            }
                            attributeWrapper.select(modelAttributesNode);
                        }
                        else if (operation instanceof InitModelTypesOperation) {
                            var vvs = operation.getVLS();
                            const dataMap = y.getMap("data");
                            var metamodel = dataMap.get("metamodel");
                            if (vvs.hasOwnProperty("id")) {
                                EntityManagerInstance.initViewTypes(vvs);
                                if (operation.getViewGenerationFlag()) {
                                    ViewGenerator.generate(metamodel, vvs);
                                }
                            }
                            else {
                                EntityManagerInstance.setViewId(null);
                                if (operation.getViewGenerationFlag()) {
                                    ViewGenerator.reset(metamodel);
                                }
                            }
                        }
                    });
                    var operation = new SetModelAttributeNodeOperation();
                    iwc.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.toNonOTOperation());
                    const canvas = y.getMap("canvas");
                    canvas.observe(function (event) {
                        event.keysChanged.forEach((key) => {
                            switch (key) {
                                case "ReloadWidgetOperation": {
                                    location.reload();
                                }
                            }
                        });
                    });
                })
                    .catch(function (e) {
                    console.error(e);
                    this.showErrorAlert("Cannot connect to Canvas widget.");
                })
                    .finally(() => {
                    $(getWidgetTagName(CONFIG$1.WIDGET.NAME.ATTRIBUTE))
                        .find("loading-spinner")
                        .hide();
                });
            })
                .catch((err) => {
                console.error(err);
                this.showErrorAlert("Cannot connect to Yjs server.");
            });
        }
        catch (error) {
            console.error(error);
        }
    }
    hideErrorAlert() {
        $(this.widgetName).find("#alert-message").text("");
        $(this.widgetName).find("error-alert").hide();
    }
    showErrorAlert(message) {
        $(this.widgetName).find("#alert-message").text(message);
        $(this.widgetName).find("error-alert").hide();
    }
    render() {
        return html `
      <style>
        ${getWidgetTagName(CONFIG$1.WIDGET.NAME.ATTRIBUTE)} {
          height: 100%;
          position: relative;
        }
        .ql-container {
          border-radius: 0.25rem;
        }
        #wrapper {
          overflow: auto;
          height: 100%;
          position: relative;
        }
        .main-wrapper {
          height: 100%;
        }
        .list_attribute ul.list {
          list-style: none;
          padding-left: 10px;
          margin: 5px 0;
        }

        .list_attribute div span.ui-icon {
          margin-left: 10px;
        }

        .key_value_attribute,
        .condition_predicate,
        .renaming_attr {
          overflow: auto;
        }

        .key_value_attribute div,
        .condition_predicate div,
        .renaming_attr div {
          width: 30%;
          float: left;
        }

        .key_value_attribute div input,
        .condition_predicate div input,
        .renaming_attr div input {
          border: 1px solid #aaaaaa;
        }

        .key_value_attribute span.ui-icon,
        .condition_predicate span.ui-icon {
          margin-top: 3px;
        }

        .single_value_attribute {
          overflow: auto;
        }

        .single_quiz_attribute {
          overflow: auto;
        }

        .single_value_attribute div {
          float: left;
          margin-right: 10px;
        }

        .single_quiz_attribute div {
          float: left;
          margin-right: 10px;
        }

        .list .single_value_attribute .name {
          display: none;
        }
        .list .single_quiz_attribute .name {
          display: none;
        }

        .single_value_attribute .name {
          width: 120px;
        }
        .single_quiz_attribute .name {
          width: 120px;
        }

        .single_value_attribute div.value span.color_preview {
          width: 12px;
          height: 18px;
          background-color: #ffffff;
          display: inline-block;
          border: 1px solid #4a4a4a;
          position: relative;
          top: 5px;
          left: -14px;
        }

        .single_quiz_attribute div.value span.color_preview {
          width: 12px;
          height: 18px;
          background-color: #ffffff;
          display: inline-block;
          border: 1px solid #4a4a4a;
          position: relative;
          top: 5px;
          left: -14px;
        }

        .single_value_attribute div.value textarea {
          width: 400px;
          height: 80px;
        }

        .single_quiz_attribute div.value textarea {
          width: 400px;
          height: 80px;
        }

        #modelAttributes .attribute_default_node .label {
          font-weight: bold;
        }

        .label {
          text-transform: capitalize;
        }

        .key_value_attribute input,
        select {
          width: 150px;
        }
        .condition_predicate input,
        select {
          width: 150px;
        }

        .renaming_attr input,
        select {
          width: 150px;
        }

        .type {
          font-weight: bold;
          margin: 0 0 3px;
        }

        .show_hint {
          font-size: 12px;
        }

        .hint {
          font-size: 12px;
          overflow-y: auto;
          max-height: 150px;
        }

        .codeEditorValue {
          position: absolute;
          width: 560px;
          height: 200px;
          overflow-y: auto;
        }
        .main-wrapper {
          position: relative;
        }
      </style>
      <link
        rel="stylesheet"
        type="text/css"
        href="https://code.jquery.com/ui/1.13.1/themes/smoothness/jquery-ui.css"
      />
      <link
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css"
        rel="stylesheet"
        integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi"
        crossorigin="anonymous"
      />

      <link
        href="https://cdn.quilljs.com/1.3.7/quill.snow.css"
        rel="stylesheet"
      />

      <div class="main-wrapper">
        <error-alert></error-alert>
        <div id="loading" class="loading"></div>
        <div id="wrapper"></div>
        <div id="q"></div>
        <loading-spinner></loading-spinner>
      </div>
    `;
    }
    connectedCallback() {
        super.connectedCallback();
        init();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
    }
};
AttributeWidget = __decorate([
    e(getWidgetTagName(CONFIG$1.WIDGET.NAME.ATTRIBUTE))
], AttributeWidget);
function JSONToGraph(json, wrapper) {
    var modelAttributesNode;
    var nodeId, edgeId;
    if (json.attributes && Object.keys(json.attributes).length > 0) {
        modelAttributesNode = EntityManagerInstance.createModelAttributesNodeFromJSON(json.attributes);
        wrapper.setModelAttributesNode(modelAttributesNode);
        modelAttributesNode.registerYType();
        modelAttributesNode.addToWrapper(wrapper);
        wrapper.select(modelAttributesNode);
    }
    for (nodeId in json.nodes) {
        if (json.nodes.hasOwnProperty(nodeId)) {
            var node = EntityManagerInstance.createNodeFromJSON(json.nodes[nodeId].type, nodeId, json.nodes[nodeId].left, json.nodes[nodeId].top, json.nodes[nodeId].width, json.nodes[nodeId].height, json.nodes[nodeId].zIndex, json.nodes[nodeId]);
            if (!node) {
                throw new Error("Node could not be created from JSON");
            }
            if ("registerYMap" in node) {
                node.registerYMap();
            }
            else {
                node.registerYType();
            }
            node.addToWrapper(wrapper);
        }
    }
    for (edgeId in json.edges) {
        if (json.edges.hasOwnProperty(edgeId)) {
            var edge = EntityManagerInstance.createEdgeFromJSON(json.edges[edgeId].type, edgeId, json.edges[edgeId].source, json.edges[edgeId].target, json.edges[edgeId]);
            edge.registerYType();
            edge.addToWrapper(wrapper);
        }
    }
}
let DebugWidget = class DebugWidget extends SyncMetaWidget(LitElement, getWidgetTagName(CONFIG$1.WIDGET.NAME.DEBUG)) {
    constructor() {
        super(...arguments);
        this.widgetName = getWidgetTagName(CONFIG$1.WIDGET.NAME.DEBUG);
    }
    firstUpdated(_changedProperties) {
        super.firstUpdated(_changedProperties);
        const $spinner = $(getWidgetTagName(CONFIG$1.WIDGET.NAME.DEBUG)).find("loading-spinner");
        const guidance = getGuidanceModeling();
        yjsSync()
            .then((y) => {
            const dataMap = y.getMap("data");
            console.info("DEBUG: Yjs successfully initialized in room " +
                window.spaceTitle +
                " with y-user-id: " +
                y.clientID);
            var $deleteMetamodel = $("#delete-meta-model").prop("disabled", false), $exportMetamodel = $("#export-meta-model").prop("disabled", false), $importMetamodel = $("#import-meta-model"), $deleteModel = $("#delete-model").prop("disabled", false), $exportModel = $("#export-model").prop("disabled", false), $importModel = $("#import-model"), $deleteGuidancemodel = $("#delete-guidance-model").prop("disabled", true), $exportGuidancemodel = $("#export-guidance-model").prop("disabled", true), $importGuidancemodel = $("#import-guidance-model"), $fileObject = $("#file-object"), $activityExport = $("#export-activity-list").prop("disabled", false), $activityDelete = $("#delete-activity-list").prop("disabled", false), feedback = function (msg) {
                alert(msg);
                $spinner.hide();
            };
            $importGuidancemodel.hide();
            $importMetamodel.hide();
            $importModel.hide();
            var getFileContent = function () {
                var fileReader, files = $fileObject[0].files, file, deferred = $.Deferred();
                if (!files || files.length === 0)
                    deferred.reject("No files selected");
                file = files[0];
                fileReader = new FileReader();
                fileReader.onload = function (e) {
                    var data = e.target.result;
                    try {
                        data = JSON.parse(data);
                    }
                    catch (e) {
                        deferred.reject("Incorrect file type. Please make sure that your file is in JSON format");
                    }
                    deferred.resolve(data);
                };
                try {
                    fileReader.readAsText(file);
                    return deferred.promise();
                }
                catch (error) {
                    return deferred.reject("Incorrect file type. Please make sure that your file is in JSON format");
                }
            };
            $deleteModel.click(function () {
                const retVal = confirm("Are you sure you want to delete the model ?");
                if (retVal) {
                    $spinner.show();
                    $exportModel.prop("disabled", true);
                    $deleteModel.prop("disabled", true);
                    const dataMap = y.getMap("data");
                    dataMap.set("model", null);
                    const canvasMap = y.getMap("canvas");
                    canvasMap.set("ReloadWidgetOperation", "delete");
                    feedback("The model was deleted. The page will be reloaded.");
                    location.reload();
                }
            });
            $deleteMetamodel.click(function () {
                const retVal = confirm("Are you sure you want to delete the Metamodel ?");
                if (retVal) {
                    $spinner.show();
                    $exportMetamodel.prop("disabled", true);
                    $deleteMetamodel.prop("disabled", true);
                    const dataMap = y.getMap("data");
                    dataMap.set("metamodel", null);
                    const canvasMap = y.getMap("canvas");
                    canvasMap.set("ReloadWidgetOperation", "meta_delete");
                    feedback("The meta model was deleted. The page will be reloaded.");
                    location.reload();
                }
            });
            $deleteGuidancemodel.click(function () {
                const retVal = confirm("Are you sure you want to delete the Guidancemodel ?");
                if (retVal) {
                    $spinner.show();
                    $exportGuidancemodel.prop("disabled", true);
                    $deleteGuidancemodel.prop("disabled", true);
                    const dataMap = y.getMap("data");
                    dataMap.set("guidancemodel", null);
                    feedback("The guidance model was deleted. The page will be reloaded.");
                    location.reload();
                }
            });
            $activityDelete.click(function () {
                const retVal = confirm("Are you sure you want to delete the activity list ?");
                if (retVal) {
                    $spinner.show();
                    const activityMap = y.getMap("activity");
                    activityMap.set("log", null);
                    feedback("The activity log has been deleted. The page will be reloaded.");
                    location.reload();
                }
            });
            $exportModel.click(function () {
                $spinner.show();
                const dataMap = y.getMap("data");
                var link = document.createElement("a");
                link.download = "model.json";
                link.href =
                    "data:," +
                        encodeURIComponent(JSON.stringify(dataMap.get("model"), null, 4));
                link.click();
                $spinner.hide();
            });
            $exportMetamodel.click(function () {
                $spinner.show();
                const dataMap = y.getMap("data");
                var link = document.createElement("a");
                link.download = "vls.json";
                link.href =
                    "data:," +
                        encodeURIComponent(JSON.stringify(dataMap.get("metamodel"), null, 4));
                link.click();
                $spinner.hide();
            });
            $exportGuidancemodel.click(function () {
                $spinner.show();
                const dataMap = y.getMap("data");
                var link = document.createElement("a");
                link.download = "guidance_model.json";
                link.href =
                    "data:," +
                        encodeURI(JSON.stringify(dataMap.get("guidancemodel"), null, 4));
                link.click();
                $spinner.hide();
            });
            $activityExport.click(function () {
                $spinner.show();
                const activityMap = y.getMap("activity");
                var link = document.createElement("a");
                link.download = "activityList.json";
                link.href =
                    "data:," +
                        encodeURI(JSON.stringify(activityMap.get("log"), null, 4));
                link.click();
                $spinner.hide();
            });
            $importModel.click(function () {
                $spinner.show();
                getFileContent()
                    .then(function (data) {
                    var initAttributes = function (attrs, map) {
                        if (attrs.hasOwnProperty("[attributes]")) {
                            var attr = attrs["[attributes]"].list;
                            for (var key in attr) {
                                if (attr.hasOwnProperty(key)) {
                                    if (attr[key].hasOwnProperty("key")) {
                                        var ytext = map.set(attr[key].key.id, new Text$1());
                                        ytext.insert(0, attr[key].key.value);
                                    }
                                    else {
                                        var ytext = map.set(attr[key].value.id, new Text$1());
                                        ytext.insert(0, attr[key].value.value);
                                    }
                                }
                            }
                        }
                        else {
                            for (var key in attrs) {
                                if (attrs.hasOwnProperty(key)) {
                                    var value = attrs[key].value;
                                    if (!value.hasOwnProperty("option")) {
                                        if (value.value instanceof String) {
                                            var ytext = map.set(value.id, new Text$1());
                                            ytext.insert(0, value.value);
                                        }
                                    }
                                }
                            }
                        }
                    };
                    const dataMap = y.getMap("data");
                    if (guidance.isGuidanceEditor()) {
                        dataMap.set("guidancemodel", data);
                    }
                    else
                        dataMap.set("model", data);
                    for (var key in data.nodes) {
                        if (data.nodes.hasOwnProperty(key)) {
                            var entity = data.nodes[key];
                            const nodesMap = y.getMap("nodes");
                            nodesMap.set(key, new Map$2());
                            var attrs = entity.attributes;
                            if (entity.hasOwnProperty("label")) {
                                var ytext = new Text$1(entity.label.value.id);
                                nodesMap.set(entity.label.value.id, ytext);
                                ytext.insert(0, entity.label.value.value);
                            }
                            initAttributes(attrs, nodesMap);
                        }
                    }
                    for (var key in data.edges) {
                        if (data.edges.hasOwnProperty(key)) {
                            var entity = data.edges[key];
                            const edgeMap = y.getMap("edges");
                            var map = edgeMap.set(key, new Map$2());
                            var attrs = entity.attributes;
                            if (entity.hasOwnProperty("label")) {
                                const ytext = new Text$1();
                                map.set(entity.label.value.id, ytext);
                                ytext.insert(0, entity.label.value.value);
                            }
                            initAttributes(attrs, map);
                        }
                    }
                    const canvasMap = y.getMap("canvas");
                    canvasMap.set("ReloadWidgetOperation", "import");
                    feedback("Imported model successfully! The page will be reloaded.");
                    location.reload();
                })
                    .catch(function (err) {
                    console.error(err);
                    feedback("Error: " + err);
                    $spinner.hide();
                });
            });
            $importMetamodel.click(function () {
                $spinner.show();
                $importMetamodel.prop("disabled", true);
                getFileContent()
                    .then(function (data) {
                    const dataMap = y.getMap("data");
                    try {
                        var vls = GenerateViewpointModel(data, y);
                        if (lodash.keys(vls.nodes).length === 0 &&
                            lodash.keys(vls.edges).length === 0 &&
                            lodash.keys(vls.attributes).length === 0) {
                            dataMap.set("metamodel", data);
                        }
                        else {
                            dataMap.set("metamodel", vls);
                        }
                        feedback("Imported Meta Model, the page will reload now");
                        setTimeout(() => {
                            location.reload();
                        }, 1000);
                    }
                    catch (e) {
                        feedback("Error: " + e);
                        throw e;
                    }
                    $importMetamodel.prop("disabled", false);
                    $spinner.hide();
                })
                    .catch(function (err) {
                    console.error(err);
                    feedback("Error: " + err);
                    $importMetamodel.prop("disabled", false);
                    $spinner.hide();
                });
            });
            $importGuidancemodel.click(function () {
                $spinner.show();
                getFileContent()
                    .then(function (data) {
                    const dataMap = y.getMap("data");
                    $exportGuidancemodel.prop("disabled", false);
                    $deleteGuidancemodel.prop("disabled", false);
                    EntityManagerInstance$1.setGuidance(guidance);
                    dataMap.set("guidancemodel", EntityManagerInstance$1.generateLogicalGuidanceRepresentation(data));
                    feedback("Done!");
                    $spinner.hide();
                })
                    .catch(function (e) {
                    feedback("Error: " + e);
                    $spinner.hide();
                });
            });
            var checkExistence = function () {
                if (!dataMap.get("model")) {
                    $exportModel.prop("disabled", true);
                    $deleteModel.prop("disabled", true);
                }
                else {
                    $exportModel.prop("disabled", false);
                    $deleteModel.prop("disabled", false);
                }
                if (!dataMap.get("metamodel")) {
                    $exportMetamodel.prop("disabled", true);
                    $deleteMetamodel.prop("disabled", true);
                }
                else {
                    $exportMetamodel.prop("disabled", false);
                    $deleteMetamodel.prop("disabled", false);
                }
                const activityMap = y.getMap("activity");
                if (!activityMap.get("log")) {
                    $activityExport.prop("disabled", true);
                    $activityDelete.prop("disabled", true);
                }
                else {
                    $activityExport.prop("disabled", false);
                    $activityDelete.prop("disabled", false);
                }
                if (!dataMap.get("guidancemodel")) {
                    $exportGuidancemodel.prop("disabled", true);
                    $deleteGuidancemodel.prop("disabled", true);
                }
                else {
                    $exportGuidancemodel.prop("disabled", false);
                    $deleteGuidancemodel.prop("disabled", false);
                }
            };
            checkExistence();
            setInterval(checkExistence, 10000);
            $spinner.hide();
            $("input:file").change(() => {
                $importGuidancemodel.show();
                $importMetamodel.show();
                $importModel.show();
            });
        })
            .catch((err) => {
            console.error(err);
            this.showErrorAlert("Cannot connect to Yjs server.");
        });
    }
    hideErrorAlert() {
        $(this.widgetName).find("#alert-message").text("");
        $(this.widgetName).find("error-alert").hide();
    }
    showErrorAlert(message) {
        $(this.widgetName).find("#alert-message").text(message);
        $(this.widgetName).find("error-alert").hide();
    }
    render() {
        return html `
      <link
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css"
        rel="stylesheet"
        integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi"
        crossorigin="anonymous"
      />
      <style>
        #debug-container {
          position: relative;
        }
        ${getWidgetTagName(CONFIG$1.WIDGET.NAME.DEBUG)} {
          position: relative;
          overflow-y: auto;
        }
      </style>

      
              <div id="debug-container">
                 <error-alert></error-alert>

                <div class="seperating_box">
                  <h6>Select a JSON file</h6>
                  <input
                    class="form-control"
                    type="file"
                    id="file-object"
                    accept=".json"
                    value="Load a file"
                  />
                </div>

                <hr />
                <div id="import-export-container">
                  <div id="modelDiv" class="seperating_box">
                    <h6>
                      <strong>(Meta- or Guidance-)Model</strong>
                    </h6>
                    <button
                      id="import-model"
                      class="btn btn-primary"
                      title="Import a model to the canvas"
                    >
                      Import
                    </button>
                    <button
                      id="export-model"
                      class="btn btn-secondary"
                      title="export the model as JSON"
                    >
                      Export
                    </button>
                    <button
                      id="delete-model"
                      title="delete the model"
                      class="btn btn-danger"
                    >
                      Delete
                    </button>
                  </div>
                  <hr />
                  <div id="vlsDiv" class="seperating_box">
                    <h6><strong>Metamodel</strong> (Model Editor only)</h6>
                    <button
                      class="btn btn-primary"
                      id="import-meta-model"
                      title="Refresh the role space to apply the new VLS."
                    >
                      Import
                    </button>
                    <button
                      id="export-meta-model"
                      title="Download the VLS as JSON"
                      class="btn btn-secondary"
                    >
                      Export
                    </button>
                    <button
                      id="delete-meta-model"
                      title="Refresh the role space and delete the current modeling language"
                      class="btn btn-danger"
                    >
                      Delete
                    </button>
                  </div>
                  <hr />
                  <div id="guidanceDiv" class="seperating_box">
                    <h6>
                      <strong>Logical Guidancemodel</strong> (Model Editor only)
                    </h6>
                    <button id="import-guidance-model" class="btn btn-primary">
                      Import
                    </button>
                    <button
                      id="export-guidance-model"
                      class="btn btn-secondary"
                    >
                      Export
                    </button>
                    <button id="delete-guidance-model" class="btn btn-danger">
                      Delete
                    </button>
                  </div>
                  <hr />
                  <div id="activityDiv" class="seperating_box">
                    <h6><strong>Activity list</strong></h6>
                    <button id="export-activity-list" class="btn btn-secondary">
                      Export
                    </button>
                    <button id="delete-activity-list" class="btn btn-danger">
                      Delete
                    </button>
                  </div>
                </div>
                <loading-spinner></loading-spinner>
              </div>
              <br />
            </div>
          
    `;
    }
    connectedCallback() {
        super.connectedCallback();
        init();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
    }
};
DebugWidget = __decorate([
    e(getWidgetTagName(CONFIG$1.WIDGET.NAME.DEBUG))
], DebugWidget);
const abstractToolHtml = "<button class=\"btn btn-light my-1 border border-dark flex w-100\">\n  <div\n    style=\"max-height: 30px\"\n    class=\"d-flex justify-content-between align-items-center\"\n  >\n    <% if (type == \"svg\" ) { %> <%=icon%> <% } else { %>\n    <img\n      style=\"background-color: <%= color %>\"\n      width=\"12px\"\n      height=\"12px \"\n      src=\"<%= icon %>\"\n    />\n\n    <% } %>\n    <span style=\"text-align: right\"><%= label %></span>\n  </div>\n</button>\n";
const DEFAULT_NODE_TOOL_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-box" viewBox="0 0 16 16"><path d="M8.186 1.113a.5.5 0 0 0-.372 0L1.846 3.5 8 5.961 14.154 3.5 8.186 1.113zM15 4.239l-6.5 2.6v7.922l6.5-2.6V4.24zM7.5 14.762V6.838L1 4.239v7.923l6.5 2.6zM7.443.184a1.5 1.5 0 0 1 1.114 0l7.129 2.852A.5.5 0 0 1 16 3.5v8.662a1 1 0 0 1-.629.928l-7.185 2.874a.5.5 0 0 1-.372 0L.63 13.09a1 1 0 0 1-.63-.928V3.5a.5.5 0 0 1 .314-.464L7.443.184z"/></svg>`;
class AbstractTool {
    constructor(toolName, toolLabel, toolDescription, toolIcon, toolColor = null, type = "svg") {
        if (!toolIcon) {
            toolIcon = DEFAULT_NODE_TOOL_ICON;
        }
        var _name = toolName;
        var _label = toolLabel;
        var _description = toolDescription;
        var _icon = toolIcon;
        var _color = toolColor || "#000000";
        var _$node;
        if (typeof toolIcon.find === "function") {
            const svgRef = toolIcon.find("svg");
            if (svgRef) {
                svgRef.height(30);
                svgRef.width(30);
                type = "svg";
                toolIcon = svgRef.get(0).outerHTML;
            }
        }
        if (type == "svg") {
            _$node = $(lodash.template(abstractToolHtml)({
                icon: toolIcon,
                label: _label,
                color: _color,
                type,
            }));
        }
        else {
            _$node = $(lodash.template(abstractToolHtml)({
                icon: "",
                label: _label,
                color: _color,
                type,
            }));
        }
        this.get$node = function () {
            return _$node;
        };
        this.setName = function (name) {
            _name = name;
        };
        this.getName = function () {
            return _name;
        };
        this.setLabel = function (label) {
            _label = label;
        };
        this.getLabel = function () {
            return _label;
        };
        this.setDescription = function (description) {
            _description = description;
        };
        this.getDescription = function () {
            return _description;
        };
        this.setIcon = function (icon) {
            _icon = icon;
        };
        this.getIcon = function () {
            return _icon;
        };
        this.setColor = function (color) {
            _color = color;
        };
        this.getColor = function () {
            return _color;
        };
        this.select = function () {
            _$node.addClass("selected");
            _$node.removeClass("btn-light");
            _$node.addClass("btn-primary");
        };
        this.unselect = function () {
            _$node.removeClass("selected");
            _$node.removeClass("btn-primary");
            _$node.addClass("btn-light");
        };
        if (_icon instanceof $) {
            _$node.find(".icon").empty().append(_icon);
        }
    }
}
class AbstractClassNodeTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = null, type = "svg") {
        super(toolName || "Abstract Class", toolLabel || "Abstract Class", toolDescription || "Click on an empty part of the canvas to add a node", toolIcon, null, type);
    }
}
class BiDirAssociationEdgeTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-arrow-left-right" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 11.5a.5.5 0 0 0 .5.5h11.793l-3.147 3.146a.5.5 0 0 0 .708.708l4-4a.5.5 0 0 0 0-.708l-4-4a.5.5 0 0 0-.708.708L13.293 11H1.5a.5.5 0 0 0-.5.5zm14-7a.5.5 0 0 1-.5.5H2.707l3.147 3.146a.5.5 0 1 1-.708.708l-4-4a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 4H14.5a.5.5 0 0 1 .5.5z"/></svg>`, type = "svg") {
        super(toolName || "Bi-Dir-Association", toolLabel || "Bi-Dir-Assoc", toolDescription ||
            "Click and hold on one Node and release on another node to add an edge between these two nodes.", toolIcon, null, type);
    }
}
class EdgeShapeNodeTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = null, type = "svg") {
        super(toolName || "Edge Shape", toolLabel || "Edge Shape", toolDescription || "Click on an empty part of the canvas to add a node", toolIcon, null, type);
    }
}
class EnumNodeTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = null, type = "svg") {
        super(toolName || "Enumeration", toolLabel || "Enum", toolDescription || "Click on an empty part of the canvas to add a node", toolIcon, null, type);
    }
}
class GeneralisationEdgeTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-arrow-up" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"/></svg>`, type = "svg") {
        super(toolName || "Generalisation", toolLabel || "Generalisation", toolDescription ||
            "Click and hold on one Node and release on another node to add an edge between these two nodes.", toolIcon, null, type);
    }
}
class MoveTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = null, iconType = null) {
        const icon = toolIcon ||
            `<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-arrows-move" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M7.646.146a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8.5 1.707V5.5a.5.5 0 0 1-1 0V1.707L6.354 2.854a.5.5 0 1 1-.708-.708l2-2zM8 10a.5.5 0 0 1 .5.5v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 0 1 .708-.708L7.5 14.293V10.5A.5.5 0 0 1 8 10zM.146 8.354a.5.5 0 0 1 0-.708l2-2a.5.5 0 1 1 .708.708L1.707 7.5H5.5a.5.5 0 0 1 0 1H1.707l1.147 1.146a.5.5 0 0 1-.708.708l-2-2zM10 8a.5.5 0 0 1 .5-.5h3.793l-1.147-1.146a.5.5 0 0 1 .708-.708l2 2a.5.5 0 0 1 0 .708l-2 2a.5.5 0 0 1-.708-.708L14.293 8.5H10.5A.5.5 0 0 1 10 8z"/>
</svg>`;
        super(toolName || "MoveTool", toolLabel || "Move", toolDescription ||
            "Move a node by dragging and dropping it. Resize a node by dragging and dropping its bottom right corner. Remove a node or edge by clicking on it with the right mouse button and selecting 'Delete'.", icon, "#FFFFFF", iconType || "svg");
    }
}
class NodeShapeNodeTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = null, type = "svg") {
        super(toolName || "Node Shape", toolLabel || "Node Shape", toolDescription || "Click on an empty part of the canvas to add a node", toolIcon, null, type);
    }
}
class ObjectNodeTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = null, type = "svg") {
        super(toolName || "Object", toolLabel || "Object", toolDescription || "Click on an empty part of the canvas to add a node", toolIcon, null, type);
    }
}
class NodeTool extends AbstractTool {
    constructor(toolName, toolLabel, toolDescription, toolIcon, iconType = "img") {
        super(toolName, toolLabel, toolDescription || "Click on an empty part of the canvas to add a node", toolIcon, null, "svg");
    }
}
class EdgeTool extends AbstractTool {
    constructor(toolName, toolLabel, toolDescription, toolIcon, toolColor, type = "img") {
        if (toolIcon && toolIcon.includes(".png")) {
            let tmp = toolIcon.split(".");
            tmp.pop();
            const key = tmp.join(".");
            if (key in DEFAULT_EDGE_ICONS) {
                toolIcon = DEFAULT_EDGE_ICONS[key];
                type = "svg";
            }
        }
        super(toolName, toolLabel, toolDescription ||
            "Click and hold on one Node and release on another node to add an edge between these two nodes.", toolIcon || DEFAULT_EDGE_ICONS["unidirassociation"], toolColor || "#000000", type);
    }
}
const DEFAULT_EDGE_ICONS = {
    unidirassociation: `<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-arrow-right" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/></svg>`,
    generalisation: `<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-arrow-up" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"/></svg>`,
    bidirassociation: `<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-arrow-left-right" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 11.5a.5.5 0 0 0 .5.5h11.793l-3.147 3.146a.5.5 0 0 0 .708.708l4-4a.5.5 0 0 0 0-.708l-4-4a.5.5 0 0 0-.708.708L13.293 11H1.5a.5.5 0 0 0-.5.5zm14-7a.5.5 0 0 1-.5.5H2.707l3.147 3.146a.5.5 0 1 1-.708.708l-4-4a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 4H14.5a.5.5 0 0 1 .5.5z"/></svg>`,
};
const circleNodeHtml = "<div class=\"custom_node\">\n  <div class=\"type\"><%= type %></div>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    preserveAspectRatio=\"none\"\n    viewBox=\"0 0 100 100\"\n    class=\"fill_parent\"\n  >\n    <circle\n      cx=\"50\"\n      cy=\"50\"\n      r=\"50\"\n      fill=\"<%= color %>\"\n      stroke=\"lightgray\"\n      stroke-width=\"2\"\n    />\n  </svg>\n  <div class=\"fill_parent\">\n    <div\n      style=\"\n        position: absolute;\n        left: 50%;\n        top: -10px;\n        -webkit-transform: translateY(-50%) translateX(-50%);\n      \"\n      class=\"label\"\n    ></div>\n  </div>\n</div>\n";
const diamondNodeHtml = "<div class=\"custom_node\">\n  <div class=\"type\"><%= type %></div>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    preserveAspectRatio=\"none\"\n    viewBox=\"0 0 100 100\"\n    class=\"fill_parent\"\n  >\n    <rect\n      x=\"15\"\n      y=\"15\"\n      width=\"70\"\n      height=\"70\"\n      fill=\"<%= color %>\"\n      stroke=\"lightgray\"\n      stroke-width=\"2\"\n      transform=\"rotate(-45 50 50)\"\n    />\n  </svg>\n  <div class=\"fill_parent\">\n    <div\n      style=\"\n        position: absolute;\n        left: 50%;\n        top: -10px;\n        -webkit-transform: translateY(-50%) translateX(-50%);\n      \"\n      class=\"label\"\n    ></div>\n  </div>\n</div>\n";
const rectangleNodeHtml = "<div class=\"custom_node\">\n  <div class=\"type\"><%= type %></div>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    preserveAspectRatio=\"none\"\n    viewBox=\"0 0 100 100\"\n    class=\"fill_parent\"\n  >\n    <rect\n      x=\"0\"\n      y=\"0\"\n      width=\"100\"\n      height=\"100\"\n      fill=\"<%= color %>\"\n      stroke=\"lightgray\"\n      stroke-width=\"2\"\n    />\n  </svg>\n  <div class=\"fill_parent\">\n    <div\n      style=\"\n        position: absolute;\n        left: 50%;\n        top: -10px;\n        -webkit-transform: translateY(-50%) translateX(-50%);\n      \"\n      class=\"label\"\n    ></div>\n  </div>\n</div>\n";
const roundedRectangleNodeHtml = "<div class=\"custom_node\">\n  <div class=\"type\"><%= type %></div>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    preserveAspectRatio=\"none\"\n    viewBox=\"0 0 100 100\"\n    class=\"fill_parent\"\n  >\n    <rect\n      x=\"0\"\n      y=\"0\"\n      rx=\"20\"\n      ry=\"20\"\n      width=\"100\"\n      height=\"100\"\n      fill=\"<%= color %>\"\n      stroke=\"lightgray\"\n      stroke-width=\"2\"\n    />\n  </svg>\n  <div class=\"fill_parent\">\n    <div\n      style=\"\n        position: absolute;\n        left: 50%;\n        top: -10px;\n        -webkit-transform: translateY(-50%) translateX(-50%);\n      \"\n      class=\"label\"\n    ></div>\n  </div>\n</div>\n";
const triangleNodeHtml = "<div class=\"custom_node\">\n  <div class=\"type\"><%= type %></div>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    preserveAspectRatio=\"none\"\n    viewBox=\"0 0 100 100\"\n    class=\"fill_parent\"\n  >\n    <path\n      d=\"M0,100 L50,0 L100,100 L0,100\"\n      fill=\"<%= color %>\"\n      stroke=\"lightgray\"\n      stroke-width=\"2\"\n    />\n  </svg>\n  <div class=\"fill_parent\">\n    <div\n      style=\"\n        position: absolute;\n        left: 50%;\n        top: -10px;\n        -webkit-transform: translateY(-50%) translateX(-50%);\n      \"\n      class=\"label\"\n    ></div>\n  </div>\n</div>\n";
class Palette {
    constructor($palette, $info) {
        var that = this;
        var _tools = {};
        var _currentToolName = null;
        var _iwc = IWCW.getInstance(CONFIG$1.WIDGET.NAME.PALETTE);
        var processToolSelection = function (name) {
            var tool;
            if (_tools.hasOwnProperty(name)) {
                if (_currentToolName) {
                    _tools[_currentToolName].unselect();
                    $info.text("");
                }
                tool = _tools[name];
                tool.select();
                $info.text(tool.getDescription());
                _currentToolName = name;
            }
        };
        var toolSelectionCallback = function (operation) {
            if (operation instanceof ToolSelectOperation) {
                processToolSelection(operation.getSelectedToolName());
            }
        };
        var setViewTypesCallback = function (operation) {
            if (operation instanceof SetViewTypesOperation) {
                if (operation.getFlag() &&
                    _tools.hasOwnProperty("ViewObject") &&
                    _tools.hasOwnProperty("ViewRelationship")) {
                    _tools["ViewObject"].get$node().show();
                    _tools["ViewRelationship"].get$node().show();
                    _tools["Object"].get$node().hide();
                    _tools["Enumeration"].get$node().hide();
                    _tools["Relationship"].get$node().hide();
                    _tools["Abstract Class"].get$node().hide();
                }
                else if (!operation.getFlag() &&
                    _tools.hasOwnProperty("ViewObject") &&
                    _tools.hasOwnProperty("ViewRelationship")) {
                    _tools["ViewObject"].get$node().hide();
                    _tools["ViewRelationship"].get$node().hide();
                    _tools["Object"].get$node().show();
                    _tools["Enumeration"].get$node().show();
                    _tools["Relationship"].get$node().show();
                    _tools["Abstract Class"].get$node().show();
                }
            }
        };
        var initModelTypesCallback = function (operation) {
            if (operation instanceof InitModelTypesOperation) {
                var vls = operation.getVLS();
                if (!$.isEmptyObject(_tools)) {
                    _tools = {};
                    $palette.empty();
                }
                that.addTool(new MoveTool());
                that.addSeparator();
                that.initNodePalette(vls);
                that.addSeparator();
                that.iniEdgePalette(vls);
                _currentToolName = "MoveTool";
            }
        };
        this.addTool = function (tool) {
            var name = tool.getName();
            var $node;
            if (!_tools.hasOwnProperty(name)) {
                _tools[name] = tool;
                $node = tool.get$node();
                $node.on("mousedown", function (ev) {
                    if (ev.which != 1)
                        return;
                    that.selectTool(name);
                });
                $palette.append($node);
            }
        };
        this.addSeparator = function () {
            $palette.append($(`<hr style="margin-top: 8px; margin-bottom: 8px;" />`));
        };
        this.getTool = function (name) {
            if (_tools.hasOwnProperty(name)) {
                return _tools[name];
            }
            return null;
        };
        this.selectTool = function (name) {
            if (_tools.hasOwnProperty(name)) {
                processToolSelection(name);
                var operation = new ToolSelectOperation(name, null);
                _iwc.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.toNonOTOperation());
            }
        };
        this.getCurrentToolName = function () {
            return _currentToolName;
        };
        this.registerCallbacks = function () {
            _iwc.registerOnDataReceivedCallback(toolSelectionCallback);
            _iwc.registerOnDataReceivedCallback(setViewTypesCallback);
            _iwc.registerOnDataReceivedCallback(initModelTypesCallback);
        };
        this.unregisterCallbacks = function () {
            _iwc.unregisterOnDataReceivedCallback(toolSelectionCallback);
            _iwc.unregisterOnDataReceivedCallback(setViewTypesCallback);
            _iwc.unregisterOnDataReceivedCallback(initModelTypesCallback);
        };
        if (_iwc) {
            this.registerCallbacks();
        }
        this.initNodePalette = function (metamodel) {
            var nodeShapeTypes = {
                circle: circleNodeHtml,
                diamond: diamondNodeHtml,
                rectangle: rectangleNodeHtml,
                rounded_rectangle: roundedRectangleNodeHtml,
                triangle: triangleNodeHtml,
            };
            var $colorTestElement = $("<div></div>");
            var nodes = metamodel.nodes, node, shape, color, $shape;
            for (var nodeId in nodes) {
                if (nodes.hasOwnProperty(nodeId)) {
                    node = nodes[nodeId];
                    if (node.shape?.customShape) {
                        shape = node.shape.customShape;
                    }
                    else {
                        shape =
                            node.shape && nodeShapeTypes.hasOwnProperty(node.shape.shape)
                                ? nodeShapeTypes[node.shape.shape]
                                : lodash.keys(nodeShapeTypes)[0];
                    }
                    if (node.shape?.customAnchors) {
                        node.shape.customAnchors;
                    }
                    else {
                        switch (node.shape?.shape) {
                            case "circle":
                                break;
                            case "diamond":
                                break;
                            case "triangle":
                                break;
                            default:
                            case "rectangle":
                                break;
                        }
                    }
                    color = node.shape?.color
                        ? $colorTestElement
                            .css("color", "#FFFFFF")
                            .css("color", node.shape.color)
                            .css("color")
                        : "#FFFFFF";
                    $shape = $("<div>")
                        .css("display", "table-cell")
                        .css("verticalAlign", "middle")
                        .css("width", node.shape?.defaultWidth || 100)
                        .css("height", node.shape?.defaultHeight || 50)
                        .append($(lodash.template(shape)({
                        color: color,
                        type: node.label,
                    })));
                    $shape.find(".type").hide();
                    that.addTool(new NodeTool(node.label, node.label, null, $shape));
                }
            }
        };
        this.iniEdgePalette = function (metamodel) {
            var edges = metamodel.edges, edge;
            for (var edgeId in edges) {
                if (edges.hasOwnProperty(edgeId)) {
                    edge = edges[edgeId];
                    that.addTool(new EdgeTool(edge.label, edge.label, null, edge.shape ? edge.shape.arrow + ".png" : null, edge.shape?.color));
                }
            }
        };
    }
}
class RelationshipGroupNodeTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = null, type = "svg") {
        super(toolName || "Relation", toolLabel || "Relation", toolDescription || "Click on an empty part of the canvas to add a node", toolIcon, null, type);
    }
}
class RelationshipNodeTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = null, type = "svg") {
        super(toolName || "Relationship", toolLabel || "Relationship", toolDescription || "Click on an empty part of the canvas to add a node", toolIcon, null, type);
    }
}
class UniDirAssociationEdgeTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-arrow-right" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/></svg>`, type = "svg") {
        super(toolName || "Uni-Dir-Association", toolLabel || "Uni-Dir-Assoc", toolDescription ||
            "Click and hold on one Node and release on another node to add an edge between these two nodes.", toolIcon, null, type);
    }
}
class ViewObjectNodeTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = null) {
        super(toolName || "ViewObject", toolLabel || "ViewObject", toolDescription ||
            "Click on an empty part of the canvas to add a view type", toolIcon, null);
    }
}
class ViewRelationshipNodeTool extends AbstractTool {
    constructor(toolName = null, toolLabel = null, toolDescription = null, toolIcon = null) {
        super(toolName || "ViewRelationship", toolLabel || "ViewRelationship", toolDescription ||
            "Click on an empty part of the canvas to add a view type", toolIcon, null);
    }
}
let PaletteWidget = class PaletteWidget extends SyncMetaWidget(LitElement, getWidgetTagName(CONFIG$1.WIDGET.NAME.PALETTE)) {
    constructor() {
        super(...arguments);
        this.widgetName = getWidgetTagName(CONFIG$1.WIDGET.NAME.PALETTE);
    }
    async firstUpdated(_changedProperties) {
        super.firstUpdated(_changedProperties);
        this.hideErrorAlert();
        yjsSync()
            .then((y) => {
            console.info("PALETTE: Yjs successfully initialized in room " +
                window.spaceTitle +
                " with y-user-id: " +
                y.clientID);
            WaitForCanvas(CONFIG$1.WIDGET.NAME.PALETTE, y)
                .then((metamodel) => {
                window.scrollTo(0, document.body.scrollHeight);
                var palette = new Palette($("#palette"), $("#info"));
                palette.addTool(new MoveTool());
                palette.addSeparator();
                if (!$.isEmptyObject(metamodel)) {
                    if (metamodel.hasOwnProperty("nodes")) {
                        palette.initNodePalette(metamodel);
                    }
                    if (metamodel.hasOwnProperty("edges")) {
                        palette.iniEdgePalette(metamodel);
                    }
                }
                else {
                    palette.addTool(new AbstractClassNodeTool());
                    palette.addTool(new ObjectNodeTool());
                    palette.addTool(new RelationshipNodeTool());
                    palette.addTool(new RelationshipGroupNodeTool());
                    palette.addTool(new EnumNodeTool());
                    palette.addTool(new NodeShapeNodeTool());
                    palette.addTool(new EdgeShapeNodeTool());
                    var viewObjectTool = new ViewObjectNodeTool();
                    palette.addTool(viewObjectTool);
                    viewObjectTool.get$node().hide();
                    var viewRelNodeTool = new ViewRelationshipNodeTool();
                    palette.addTool(viewRelNodeTool);
                    viewRelNodeTool.get$node().hide();
                    palette.addSeparator();
                    palette.addTool(new BiDirAssociationEdgeTool());
                    palette.addTool(new UniDirAssociationEdgeTool());
                    palette.addTool(new GeneralisationEdgeTool());
                }
            })
                .catch((err) => {
                console.error("PALETTE: Error while waiting for CANVAS: ", err);
                this.showErrorAlert("Cannot connect to Canvas widget.");
            })
                .finally(() => {
                $(getWidgetTagName(CONFIG$1.WIDGET.NAME.PALETTE))
                    .find("loading-spinner")
                    .hide();
            });
        })
            .catch((error) => {
            console.error("PALETTE: Error while waiting for CANVAS: ", error);
            this.showErrorAlert("Cannot connect to Yjs server.");
        });
    }
    createRenderRoot() {
        return this;
    }
    hideErrorAlert() {
        $(this.widgetName).find("#alert-message").text("");
        $(this.widgetName).find("error-alert").hide();
    }
    showErrorAlert(message) {
        $(this.widgetName).find("#alert-message").text(message);
        $(this.widgetName).find("error-alert").hide();
    }
    render() {
        return html `
      <style>
        ${getWidgetTagName(CONFIG$1.WIDGET.NAME.PALETTE)} {
          height: 100%;
          position: relative;
        }

        button .icon div.fill_parent {
          display: none;
        }

        button span {
          padding-left: 10px;
        }

        hr {
          border-width: 0 0 1px 0;
          border-color: #cccccc;
          margin: 0.2em 0;
        }
        p#info {
          font-size: 0.6em;
        }
      </style>
      <link
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
        rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
        crossorigin="anonymous"
      />
      <link
        rel="stylesheet"
        type="text/css"
        href="https://code.jquery.com/ui/1.13.1/themes/smoothness/jquery-ui.css"
      />
      <div class="h-100" style="overflow-y:auto">
        <error-alert></error-alert>
        <div id="palette"></div>
        <p id="info"></p>
        <div id="q"></div>
        <loading-spinner></loading-spinner>
      </div>
    `;
    }
    connectedCallback() {
        super.connectedCallback();
        init();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
    }
};
PaletteWidget = __decorate([
    e(getWidgetTagName(CONFIG$1.WIDGET.NAME.PALETTE))
], PaletteWidget);
let ErrorAlert = class ErrorAlert extends LitElement {
    createRenderRoot() {
        return this;
    }
    render() {
        return html `
      <div class="alert alert-danger d-flex align-items-center" role="alert">
        <i class="bi bi-exclamation-triangle-fill"></i>
        <div id="alert-message"></div>
      </div>
    `;
    }
};
ErrorAlert = __decorate([
    e("error-alert")
], ErrorAlert);
const activityBoxHtml = "<div\n  class=\"toast w-100 d-block me-2 mb-3\"\n  role=\"alert\"\n  aria-live=\"assertive\"\n  aria-atomic=\"true\"\n  style=\"border: 3px; border-style: solid; border-color: <%= color %>\"\n>\n  <div class=\"toast-header\">\n    <svg\n      class=\"bd-placeholder-img rounded me-2\"\n      width=\"20\"\n      height=\"20\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      aria-hidden=\"true\"\n      preserveAspectRatio=\"xMidYMid slice\"\n      focusable=\"false\"\n    >\n      <rect width=\"100%\" height=\"100%\" fill=\"<%= color %>\"></rect>\n    </svg>\n    <strong class=\"me-1\"><%= heading %></strong>\n    <small style=\"font-size: 0.7em; text-align: end; margin-left: auto\"\n      ><%= timestamp %></small\n    >\n  </div>\n  <div class=\"toast-body\"><%= text %></div>\n</div>\n";
class Activity {
    constructor(entityId, sender, text, timestamp) {
        this._type = undefined;
        var that = this;
        var isTrackable = false;
        var _iwcw = IWCW.getInstance(CONFIG$1.WIDGET.NAME.ACTIVITY);
        var _entityId = entityId;
        var _sender = sender;
        var _text = text;
        var _timestamp = timestamp;
        this._type = undefined;
        var _activityBoxTemplate = lodash.template(activityBoxHtml);
        var getDateTimeAsString = function () {
            const today = new Date();
            var d = new Date(_timestamp);
            if (d.getDate() === today.getDate() &&
                d.getMonth() === today.getMonth() &&
                d.getFullYear() === today.getFullYear()) {
                var hour = d.getHours();
                var min = d.getMinutes();
                if (hour < 10) {
                    hour = "0" + hour;
                }
                if (min < 10) {
                    min = "0" + min;
                }
                var dateTime = hour + ":" + min;
                return dateTime;
            }
            var months = [
                "01",
                "02",
                "03",
                "04",
                "05",
                "06",
                "07",
                "08",
                "09",
                "10",
                "11",
                "12",
            ];
            var year = d.getFullYear() % 100;
            var month = months[d.getMonth()];
            var date = d.getDate();
            var hour = d.getHours();
            var min = d.getMinutes();
            if (hour < 10) {
                hour = "0" + hour;
            }
            if (min < 10) {
                min = "0" + min;
            }
            if (d.getFullYear() === today.getFullYear()) {
                var dateTime = date + "." + month + "/" + hour + ":" + min;
                return dateTime;
            }
            var dateTime = date + "." + month + "." + year + "/" + hour + ":" + min;
            return dateTime;
        };
        var _$node;
        if (_sender) {
            const userList = y.getMap("userList");
            let username;
            if (userList.get(_sender)) {
                username = userList.get(_sender)[CONFIG$1.NS.PERSON.TITLE];
                if (userList.get(_sender).self) {
                    username = username + " (You)";
                }
            }
            else {
                username = "Anonymous";
            }
            _$node = $(_activityBoxTemplate({
                heading: username,
                text: _text,
                color: userList.get(_sender)
                    ? Util.getColor(userList.get(_sender).globalId)
                    : "#C0C5CE",
                timestamp: getDateTimeAsString(),
            })).hide();
        }
        else
            _$node = $(_activityBoxTemplate({
                heading: "",
                text: "",
                color: "#000000",
                timestamp: getDateTimeAsString(),
            })).hide();
        var _$textNode = _$node.find(".text");
        this.getEntityId = function () {
            return _entityId;
        };
        this.getSender = function () {
            return _sender;
        };
        this.getTimestampe = function () {
            return _timestamp;
        };
        this.getText = function () {
            return _text;
        };
        this.setText = function (text) {
            _text = text;
            _$textNode.text(text);
        };
        this.get$node = function () {
            return _$node;
        };
        this.isTrackable = function () {
            return isTrackable;
        };
        this.hide = function () {
            this.get$node().hide();
        };
        this.show = function () {
            this.get$node().show();
        };
        this.setType = function (type) {
            this._type = type;
        };
        this.getType = function () {
            return this._type;
        };
        this._toJSON = function () {
            var json = {
                entityId: _entityId,
                sender: _sender,
                text: _text,
                timestamp: _timestamp,
                type: this._type,
            };
            const userList = y.getMap("userList");
            var user = userList.get(sender);
            if (user) {
                json.user = {};
                json.user.title = user[CONFIG$1.NS.PERSON.TITLE];
                json.user.mail = user[CONFIG$1.NS.PERSON.MBOX];
                json.user.color = Util.getColor(user.globalId);
            }
            return json;
        };
        this.trackable = function () {
            _$node.click(function (event) {
                var operation = new MoveCanvasOperation(that.getEntityId(), false);
                _iwcw.sendLocalNonOTOperation(CONFIG$1.WIDGET.NAME.MAIN, operation.toNonOTOperation());
            });
            _$node.hover(function () {
                const color = y.getMap("userList").get(_sender)
                    ? Util.getColor(y.getMap("userList").get(_sender).globalId)
                    : "#ccc";
                $(this).css("border", "5px solid " + color);
            }, function () {
                const color = y.getMap("userList").get(_sender)
                    ? Util.getColor(y.getMap("userList").get(_sender).globalId)
                    : "#ccc";
                $(this).css("border", "1px solid" + color);
            });
            _$node.find(".timestamp").css("border-color", "rgb(112, 222, 148)");
            isTrackable = true;
        };
        this.untrackable = function () {
            const color = y.getMap("userList").get(_sender)?.globalId
                ? Util.getColor(y.getMap("userList").get(_sender).globalId)
                : "rgb(112, 222, 148)";
            _$node.off();
            _$node.find(".timestamp").css("border-color", color);
            isTrackable = false;
        };
    }
    toJSON() {
        return this._toJSON();
    }
}
class NodeAddActivity extends Activity {
    constructor(entityId, sender, text, timestamp, nodeType) {
        super(entityId, sender, text, timestamp);
        this.toJSON = function () {
            var json = Activity.prototype.toJSON.call(this);
            json.nodeType = nodeType;
            json.type = NodeAddActivity.TYPE;
            return json;
        };
    }
    static { this.TYPE = "NodeAddActivity"; }
}
class NodeDeleteActivity extends Activity {
    constructor(entityId, sender, text, timestamp) {
        super(entityId, sender, text, timestamp);
        this.toJSON = function () {
            var json = Activity.prototype.toJSON.call(this);
            json.type = NodeDeleteActivity.TYPE;
            return json;
        };
    }
    static { this.TYPE = "NodeDeleteActivity"; }
}
class NodeMoveActivity extends Activity {
    constructor(entityId, sender, text, timestamp, nodeType) {
        super(entityId, sender, text, timestamp);
        this.toJSON = function () {
            var json = Activity.prototype.toJSON.call(this);
            json.type = NodeMoveActivity.TYPE;
            json.nodeType = nodeType;
            return json;
        };
    }
    static { this.TYPE = "NodeMoveActivity"; }
}
class NodeResizeActivity extends Activity {
    constructor(entityId, sender, text, timestamp, nodeType) {
        super(entityId, sender, text, timestamp);
        this.toJSON = function () {
            var json = Activity.prototype.toJSON.call(this);
            json.type = NodeResizeActivity.TYPE;
            json.nodeType = nodeType;
            return json;
        };
    }
    static { this.TYPE = "NodeResizeActivity"; }
}
class EdgeAddActivity extends Activity {
    constructor(entityId, sender, text, timestamp, edgeType, sourceNodeLabel, sourceNodeId, sourceNodeType, targetNodeLabel, targetNodeId, targetNodeType) {
        super(entityId, sender, text, timestamp);
        var _edgeType = edgeType;
        var _sourceNodeLabel = sourceNodeLabel;
        var _sourceNodeId = sourceNodeId;
        var _sourceNodeType = sourceNodeType;
        var _targetNodeLabel = targetNodeLabel;
        var _targetNodeId = targetNodeId;
        var _targetNodeType = targetNodeType;
        var _edgeLabel = "";
        this.toJSON = function () {
            var json = Activity.prototype.toJSON.call(this);
            json.type = EdgeAddActivity.TYPE;
            json.edgeType = _edgeType;
            json.edgeLabel = _edgeLabel;
            json.sourceNodeLabel = _sourceNodeLabel;
            json.sourceNodeId = _sourceNodeId;
            json.sourceNodeType = _sourceNodeType;
            json.targetNodeLabel = _targetNodeLabel;
            json.targetNodeId = _targetNodeId;
            json.targetNodeType = _targetNodeType;
            return json;
        };
    }
    static { this.TYPE = "EdgeAddActivity"; }
}
class EdgeDeleteActivity extends Activity {
    constructor(entityId, sender, text, timestamp) {
        super(entityId, sender, text, timestamp);
        this.toJSON = function () {
            var json = Activity.prototype.toJSON.call(this);
            json.type = EdgeDeleteActivity.TYPE;
            return json;
        };
    }
    static { this.TYPE = "EdgeDeleteActivity"; }
}
class EditorGenerateActivity extends Activity {
    constructor(entityId, sender, text, timestamp) {
        super(entityId, sender, text, timestamp);
        this.toJSON = function () {
            var json = Activity.prototype.toJSON.call(this);
            json.type = EditorGenerateActivity.TYPE;
            return json;
        };
    }
    static { this.TYPE = "EditorGenerateActivity"; }
}
class UserJoinActivity extends Activity {
    constructor(entityId, sender, text, timestamp) {
        super(entityId, sender, text, timestamp);
    }
    static { this.TYPE = "UserJoinActivity"; }
}
class ValueChangeActivity extends Activity {
    constructor(entityId, sender, text, timestamp, value, subjectEntityName, rootSubjectEntityType, rootSubjectEntityId) {
        super(entityId, sender, text, timestamp);
        var _value = value;
        var _subjectEntityName = subjectEntityName;
        var _rootSubjectEntityType = rootSubjectEntityType;
        var _rootSubjectEntityId = rootSubjectEntityId;
        this.getValue = function () {
            return _value;
        };
        this.getSubjectEntityName = function () {
            return _subjectEntityName;
        };
        this.getRootSubjectEntityType = function () {
            return _rootSubjectEntityType;
        };
        this.getRootSubjectEntityId = function () {
            return _rootSubjectEntityId;
        };
        this.toJSON = function () {
            var json = Activity.prototype.toJSON.call(this);
            json.value = _value;
            json.type = ValueChangeActivity.TYPE;
            json.subjectEntityName = _subjectEntityName;
            json.rootSubjectEntityId = _rootSubjectEntityId;
            json.rootSubjectEntityType = _rootSubjectEntityType;
            return json;
        };
    }
    static { this.TYPE = "ValueChangeActivity"; }
}
class ViewApplyActivity extends Activity {
    constructor(viewId, sender, timestamp) {
        super(null, sender, timestamp);
        var _viewId = viewId;
        this.getViewId = function () {
            return _viewId;
        };
    }
    static { this.TYPE = "ViewApplyActivity"; }
}
class ReloadWidgetActivity extends Activity {
    constructor(entityId, sender, text, timestamp) {
        super(entityId, sender, text, timestamp);
    }
    static { this.TYPE = "ReloadWidgetActivity"; }
}
const userBoxHtml = "<div\n  class=\"item card card-body rounded mb-2\"\n  style=\"background-color: <%= color %>\"\n>\n  <div class=\"d-flex\">\n    <h6 class=\"me-1\"><%= heading %></h6>\n    <span class=\"text ms-auto align-bottom\"><%= text %> ago</span>\n  </div>\n  <!-- <h3 class=\"lblViewId\"><%=view%></h3> -->\n</div>\n";
class User {
    constructor(jabberId, lastActivityDate, isLocalUser) {
        this.isAnonymous = true;
        var that = this;
        var _entityId = jabberId;
        const userList = y.getMap("userList");
        this.isAnonymous = !userList.get(jabberId);
        var _lastActivityDate = lastActivityDate;
        var _userBoxTemplate = lodash.template(userBoxHtml);
        let username;
        if (userList.get(jabberId)) {
            username = userList.get(jabberId)[CONFIG$1.NS.PERSON.TITLE];
            if (userList.get(jabberId).self) {
                username = username + " (You)";
            }
        }
        else {
            username = "Anonymous";
        }
        var _$node = $(_userBoxTemplate({
            heading: username,
            text: "",
            color: userList.get(jabberId)
                ? Util.getColor(userList.get(jabberId).globalId)
                : "#C0C5CE",
            view: "",
        })).hide();
        var _$textNode = _$node.find(".text");
        this.getJabberId = function () {
            return _entityId;
        };
        this.setLastActivityDate = function (lastActivityDate) {
            _lastActivityDate = lastActivityDate;
            updateText();
        };
        this.getLastActivityDate = function () {
            return _lastActivityDate;
        };
        var setText = function (text) {
            _$textNode.text(text);
        };
        this.get$node = function () {
            return _$node;
        };
        this.hide = function () {
            this.get$node().hide();
        };
        this.show = function () {
            this.get$node().show();
        };
        var updateText = function () {
            var diff = Math.floor(new Date() - that.getLastActivityDate());
            var secs = Math.floor(diff / 10000) * 10;
            var mins = Math.floor(secs / 60);
            var hours = Math.floor(mins / 60);
            var days = Math.floor(hours / 24);
            if (secs < 60) {
                setText("last seen: " + secs + "s ago");
            }
            else if (mins < 60) {
                setText("last seen: " + mins + "m ago");
            }
            else if (hours < 24) {
                setText("last seen: " + hours + "h ago");
            }
            else {
                setText(days + "d ago");
            }
        };
        updateText();
        setInterval(updateText, 10000);
    }
}
class ActivityList {
    constructor($userListNode, $activityListNode) {
        this.userList = {};
        this.activityList = [];
        var that = this;
        var _$userListNode = $userListNode;
        var _$activityListNode = $activityListNode;
        var userList = {};
        var activityList = [];
        this.addUser = function (jabberId, isLocalUser = false) {
            if (!jabberId) {
                console.error("jabberid not valid", jabberId, "aborting");
                return;
            }
            var user;
            if (!userList.hasOwnProperty(jabberId)) {
                const userListContainsLocalUser = lodash.some(userList, (u) => u.isLocalUser);
                user = new User(jabberId, new Date(), isLocalUser);
                if (user.isLocalUser && userListContainsLocalUser) {
                    console.warn("Local user already exists in user list. Not adding new local user.");
                    return;
                }
                if (user.isAnonymous) {
                    if (!Object.values(userList).some((user) => user.isAnonymous)) {
                        userList[jabberId] = user;
                        _$userListNode.append(user.get$node().show("clip", {}, 200));
                    }
                }
                else {
                    userList[jabberId] = user;
                    _$userListNode.append(user.get$node().show("clip", {}, 200));
                }
            }
            else {
                user = userList[jabberId];
                user.setLastActivityDate(new Date());
                user.show();
            }
        };
        this.getUser = function (jabberId) {
            if (userList.hasOwnProperty(jabberId)) {
                return userList[jabberId];
            }
            return null;
        };
        this.removeUser = function (jabberId) {
            var user;
            if (userList.hasOwnProperty(jabberId)) {
                user = userList[jabberId];
                user.setLastActivityDate(new Date());
                user.hide();
            }
        };
        this.addActivity = function (activity) {
            activityList.unshift(activity);
            _$activityListNode.prepend(activity.get$node().show("clip", {}, 200));
        };
        this.addActivityToLog = function (activity, data) {
            const activityMap = y.getMap("activity");
            var jsonActivityList = activityMap.get("log");
            if (!jsonActivityList)
                activityMap.set("log", that.toJSON());
            else {
                var json = activity.toJSON();
                if (data)
                    json.data = data;
                jsonActivityList.unshift(json);
                activityMap.set("log", jsonActivityList);
            }
        };
        this.getFirst = function () {
            if (activityList.length > 0) {
                return activityList[0];
            }
            return null;
        };
        this.toJSON = function () {
            var list = [];
            lodash.forEach(activityList, function (activity) {
                list.unshift(activity.toJSON());
            });
            return list;
        };
        var operationCallback = function (operation) {
            var activity, user, firstActivity, data;
            if (operation instanceof ActivityOperation) {
                data = operation.getData();
                if (!operation.getType()) {
                    console.warn("Operation type not set", operation);
                    return;
                }
                switch (operation.getType()) {
                    case NodeAddActivity.TYPE:
                        activity = new NodeAddActivity(operation.getEntityId(), operation.getSender(), operation.getText(), Date.now(), data.nodeType);
                        that.addActivity(activity);
                        that.findTrackableActivities(activity);
                        break;
                    case EdgeAddActivity.TYPE:
                        activity = new EdgeAddActivity(operation.getEntityId(), operation.getSender(), operation.getText(), Date.now(), data.nodeType, data.sourceNodeLabel, data.sourceNodeId, data.sourceNodeType, data.targetNodeLabel, data.targetNodeId, data.targetNodeType);
                        that.findTrackableActivities(activity);
                        that.addActivity(activity);
                        that.findTrackableActivities(activity);
                        break;
                    case NodeDeleteActivity.TYPE:
                        activity = new NodeDeleteActivity(operation.getEntityId(), operation.getSender(), operation.getText(), Date.now());
                        that.addActivity(activity);
                        that.findUntrackableActivities(activity);
                        break;
                    case EdgeDeleteActivity.TYPE:
                        activity = new EdgeDeleteActivity(operation.getEntityId(), operation.getSender(), operation.getText(), Date.now());
                        that.addActivity(activity);
                        that.findUntrackableActivities(activity);
                        break;
                    case NodeMoveActivity.TYPE:
                        activity = new NodeMoveActivity(operation.getEntityId(), operation.getSender(), operation.getText(), Date.now(), data.nodeType);
                        that.addActivity(activity);
                        activity.trackable();
                        break;
                    case NodeResizeActivity.TYPE:
                        activity = new NodeResizeActivity(operation.getEntityId(), operation.getSender(), operation.getText(), Date.now(), data.nodeType);
                        that.addActivity(activity);
                        activity.trackable();
                        break;
                    case ValueChangeActivity.TYPE:
                        activity = new ValueChangeActivity(operation.getEntityId(), operation.getSender(), operation.getText(), Date.now(), data.value, data.subjectEntityName, data.rootSubjectEntityType, data.rootSubjectEntityId);
                        firstActivity = that.getFirst();
                        if (firstActivity &&
                            firstActivity instanceof ValueChangeActivity &&
                            firstActivity.getEntityId() === activity.getEntityId() &&
                            firstActivity.getSender() === activity.getSender()) {
                            firstActivity.setText(activity.getText());
                        }
                        else {
                            that.addActivity(activity);
                        }
                        activity.trackable();
                        break;
                    case EditorGenerateActivity.TYPE:
                        activity = new EditorGenerateActivity(operation.getEntityId(), operation.getSender(), operation.getText(), Date.now());
                        that.addActivity(activity);
                        break;
                    case UserJoinActivity.TYPE:
                        that.addUser(operation.getSender());
                        break;
                    case "UserLeftActivity": {
                        const sender = operation.getSender() || "Anonymous";
                        activity = new Activity(null, sender, ".. left the space", Date.now());
                        activity.setType("UserLeftActivity");
                        that.addActivity(activity);
                        that.removeUser(operation.getSender());
                        break;
                    }
                    case "ApplyLayoutActivity": {
                        activity = new Activity(null, operation.getSender(), operation.getText(), Date.now());
                        activity.setType("ApplyLayoutActivity");
                        that.addActivity(activity);
                        break;
                    }
                    case "ReloadWidgetOperation":
                        activity = new ReloadWidgetActivity(operation.getEntityId(), operation.getSender(), operation.getText(), Date.now());
                        activity.setType("ReloadWidgetOperation");
                        that.addActivity(activity);
                        break;
                    case ViewApplyActivity.TYPE:
                        activity = new ViewApplyActivity(operation.getEntityId(), operation.getSender());
                        if (userList.hasOwnProperty(activity.getSender())) {
                            userList[activity.getSender()]
                                .get$node()
                                .find(".lblViewId")
                                .text(activity.getViewId());
                        }
                        break;
                    case "WidgetTrackingActivity":
                        activity = new Activity(operation.getEntityId(), operation.getSender(), operation.getText(), Date.now());
                        activity.setType(operation.getType());
                        break;
                    default: {
                        activity = new Activity(operation.getEntityId(), operation.getSender(), operation.getText(), Date.now());
                        activity.setType(operation.getType());
                        that.addActivity(activity);
                        break;
                    }
                }
                user = that.getUser(operation.getSender());
                if (user) {
                    user.setLastActivityDate(new Date());
                    const userMap = y.getMap("users");
                    if (userMap.get(y.clientID) === operation.getSender())
                        that.addActivityToLog(activity, data);
                }
                return;
            }
        };
        this.findUntrackableActivities = function (activity) {
            for (var i = 0; i < activityList.length; i++) {
                var a = activityList[i];
                if (a.isTrackable &&
                    (activity.getEntityId() === a.getEntityId() ||
                        a instanceof NodeDeleteActivity ||
                        a instanceof EdgeAddActivity)) {
                    a.untrackable();
                }
            }
        };
        this.findTrackableActivities = function (activity) {
            for (var i = 0; i < activityList.length; i++) {
                var a = activityList[i];
                if (!a.isTrackable() &&
                    activity.getEntityId() === a.getEntityId() &&
                    !(a instanceof NodeDeleteActivity || a instanceof EdgeDeleteActivity)) {
                    a.trackable();
                }
            }
        };
        this.init = function () {
            const activityMap = y.getMap("activity");
            var list = activityMap.get("log");
            var activity;
            var checkEntity = function (entityId) {
                const nodesMap = y.getMap("nodes");
                const edgesMap = y.getMap("edges");
                if (nodesMap.has(entityId) || edgesMap.has(entityId))
                    return true;
                else
                    return false;
            };
            if (list) {
                lodash.forEachRight(list, function (a) {
                    switch (a.type) {
                        case NodeAddActivity.TYPE: {
                            activity = new NodeAddActivity(a.entityId, a.sender, a.text, a.timestamp, a.nodeType);
                            that.addActivity(activity);
                            break;
                        }
                        case NodeDeleteActivity.TYPE: {
                            activity = new NodeDeleteActivity(a.entityId, a.sender, a.text, a.timestamp);
                            that.addActivity(activity);
                            break;
                        }
                        case EdgeAddActivity.TYPE: {
                            activity = new EdgeAddActivity(a.entityId, a.sender, a.text, a.timestamp, a.nodeType, a.sourceNodeLabel, a.sourceNodeId, a.sourceNodeType, a.targetNodeLabel, a.targetNodeId, a.targetNodeType);
                            that.addActivity(activity);
                            break;
                        }
                        case EdgeDeleteActivity.TYPE: {
                            activity = new EdgeDeleteActivity(a.entityId, a.sender, a.text, a.timestamp);
                            that.addActivity(activity);
                            break;
                        }
                        case NodeMoveActivity.TYPE: {
                            activity = new NodeMoveActivity(a.entityId, a.sender, a.text, a.timestamp, a.nodeType);
                            that.addActivity(activity);
                            break;
                        }
                        case NodeResizeActivity.TYPE: {
                            activity = new NodeResizeActivity(a.entityId, a.sender, a.text, a.timestamp, a.nodeType);
                            that.addActivity(activity);
                            const nodesMap = y.getMap("nodes");
                            if (nodesMap.size > 0)
                                break;
                        }
                        case ValueChangeActivity.TYPE: {
                            activity = new ValueChangeActivity(a.entityId, a.sender, a.text, a.timestamp, a.value, a.subjectEntityName, a.rootSubjectEntityType, a.rootSubjectEntityId);
                            that.addActivity(activity);
                            break;
                        }
                        case EditorGenerateActivity.TYPE: {
                            activity = new EditorGenerateActivity(a.entityId, a.sender, a.text, a.timestamp);
                            that.addActivity(activity);
                            break;
                        }
                        default: {
                            activity = new Activity(a.entityId, a.sender, a.text, a.timestamp);
                            that.addActivity(activity);
                            break;
                        }
                    }
                    if (checkEntity(activity.getEntityId()))
                        activity.trackable();
                    else
                        activity.untrackable();
                });
            }
        };
        if (y) {
            const activityMap = y.getMap("activity");
            activityMap.observe(function (event) {
                event.keysChanged.forEach((key) => {
                    if (key == "log")
                        return;
                    const activity = event.currentTarget.get(key);
                    if (!activity)
                        return;
                    operationCallback(new ActivityOperation(activity.type, activity.entityId, activity.sender, activity.text, activity.data));
                });
            });
            const selectionMap = y.getMap("select");
            selectionMap.observe(function (event) {
                event.keysChanged.forEach((key) => {
                    const value = event.currentTarget.get(key);
                    if (value === null) {
                        lodash.each(activityList, function (activity) {
                            activity.show();
                        });
                    }
                    else {
                        lodash.each(activityList, function (activity) {
                            activity.show();
                        });
                        lodash.each(lodash.filter(activityList, function (activity) {
                            if (activity instanceof ValueChangeActivity) {
                                return activity.getRootSubjectEntityId() !== value;
                            }
                            return activity.getEntityId() !== value;
                        }), function (activity) {
                            activity.hide();
                        });
                    }
                });
            });
        }
    }
}
function WidgetTracker() {
    var start;
    return {
        init: function (userId, $parent_node = $(frameElement.offsetParent).parent()) {
            $parent_node.find(".widget-wrapper").each(function () {
                $(this).hover(function (event) {
                    start = $.now();
                }, function (event) {
                    var $widget, now = $.now();
                    if ($(event.target).is(".widget-wrapper"))
                        $widget = $(event.target);
                    else
                        $widget = $(event.target).parents(".widget-wrapper");
                    if (now - start >= 1500) {
                        const activityMap = y.getMap("activity");
                        activityMap.set("ActivityOperation", {
                            sender: userId,
                            type: "WidgetTrackingActivity",
                            entityId: $widget.find(".widget-title-bar span").text(),
                            text: "",
                            data: {
                                start: start,
                                end: now,
                            },
                        });
                    }
                });
            });
        },
    };
}
var WidgetTracker$1 = new WidgetTracker();
let Spinner = class Spinner extends LitElement {
    render() {
        return html `
      <style>
        @keyframes ldio-y0l1rz5jzvl {
          0% {
            opacity: 1;
          }
          100% {
            opacity: 0;
          }
        }
        #loading_overlay {
          position: absolute;
          top: 0;
          left: 0;
          height: 100%;
          width: 100%;
          background-color: rgba(255, 255, 255, 0.5448185483870968);
        }
        .ldio-y0l1rz5jzvl div {
          left: 50%;
          top: 50%;
          position: absolute;
          animation: ldio-y0l1rz5jzvl linear 1s infinite;
          background: #00549f;
          width: 14px;
          height: 14px;
          margin-left: -7px;
          margin-top: -7px;
          border-radius: 7px / 7px;
          transform-origin: 7px 47px;
        }
        .ldio-y0l1rz5jzvl div:nth-child(1) {
          transform: rotate(0deg);
          animation-delay: -0.9166666666666666s;
          background: #00549f;
        }
        .ldio-y0l1rz5jzvl div:nth-child(2) {
          transform: rotate(30deg);
          animation-delay: -0.8333333333333334s;
          background: #00549f;
        }
        .ldio-y0l1rz5jzvl div:nth-child(3) {
          transform: rotate(60deg);
          animation-delay: -0.75s;
          background: #00549f;
        }
        .ldio-y0l1rz5jzvl div:nth-child(4) {
          transform: rotate(90deg);
          animation-delay: -0.6666666666666666s;
          background: #00549f;
        }
        .ldio-y0l1rz5jzvl div:nth-child(5) {
          transform: rotate(120deg);
          animation-delay: -0.5833333333333334s;
          background: #00549f;
        }
        .ldio-y0l1rz5jzvl div:nth-child(6) {
          transform: rotate(150deg);
          animation-delay: -0.5s;
          background: #00549f;
        }
        .ldio-y0l1rz5jzvl div:nth-child(7) {
          transform: rotate(180deg);
          animation-delay: -0.4166666666666667s;
          background: #00549f;
        }
        .ldio-y0l1rz5jzvl div:nth-child(8) {
          transform: rotate(210deg);
          animation-delay: -0.3333333333333333s;
          background: #00549f;
        }
        .ldio-y0l1rz5jzvl div:nth-child(9) {
          transform: rotate(240deg);
          animation-delay: -0.25s;
          background: #00549f;
        }
        .ldio-y0l1rz5jzvl div:nth-child(10) {
          transform: rotate(270deg);
          animation-delay: -0.16666666666666666s;
          background: #00549f;
        }
        .ldio-y0l1rz5jzvl div:nth-child(11) {
          transform: rotate(300deg);
          animation-delay: -0.08333333333333333s;
          background: #00549f;
        }
        .ldio-y0l1rz5jzvl div:nth-child(12) {
          transform: rotate(330deg);
          animation-delay: 0s;
          background: #00549f;
        }
        .loadingio-spinner-spinner-bl6ykl6ungk {
          width: 100%;
          height: 100%;
          display: inline-block;
          overflow: hidden;
          background: rgba(255, 255, 255, 0.5448185483870968);
        }
        .ldio-y0l1rz5jzvl {
          width: 100%;
          height: 100%;
          position: relative;
          transform: translateZ(0) scale(1);
          backface-visibility: hidden;
          transform-origin: 0 0; /* see note above */
        }
        .ldio-y0l1rz5jzvl div {
          box-sizing: content-box;
        }
        /* generated by https://loading.io/ */
      </style>

      <div id="loading_overlay">
        <div class="loadingio-spinner-spinner-bl6ykl6ungk">
          <div class="ldio-y0l1rz5jzvl">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
          </div>
        </div>
      </div>
    `;
    }
};
Spinner = __decorate([
    e("loading-spinner")
], Spinner);
let ActivityWidget = class ActivityWidget extends SyncMetaWidget(LitElement, getWidgetTagName(CONFIG$1.WIDGET.NAME.ACTIVITY)) {
    firstUpdated(_changedProperties) {
        super.firstUpdated(_changedProperties);
        yjsSync()
            .then((y) => {
            window.y = y;
            console.info("ACTIVITY: Yjs successfully initialized in room " +
                window.spaceTitle +
                " with y-user-id: " +
                y.clientID);
            WaitForCanvas(CONFIG$1.WIDGET.NAME.ACTIVITY, y)
                .then(function (data) {
                var activityList = new ActivityList($("#user_list"), $("#activity_list"));
                const joinMap = y.getMap("join");
                joinMap.observe(function (event) {
                    event.keysChanged.forEach((key) => {
                        if (key != "invisible_user") {
                            activityList.addUser(key, event.currentTarget.get(key));
                        }
                    });
                });
                console.info("ACTIVITY: Got message from CANVAS");
                var user = data.local.user;
                const userMap = y.getMap("users");
                const userList = y.getMap("userList");
                userMap.set(y.clientID, user[CONFIG$1.NS.PERSON.JABBERID]);
                const $node = $(getWidgetTagName(CONFIG$1.WIDGET.NAME.ACTIVITY));
                WidgetTracker$1.init(user[CONFIG$1.NS.PERSON.JABBERID], $node);
                if (!userList.get(user[CONFIG$1.NS.PERSON.JABBERID])) {
                    user.globalId = Util.getGlobalId(data.local, y);
                    userList.set(user[CONFIG$1.NS.PERSON.JABBERID], user);
                }
                var list = data.list;
                for (var i = 0; i < list.length; i++) {
                    activityList.addUser(list[i]);
                }
                activityList.init();
                $(getWidgetTagName(CONFIG$1.WIDGET.NAME.ACTIVITY))
                    .find("loading-spinner")
                    .hide();
            })
                .catch(function (err) {
                console.error("ACTIVITY: Error while waiting for CANVAS: ", err);
            });
        })
            .catch(function (err) {
            console.error("ACTIVITY: Error while initializing Yjs: " + err);
            this.showErrorAlert("Cannot connect to Yjs server.");
        });
    }
    render() {
        return html `
      <style>
        ${getWidgetTagName(CONFIG$1.WIDGET.NAME.ACTIVITY)} {
          height: 100%;
          position: relative;
        }
        h2 {
          font-size: 0.8em;
          margin: 1px 1px 3px;
          color: #666666;
        }

        .list {
          width: 100%;
          height: auto;
          overflow: hidden;
        }
        .fs-sm {
          font-size: 50%;
        }
        .toast {
          display: block;
        }
        #user_list .item {
          background-color: rgb(138, 255, 200);
          display: block;
          border-radius: 3px;
          border: 2px solid #ccc;
          box-shadow: 2px 2px 2px #e3e3e3;
          position: relative;
          margin-top: 5px;
          margin-bottom: 5px;
        }

        #user_list .item h3 {
          white-space: nowrap;
          text-overflow: ellipsis;
          overflow: hidden;
        }

        #user_list .item span {
          font-size: 0.8em;
          text-align: end;
        }

        #activity_list {
          width: auto;
          box-sizing: border-box;
          padding-bottom: 150%;
          overflow-y: auto;
        }

        #activity_list .item {
          border: 1px solid #ccc;
          border-radius: 4px;
          padding: 0.4em;
          margin: 0 0.5em 0.5em 0;
          background: #f3f3f3 linear-gradient(to bottom, #ffffff, #e3e3e3);
          box-shadow: 2px 2px 2px #e3e3e3;
        }
        #activity_list .item h3 {
          background: #d3d3d3
            linear-gradient(
              to bottom,
              rgba(255, 255, 255, 0.7),
              rgba(200, 200, 200, 0)
            );
          border: 1px solid #ccc;
          border-radius: 2px;
          margin: 0;
          padding: 0.2em;
          text-align: center;
          font-size: 1.1em;
          font-weight: bold;
          overflow: hidden;
          white-space: nowrap;
          text-overflow: ellipsis;
        }
        #activity_list .item p {
          margin: 0.4em 0.2em;
        }

        .timestamp {
          border-radius: 8px;
          border-style: solid;
          border-width: 0.5px;
          text-align: center;
        }
        /* custom scrollbar */
        ::-webkit-scrollbar {
          width: 20px;
        }

        ::-webkit-scrollbar-track {
          background-color: transparent;
        }

        ::-webkit-scrollbar-thumb {
          background-color: #d6dee1;
          border-radius: 20px;
          border: 6px solid transparent;
          background-clip: content-box;
        }

        ::-webkit-scrollbar-thumb:hover {
          background-color: #a8bbbf;
        }
      </style>
      <link
        rel="stylesheet"
        type="text/css"
        href="https://code.jquery.com/ui/1.13.1/themes/smoothness/jquery-ui.css"
      />
      <link
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
        rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
        crossorigin="anonymous"
      />
      <div class="h-100" style="overflow-y:auto">
        <error-alert></error-alert>
        <h4>Users online</h4>
        <div class="list_wrapper">
          <div id="user_list" class="list"></div>
        </div>
        <h4>Activities</h4>
        <div class="list_wrapper">
          <div id="activity_list" class="list"></div>
        </div>
        <div id="q"></div>
        <loading-spinner></loading-spinner>
      </div>
    `;
    }
    connectedCallback() {
        super.connectedCallback();
        init();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
    }
};
ActivityWidget = __decorate([
    e(getWidgetTagName(CONFIG$1.WIDGET.NAME.ACTIVITY))
], ActivityWidget);
let WidgetContainer = class WidgetContainer extends LitElement {
    createRenderRoot() {
        return this;
    }
    constructor() {
        super();
    }
    render() {
        return html `
      <link
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
        rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
        crossorigin="anonymous"
      />
      <style>
        :host {
          display: block;
        }

        .innercontainer {
          border-radius: 5px;
          flex: 1;
          height: 100%;
          resize: horizontal;
          -webkit-box-shadow: 0px 0px 30px 3px rgba(158, 158, 158, 0.89);
          box-shadow: 0px 0px 30px 3px rgba(158, 158, 158, 0.59);
        }
        .innercontainer:nth-of-type(1) {
          flex: 4;
          display: flex;
          flex-flow: column;
        }
        .innercontainer:nth-of-type(3) {
          display: flex;
          flex-flow: column;
        }
        .middle-container {
          flex: 2;
          display: flex;
          justify-content: space-between;
          flex-direction: column;
        }
      </style>
      <div class="container-fluid row w-100 px-0 mx-0" style="height:98vh">
        <div class="col-9 innercontainer">
          <div class="row h-100">
            <div class="col-9 px-1 border-end h-100">
              <canvas-widget></canvas-widget>
            </div>
            <div class="col-3  h-100">
              <palette-widget> </palette-widget>
            </div>
          </div>
        </div>
        <div class="col-3 innercontainer ">
          <property-browser-widget></property-browser-widget>
        </div>

        <div
          class="modal fade"
          id="exportModal"
          tabindex="-1"
          aria-labelledby="exampleModalLabel"
          aria-hidden="true"
          style="z-index: 2147483647 !important;"
        >
          <div class="modal-dialog">
            <div class="modal-content">
              <div class="modal-header">
                <button
                  type="button"
                  class="btn-close"
                  data-bs-dismiss="modal"
                  aria-label="Close"
                ></button>
              </div>
              <div class="modal-body">
                <debug-widget></debug-widget>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div
        class="offcanvas offcanvas-end"
        tabindex="-1"
        id="offcanvasRight"
        aria-labelledby="offcanvasRightLabel"
      >
        <div class="offcanvas-header">
          <button
            type="button"
            class="btn-close"
            data-bs-dismiss="offcanvas"
            aria-label="Close"
          ></button>
        </div>
        <div class="offcanvas-body">
          <user-activity-widget></user-activity-widget>
        </div>
      </div>
    `;
    }
    connectedCallback() {
        super.connectedCallback();
        setTimeout(() => {
            var _a, _b;
            const debugWidgetButton = `<button
                type="button"
                class="btn btn-outline-secondary "
                data-bs-toggle="modal"
                data-bs-target="#exportModal"
                id="exportModel"
                title="Export/Import Utilities"
              >
                <i class="bi bi-cloud-fill me-1"></i> Export/Import
              </button>`;
            const activityWidgetButton = ` <button
        class="btn btn-outline-primary me-1"
        type="button"
        data-bs-toggle="offcanvas"
        data-bs-target="#offcanvasRight"
        aria-controls="offcanvasRight",
        title="User Activities"
      >
        <i class="bi bi-people-fill me-1"></i> Activities 
      </button>`;
            const rowContainer = document.querySelector("#main-widget-utilities-container");
            if (!(rowContainer === null || rowContainer === void 0 ? void 0 : rowContainer.firstElementChild)) {
                console.error(`Could not find the first col of row container. ${document.querySelector("#main-widget-utilities-container")} 
          This means that the debug widget button will not be added. 
          Make sure that the following selector is correct: #main-widget-utilities-container. The first child will be used to append the button.`);
                return;
            }
            (_a = rowContainer.firstElementChild) === null || _a === void 0 ? void 0 : _a.appendChild(new DOMParser().parseFromString(activityWidgetButton, "text/html").body
                .firstChild);
            (_b = rowContainer.firstElementChild) === null || _b === void 0 ? void 0 : _b.appendChild(new DOMParser().parseFromString(debugWidgetButton, "text/html").body
                .firstChild);
        }, 100);
    }
};
WidgetContainer = __decorate([
    e("widget-container")
], WidgetContainer);
function CVG(viewType) {
    const dataMap = y.getMap("data");
    var metamodel = dataMap.get("model");
    var metaGraph = new graphlib.Graph();
    lodash.forEach(metamodel.nodes, function (value, index) {
        metaGraph.setNode(index, value);
    });
    lodash.forEach(metamodel.edges, function (value, index) {
        value.id = index;
        metaGraph.setEdge(value.source, value.target, value);
    });
    var originId = viewType
        .getAttribute(viewType.getEntityId() + "[target]")
        .getValue()
        .getValue();
    var neighborsOfOrigin = metaGraph.neighbors(originId);
    var canvas = viewType.getCanvas();
    var viewpointName = $("#lblCurrentView").text().replace("View:", "");
    lodash.forEach(neighborsOfOrigin, function (neighborId) {
        var node = metaGraph.node(neighborId);
        var newNodeId;
        if (node.type === "Node Shape" ||
            node.type === "Edge Shape" ||
            node.type === "Relation") {
            newNodeId = viewpointName + "_" + neighborId;
            if (!EntityManagerInstance$1.findNode(newNodeId))
                canvas.createNode(node.type, node.left, node.top, node.width, node.height, node.zIndex, node.containment, node, newNodeId);
        }
        else if (viewType.getType() === "ViewObject" &&
            node.type === "Relationship") {
            var viewtypes = EntityManagerInstance$1.getNodesByType("ViewRelationship");
            for (var key in viewtypes) {
                if (viewtypes.hasOwnProperty(key)) {
                    var viewType2 = viewtypes[key];
                    if (viewType2
                        .getAttribute(viewType2.getEntityId() + "[target]")
                        .getValue()
                        .getValue() === neighborId)
                        newNodeId = viewType2.getEntityId();
                }
            }
        }
        else if (viewType.getType() === "ViewRelationship" &&
            node.type === "Object") {
            var viewtypes = EntityManagerInstance$1.getNodesByType("ViewObject");
            for (var key in viewtypes) {
                if (viewtypes.hasOwnProperty(key)) {
                    var viewType2 = viewtypes[key];
                    if (viewType2
                        .getAttribute(viewType2.getEntityId() + "[target]")
                        .getValue()
                        .getValue() === neighborId)
                        newNodeId = viewType2.getEntityId();
                }
            }
        }
        if (newNodeId) {
            var edge = metaGraph.edge(originId, neighborId);
            if (!edge) {
                edge = metaGraph.edge(neighborId, originId);
                canvas.createEdge(edge.type, newNodeId, viewType.getEntityId(), edge, viewpointName + "_" + edge.id, viewpointName);
            }
            else {
                canvas.createEdge(edge.type, viewType.getEntityId(), newNodeId, edge, viewpointName + "_" + edge.id, viewpointName);
            }
        }
    });
}
var ClosedViewGeneration = Object.freeze({
    __proto__: null,
    default: CVG
});
export { WidgetContainer };
//# sourceMappingURL=widget.container.js.map